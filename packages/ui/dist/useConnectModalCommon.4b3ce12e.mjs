import require$$1$3 from "ethers";
import { Button, Spin, Row, Col } from "antd";
import * as React from "react";
import { useState } from "react";
import { A as AntdIcon, _ as _objectSpread2, j as jsx, g as getChainIconOld, t as toMasskedAddress, a as jsxs, I as Icon, F as Fragment$1, b as getChainName, i as isChainEmpty } from "./index.321a7bed.mjs";
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getAugmentedNamespace(n) {
  var e = n.default;
  if (typeof e == "function") {
    var t = function() {
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(o) {
    var c = Object.getOwnPropertyDescriptor(n, o);
    Object.defineProperty(t, o, c.get ? c : {
      enumerable: !0,
      get: function() {
        return n[o];
      }
    });
  }), t;
}
var LoadingOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" };
const LoadingOutlinedSvg = LoadingOutlined$2;
var LoadingOutlined = function(e, t) {
  return /* @__PURE__ */ React.createElement(AntdIcon, _objectSpread2(_objectSpread2({}, e), {}, {
    ref: t,
    icon: LoadingOutlinedSvg
  }));
};
LoadingOutlined.displayName = "LoadingOutlined";
const LoadingOutlined$1 = /* @__PURE__ */ React.forwardRef(LoadingOutlined), Za = {}, nodeCrypto = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Za
}, Symbol.toStringTag, { value: "Module" }));
var dist$1 = {}, face = {}, dist = {}, auth$1 = {};
Object.defineProperty(auth$1, "__esModule", { value: !0 });
var blockchain = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.getPlatFormCoinDecimalByBlockchain = n.isEthlikeBlockchain = n.networkToBlockchain = n.Blockchain = n.NetworkChainIdMap = n.isSupportedNetwork = n.Network = void 0;
  var e;
  (function(w) {
    w.ETHEREUM = "ethereum", w.ROPSTEN = "ropsten", w.GOERLI = "goerli", w.POLYGON = "polygon", w.MUMBAI = "mumbai", w.BNB_SMART_CHAIN = "bnb_smart_chain", w.BNB_SMART_CHAIN_TESTNET = "bnb_smart_chain_testnet", w.KLAYTN = "klaytn", w.BAOBAB = "baobab", w.SOLANA = "solana", w.SOLANA_DEVNET = "solana_devnet", w.NEAR = "near", w.NEAR_TESTNET = "near_testnet", w.BORA = "bora", w.BORA_TESTNET = "bora_testnet", w.ETH_MAINNET = "ethereum", w.ETH_TESTNET = "ropsten", w.MATIC_MAINNET = "polygon", w.MATIC_TESTNET = "mumbai", w.BINANCE_COIN_MAINNET = "bnb_smart_chain", w.BINANCE_COIN_TESTNET = "bnb_smart_chain_testnet", w.KLAYTN_MAINNET = "klaytn", w.KLAYTN_TESTNET = "baobab";
  })(e = n.Network || (n.Network = {}));
  const t = (w) => {
    switch (w) {
      case e.ETHEREUM:
      case e.GOERLI:
      case e.POLYGON:
      case e.MUMBAI:
      case e.BNB_SMART_CHAIN:
      case e.BNB_SMART_CHAIN_TESTNET:
      case e.KLAYTN:
      case e.BAOBAB:
      case e.SOLANA:
      case e.SOLANA_DEVNET:
      case e.NEAR:
      case e.NEAR_TESTNET:
      case e.BORA:
      case e.BORA_TESTNET:
        return !0;
      default:
        return !1;
    }
  };
  n.isSupportedNetwork = t, n.NetworkChainIdMap = {
    [e.ETHEREUM]: 1,
    [e.ROPSTEN]: 3,
    [e.GOERLI]: 5,
    [e.POLYGON]: 137,
    [e.MUMBAI]: 80001,
    [e.BNB_SMART_CHAIN]: 56,
    [e.BNB_SMART_CHAIN_TESTNET]: 97,
    [e.KLAYTN]: 8217,
    [e.BAOBAB]: 1001,
    [e.SOLANA]: 0,
    [e.SOLANA_DEVNET]: 0,
    [e.NEAR]: 0,
    [e.NEAR_TESTNET]: 0,
    [e.BORA]: 77001,
    [e.BORA_TESTNET]: 99001,
    1: e.ETHEREUM,
    3: e.ROPSTEN,
    5: e.GOERLI,
    137: e.POLYGON,
    80001: e.MUMBAI,
    56: e.BNB_SMART_CHAIN,
    97: e.BNB_SMART_CHAIN_TESTNET,
    8217: e.KLAYTN,
    1001: e.BAOBAB,
    77001: e.BORA,
    99001: e.BORA_TESTNET
  };
  var o;
  (function(w) {
    w.ETHEREUM = "ETHEREUM", w.POLYGON = "POLYGON", w.BNB_SMART_CHAIN = "BNB_SMART_CHAIN", w.KLAYTN = "KLAYTN", w.SOLANA = "SOLANA", w.NEAR = "NEAR", w.BORA = "BORA";
  })(o = n.Blockchain || (n.Blockchain = {}));
  const c = [
    o.ETHEREUM,
    o.POLYGON,
    o.BNB_SMART_CHAIN,
    o.KLAYTN,
    o.BORA
  ];
  function a(w) {
    switch (w) {
      case e.ETHEREUM:
      case e.ROPSTEN:
      case e.GOERLI:
        return o.ETHEREUM;
      case e.POLYGON:
      case e.MUMBAI:
        return o.POLYGON;
      case e.BNB_SMART_CHAIN:
      case e.BNB_SMART_CHAIN_TESTNET:
        return o.BNB_SMART_CHAIN;
      case e.KLAYTN:
      case e.BAOBAB:
        return o.KLAYTN;
      case e.SOLANA:
      case e.SOLANA_DEVNET:
        return o.SOLANA;
      case e.BORA:
      case e.BORA_TESTNET:
        return o.BORA;
      case e.NEAR:
      case e.NEAR_TESTNET:
        return o.NEAR;
    }
    throw new Error(`Unsupported network: ${w}`);
  }
  n.networkToBlockchain = a;
  function d(w) {
    return c.indexOf(w) !== -1;
  }
  n.isEthlikeBlockchain = d;
  const p = (w) => {
    switch (w) {
      case o.ETHEREUM:
      case o.POLYGON:
      case o.KLAYTN:
      case o.BNB_SMART_CHAIN:
      case o.BORA:
        return 18;
      case o.SOLANA:
        return 9;
      case o.NEAR:
        return 24;
      default:
        throw new Error("unsupported blockchain");
    }
  };
  n.getPlatFormCoinDecimalByBlockchain = p;
})(blockchain);
var crypto$4 = {};
Object.defineProperty(crypto$4, "__esModule", { value: !0 });
crypto$4.CryptoBuffer = void 0;
const ethers_1$1 = require$$1$3;
class CryptoBuffer {
  constructor(e, t) {
    CryptoBuffer.ensureHexString(e), CryptoBuffer.checkLength(e, t), this.hex = e, this.length = t;
  }
  static empty() {
    return new CryptoBuffer("", 0);
  }
  static fromUint8Array(e) {
    return new CryptoBuffer(uint8ArrayToHex(e), e.length);
  }
  static fromHex(e, t) {
    return new CryptoBuffer(e, t);
  }
  static ensureHexString(e) {
    try {
      if (e === "")
        return;
      if (e == null)
        throw new Error(`hex is null ${e}`);
      if (!e.startsWith("0x"))
        throw new Error(`hex does not start with 0x ${e}`);
      if (e.match("0x[0-9a-fA-F]+") == null)
        throw new Error(`invalid hex data ${e}`);
    } catch (t) {
      throw t;
    }
  }
  static checkLength(e, t) {
    if (e.length === 0)
      return;
    if ((e.length - 2) * 4 / 8 > t)
      throw new Error(`length is less than hex data ${e}, ${t}`);
  }
  toString() {
    return this.hex;
  }
  toHex() {
    return this.hex;
  }
  toBigNumber() {
    return ethers_1$1.BigNumber.from(this.hex);
  }
  toJSON() {
    return JSON.stringify({
      hex: this.hex,
      length: this.length
    });
  }
  static fromJSON(e) {
    const { hex: t, length: o } = JSON.parse(e);
    return new CryptoBuffer(t, o);
  }
  static fromBigNumber(e, t) {
    return CryptoBuffer.fromHex(e.toHexString(), t);
  }
  toUInt8Array() {
    const e = this.hex.substring(2), t = [];
    for (let o = 0; o < e.length; o += 2)
      t.push(parseInt(e.substring(o, o + 2), 16));
    return new Uint8Array(t);
  }
  static concat(e, t) {
    try {
      const o = e.toUInt8Array(), c = t.toUInt8Array(), a = new Uint8Array(o.length + c.length);
      a.set(o), a.set(c, o.length);
      const d = uint8ArrayToHex(a);
      return new CryptoBuffer(d, o.length + c.length);
    } catch {
      return CryptoBuffer.empty();
    }
    return CryptoBuffer.empty();
  }
  split(e) {
    const t = this.toUInt8Array();
    return [
      CryptoBuffer.fromUint8Array(t.slice(0, e)),
      CryptoBuffer.fromUint8Array(t.slice(e))
    ];
  }
  clone() {
    return new CryptoBuffer(this.hex, this.length);
  }
  unsafeSetLength(e) {
    this.length = e;
  }
}
crypto$4.CryptoBuffer = CryptoBuffer;
function uint8ArrayToHex(n) {
  return "0x" + [...n].map((e) => e.toString(16).padStart(2, "0")).join("");
}
var currency = {};
Object.defineProperty(currency, "__esModule", { value: !0 });
var env = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.Env = void 0, function(e) {
    e.Local = "Local", e.Dev = "Dev", e.StageTest = "StageTest", e.StageMainnet = "StageMainnet", e.ProdTest = "ProdTest", e.ProdMainnet = "ProdMainnet";
  }(n.Env || (n.Env = {}));
})(env);
var error = {}, typeGuards = {}, jsonRpc = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.RpcErrorCode = n.JsonRpcSource = n.JsonRpcMethod = void 0, function(e) {
    e.face_logInSignUp = "face_logInSignUp", e.face_loggedIn = "face_loggedIn", e.face_logOut = "face_logOut", e.face_currentUser = "face_currentUser", e.face_accounts = "face_accounts", e.face_openIframe = "face_openIframe", e.face_closeIframe = "face_closeIframe", e.face_ready = "face_ready", e.face_openHome = "face_openHome", e.face_openWalletConnect = "face_openWalletConnect", e.face_switchNetwork = "face_switchNetwork", e.face_directSocialLogin = "face_directSocialLogin", e.face_loginWithIdToken = "face_loginWithIdToken", e.eth_sendTransaction = "eth_sendTransaction", e.eth_getBalance = "eth_getBalance", e.eth_call = "eth_call", e.eth_estimateGas = "eth_estimateGas", e.eth_sign = "eth_sign", e.eth_accounts = "eth_accounts", e.personal_sign = "personal_sign", e.personal_listAccounts = "personal_listAccounts", e.wallet_switchEthereumChain = "wallet_switchEthereumChain", e.solana_sendTransaction = "solana_sendTransaction", e.near_broadcast_tx_async = "near_broadcast_tx_async", e.near_get_balance = "near_get_balance";
  }(n.JsonRpcMethod || (n.JsonRpcMethod = {})), function(e) {
    e.FACE_SDK = "FACE_SDK", e.FACE_IFRAME = "FACE_IFRAME", e.FACE_WALLET_CONNECT = "FACE_WALLET_CONNECT", e.FACE_NATIVE_SDK = "FACE_NATIVE_SDK";
  }(n.JsonRpcSource || (n.JsonRpcSource = {})), function(e) {
    e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR";
  }(n.RpcErrorCode || (n.RpcErrorCode = {}));
})(jsonRpc);
var hasRequiredTypeGuards;
function requireTypeGuards() {
  if (hasRequiredTypeGuards)
    return typeGuards;
  hasRequiredTypeGuards = 1, Object.defineProperty(typeGuards, "__esModule", { value: !0 }), typeGuards.isFaceErrorCode = typeGuards.isJsonRpcErrorCode = typeGuards.isEmpty = typeGuards.isJsonRpcResponsePayload = typeGuards.isJsonRpcRequestPayload = void 0;
  const n = requireError(), e = jsonRpc;
  function t(I) {
    return typeof I > "u";
  }
  function o(I) {
    return I === null;
  }
  function c(I) {
    return o(I) || t(I);
  }
  function a(I) {
    return c(I) ? !1 : !t(I.jsonrpc) && !t(I.id) && !t(I.method) && !t(I.params);
  }
  typeGuards.isJsonRpcRequestPayload = a;
  function d(I) {
    return c(I) ? !1 : !t(I.jsonrpc) && !t(I.id) && (!t(I.result) || !t(I.error));
  }
  typeGuards.isJsonRpcResponsePayload = d;
  function p(I) {
    if (!I)
      return !0;
    for (const B in I)
      if (Object.hasOwnProperty.call(I, B))
        return !1;
    return !0;
  }
  typeGuards.isEmpty = p;
  function w(I) {
    return c(I) ? !1 : typeof I == "number" && Object.values(e.RpcErrorCode).includes(I);
  }
  typeGuards.isJsonRpcErrorCode = w;
  function M(I) {
    return c(I) ? !1 : typeof I == "number" && Object.values(n.FaceErrorCode).includes(I);
  }
  return typeGuards.isFaceErrorCode = M, typeGuards;
}
var hasRequiredError;
function requireError() {
  return hasRequiredError || (hasRequiredError = 1, function(n) {
    Object.defineProperty(n, "__esModule", { value: !0 }), n.noUserDataError = n.pinCodeTrialLimitExceededError = n.wrongPinCodeError = n.invalidAddressWithWalletError = n.unsupportedChainError = n.invalidHostNameError = n.invalidApiKeyError = n.unknownError = n.notImplementedError = n.localStorageError = n.invalidParameterError = n.invalidFormatError = n.cryptoError = n.invalidEnvironmentError = n.firebaseError = n.nitroEnclaveError = n.faceServerError = n.jsonRpcError = n.sendTransactionError = n.FaceError = n.FaceErrorCode = n.HttpStatus = void 0;
    const e = requireTypeGuards();
    (function(ue) {
      ue[ue.SUCCESS = 200] = "SUCCESS", ue[ue.CREATED = 201] = "CREATED", ue[ue.BAD_REQUEST = 400] = "BAD_REQUEST", ue[ue.UNAUTHORIZED = 401] = "UNAUTHORIZED", ue[ue.FORBIDDEN = 403] = "FORBIDDEN", ue[ue.NOT_FOUND = 404] = "NOT_FOUND", ue[ue.INTERNAL_SERVER_ERROR = 500] = "INTERNAL_SERVER_ERROR";
    })(n.HttpStatus || (n.HttpStatus = {}));
    var t;
    (function(ue) {
      ue[ue.BAD_REQUEST = 4e3] = "BAD_REQUEST", ue[ue.USER_REJECTED_REQUEST = 4001] = "USER_REJECTED_REQUEST", ue[ue.NOT_IMPLEMENTED = 4002] = "NOT_IMPLEMENTED", ue[ue.UNAUTHORIZED = 4100] = "UNAUTHORIZED", ue[ue.UNSUPPORTED_METHOD = 4200] = "UNSUPPORTED_METHOD", ue[ue.UNSUPPORTED_CHAIN = 4201] = "UNSUPPORTED_CHAIN", ue[ue.DISCONNECTED = 4900] = "DISCONNECTED", ue[ue.CHAIN_DISCONNECTED = 4901] = "CHAIN_DISCONNECTED", ue[ue.SEND_TRANCTION_FAILED = 4902] = "SEND_TRANCTION_FAILED", ue[ue.WRONG_PINCODE = 4903] = "WRONG_PINCODE", ue[ue.PINCODE_TRIAL_LIMIT_EXCEEDED = 4904] = "PINCODE_TRIAL_LIMIT_EXCEEDED", ue[ue.NO_USER_DATA = 4905] = "NO_USER_DATA", ue[ue.INTERNAL = 5e3] = "INTERNAL";
    })(t = n.FaceErrorCode || (n.FaceErrorCode = {}));
    class o extends Error {
      constructor(he) {
        super(), this.isFaceError = !0, this.code = this.isValidErrorCode(he.code) ? he.code : t.INTERNAL, this.message = `Face Error: [${this.code}] ${he.message}`, this.origin = he.origin, this.data = he.data, Object.setPrototypeOf(this, o.prototype), Error.captureStackTrace(this, this.constructor);
      }
      isValidErrorCode(he) {
        return (0, e.isJsonRpcErrorCode)(he) || (0, e.isFaceErrorCode)(he);
      }
    }
    n.FaceError = o;
    function c(ue) {
      return new o({
        message: ue.message,
        code: t.SEND_TRANCTION_FAILED,
        data: ue.data
      });
    }
    n.sendTransactionError = c;
    function a(ue) {
      return new o({
        message: ue.message,
        code: ue.code,
        data: ue.data
      });
    }
    n.jsonRpcError = a;
    function d(ue, he, Se) {
      return new o({
        message: `face server error: ${ue}`,
        code: t.INTERNAL,
        origin: he,
        data: Se
      });
    }
    n.faceServerError = d;
    function p(ue, he, Se) {
      return new o({
        message: `nitro enclave error: ${ue}`,
        code: t.INTERNAL,
        origin: he,
        data: Se
      });
    }
    n.nitroEnclaveError = p;
    function w(ue, he, Se) {
      return new o({
        message: `firebase error: ${ue}`,
        code: t.INTERNAL,
        origin: he,
        data: Se
      });
    }
    n.firebaseError = w;
    function M(ue) {
      return new o({
        message: "invalid environment",
        code: t.INTERNAL,
        data: ue
      });
    }
    n.invalidEnvironmentError = M;
    function I(ue, he, Se) {
      return new o({
        message: `crypto error: ${ue}`,
        code: t.INTERNAL,
        origin: he,
        data: Se
      });
    }
    n.cryptoError = I;
    function B(ue, he, Se) {
      return new o({
        message: `invalid format error: ${ue}`,
        code: t.INTERNAL,
        origin: he,
        data: Se
      });
    }
    n.invalidFormatError = B;
    function H(ue, he, Se) {
      return new o({
        message: `invalid params error: ${ue}`,
        code: t.INTERNAL,
        origin: he,
        data: Se
      });
    }
    n.invalidParameterError = H;
    function L(ue, he, Se) {
      return new o({
        message: `local storage error: ${ue}`,
        code: t.INTERNAL,
        origin: he,
        data: Se
      });
    }
    n.localStorageError = L;
    function W(ue) {
      return new o({
        message: ue,
        code: t.NOT_IMPLEMENTED
      });
    }
    n.notImplementedError = W;
    function $(ue) {
      return new o({
        message: "unknown error",
        code: t.INTERNAL,
        origin: ue
      });
    }
    n.unknownError = $;
    function P(ue) {
      return new o({
        message: "invalid api key error",
        code: t.UNAUTHORIZED,
        origin: ue
      });
    }
    n.invalidApiKeyError = P;
    function U(ue) {
      return new o({
        message: "invalid host name error",
        code: t.UNAUTHORIZED,
        origin: ue
      });
    }
    n.invalidHostNameError = U;
    function G(ue) {
      return new o({
        message: "unsupported chain error",
        code: t.UNSUPPORTED_CHAIN,
        origin: ue
      });
    }
    n.unsupportedChainError = G;
    function D(ue) {
      return new o({
        message: "invalid address compared with wallet address",
        code: t.INTERNAL,
        origin: ue
      });
    }
    n.invalidAddressWithWalletError = D;
    function Z(ue) {
      return new o({
        message: "invalid pin code",
        code: t.WRONG_PINCODE,
        origin: ue
      });
    }
    n.wrongPinCodeError = Z;
    function J(ue) {
      return new o({
        message: "pin code trial limit exceeded",
        code: t.PINCODE_TRIAL_LIMIT_EXCEEDED,
        origin: ue
      });
    }
    n.pinCodeTrialLimitExceededError = J;
    function te(ue) {
      return new o({
        message: "no user data",
        code: t.NO_USER_DATA,
        origin: ue
      });
    }
    n.noUserDataError = te;
  }(error)), error;
}
var faceEvent = {};
Object.defineProperty(faceEvent, "__esModule", { value: !0 });
faceEvent.parseFaceSolanaNearTransactionPayload = void 0;
function parseFaceSolanaNearTransactionPayload(n) {
  return n == null || typeof n != "object" || n.serializedHex == null || typeof n.serializedHex != "string" ? null : n;
}
faceEvent.parseFaceSolanaNearTransactionPayload = parseFaceSolanaNearTransactionPayload;
var transaction$1 = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.TxType = void 0, function(e) {
    e.COIN = "COIN", e.ERC20 = "ERC20", e.ERC721 = "ERC721", e.ERC1155 = "ERC1155", e.FT = "FT";
  }(n.TxType || (n.TxType = {}));
})(transaction$1);
var user = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.UserStatus = n.WalletPath = n.FaceVersionLocalKey = n.FaceShare1LocalKey = n.FaceUserLocalKey = n.FaceSessionLocalKey = void 0, n.FaceSessionLocalKey = "Face-Session", n.FaceUserLocalKey = "Face-User", n.FaceShare1LocalKey = "Face-Share1", n.FaceVersionLocalKey = "Face-Version", n.WalletPath = "m/44'/60'/1'/0/0", function(e) {
    e.isWalletCreated = "isWalletCreated", e.isNewUser = "isNewUser", e.isRegisteredPinCode = "isRegisteredPinCode", e.isAdmin = "isAdmin";
  }(n.UserStatus || (n.UserStatus = {}));
})(user);
(function(n) {
  var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, c, a, d) {
    d === void 0 && (d = a);
    var p = Object.getOwnPropertyDescriptor(c, a);
    (!p || ("get" in p ? !c.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return c[a];
    } }), Object.defineProperty(o, d, p);
  } : function(o, c, a, d) {
    d === void 0 && (d = a), o[d] = c[a];
  }), t = commonjsGlobal && commonjsGlobal.__exportStar || function(o, c) {
    for (var a in o)
      a !== "default" && !Object.prototype.hasOwnProperty.call(c, a) && e(c, o, a);
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), t(auth$1, n), t(blockchain, n), t(crypto$4, n), t(currency, n), t(env, n), t(requireError(), n), t(faceEvent, n), t(jsonRpc, n), t(transaction$1, n), t(user, n);
})(dist);
var auth = {};
Object.defineProperty(auth, "__esModule", { value: !0 });
auth.Auth = void 0;
class Auth {
  constructor(e) {
    this.internal = e;
  }
  async login() {
    return this.internal.loginWithCredential();
  }
  async directSocialLogin(e) {
    return this.internal.directSocialLogin(e);
  }
  async loginWithIdToken(e) {
    return this.internal.loginWithIdToken(e);
  }
  async logout() {
    await this.internal.logout();
  }
  async getCurrentUser() {
    return await this.internal.getCurrentUser();
  }
  async isLoggedIn() {
    return await this.internal.isLoggedIn();
  }
}
auth.Auth = Auth;
var Near$1 = {}, NearProvider$1 = {}, browserIndex$1 = {}, browserIndex = {}, keystore = {};
Object.defineProperty(keystore, "__esModule", { value: !0 });
keystore.KeyStore = void 0;
class KeyStore {
}
keystore.KeyStore = KeyStore;
var in_memory_key_store = {}, key_pair = {};
function commonjsRequire$1(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(nodeCrypto);
(function(n) {
  (function(e) {
    var t = function(q) {
      var Q, ae = new Float64Array(16);
      if (q)
        for (Q = 0; Q < q.length; Q++)
          ae[Q] = q[Q];
      return ae;
    }, o = function() {
      throw new Error("no PRNG");
    }, c = new Uint8Array(16), a = new Uint8Array(32);
    a[0] = 9;
    var d = t(), p = t([1]), w = t([56129, 1]), M = t([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), I = t([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), B = t([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), H = t([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), L = t([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function W(q, Q, ae, k) {
      q[Q] = ae >> 24 & 255, q[Q + 1] = ae >> 16 & 255, q[Q + 2] = ae >> 8 & 255, q[Q + 3] = ae & 255, q[Q + 4] = k >> 24 & 255, q[Q + 5] = k >> 16 & 255, q[Q + 6] = k >> 8 & 255, q[Q + 7] = k & 255;
    }
    function $(q, Q, ae, k, re) {
      var Ee, pe = 0;
      for (Ee = 0; Ee < re; Ee++)
        pe |= q[Q + Ee] ^ ae[k + Ee];
      return (1 & pe - 1 >>> 8) - 1;
    }
    function P(q, Q, ae, k) {
      return $(q, Q, ae, k, 16);
    }
    function U(q, Q, ae, k) {
      return $(q, Q, ae, k, 32);
    }
    function G(q, Q, ae, k) {
      for (var re = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, Ee = ae[0] & 255 | (ae[1] & 255) << 8 | (ae[2] & 255) << 16 | (ae[3] & 255) << 24, pe = ae[4] & 255 | (ae[5] & 255) << 8 | (ae[6] & 255) << 16 | (ae[7] & 255) << 24, _e = ae[8] & 255 | (ae[9] & 255) << 8 | (ae[10] & 255) << 16 | (ae[11] & 255) << 24, bt = ae[12] & 255 | (ae[13] & 255) << 8 | (ae[14] & 255) << 16 | (ae[15] & 255) << 24, Te = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, Re = Q[0] & 255 | (Q[1] & 255) << 8 | (Q[2] & 255) << 16 | (Q[3] & 255) << 24, Dr = Q[4] & 255 | (Q[5] & 255) << 8 | (Q[6] & 255) << 16 | (Q[7] & 255) << 24, vt = Q[8] & 255 | (Q[9] & 255) << 8 | (Q[10] & 255) << 16 | (Q[11] & 255) << 24, pr = Q[12] & 255 | (Q[13] & 255) << 8 | (Q[14] & 255) << 16 | (Q[15] & 255) << 24, Pr = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, Lr = ae[16] & 255 | (ae[17] & 255) << 8 | (ae[18] & 255) << 16 | (ae[19] & 255) << 24, Kr = ae[20] & 255 | (ae[21] & 255) << 8 | (ae[22] & 255) << 16 | (ae[23] & 255) << 24, $r = ae[24] & 255 | (ae[25] & 255) << 8 | (ae[26] & 255) << 16 | (ae[27] & 255) << 24, Fr = ae[28] & 255 | (ae[29] & 255) << 8 | (ae[30] & 255) << 16 | (ae[31] & 255) << 24, Ur = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, ar = re, gr = Ee, zt = pe, lr = _e, dr = bt, wt = Te, Le = Re, Fe = Dr, gt = vt, et = pr, xt = Pr, Et = Lr, jr = Kr, on = $r, an = Fr, sn = Ur, we, Jn = 0; Jn < 20; Jn += 2)
        we = ar + jr | 0, dr ^= we << 7 | we >>> 32 - 7, we = dr + ar | 0, gt ^= we << 9 | we >>> 32 - 9, we = gt + dr | 0, jr ^= we << 13 | we >>> 32 - 13, we = jr + gt | 0, ar ^= we << 18 | we >>> 32 - 18, we = wt + gr | 0, et ^= we << 7 | we >>> 32 - 7, we = et + wt | 0, on ^= we << 9 | we >>> 32 - 9, we = on + et | 0, gr ^= we << 13 | we >>> 32 - 13, we = gr + on | 0, wt ^= we << 18 | we >>> 32 - 18, we = xt + Le | 0, an ^= we << 7 | we >>> 32 - 7, we = an + xt | 0, zt ^= we << 9 | we >>> 32 - 9, we = zt + an | 0, Le ^= we << 13 | we >>> 32 - 13, we = Le + zt | 0, xt ^= we << 18 | we >>> 32 - 18, we = sn + Et | 0, lr ^= we << 7 | we >>> 32 - 7, we = lr + sn | 0, Fe ^= we << 9 | we >>> 32 - 9, we = Fe + lr | 0, Et ^= we << 13 | we >>> 32 - 13, we = Et + Fe | 0, sn ^= we << 18 | we >>> 32 - 18, we = ar + lr | 0, gr ^= we << 7 | we >>> 32 - 7, we = gr + ar | 0, zt ^= we << 9 | we >>> 32 - 9, we = zt + gr | 0, lr ^= we << 13 | we >>> 32 - 13, we = lr + zt | 0, ar ^= we << 18 | we >>> 32 - 18, we = wt + dr | 0, Le ^= we << 7 | we >>> 32 - 7, we = Le + wt | 0, Fe ^= we << 9 | we >>> 32 - 9, we = Fe + Le | 0, dr ^= we << 13 | we >>> 32 - 13, we = dr + Fe | 0, wt ^= we << 18 | we >>> 32 - 18, we = xt + et | 0, Et ^= we << 7 | we >>> 32 - 7, we = Et + xt | 0, gt ^= we << 9 | we >>> 32 - 9, we = gt + Et | 0, et ^= we << 13 | we >>> 32 - 13, we = et + gt | 0, xt ^= we << 18 | we >>> 32 - 18, we = sn + an | 0, jr ^= we << 7 | we >>> 32 - 7, we = jr + sn | 0, on ^= we << 9 | we >>> 32 - 9, we = on + jr | 0, an ^= we << 13 | we >>> 32 - 13, we = an + on | 0, sn ^= we << 18 | we >>> 32 - 18;
      ar = ar + re | 0, gr = gr + Ee | 0, zt = zt + pe | 0, lr = lr + _e | 0, dr = dr + bt | 0, wt = wt + Te | 0, Le = Le + Re | 0, Fe = Fe + Dr | 0, gt = gt + vt | 0, et = et + pr | 0, xt = xt + Pr | 0, Et = Et + Lr | 0, jr = jr + Kr | 0, on = on + $r | 0, an = an + Fr | 0, sn = sn + Ur | 0, q[0] = ar >>> 0 & 255, q[1] = ar >>> 8 & 255, q[2] = ar >>> 16 & 255, q[3] = ar >>> 24 & 255, q[4] = gr >>> 0 & 255, q[5] = gr >>> 8 & 255, q[6] = gr >>> 16 & 255, q[7] = gr >>> 24 & 255, q[8] = zt >>> 0 & 255, q[9] = zt >>> 8 & 255, q[10] = zt >>> 16 & 255, q[11] = zt >>> 24 & 255, q[12] = lr >>> 0 & 255, q[13] = lr >>> 8 & 255, q[14] = lr >>> 16 & 255, q[15] = lr >>> 24 & 255, q[16] = dr >>> 0 & 255, q[17] = dr >>> 8 & 255, q[18] = dr >>> 16 & 255, q[19] = dr >>> 24 & 255, q[20] = wt >>> 0 & 255, q[21] = wt >>> 8 & 255, q[22] = wt >>> 16 & 255, q[23] = wt >>> 24 & 255, q[24] = Le >>> 0 & 255, q[25] = Le >>> 8 & 255, q[26] = Le >>> 16 & 255, q[27] = Le >>> 24 & 255, q[28] = Fe >>> 0 & 255, q[29] = Fe >>> 8 & 255, q[30] = Fe >>> 16 & 255, q[31] = Fe >>> 24 & 255, q[32] = gt >>> 0 & 255, q[33] = gt >>> 8 & 255, q[34] = gt >>> 16 & 255, q[35] = gt >>> 24 & 255, q[36] = et >>> 0 & 255, q[37] = et >>> 8 & 255, q[38] = et >>> 16 & 255, q[39] = et >>> 24 & 255, q[40] = xt >>> 0 & 255, q[41] = xt >>> 8 & 255, q[42] = xt >>> 16 & 255, q[43] = xt >>> 24 & 255, q[44] = Et >>> 0 & 255, q[45] = Et >>> 8 & 255, q[46] = Et >>> 16 & 255, q[47] = Et >>> 24 & 255, q[48] = jr >>> 0 & 255, q[49] = jr >>> 8 & 255, q[50] = jr >>> 16 & 255, q[51] = jr >>> 24 & 255, q[52] = on >>> 0 & 255, q[53] = on >>> 8 & 255, q[54] = on >>> 16 & 255, q[55] = on >>> 24 & 255, q[56] = an >>> 0 & 255, q[57] = an >>> 8 & 255, q[58] = an >>> 16 & 255, q[59] = an >>> 24 & 255, q[60] = sn >>> 0 & 255, q[61] = sn >>> 8 & 255, q[62] = sn >>> 16 & 255, q[63] = sn >>> 24 & 255;
    }
    function D(q, Q, ae, k) {
      for (var re = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, Ee = ae[0] & 255 | (ae[1] & 255) << 8 | (ae[2] & 255) << 16 | (ae[3] & 255) << 24, pe = ae[4] & 255 | (ae[5] & 255) << 8 | (ae[6] & 255) << 16 | (ae[7] & 255) << 24, _e = ae[8] & 255 | (ae[9] & 255) << 8 | (ae[10] & 255) << 16 | (ae[11] & 255) << 24, bt = ae[12] & 255 | (ae[13] & 255) << 8 | (ae[14] & 255) << 16 | (ae[15] & 255) << 24, Te = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, Re = Q[0] & 255 | (Q[1] & 255) << 8 | (Q[2] & 255) << 16 | (Q[3] & 255) << 24, Dr = Q[4] & 255 | (Q[5] & 255) << 8 | (Q[6] & 255) << 16 | (Q[7] & 255) << 24, vt = Q[8] & 255 | (Q[9] & 255) << 8 | (Q[10] & 255) << 16 | (Q[11] & 255) << 24, pr = Q[12] & 255 | (Q[13] & 255) << 8 | (Q[14] & 255) << 16 | (Q[15] & 255) << 24, Pr = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, Lr = ae[16] & 255 | (ae[17] & 255) << 8 | (ae[18] & 255) << 16 | (ae[19] & 255) << 24, Kr = ae[20] & 255 | (ae[21] & 255) << 8 | (ae[22] & 255) << 16 | (ae[23] & 255) << 24, $r = ae[24] & 255 | (ae[25] & 255) << 8 | (ae[26] & 255) << 16 | (ae[27] & 255) << 24, Fr = ae[28] & 255 | (ae[29] & 255) << 8 | (ae[30] & 255) << 16 | (ae[31] & 255) << 24, Ur = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, ar = re, gr = Ee, zt = pe, lr = _e, dr = bt, wt = Te, Le = Re, Fe = Dr, gt = vt, et = pr, xt = Pr, Et = Lr, jr = Kr, on = $r, an = Fr, sn = Ur, we, Jn = 0; Jn < 20; Jn += 2)
        we = ar + jr | 0, dr ^= we << 7 | we >>> 32 - 7, we = dr + ar | 0, gt ^= we << 9 | we >>> 32 - 9, we = gt + dr | 0, jr ^= we << 13 | we >>> 32 - 13, we = jr + gt | 0, ar ^= we << 18 | we >>> 32 - 18, we = wt + gr | 0, et ^= we << 7 | we >>> 32 - 7, we = et + wt | 0, on ^= we << 9 | we >>> 32 - 9, we = on + et | 0, gr ^= we << 13 | we >>> 32 - 13, we = gr + on | 0, wt ^= we << 18 | we >>> 32 - 18, we = xt + Le | 0, an ^= we << 7 | we >>> 32 - 7, we = an + xt | 0, zt ^= we << 9 | we >>> 32 - 9, we = zt + an | 0, Le ^= we << 13 | we >>> 32 - 13, we = Le + zt | 0, xt ^= we << 18 | we >>> 32 - 18, we = sn + Et | 0, lr ^= we << 7 | we >>> 32 - 7, we = lr + sn | 0, Fe ^= we << 9 | we >>> 32 - 9, we = Fe + lr | 0, Et ^= we << 13 | we >>> 32 - 13, we = Et + Fe | 0, sn ^= we << 18 | we >>> 32 - 18, we = ar + lr | 0, gr ^= we << 7 | we >>> 32 - 7, we = gr + ar | 0, zt ^= we << 9 | we >>> 32 - 9, we = zt + gr | 0, lr ^= we << 13 | we >>> 32 - 13, we = lr + zt | 0, ar ^= we << 18 | we >>> 32 - 18, we = wt + dr | 0, Le ^= we << 7 | we >>> 32 - 7, we = Le + wt | 0, Fe ^= we << 9 | we >>> 32 - 9, we = Fe + Le | 0, dr ^= we << 13 | we >>> 32 - 13, we = dr + Fe | 0, wt ^= we << 18 | we >>> 32 - 18, we = xt + et | 0, Et ^= we << 7 | we >>> 32 - 7, we = Et + xt | 0, gt ^= we << 9 | we >>> 32 - 9, we = gt + Et | 0, et ^= we << 13 | we >>> 32 - 13, we = et + gt | 0, xt ^= we << 18 | we >>> 32 - 18, we = sn + an | 0, jr ^= we << 7 | we >>> 32 - 7, we = jr + sn | 0, on ^= we << 9 | we >>> 32 - 9, we = on + jr | 0, an ^= we << 13 | we >>> 32 - 13, we = an + on | 0, sn ^= we << 18 | we >>> 32 - 18;
      q[0] = ar >>> 0 & 255, q[1] = ar >>> 8 & 255, q[2] = ar >>> 16 & 255, q[3] = ar >>> 24 & 255, q[4] = wt >>> 0 & 255, q[5] = wt >>> 8 & 255, q[6] = wt >>> 16 & 255, q[7] = wt >>> 24 & 255, q[8] = xt >>> 0 & 255, q[9] = xt >>> 8 & 255, q[10] = xt >>> 16 & 255, q[11] = xt >>> 24 & 255, q[12] = sn >>> 0 & 255, q[13] = sn >>> 8 & 255, q[14] = sn >>> 16 & 255, q[15] = sn >>> 24 & 255, q[16] = Le >>> 0 & 255, q[17] = Le >>> 8 & 255, q[18] = Le >>> 16 & 255, q[19] = Le >>> 24 & 255, q[20] = Fe >>> 0 & 255, q[21] = Fe >>> 8 & 255, q[22] = Fe >>> 16 & 255, q[23] = Fe >>> 24 & 255, q[24] = gt >>> 0 & 255, q[25] = gt >>> 8 & 255, q[26] = gt >>> 16 & 255, q[27] = gt >>> 24 & 255, q[28] = et >>> 0 & 255, q[29] = et >>> 8 & 255, q[30] = et >>> 16 & 255, q[31] = et >>> 24 & 255;
    }
    function Z(q, Q, ae, k) {
      G(q, Q, ae, k);
    }
    function J(q, Q, ae, k) {
      D(q, Q, ae, k);
    }
    var te = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function ue(q, Q, ae, k, re, Ee, pe) {
      var _e = new Uint8Array(16), bt = new Uint8Array(64), Te, Re;
      for (Re = 0; Re < 16; Re++)
        _e[Re] = 0;
      for (Re = 0; Re < 8; Re++)
        _e[Re] = Ee[Re];
      for (; re >= 64; ) {
        for (Z(bt, _e, pe, te), Re = 0; Re < 64; Re++)
          q[Q + Re] = ae[k + Re] ^ bt[Re];
        for (Te = 1, Re = 8; Re < 16; Re++)
          Te = Te + (_e[Re] & 255) | 0, _e[Re] = Te & 255, Te >>>= 8;
        re -= 64, Q += 64, k += 64;
      }
      if (re > 0)
        for (Z(bt, _e, pe, te), Re = 0; Re < re; Re++)
          q[Q + Re] = ae[k + Re] ^ bt[Re];
      return 0;
    }
    function he(q, Q, ae, k, re) {
      var Ee = new Uint8Array(16), pe = new Uint8Array(64), _e, bt;
      for (bt = 0; bt < 16; bt++)
        Ee[bt] = 0;
      for (bt = 0; bt < 8; bt++)
        Ee[bt] = k[bt];
      for (; ae >= 64; ) {
        for (Z(pe, Ee, re, te), bt = 0; bt < 64; bt++)
          q[Q + bt] = pe[bt];
        for (_e = 1, bt = 8; bt < 16; bt++)
          _e = _e + (Ee[bt] & 255) | 0, Ee[bt] = _e & 255, _e >>>= 8;
        ae -= 64, Q += 64;
      }
      if (ae > 0)
        for (Z(pe, Ee, re, te), bt = 0; bt < ae; bt++)
          q[Q + bt] = pe[bt];
      return 0;
    }
    function Se(q, Q, ae, k, re) {
      var Ee = new Uint8Array(32);
      J(Ee, k, re, te);
      for (var pe = new Uint8Array(8), _e = 0; _e < 8; _e++)
        pe[_e] = k[_e + 16];
      return he(q, Q, ae, pe, Ee);
    }
    function C(q, Q, ae, k, re, Ee, pe) {
      var _e = new Uint8Array(32);
      J(_e, Ee, pe, te);
      for (var bt = new Uint8Array(8), Te = 0; Te < 8; Te++)
        bt[Te] = Ee[Te + 16];
      return ue(q, Q, ae, k, re, bt, _e);
    }
    var O = function(q) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var Q, ae, k, re, Ee, pe, _e, bt;
      Q = q[0] & 255 | (q[1] & 255) << 8, this.r[0] = Q & 8191, ae = q[2] & 255 | (q[3] & 255) << 8, this.r[1] = (Q >>> 13 | ae << 3) & 8191, k = q[4] & 255 | (q[5] & 255) << 8, this.r[2] = (ae >>> 10 | k << 6) & 7939, re = q[6] & 255 | (q[7] & 255) << 8, this.r[3] = (k >>> 7 | re << 9) & 8191, Ee = q[8] & 255 | (q[9] & 255) << 8, this.r[4] = (re >>> 4 | Ee << 12) & 255, this.r[5] = Ee >>> 1 & 8190, pe = q[10] & 255 | (q[11] & 255) << 8, this.r[6] = (Ee >>> 14 | pe << 2) & 8191, _e = q[12] & 255 | (q[13] & 255) << 8, this.r[7] = (pe >>> 11 | _e << 5) & 8065, bt = q[14] & 255 | (q[15] & 255) << 8, this.r[8] = (_e >>> 8 | bt << 8) & 8191, this.r[9] = bt >>> 5 & 127, this.pad[0] = q[16] & 255 | (q[17] & 255) << 8, this.pad[1] = q[18] & 255 | (q[19] & 255) << 8, this.pad[2] = q[20] & 255 | (q[21] & 255) << 8, this.pad[3] = q[22] & 255 | (q[23] & 255) << 8, this.pad[4] = q[24] & 255 | (q[25] & 255) << 8, this.pad[5] = q[26] & 255 | (q[27] & 255) << 8, this.pad[6] = q[28] & 255 | (q[29] & 255) << 8, this.pad[7] = q[30] & 255 | (q[31] & 255) << 8;
    };
    O.prototype.blocks = function(q, Q, ae) {
      for (var k = this.fin ? 0 : 2048, re, Ee, pe, _e, bt, Te, Re, Dr, vt, pr, Pr, Lr, Kr, $r, Fr, Ur, ar, gr, zt, lr = this.h[0], dr = this.h[1], wt = this.h[2], Le = this.h[3], Fe = this.h[4], gt = this.h[5], et = this.h[6], xt = this.h[7], Et = this.h[8], jr = this.h[9], on = this.r[0], an = this.r[1], sn = this.r[2], we = this.r[3], Jn = this.r[4], Hi = this.r[5], Ji = this.r[6], un = this.r[7], Di = this.r[8], Ki = this.r[9]; ae >= 16; )
        re = q[Q + 0] & 255 | (q[Q + 1] & 255) << 8, lr += re & 8191, Ee = q[Q + 2] & 255 | (q[Q + 3] & 255) << 8, dr += (re >>> 13 | Ee << 3) & 8191, pe = q[Q + 4] & 255 | (q[Q + 5] & 255) << 8, wt += (Ee >>> 10 | pe << 6) & 8191, _e = q[Q + 6] & 255 | (q[Q + 7] & 255) << 8, Le += (pe >>> 7 | _e << 9) & 8191, bt = q[Q + 8] & 255 | (q[Q + 9] & 255) << 8, Fe += (_e >>> 4 | bt << 12) & 8191, gt += bt >>> 1 & 8191, Te = q[Q + 10] & 255 | (q[Q + 11] & 255) << 8, et += (bt >>> 14 | Te << 2) & 8191, Re = q[Q + 12] & 255 | (q[Q + 13] & 255) << 8, xt += (Te >>> 11 | Re << 5) & 8191, Dr = q[Q + 14] & 255 | (q[Q + 15] & 255) << 8, Et += (Re >>> 8 | Dr << 8) & 8191, jr += Dr >>> 5 | k, vt = 0, pr = vt, pr += lr * on, pr += dr * (5 * Ki), pr += wt * (5 * Di), pr += Le * (5 * un), pr += Fe * (5 * Ji), vt = pr >>> 13, pr &= 8191, pr += gt * (5 * Hi), pr += et * (5 * Jn), pr += xt * (5 * we), pr += Et * (5 * sn), pr += jr * (5 * an), vt += pr >>> 13, pr &= 8191, Pr = vt, Pr += lr * an, Pr += dr * on, Pr += wt * (5 * Ki), Pr += Le * (5 * Di), Pr += Fe * (5 * un), vt = Pr >>> 13, Pr &= 8191, Pr += gt * (5 * Ji), Pr += et * (5 * Hi), Pr += xt * (5 * Jn), Pr += Et * (5 * we), Pr += jr * (5 * sn), vt += Pr >>> 13, Pr &= 8191, Lr = vt, Lr += lr * sn, Lr += dr * an, Lr += wt * on, Lr += Le * (5 * Ki), Lr += Fe * (5 * Di), vt = Lr >>> 13, Lr &= 8191, Lr += gt * (5 * un), Lr += et * (5 * Ji), Lr += xt * (5 * Hi), Lr += Et * (5 * Jn), Lr += jr * (5 * we), vt += Lr >>> 13, Lr &= 8191, Kr = vt, Kr += lr * we, Kr += dr * sn, Kr += wt * an, Kr += Le * on, Kr += Fe * (5 * Ki), vt = Kr >>> 13, Kr &= 8191, Kr += gt * (5 * Di), Kr += et * (5 * un), Kr += xt * (5 * Ji), Kr += Et * (5 * Hi), Kr += jr * (5 * Jn), vt += Kr >>> 13, Kr &= 8191, $r = vt, $r += lr * Jn, $r += dr * we, $r += wt * sn, $r += Le * an, $r += Fe * on, vt = $r >>> 13, $r &= 8191, $r += gt * (5 * Ki), $r += et * (5 * Di), $r += xt * (5 * un), $r += Et * (5 * Ji), $r += jr * (5 * Hi), vt += $r >>> 13, $r &= 8191, Fr = vt, Fr += lr * Hi, Fr += dr * Jn, Fr += wt * we, Fr += Le * sn, Fr += Fe * an, vt = Fr >>> 13, Fr &= 8191, Fr += gt * on, Fr += et * (5 * Ki), Fr += xt * (5 * Di), Fr += Et * (5 * un), Fr += jr * (5 * Ji), vt += Fr >>> 13, Fr &= 8191, Ur = vt, Ur += lr * Ji, Ur += dr * Hi, Ur += wt * Jn, Ur += Le * we, Ur += Fe * sn, vt = Ur >>> 13, Ur &= 8191, Ur += gt * an, Ur += et * on, Ur += xt * (5 * Ki), Ur += Et * (5 * Di), Ur += jr * (5 * un), vt += Ur >>> 13, Ur &= 8191, ar = vt, ar += lr * un, ar += dr * Ji, ar += wt * Hi, ar += Le * Jn, ar += Fe * we, vt = ar >>> 13, ar &= 8191, ar += gt * sn, ar += et * an, ar += xt * on, ar += Et * (5 * Ki), ar += jr * (5 * Di), vt += ar >>> 13, ar &= 8191, gr = vt, gr += lr * Di, gr += dr * un, gr += wt * Ji, gr += Le * Hi, gr += Fe * Jn, vt = gr >>> 13, gr &= 8191, gr += gt * we, gr += et * sn, gr += xt * an, gr += Et * on, gr += jr * (5 * Ki), vt += gr >>> 13, gr &= 8191, zt = vt, zt += lr * Ki, zt += dr * Di, zt += wt * un, zt += Le * Ji, zt += Fe * Hi, vt = zt >>> 13, zt &= 8191, zt += gt * Jn, zt += et * we, zt += xt * sn, zt += Et * an, zt += jr * on, vt += zt >>> 13, zt &= 8191, vt = (vt << 2) + vt | 0, vt = vt + pr | 0, pr = vt & 8191, vt = vt >>> 13, Pr += vt, lr = pr, dr = Pr, wt = Lr, Le = Kr, Fe = $r, gt = Fr, et = Ur, xt = ar, Et = gr, jr = zt, Q += 16, ae -= 16;
      this.h[0] = lr, this.h[1] = dr, this.h[2] = wt, this.h[3] = Le, this.h[4] = Fe, this.h[5] = gt, this.h[6] = et, this.h[7] = xt, this.h[8] = Et, this.h[9] = jr;
    }, O.prototype.finish = function(q, Q) {
      var ae = new Uint16Array(10), k, re, Ee, pe;
      if (this.leftover) {
        for (pe = this.leftover, this.buffer[pe++] = 1; pe < 16; pe++)
          this.buffer[pe] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (k = this.h[1] >>> 13, this.h[1] &= 8191, pe = 2; pe < 10; pe++)
        this.h[pe] += k, k = this.h[pe] >>> 13, this.h[pe] &= 8191;
      for (this.h[0] += k * 5, k = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += k, k = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += k, ae[0] = this.h[0] + 5, k = ae[0] >>> 13, ae[0] &= 8191, pe = 1; pe < 10; pe++)
        ae[pe] = this.h[pe] + k, k = ae[pe] >>> 13, ae[pe] &= 8191;
      for (ae[9] -= 1 << 13, re = (k ^ 1) - 1, pe = 0; pe < 10; pe++)
        ae[pe] &= re;
      for (re = ~re, pe = 0; pe < 10; pe++)
        this.h[pe] = this.h[pe] & re | ae[pe];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Ee = this.h[0] + this.pad[0], this.h[0] = Ee & 65535, pe = 1; pe < 8; pe++)
        Ee = (this.h[pe] + this.pad[pe] | 0) + (Ee >>> 16) | 0, this.h[pe] = Ee & 65535;
      q[Q + 0] = this.h[0] >>> 0 & 255, q[Q + 1] = this.h[0] >>> 8 & 255, q[Q + 2] = this.h[1] >>> 0 & 255, q[Q + 3] = this.h[1] >>> 8 & 255, q[Q + 4] = this.h[2] >>> 0 & 255, q[Q + 5] = this.h[2] >>> 8 & 255, q[Q + 6] = this.h[3] >>> 0 & 255, q[Q + 7] = this.h[3] >>> 8 & 255, q[Q + 8] = this.h[4] >>> 0 & 255, q[Q + 9] = this.h[4] >>> 8 & 255, q[Q + 10] = this.h[5] >>> 0 & 255, q[Q + 11] = this.h[5] >>> 8 & 255, q[Q + 12] = this.h[6] >>> 0 & 255, q[Q + 13] = this.h[6] >>> 8 & 255, q[Q + 14] = this.h[7] >>> 0 & 255, q[Q + 15] = this.h[7] >>> 8 & 255;
    }, O.prototype.update = function(q, Q, ae) {
      var k, re;
      if (this.leftover) {
        for (re = 16 - this.leftover, re > ae && (re = ae), k = 0; k < re; k++)
          this.buffer[this.leftover + k] = q[Q + k];
        if (ae -= re, Q += re, this.leftover += re, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (ae >= 16 && (re = ae - ae % 16, this.blocks(q, Q, re), Q += re, ae -= re), ae) {
        for (k = 0; k < ae; k++)
          this.buffer[this.leftover + k] = q[Q + k];
        this.leftover += ae;
      }
    };
    function V(q, Q, ae, k, re, Ee) {
      var pe = new O(Ee);
      return pe.update(ae, k, re), pe.finish(q, Q), 0;
    }
    function x(q, Q, ae, k, re, Ee) {
      var pe = new Uint8Array(16);
      return V(pe, 0, ae, k, re, Ee), P(q, Q, pe, 0);
    }
    function u(q, Q, ae, k, re) {
      var Ee;
      if (ae < 32)
        return -1;
      for (C(q, 0, Q, 0, ae, k, re), V(q, 16, q, 32, ae - 32, q), Ee = 0; Ee < 16; Ee++)
        q[Ee] = 0;
      return 0;
    }
    function h(q, Q, ae, k, re) {
      var Ee, pe = new Uint8Array(32);
      if (ae < 32 || (Se(pe, 0, 32, k, re), x(Q, 16, Q, 32, ae - 32, pe) !== 0))
        return -1;
      for (C(q, 0, Q, 0, ae, k, re), Ee = 0; Ee < 32; Ee++)
        q[Ee] = 0;
      return 0;
    }
    function g(q, Q) {
      var ae;
      for (ae = 0; ae < 16; ae++)
        q[ae] = Q[ae] | 0;
    }
    function y(q) {
      var Q, ae, k = 1;
      for (Q = 0; Q < 16; Q++)
        ae = q[Q] + k + 65535, k = Math.floor(ae / 65536), q[Q] = ae - k * 65536;
      q[0] += k - 1 + 37 * (k - 1);
    }
    function m(q, Q, ae) {
      for (var k, re = ~(ae - 1), Ee = 0; Ee < 16; Ee++)
        k = re & (q[Ee] ^ Q[Ee]), q[Ee] ^= k, Q[Ee] ^= k;
    }
    function _(q, Q) {
      var ae, k, re, Ee = t(), pe = t();
      for (ae = 0; ae < 16; ae++)
        pe[ae] = Q[ae];
      for (y(pe), y(pe), y(pe), k = 0; k < 2; k++) {
        for (Ee[0] = pe[0] - 65517, ae = 1; ae < 15; ae++)
          Ee[ae] = pe[ae] - 65535 - (Ee[ae - 1] >> 16 & 1), Ee[ae - 1] &= 65535;
        Ee[15] = pe[15] - 32767 - (Ee[14] >> 16 & 1), re = Ee[15] >> 16 & 1, Ee[14] &= 65535, m(pe, Ee, 1 - re);
      }
      for (ae = 0; ae < 16; ae++)
        q[2 * ae] = pe[ae] & 255, q[2 * ae + 1] = pe[ae] >> 8;
    }
    function R(q, Q) {
      var ae = new Uint8Array(32), k = new Uint8Array(32);
      return _(ae, q), _(k, Q), U(ae, 0, k, 0);
    }
    function b(q) {
      var Q = new Uint8Array(32);
      return _(Q, q), Q[0] & 1;
    }
    function l(q, Q) {
      var ae;
      for (ae = 0; ae < 16; ae++)
        q[ae] = Q[2 * ae] + (Q[2 * ae + 1] << 8);
      q[15] &= 32767;
    }
    function v(q, Q, ae) {
      for (var k = 0; k < 16; k++)
        q[k] = Q[k] + ae[k];
    }
    function X(q, Q, ae) {
      for (var k = 0; k < 16; k++)
        q[k] = Q[k] - ae[k];
    }
    function S(q, Q, ae) {
      var k, re, Ee = 0, pe = 0, _e = 0, bt = 0, Te = 0, Re = 0, Dr = 0, vt = 0, pr = 0, Pr = 0, Lr = 0, Kr = 0, $r = 0, Fr = 0, Ur = 0, ar = 0, gr = 0, zt = 0, lr = 0, dr = 0, wt = 0, Le = 0, Fe = 0, gt = 0, et = 0, xt = 0, Et = 0, jr = 0, on = 0, an = 0, sn = 0, we = ae[0], Jn = ae[1], Hi = ae[2], Ji = ae[3], un = ae[4], Di = ae[5], Ki = ae[6], es = ae[7], Zi = ae[8], Xi = ae[9], Qi = ae[10], eo = ae[11], ts = ae[12], rs = ae[13], ns = ae[14], os = ae[15];
      k = Q[0], Ee += k * we, pe += k * Jn, _e += k * Hi, bt += k * Ji, Te += k * un, Re += k * Di, Dr += k * Ki, vt += k * es, pr += k * Zi, Pr += k * Xi, Lr += k * Qi, Kr += k * eo, $r += k * ts, Fr += k * rs, Ur += k * ns, ar += k * os, k = Q[1], pe += k * we, _e += k * Jn, bt += k * Hi, Te += k * Ji, Re += k * un, Dr += k * Di, vt += k * Ki, pr += k * es, Pr += k * Zi, Lr += k * Xi, Kr += k * Qi, $r += k * eo, Fr += k * ts, Ur += k * rs, ar += k * ns, gr += k * os, k = Q[2], _e += k * we, bt += k * Jn, Te += k * Hi, Re += k * Ji, Dr += k * un, vt += k * Di, pr += k * Ki, Pr += k * es, Lr += k * Zi, Kr += k * Xi, $r += k * Qi, Fr += k * eo, Ur += k * ts, ar += k * rs, gr += k * ns, zt += k * os, k = Q[3], bt += k * we, Te += k * Jn, Re += k * Hi, Dr += k * Ji, vt += k * un, pr += k * Di, Pr += k * Ki, Lr += k * es, Kr += k * Zi, $r += k * Xi, Fr += k * Qi, Ur += k * eo, ar += k * ts, gr += k * rs, zt += k * ns, lr += k * os, k = Q[4], Te += k * we, Re += k * Jn, Dr += k * Hi, vt += k * Ji, pr += k * un, Pr += k * Di, Lr += k * Ki, Kr += k * es, $r += k * Zi, Fr += k * Xi, Ur += k * Qi, ar += k * eo, gr += k * ts, zt += k * rs, lr += k * ns, dr += k * os, k = Q[5], Re += k * we, Dr += k * Jn, vt += k * Hi, pr += k * Ji, Pr += k * un, Lr += k * Di, Kr += k * Ki, $r += k * es, Fr += k * Zi, Ur += k * Xi, ar += k * Qi, gr += k * eo, zt += k * ts, lr += k * rs, dr += k * ns, wt += k * os, k = Q[6], Dr += k * we, vt += k * Jn, pr += k * Hi, Pr += k * Ji, Lr += k * un, Kr += k * Di, $r += k * Ki, Fr += k * es, Ur += k * Zi, ar += k * Xi, gr += k * Qi, zt += k * eo, lr += k * ts, dr += k * rs, wt += k * ns, Le += k * os, k = Q[7], vt += k * we, pr += k * Jn, Pr += k * Hi, Lr += k * Ji, Kr += k * un, $r += k * Di, Fr += k * Ki, Ur += k * es, ar += k * Zi, gr += k * Xi, zt += k * Qi, lr += k * eo, dr += k * ts, wt += k * rs, Le += k * ns, Fe += k * os, k = Q[8], pr += k * we, Pr += k * Jn, Lr += k * Hi, Kr += k * Ji, $r += k * un, Fr += k * Di, Ur += k * Ki, ar += k * es, gr += k * Zi, zt += k * Xi, lr += k * Qi, dr += k * eo, wt += k * ts, Le += k * rs, Fe += k * ns, gt += k * os, k = Q[9], Pr += k * we, Lr += k * Jn, Kr += k * Hi, $r += k * Ji, Fr += k * un, Ur += k * Di, ar += k * Ki, gr += k * es, zt += k * Zi, lr += k * Xi, dr += k * Qi, wt += k * eo, Le += k * ts, Fe += k * rs, gt += k * ns, et += k * os, k = Q[10], Lr += k * we, Kr += k * Jn, $r += k * Hi, Fr += k * Ji, Ur += k * un, ar += k * Di, gr += k * Ki, zt += k * es, lr += k * Zi, dr += k * Xi, wt += k * Qi, Le += k * eo, Fe += k * ts, gt += k * rs, et += k * ns, xt += k * os, k = Q[11], Kr += k * we, $r += k * Jn, Fr += k * Hi, Ur += k * Ji, ar += k * un, gr += k * Di, zt += k * Ki, lr += k * es, dr += k * Zi, wt += k * Xi, Le += k * Qi, Fe += k * eo, gt += k * ts, et += k * rs, xt += k * ns, Et += k * os, k = Q[12], $r += k * we, Fr += k * Jn, Ur += k * Hi, ar += k * Ji, gr += k * un, zt += k * Di, lr += k * Ki, dr += k * es, wt += k * Zi, Le += k * Xi, Fe += k * Qi, gt += k * eo, et += k * ts, xt += k * rs, Et += k * ns, jr += k * os, k = Q[13], Fr += k * we, Ur += k * Jn, ar += k * Hi, gr += k * Ji, zt += k * un, lr += k * Di, dr += k * Ki, wt += k * es, Le += k * Zi, Fe += k * Xi, gt += k * Qi, et += k * eo, xt += k * ts, Et += k * rs, jr += k * ns, on += k * os, k = Q[14], Ur += k * we, ar += k * Jn, gr += k * Hi, zt += k * Ji, lr += k * un, dr += k * Di, wt += k * Ki, Le += k * es, Fe += k * Zi, gt += k * Xi, et += k * Qi, xt += k * eo, Et += k * ts, jr += k * rs, on += k * ns, an += k * os, k = Q[15], ar += k * we, gr += k * Jn, zt += k * Hi, lr += k * Ji, dr += k * un, wt += k * Di, Le += k * Ki, Fe += k * es, gt += k * Zi, et += k * Xi, xt += k * Qi, Et += k * eo, jr += k * ts, on += k * rs, an += k * ns, sn += k * os, Ee += 38 * gr, pe += 38 * zt, _e += 38 * lr, bt += 38 * dr, Te += 38 * wt, Re += 38 * Le, Dr += 38 * Fe, vt += 38 * gt, pr += 38 * et, Pr += 38 * xt, Lr += 38 * Et, Kr += 38 * jr, $r += 38 * on, Fr += 38 * an, Ur += 38 * sn, re = 1, k = Ee + re + 65535, re = Math.floor(k / 65536), Ee = k - re * 65536, k = pe + re + 65535, re = Math.floor(k / 65536), pe = k - re * 65536, k = _e + re + 65535, re = Math.floor(k / 65536), _e = k - re * 65536, k = bt + re + 65535, re = Math.floor(k / 65536), bt = k - re * 65536, k = Te + re + 65535, re = Math.floor(k / 65536), Te = k - re * 65536, k = Re + re + 65535, re = Math.floor(k / 65536), Re = k - re * 65536, k = Dr + re + 65535, re = Math.floor(k / 65536), Dr = k - re * 65536, k = vt + re + 65535, re = Math.floor(k / 65536), vt = k - re * 65536, k = pr + re + 65535, re = Math.floor(k / 65536), pr = k - re * 65536, k = Pr + re + 65535, re = Math.floor(k / 65536), Pr = k - re * 65536, k = Lr + re + 65535, re = Math.floor(k / 65536), Lr = k - re * 65536, k = Kr + re + 65535, re = Math.floor(k / 65536), Kr = k - re * 65536, k = $r + re + 65535, re = Math.floor(k / 65536), $r = k - re * 65536, k = Fr + re + 65535, re = Math.floor(k / 65536), Fr = k - re * 65536, k = Ur + re + 65535, re = Math.floor(k / 65536), Ur = k - re * 65536, k = ar + re + 65535, re = Math.floor(k / 65536), ar = k - re * 65536, Ee += re - 1 + 37 * (re - 1), re = 1, k = Ee + re + 65535, re = Math.floor(k / 65536), Ee = k - re * 65536, k = pe + re + 65535, re = Math.floor(k / 65536), pe = k - re * 65536, k = _e + re + 65535, re = Math.floor(k / 65536), _e = k - re * 65536, k = bt + re + 65535, re = Math.floor(k / 65536), bt = k - re * 65536, k = Te + re + 65535, re = Math.floor(k / 65536), Te = k - re * 65536, k = Re + re + 65535, re = Math.floor(k / 65536), Re = k - re * 65536, k = Dr + re + 65535, re = Math.floor(k / 65536), Dr = k - re * 65536, k = vt + re + 65535, re = Math.floor(k / 65536), vt = k - re * 65536, k = pr + re + 65535, re = Math.floor(k / 65536), pr = k - re * 65536, k = Pr + re + 65535, re = Math.floor(k / 65536), Pr = k - re * 65536, k = Lr + re + 65535, re = Math.floor(k / 65536), Lr = k - re * 65536, k = Kr + re + 65535, re = Math.floor(k / 65536), Kr = k - re * 65536, k = $r + re + 65535, re = Math.floor(k / 65536), $r = k - re * 65536, k = Fr + re + 65535, re = Math.floor(k / 65536), Fr = k - re * 65536, k = Ur + re + 65535, re = Math.floor(k / 65536), Ur = k - re * 65536, k = ar + re + 65535, re = Math.floor(k / 65536), ar = k - re * 65536, Ee += re - 1 + 37 * (re - 1), q[0] = Ee, q[1] = pe, q[2] = _e, q[3] = bt, q[4] = Te, q[5] = Re, q[6] = Dr, q[7] = vt, q[8] = pr, q[9] = Pr, q[10] = Lr, q[11] = Kr, q[12] = $r, q[13] = Fr, q[14] = Ur, q[15] = ar;
    }
    function Y(q, Q) {
      S(q, Q, Q);
    }
    function fe(q, Q) {
      var ae = t(), k;
      for (k = 0; k < 16; k++)
        ae[k] = Q[k];
      for (k = 253; k >= 0; k--)
        Y(ae, ae), k !== 2 && k !== 4 && S(ae, ae, Q);
      for (k = 0; k < 16; k++)
        q[k] = ae[k];
    }
    function oe(q, Q) {
      var ae = t(), k;
      for (k = 0; k < 16; k++)
        ae[k] = Q[k];
      for (k = 250; k >= 0; k--)
        Y(ae, ae), k !== 1 && S(ae, ae, Q);
      for (k = 0; k < 16; k++)
        q[k] = ae[k];
    }
    function de(q, Q, ae) {
      var k = new Uint8Array(32), re = new Float64Array(80), Ee, pe, _e = t(), bt = t(), Te = t(), Re = t(), Dr = t(), vt = t();
      for (pe = 0; pe < 31; pe++)
        k[pe] = Q[pe];
      for (k[31] = Q[31] & 127 | 64, k[0] &= 248, l(re, ae), pe = 0; pe < 16; pe++)
        bt[pe] = re[pe], Re[pe] = _e[pe] = Te[pe] = 0;
      for (_e[0] = Re[0] = 1, pe = 254; pe >= 0; --pe)
        Ee = k[pe >>> 3] >>> (pe & 7) & 1, m(_e, bt, Ee), m(Te, Re, Ee), v(Dr, _e, Te), X(_e, _e, Te), v(Te, bt, Re), X(bt, bt, Re), Y(Re, Dr), Y(vt, _e), S(_e, Te, _e), S(Te, bt, Dr), v(Dr, _e, Te), X(_e, _e, Te), Y(bt, _e), X(Te, Re, vt), S(_e, Te, w), v(_e, _e, Re), S(Te, Te, _e), S(_e, Re, vt), S(Re, bt, re), Y(bt, Dr), m(_e, bt, Ee), m(Te, Re, Ee);
      for (pe = 0; pe < 16; pe++)
        re[pe + 16] = _e[pe], re[pe + 32] = Te[pe], re[pe + 48] = bt[pe], re[pe + 64] = Re[pe];
      var pr = re.subarray(32), Pr = re.subarray(16);
      return fe(pr, pr), S(Pr, Pr, pr), _(q, Pr), 0;
    }
    function Ie(q, Q) {
      return de(q, Q, a);
    }
    function ye(q, Q) {
      return o(Q, 32), Ie(q, Q);
    }
    function be(q, Q, ae) {
      var k = new Uint8Array(32);
      return de(k, ae, Q), J(q, c, k, te);
    }
    var rt = u, xe = h;
    function Ne(q, Q, ae, k, re, Ee) {
      var pe = new Uint8Array(32);
      return be(pe, re, Ee), rt(q, Q, ae, k, pe);
    }
    function j(q, Q, ae, k, re, Ee) {
      var pe = new Uint8Array(32);
      return be(pe, re, Ee), xe(q, Q, ae, k, pe);
    }
    var z = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function ee(q, Q, ae, k) {
      for (var re = new Int32Array(16), Ee = new Int32Array(16), pe, _e, bt, Te, Re, Dr, vt, pr, Pr, Lr, Kr, $r, Fr, Ur, ar, gr, zt, lr, dr, wt, Le, Fe, gt, et, xt, Et, jr = q[0], on = q[1], an = q[2], sn = q[3], we = q[4], Jn = q[5], Hi = q[6], Ji = q[7], un = Q[0], Di = Q[1], Ki = Q[2], es = Q[3], Zi = Q[4], Xi = Q[5], Qi = Q[6], eo = Q[7], ts = 0; k >= 128; ) {
        for (dr = 0; dr < 16; dr++)
          wt = 8 * dr + ts, re[dr] = ae[wt + 0] << 24 | ae[wt + 1] << 16 | ae[wt + 2] << 8 | ae[wt + 3], Ee[dr] = ae[wt + 4] << 24 | ae[wt + 5] << 16 | ae[wt + 6] << 8 | ae[wt + 7];
        for (dr = 0; dr < 80; dr++)
          if (pe = jr, _e = on, bt = an, Te = sn, Re = we, Dr = Jn, vt = Hi, pr = Ji, Pr = un, Lr = Di, Kr = Ki, $r = es, Fr = Zi, Ur = Xi, ar = Qi, gr = eo, Le = Ji, Fe = eo, gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = (we >>> 14 | Zi << 32 - 14) ^ (we >>> 18 | Zi << 32 - 18) ^ (Zi >>> 41 - 32 | we << 32 - (41 - 32)), Fe = (Zi >>> 14 | we << 32 - 14) ^ (Zi >>> 18 | we << 32 - 18) ^ (we >>> 41 - 32 | Zi << 32 - (41 - 32)), gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, Le = we & Jn ^ ~we & Hi, Fe = Zi & Xi ^ ~Zi & Qi, gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, Le = z[dr * 2], Fe = z[dr * 2 + 1], gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, Le = re[dr % 16], Fe = Ee[dr % 16], gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, zt = xt & 65535 | Et << 16, lr = gt & 65535 | et << 16, Le = zt, Fe = lr, gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = (jr >>> 28 | un << 32 - 28) ^ (un >>> 34 - 32 | jr << 32 - (34 - 32)) ^ (un >>> 39 - 32 | jr << 32 - (39 - 32)), Fe = (un >>> 28 | jr << 32 - 28) ^ (jr >>> 34 - 32 | un << 32 - (34 - 32)) ^ (jr >>> 39 - 32 | un << 32 - (39 - 32)), gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, Le = jr & on ^ jr & an ^ on & an, Fe = un & Di ^ un & Ki ^ Di & Ki, gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, pr = xt & 65535 | Et << 16, gr = gt & 65535 | et << 16, Le = Te, Fe = $r, gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = zt, Fe = lr, gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, Te = xt & 65535 | Et << 16, $r = gt & 65535 | et << 16, on = pe, an = _e, sn = bt, we = Te, Jn = Re, Hi = Dr, Ji = vt, jr = pr, Di = Pr, Ki = Lr, es = Kr, Zi = $r, Xi = Fr, Qi = Ur, eo = ar, un = gr, dr % 16 === 15)
            for (wt = 0; wt < 16; wt++)
              Le = re[wt], Fe = Ee[wt], gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = re[(wt + 9) % 16], Fe = Ee[(wt + 9) % 16], gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, zt = re[(wt + 1) % 16], lr = Ee[(wt + 1) % 16], Le = (zt >>> 1 | lr << 32 - 1) ^ (zt >>> 8 | lr << 32 - 8) ^ zt >>> 7, Fe = (lr >>> 1 | zt << 32 - 1) ^ (lr >>> 8 | zt << 32 - 8) ^ (lr >>> 7 | zt << 32 - 7), gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, zt = re[(wt + 14) % 16], lr = Ee[(wt + 14) % 16], Le = (zt >>> 19 | lr << 32 - 19) ^ (lr >>> 61 - 32 | zt << 32 - (61 - 32)) ^ zt >>> 6, Fe = (lr >>> 19 | zt << 32 - 19) ^ (zt >>> 61 - 32 | lr << 32 - (61 - 32)) ^ (lr >>> 6 | zt << 32 - 6), gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, re[wt] = xt & 65535 | Et << 16, Ee[wt] = gt & 65535 | et << 16;
        Le = jr, Fe = un, gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = q[0], Fe = Q[0], gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, q[0] = jr = xt & 65535 | Et << 16, Q[0] = un = gt & 65535 | et << 16, Le = on, Fe = Di, gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = q[1], Fe = Q[1], gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, q[1] = on = xt & 65535 | Et << 16, Q[1] = Di = gt & 65535 | et << 16, Le = an, Fe = Ki, gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = q[2], Fe = Q[2], gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, q[2] = an = xt & 65535 | Et << 16, Q[2] = Ki = gt & 65535 | et << 16, Le = sn, Fe = es, gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = q[3], Fe = Q[3], gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, q[3] = sn = xt & 65535 | Et << 16, Q[3] = es = gt & 65535 | et << 16, Le = we, Fe = Zi, gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = q[4], Fe = Q[4], gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, q[4] = we = xt & 65535 | Et << 16, Q[4] = Zi = gt & 65535 | et << 16, Le = Jn, Fe = Xi, gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = q[5], Fe = Q[5], gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, q[5] = Jn = xt & 65535 | Et << 16, Q[5] = Xi = gt & 65535 | et << 16, Le = Hi, Fe = Qi, gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = q[6], Fe = Q[6], gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, q[6] = Hi = xt & 65535 | Et << 16, Q[6] = Qi = gt & 65535 | et << 16, Le = Ji, Fe = eo, gt = Fe & 65535, et = Fe >>> 16, xt = Le & 65535, Et = Le >>> 16, Le = q[7], Fe = Q[7], gt += Fe & 65535, et += Fe >>> 16, xt += Le & 65535, Et += Le >>> 16, et += gt >>> 16, xt += et >>> 16, Et += xt >>> 16, q[7] = Ji = xt & 65535 | Et << 16, Q[7] = eo = gt & 65535 | et << 16, ts += 128, k -= 128;
      }
      return k;
    }
    function ve(q, Q, ae) {
      var k = new Int32Array(8), re = new Int32Array(8), Ee = new Uint8Array(256), pe, _e = ae;
      for (k[0] = 1779033703, k[1] = 3144134277, k[2] = 1013904242, k[3] = 2773480762, k[4] = 1359893119, k[5] = 2600822924, k[6] = 528734635, k[7] = 1541459225, re[0] = 4089235720, re[1] = 2227873595, re[2] = 4271175723, re[3] = 1595750129, re[4] = 2917565137, re[5] = 725511199, re[6] = 4215389547, re[7] = 327033209, ee(k, re, Q, ae), ae %= 128, pe = 0; pe < ae; pe++)
        Ee[pe] = Q[_e - ae + pe];
      for (Ee[ae] = 128, ae = 256 - 128 * (ae < 112 ? 1 : 0), Ee[ae - 9] = 0, W(Ee, ae - 8, _e / 536870912 | 0, _e << 3), ee(k, re, Ee, ae), pe = 0; pe < 8; pe++)
        W(q, 8 * pe, k[pe], re[pe]);
      return 0;
    }
    function me(q, Q) {
      var ae = t(), k = t(), re = t(), Ee = t(), pe = t(), _e = t(), bt = t(), Te = t(), Re = t();
      X(ae, q[1], q[0]), X(Re, Q[1], Q[0]), S(ae, ae, Re), v(k, q[0], q[1]), v(Re, Q[0], Q[1]), S(k, k, Re), S(re, q[3], Q[3]), S(re, re, I), S(Ee, q[2], Q[2]), v(Ee, Ee, Ee), X(pe, k, ae), X(_e, Ee, re), v(bt, Ee, re), v(Te, k, ae), S(q[0], pe, _e), S(q[1], Te, bt), S(q[2], bt, _e), S(q[3], pe, Te);
    }
    function Ae(q, Q, ae) {
      var k;
      for (k = 0; k < 4; k++)
        m(q[k], Q[k], ae);
    }
    function it(q, Q) {
      var ae = t(), k = t(), re = t();
      fe(re, Q[2]), S(ae, Q[0], re), S(k, Q[1], re), _(q, k), q[31] ^= b(ae) << 7;
    }
    function ke(q, Q, ae) {
      var k, re;
      for (g(q[0], d), g(q[1], p), g(q[2], p), g(q[3], d), re = 255; re >= 0; --re)
        k = ae[re / 8 | 0] >> (re & 7) & 1, Ae(q, Q, k), me(Q, q), me(q, q), Ae(q, Q, k);
    }
    function qe(q, Q) {
      var ae = [t(), t(), t(), t()];
      g(ae[0], B), g(ae[1], H), g(ae[2], p), S(ae[3], B, H), ke(q, ae, Q);
    }
    function or(q, Q, ae) {
      var k = new Uint8Array(64), re = [t(), t(), t(), t()], Ee;
      for (ae || o(Q, 32), ve(k, Q, 32), k[0] &= 248, k[31] &= 127, k[31] |= 64, qe(re, k), it(q, re), Ee = 0; Ee < 32; Ee++)
        Q[Ee + 32] = q[Ee];
      return 0;
    }
    var Oe = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function T(q, Q) {
      var ae, k, re, Ee;
      for (k = 63; k >= 32; --k) {
        for (ae = 0, re = k - 32, Ee = k - 12; re < Ee; ++re)
          Q[re] += ae - 16 * Q[k] * Oe[re - (k - 32)], ae = Math.floor((Q[re] + 128) / 256), Q[re] -= ae * 256;
        Q[re] += ae, Q[k] = 0;
      }
      for (ae = 0, re = 0; re < 32; re++)
        Q[re] += ae - (Q[31] >> 4) * Oe[re], ae = Q[re] >> 8, Q[re] &= 255;
      for (re = 0; re < 32; re++)
        Q[re] -= ae * Oe[re];
      for (k = 0; k < 32; k++)
        Q[k + 1] += Q[k] >> 8, q[k] = Q[k] & 255;
    }
    function A(q) {
      var Q = new Float64Array(64), ae;
      for (ae = 0; ae < 64; ae++)
        Q[ae] = q[ae];
      for (ae = 0; ae < 64; ae++)
        q[ae] = 0;
      T(q, Q);
    }
    function E(q, Q, ae, k) {
      var re = new Uint8Array(64), Ee = new Uint8Array(64), pe = new Uint8Array(64), _e, bt, Te = new Float64Array(64), Re = [t(), t(), t(), t()];
      ve(re, k, 32), re[0] &= 248, re[31] &= 127, re[31] |= 64;
      var Dr = ae + 64;
      for (_e = 0; _e < ae; _e++)
        q[64 + _e] = Q[_e];
      for (_e = 0; _e < 32; _e++)
        q[32 + _e] = re[32 + _e];
      for (ve(pe, q.subarray(32), ae + 32), A(pe), qe(Re, pe), it(q, Re), _e = 32; _e < 64; _e++)
        q[_e] = k[_e];
      for (ve(Ee, q, ae + 64), A(Ee), _e = 0; _e < 64; _e++)
        Te[_e] = 0;
      for (_e = 0; _e < 32; _e++)
        Te[_e] = pe[_e];
      for (_e = 0; _e < 32; _e++)
        for (bt = 0; bt < 32; bt++)
          Te[_e + bt] += Ee[_e] * re[bt];
      return T(q.subarray(32), Te), Dr;
    }
    function F(q, Q) {
      var ae = t(), k = t(), re = t(), Ee = t(), pe = t(), _e = t(), bt = t();
      return g(q[2], p), l(q[1], Q), Y(re, q[1]), S(Ee, re, M), X(re, re, q[2]), v(Ee, q[2], Ee), Y(pe, Ee), Y(_e, pe), S(bt, _e, pe), S(ae, bt, re), S(ae, ae, Ee), oe(ae, ae), S(ae, ae, re), S(ae, ae, Ee), S(ae, ae, Ee), S(q[0], ae, Ee), Y(k, q[0]), S(k, k, Ee), R(k, re) && S(q[0], q[0], L), Y(k, q[0]), S(k, k, Ee), R(k, re) ? -1 : (b(q[0]) === Q[31] >> 7 && X(q[0], d, q[0]), S(q[3], q[0], q[1]), 0);
    }
    function ie(q, Q, ae, k) {
      var re, Ee = new Uint8Array(32), pe = new Uint8Array(64), _e = [t(), t(), t(), t()], bt = [t(), t(), t(), t()];
      if (ae < 64 || F(bt, k))
        return -1;
      for (re = 0; re < ae; re++)
        q[re] = Q[re];
      for (re = 0; re < 32; re++)
        q[re + 32] = k[re];
      if (ve(pe, q, ae), A(pe), ke(_e, bt, pe), qe(bt, Q.subarray(32)), me(_e, bt), it(Ee, _e), ae -= 64, U(Q, 0, Ee, 0)) {
        for (re = 0; re < ae; re++)
          q[re] = 0;
        return -1;
      }
      for (re = 0; re < ae; re++)
        q[re] = Q[re + 64];
      return ae;
    }
    var ne = 32, ce = 24, nt = 32, Be = 16, Ce = 32, _t = 32, Me = 32, pt = 32, qr = 32, Xe = ce, yt = nt, Zr = Be, He = 64, dt = 32, Hr = 64, Ze = 32, mt = 64;
    e.lowlevel = {
      crypto_core_hsalsa20: J,
      crypto_stream_xor: C,
      crypto_stream: Se,
      crypto_stream_salsa20_xor: ue,
      crypto_stream_salsa20: he,
      crypto_onetimeauth: V,
      crypto_onetimeauth_verify: x,
      crypto_verify_16: P,
      crypto_verify_32: U,
      crypto_secretbox: u,
      crypto_secretbox_open: h,
      crypto_scalarmult: de,
      crypto_scalarmult_base: Ie,
      crypto_box_beforenm: be,
      crypto_box_afternm: rt,
      crypto_box: Ne,
      crypto_box_open: j,
      crypto_box_keypair: ye,
      crypto_hash: ve,
      crypto_sign: E,
      crypto_sign_keypair: or,
      crypto_sign_open: ie,
      crypto_secretbox_KEYBYTES: ne,
      crypto_secretbox_NONCEBYTES: ce,
      crypto_secretbox_ZEROBYTES: nt,
      crypto_secretbox_BOXZEROBYTES: Be,
      crypto_scalarmult_BYTES: Ce,
      crypto_scalarmult_SCALARBYTES: _t,
      crypto_box_PUBLICKEYBYTES: Me,
      crypto_box_SECRETKEYBYTES: pt,
      crypto_box_BEFORENMBYTES: qr,
      crypto_box_NONCEBYTES: Xe,
      crypto_box_ZEROBYTES: yt,
      crypto_box_BOXZEROBYTES: Zr,
      crypto_sign_BYTES: He,
      crypto_sign_PUBLICKEYBYTES: dt,
      crypto_sign_SECRETKEYBYTES: Hr,
      crypto_sign_SEEDBYTES: Ze,
      crypto_hash_BYTES: mt,
      gf: t,
      D: M,
      L: Oe,
      pack25519: _,
      unpack25519: l,
      M: S,
      A: v,
      S: Y,
      Z: X,
      pow2523: oe,
      add: me,
      set25519: g,
      modL: T,
      scalarmult: ke,
      scalarbase: qe
    };
    function zr(q, Q) {
      if (q.length !== ne)
        throw new Error("bad key size");
      if (Q.length !== ce)
        throw new Error("bad nonce size");
    }
    function Qe(q, Q) {
      if (q.length !== Me)
        throw new Error("bad public key size");
      if (Q.length !== pt)
        throw new Error("bad secret key size");
    }
    function tt() {
      for (var q = 0; q < arguments.length; q++)
        if (!(arguments[q] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Wr(q) {
      for (var Q = 0; Q < q.length; Q++)
        q[Q] = 0;
    }
    e.randomBytes = function(q) {
      var Q = new Uint8Array(q);
      return o(Q, q), Q;
    }, e.secretbox = function(q, Q, ae) {
      tt(q, Q, ae), zr(ae, Q);
      for (var k = new Uint8Array(nt + q.length), re = new Uint8Array(k.length), Ee = 0; Ee < q.length; Ee++)
        k[Ee + nt] = q[Ee];
      return u(re, k, k.length, Q, ae), re.subarray(Be);
    }, e.secretbox.open = function(q, Q, ae) {
      tt(q, Q, ae), zr(ae, Q);
      for (var k = new Uint8Array(Be + q.length), re = new Uint8Array(k.length), Ee = 0; Ee < q.length; Ee++)
        k[Ee + Be] = q[Ee];
      return k.length < 32 || h(re, k, k.length, Q, ae) !== 0 ? null : re.subarray(nt);
    }, e.secretbox.keyLength = ne, e.secretbox.nonceLength = ce, e.secretbox.overheadLength = Be, e.scalarMult = function(q, Q) {
      if (tt(q, Q), q.length !== _t)
        throw new Error("bad n size");
      if (Q.length !== Ce)
        throw new Error("bad p size");
      var ae = new Uint8Array(Ce);
      return de(ae, q, Q), ae;
    }, e.scalarMult.base = function(q) {
      if (tt(q), q.length !== _t)
        throw new Error("bad n size");
      var Q = new Uint8Array(Ce);
      return Ie(Q, q), Q;
    }, e.scalarMult.scalarLength = _t, e.scalarMult.groupElementLength = Ce, e.box = function(q, Q, ae, k) {
      var re = e.box.before(ae, k);
      return e.secretbox(q, Q, re);
    }, e.box.before = function(q, Q) {
      tt(q, Q), Qe(q, Q);
      var ae = new Uint8Array(qr);
      return be(ae, q, Q), ae;
    }, e.box.after = e.secretbox, e.box.open = function(q, Q, ae, k) {
      var re = e.box.before(ae, k);
      return e.secretbox.open(q, Q, re);
    }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
      var q = new Uint8Array(Me), Q = new Uint8Array(pt);
      return ye(q, Q), { publicKey: q, secretKey: Q };
    }, e.box.keyPair.fromSecretKey = function(q) {
      if (tt(q), q.length !== pt)
        throw new Error("bad secret key size");
      var Q = new Uint8Array(Me);
      return Ie(Q, q), { publicKey: Q, secretKey: new Uint8Array(q) };
    }, e.box.publicKeyLength = Me, e.box.secretKeyLength = pt, e.box.sharedKeyLength = qr, e.box.nonceLength = Xe, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function(q, Q) {
      if (tt(q, Q), Q.length !== Hr)
        throw new Error("bad secret key size");
      var ae = new Uint8Array(He + q.length);
      return E(ae, q, q.length, Q), ae;
    }, e.sign.open = function(q, Q) {
      if (tt(q, Q), Q.length !== dt)
        throw new Error("bad public key size");
      var ae = new Uint8Array(q.length), k = ie(ae, q, q.length, Q);
      if (k < 0)
        return null;
      for (var re = new Uint8Array(k), Ee = 0; Ee < re.length; Ee++)
        re[Ee] = ae[Ee];
      return re;
    }, e.sign.detached = function(q, Q) {
      for (var ae = e.sign(q, Q), k = new Uint8Array(He), re = 0; re < k.length; re++)
        k[re] = ae[re];
      return k;
    }, e.sign.detached.verify = function(q, Q, ae) {
      if (tt(q, Q, ae), Q.length !== He)
        throw new Error("bad signature size");
      if (ae.length !== dt)
        throw new Error("bad public key size");
      var k = new Uint8Array(He + q.length), re = new Uint8Array(He + q.length), Ee;
      for (Ee = 0; Ee < He; Ee++)
        k[Ee] = Q[Ee];
      for (Ee = 0; Ee < q.length; Ee++)
        k[Ee + He] = q[Ee];
      return ie(re, k, k.length, ae) >= 0;
    }, e.sign.keyPair = function() {
      var q = new Uint8Array(dt), Q = new Uint8Array(Hr);
      return or(q, Q), { publicKey: q, secretKey: Q };
    }, e.sign.keyPair.fromSecretKey = function(q) {
      if (tt(q), q.length !== Hr)
        throw new Error("bad secret key size");
      for (var Q = new Uint8Array(dt), ae = 0; ae < Q.length; ae++)
        Q[ae] = q[32 + ae];
      return { publicKey: Q, secretKey: new Uint8Array(q) };
    }, e.sign.keyPair.fromSeed = function(q) {
      if (tt(q), q.length !== Ze)
        throw new Error("bad seed size");
      for (var Q = new Uint8Array(dt), ae = new Uint8Array(Hr), k = 0; k < 32; k++)
        ae[k] = q[k];
      return or(Q, ae, !0), { publicKey: Q, secretKey: ae };
    }, e.sign.publicKeyLength = dt, e.sign.secretKeyLength = Hr, e.sign.seedLength = Ze, e.sign.signatureLength = He, e.hash = function(q) {
      tt(q);
      var Q = new Uint8Array(mt);
      return ve(Q, q, q.length), Q;
    }, e.hash.hashLength = mt, e.verify = function(q, Q) {
      return tt(q, Q), q.length === 0 || Q.length === 0 || q.length !== Q.length ? !1 : $(q, 0, Q, 0, q.length) === 0;
    }, e.setPRNG = function(q) {
      o = q;
    }, function() {
      var q = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (q && q.getRandomValues) {
        var Q = 65536;
        e.setPRNG(function(ae, k) {
          var re, Ee = new Uint8Array(k);
          for (re = 0; re < k; re += Q)
            q.getRandomValues(Ee.subarray(re, re + Math.min(k - re, Q)));
          for (re = 0; re < k; re++)
            ae[re] = Ee[re];
          Wr(Ee);
        });
      } else
        typeof commonjsRequire$1 < "u" && (q = require$$0$3, q && q.randomBytes && e.setPRNG(function(ae, k) {
          var re, Ee = q.randomBytes(k);
          for (re = 0; re < k; re++)
            ae[re] = Ee[re];
          Wr(Ee);
        }));
    }();
  })(n.exports ? n.exports : self.nacl = self.nacl || {});
})(naclFast);
var serialize$2 = {}, lib$4 = {}, bn$5 = { exports: {} };
(function(n) {
  (function(e, t) {
    function o(x, u) {
      if (!x)
        throw new Error(u || "Assertion failed");
    }
    function c(x, u) {
      x.super_ = u;
      var h = function() {
      };
      h.prototype = u.prototype, x.prototype = new h(), x.prototype.constructor = x;
    }
    function a(x, u, h) {
      if (a.isBN(x))
        return x;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, x !== null && ((u === "le" || u === "be") && (h = u, u = 10), this._init(x || 0, u || 10, h || "be"));
    }
    typeof e == "object" ? e.exports = a : t.BN = a, a.BN = a, a.wordSize = 26;
    var d;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? d = window.Buffer : d = require$$0$3.Buffer;
    } catch {
    }
    a.isBN = function(u) {
      return u instanceof a ? !0 : u !== null && typeof u == "object" && u.constructor.wordSize === a.wordSize && Array.isArray(u.words);
    }, a.max = function(u, h) {
      return u.cmp(h) > 0 ? u : h;
    }, a.min = function(u, h) {
      return u.cmp(h) < 0 ? u : h;
    }, a.prototype._init = function(u, h, g) {
      if (typeof u == "number")
        return this._initNumber(u, h, g);
      if (typeof u == "object")
        return this._initArray(u, h, g);
      h === "hex" && (h = 16), o(h === (h | 0) && h >= 2 && h <= 36), u = u.toString().replace(/\s+/g, "");
      var y = 0;
      u[0] === "-" && (y++, this.negative = 1), y < u.length && (h === 16 ? this._parseHex(u, y, g) : (this._parseBase(u, h, y), g === "le" && this._initArray(this.toArray(), h, g)));
    }, a.prototype._initNumber = function(u, h, g) {
      u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [
        u & 67108863,
        u / 67108864 & 67108863
      ], this.length = 2) : (o(u < 9007199254740992), this.words = [
        u & 67108863,
        u / 67108864 & 67108863,
        1
      ], this.length = 3), g === "le" && this._initArray(this.toArray(), h, g);
    }, a.prototype._initArray = function(u, h, g) {
      if (o(typeof u.length == "number"), u.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var m, _, R = 0;
      if (g === "be")
        for (y = u.length - 1, m = 0; y >= 0; y -= 3)
          _ = u[y] | u[y - 1] << 8 | u[y - 2] << 16, this.words[m] |= _ << R & 67108863, this.words[m + 1] = _ >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, m++);
      else if (g === "le")
        for (y = 0, m = 0; y < u.length; y += 3)
          _ = u[y] | u[y + 1] << 8 | u[y + 2] << 16, this.words[m] |= _ << R & 67108863, this.words[m + 1] = _ >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, m++);
      return this._strip();
    };
    function p(x, u) {
      var h = x.charCodeAt(u);
      if (h >= 48 && h <= 57)
        return h - 48;
      if (h >= 65 && h <= 70)
        return h - 55;
      if (h >= 97 && h <= 102)
        return h - 87;
      o(!1, "Invalid character in " + x);
    }
    function w(x, u, h) {
      var g = p(x, h);
      return h - 1 >= u && (g |= p(x, h - 1) << 4), g;
    }
    a.prototype._parseHex = function(u, h, g) {
      this.length = Math.ceil((u.length - h) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var m = 0, _ = 0, R;
      if (g === "be")
        for (y = u.length - 1; y >= h; y -= 2)
          R = w(u, h, y) << m, this.words[_] |= R & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= R >>> 26) : m += 8;
      else {
        var b = u.length - h;
        for (y = b % 2 === 0 ? h + 1 : h; y < u.length; y += 2)
          R = w(u, h, y) << m, this.words[_] |= R & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= R >>> 26) : m += 8;
      }
      this._strip();
    };
    function M(x, u, h, g) {
      for (var y = 0, m = 0, _ = Math.min(x.length, h), R = u; R < _; R++) {
        var b = x.charCodeAt(R) - 48;
        y *= g, b >= 49 ? m = b - 49 + 10 : b >= 17 ? m = b - 17 + 10 : m = b, o(b >= 0 && m < g, "Invalid character"), y += m;
      }
      return y;
    }
    a.prototype._parseBase = function(u, h, g) {
      this.words = [0], this.length = 1;
      for (var y = 0, m = 1; m <= 67108863; m *= h)
        y++;
      y--, m = m / h | 0;
      for (var _ = u.length - g, R = _ % y, b = Math.min(_, _ - R) + g, l = 0, v = g; v < b; v += y)
        l = M(u, v, v + y, h), this.imuln(m), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      if (R !== 0) {
        var X = 1;
        for (l = M(u, v, u.length, h), v = 0; v < R; v++)
          X *= h;
        this.imuln(X), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      }
      this._strip();
    }, a.prototype.copy = function(u) {
      u.words = new Array(this.length);
      for (var h = 0; h < this.length; h++)
        u.words[h] = this.words[h];
      u.length = this.length, u.negative = this.negative, u.red = this.red;
    };
    function I(x, u) {
      x.words = u.words, x.length = u.length, x.negative = u.negative, x.red = u.red;
    }
    if (a.prototype._move = function(u) {
      I(u, this);
    }, a.prototype.clone = function() {
      var u = new a(null);
      return this.copy(u), u;
    }, a.prototype._expand = function(u) {
      for (; this.length < u; )
        this.words[this.length++] = 0;
      return this;
    }, a.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, a.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        a.prototype[Symbol.for("nodejs.util.inspect.custom")] = B;
      } catch {
        a.prototype.inspect = B;
      }
    else
      a.prototype.inspect = B;
    function B() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var H = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], L = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], W = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    a.prototype.toString = function(u, h) {
      u = u || 10, h = h | 0 || 1;
      var g;
      if (u === 16 || u === "hex") {
        g = "";
        for (var y = 0, m = 0, _ = 0; _ < this.length; _++) {
          var R = this.words[_], b = ((R << y | m) & 16777215).toString(16);
          m = R >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, _--), m !== 0 || _ !== this.length - 1 ? g = H[6 - b.length] + b + g : g = b + g;
        }
        for (m !== 0 && (g = m.toString(16) + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      if (u === (u | 0) && u >= 2 && u <= 36) {
        var l = L[u], v = W[u];
        g = "";
        var X = this.clone();
        for (X.negative = 0; !X.isZero(); ) {
          var S = X.modrn(v).toString(u);
          X = X.idivn(v), X.isZero() ? g = S + g : g = H[l - S.length] + S + g;
        }
        for (this.isZero() && (g = "0" + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      o(!1, "Base should be between 2 and 36");
    }, a.prototype.toNumber = function() {
      var u = this.words[0];
      return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
    }, a.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, d && (a.prototype.toBuffer = function(u, h) {
      return this.toArrayLike(d, u, h);
    }), a.prototype.toArray = function(u, h) {
      return this.toArrayLike(Array, u, h);
    };
    var $ = function(u, h) {
      return u.allocUnsafe ? u.allocUnsafe(h) : new u(h);
    };
    a.prototype.toArrayLike = function(u, h, g) {
      this._strip();
      var y = this.byteLength(), m = g || Math.max(1, y);
      o(y <= m, "byte array longer than desired length"), o(m > 0, "Requested array length <= 0");
      var _ = $(u, m), R = h === "le" ? "LE" : "BE";
      return this["_toArrayLike" + R](_, y), _;
    }, a.prototype._toArrayLikeLE = function(u, h) {
      for (var g = 0, y = 0, m = 0, _ = 0; m < this.length; m++) {
        var R = this.words[m] << _ | y;
        u[g++] = R & 255, g < u.length && (u[g++] = R >> 8 & 255), g < u.length && (u[g++] = R >> 16 & 255), _ === 6 ? (g < u.length && (u[g++] = R >> 24 & 255), y = 0, _ = 0) : (y = R >>> 24, _ += 2);
      }
      if (g < u.length)
        for (u[g++] = y; g < u.length; )
          u[g++] = 0;
    }, a.prototype._toArrayLikeBE = function(u, h) {
      for (var g = u.length - 1, y = 0, m = 0, _ = 0; m < this.length; m++) {
        var R = this.words[m] << _ | y;
        u[g--] = R & 255, g >= 0 && (u[g--] = R >> 8 & 255), g >= 0 && (u[g--] = R >> 16 & 255), _ === 6 ? (g >= 0 && (u[g--] = R >> 24 & 255), y = 0, _ = 0) : (y = R >>> 24, _ += 2);
      }
      if (g >= 0)
        for (u[g--] = y; g >= 0; )
          u[g--] = 0;
    }, Math.clz32 ? a.prototype._countBits = function(u) {
      return 32 - Math.clz32(u);
    } : a.prototype._countBits = function(u) {
      var h = u, g = 0;
      return h >= 4096 && (g += 13, h >>>= 13), h >= 64 && (g += 7, h >>>= 7), h >= 8 && (g += 4, h >>>= 4), h >= 2 && (g += 2, h >>>= 2), g + h;
    }, a.prototype._zeroBits = function(u) {
      if (u === 0)
        return 26;
      var h = u, g = 0;
      return (h & 8191) === 0 && (g += 13, h >>>= 13), (h & 127) === 0 && (g += 7, h >>>= 7), (h & 15) === 0 && (g += 4, h >>>= 4), (h & 3) === 0 && (g += 2, h >>>= 2), (h & 1) === 0 && g++, g;
    }, a.prototype.bitLength = function() {
      var u = this.words[this.length - 1], h = this._countBits(u);
      return (this.length - 1) * 26 + h;
    };
    function P(x) {
      for (var u = new Array(x.bitLength()), h = 0; h < u.length; h++) {
        var g = h / 26 | 0, y = h % 26;
        u[h] = x.words[g] >>> y & 1;
      }
      return u;
    }
    a.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var u = 0, h = 0; h < this.length; h++) {
        var g = this._zeroBits(this.words[h]);
        if (u += g, g !== 26)
          break;
      }
      return u;
    }, a.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, a.prototype.toTwos = function(u) {
      return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
    }, a.prototype.fromTwos = function(u) {
      return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
    }, a.prototype.isNeg = function() {
      return this.negative !== 0;
    }, a.prototype.neg = function() {
      return this.clone().ineg();
    }, a.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, a.prototype.iuor = function(u) {
      for (; this.length < u.length; )
        this.words[this.length++] = 0;
      for (var h = 0; h < u.length; h++)
        this.words[h] = this.words[h] | u.words[h];
      return this._strip();
    }, a.prototype.ior = function(u) {
      return o((this.negative | u.negative) === 0), this.iuor(u);
    }, a.prototype.or = function(u) {
      return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
    }, a.prototype.uor = function(u) {
      return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
    }, a.prototype.iuand = function(u) {
      var h;
      this.length > u.length ? h = u : h = this;
      for (var g = 0; g < h.length; g++)
        this.words[g] = this.words[g] & u.words[g];
      return this.length = h.length, this._strip();
    }, a.prototype.iand = function(u) {
      return o((this.negative | u.negative) === 0), this.iuand(u);
    }, a.prototype.and = function(u) {
      return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
    }, a.prototype.uand = function(u) {
      return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
    }, a.prototype.iuxor = function(u) {
      var h, g;
      this.length > u.length ? (h = this, g = u) : (h = u, g = this);
      for (var y = 0; y < g.length; y++)
        this.words[y] = h.words[y] ^ g.words[y];
      if (this !== h)
        for (; y < h.length; y++)
          this.words[y] = h.words[y];
      return this.length = h.length, this._strip();
    }, a.prototype.ixor = function(u) {
      return o((this.negative | u.negative) === 0), this.iuxor(u);
    }, a.prototype.xor = function(u) {
      return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
    }, a.prototype.uxor = function(u) {
      return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
    }, a.prototype.inotn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = Math.ceil(u / 26) | 0, g = u % 26;
      this._expand(h), g > 0 && h--;
      for (var y = 0; y < h; y++)
        this.words[y] = ~this.words[y] & 67108863;
      return g > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - g), this._strip();
    }, a.prototype.notn = function(u) {
      return this.clone().inotn(u);
    }, a.prototype.setn = function(u, h) {
      o(typeof u == "number" && u >= 0);
      var g = u / 26 | 0, y = u % 26;
      return this._expand(g + 1), h ? this.words[g] = this.words[g] | 1 << y : this.words[g] = this.words[g] & ~(1 << y), this._strip();
    }, a.prototype.iadd = function(u) {
      var h;
      if (this.negative !== 0 && u.negative === 0)
        return this.negative = 0, h = this.isub(u), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && u.negative !== 0)
        return u.negative = 0, h = this.isub(u), u.negative = 1, h._normSign();
      var g, y;
      this.length > u.length ? (g = this, y = u) : (g = u, y = this);
      for (var m = 0, _ = 0; _ < y.length; _++)
        h = (g.words[_] | 0) + (y.words[_] | 0) + m, this.words[_] = h & 67108863, m = h >>> 26;
      for (; m !== 0 && _ < g.length; _++)
        h = (g.words[_] | 0) + m, this.words[_] = h & 67108863, m = h >>> 26;
      if (this.length = g.length, m !== 0)
        this.words[this.length] = m, this.length++;
      else if (g !== this)
        for (; _ < g.length; _++)
          this.words[_] = g.words[_];
      return this;
    }, a.prototype.add = function(u) {
      var h;
      return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, h = this.sub(u), u.negative ^= 1, h) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, h = u.sub(this), this.negative = 1, h) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
    }, a.prototype.isub = function(u) {
      if (u.negative !== 0) {
        u.negative = 0;
        var h = this.iadd(u);
        return u.negative = 1, h._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
      var g = this.cmp(u);
      if (g === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, m;
      g > 0 ? (y = this, m = u) : (y = u, m = this);
      for (var _ = 0, R = 0; R < m.length; R++)
        h = (y.words[R] | 0) - (m.words[R] | 0) + _, _ = h >> 26, this.words[R] = h & 67108863;
      for (; _ !== 0 && R < y.length; R++)
        h = (y.words[R] | 0) + _, _ = h >> 26, this.words[R] = h & 67108863;
      if (_ === 0 && R < y.length && y !== this)
        for (; R < y.length; R++)
          this.words[R] = y.words[R];
      return this.length = Math.max(this.length, R), y !== this && (this.negative = 1), this._strip();
    }, a.prototype.sub = function(u) {
      return this.clone().isub(u);
    };
    function U(x, u, h) {
      h.negative = u.negative ^ x.negative;
      var g = x.length + u.length | 0;
      h.length = g, g = g - 1 | 0;
      var y = x.words[0] | 0, m = u.words[0] | 0, _ = y * m, R = _ & 67108863, b = _ / 67108864 | 0;
      h.words[0] = R;
      for (var l = 1; l < g; l++) {
        for (var v = b >>> 26, X = b & 67108863, S = Math.min(l, u.length - 1), Y = Math.max(0, l - x.length + 1); Y <= S; Y++) {
          var fe = l - Y | 0;
          y = x.words[fe] | 0, m = u.words[Y] | 0, _ = y * m + X, v += _ / 67108864 | 0, X = _ & 67108863;
        }
        h.words[l] = X | 0, b = v | 0;
      }
      return b !== 0 ? h.words[l] = b | 0 : h.length--, h._strip();
    }
    var G = function(u, h, g) {
      var y = u.words, m = h.words, _ = g.words, R = 0, b, l, v, X = y[0] | 0, S = X & 8191, Y = X >>> 13, fe = y[1] | 0, oe = fe & 8191, de = fe >>> 13, Ie = y[2] | 0, ye = Ie & 8191, be = Ie >>> 13, rt = y[3] | 0, xe = rt & 8191, Ne = rt >>> 13, j = y[4] | 0, z = j & 8191, ee = j >>> 13, ve = y[5] | 0, me = ve & 8191, Ae = ve >>> 13, it = y[6] | 0, ke = it & 8191, qe = it >>> 13, or = y[7] | 0, Oe = or & 8191, T = or >>> 13, A = y[8] | 0, E = A & 8191, F = A >>> 13, ie = y[9] | 0, ne = ie & 8191, ce = ie >>> 13, nt = m[0] | 0, Be = nt & 8191, Ce = nt >>> 13, _t = m[1] | 0, Me = _t & 8191, pt = _t >>> 13, qr = m[2] | 0, Xe = qr & 8191, yt = qr >>> 13, Zr = m[3] | 0, He = Zr & 8191, dt = Zr >>> 13, Hr = m[4] | 0, Ze = Hr & 8191, mt = Hr >>> 13, zr = m[5] | 0, Qe = zr & 8191, tt = zr >>> 13, Wr = m[6] | 0, q = Wr & 8191, Q = Wr >>> 13, ae = m[7] | 0, k = ae & 8191, re = ae >>> 13, Ee = m[8] | 0, pe = Ee & 8191, _e = Ee >>> 13, bt = m[9] | 0, Te = bt & 8191, Re = bt >>> 13;
      g.negative = u.negative ^ h.negative, g.length = 19, b = Math.imul(S, Be), l = Math.imul(S, Ce), l = l + Math.imul(Y, Be) | 0, v = Math.imul(Y, Ce);
      var Dr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, b = Math.imul(oe, Be), l = Math.imul(oe, Ce), l = l + Math.imul(de, Be) | 0, v = Math.imul(de, Ce), b = b + Math.imul(S, Me) | 0, l = l + Math.imul(S, pt) | 0, l = l + Math.imul(Y, Me) | 0, v = v + Math.imul(Y, pt) | 0;
      var vt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, b = Math.imul(ye, Be), l = Math.imul(ye, Ce), l = l + Math.imul(be, Be) | 0, v = Math.imul(be, Ce), b = b + Math.imul(oe, Me) | 0, l = l + Math.imul(oe, pt) | 0, l = l + Math.imul(de, Me) | 0, v = v + Math.imul(de, pt) | 0, b = b + Math.imul(S, Xe) | 0, l = l + Math.imul(S, yt) | 0, l = l + Math.imul(Y, Xe) | 0, v = v + Math.imul(Y, yt) | 0;
      var pr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, b = Math.imul(xe, Be), l = Math.imul(xe, Ce), l = l + Math.imul(Ne, Be) | 0, v = Math.imul(Ne, Ce), b = b + Math.imul(ye, Me) | 0, l = l + Math.imul(ye, pt) | 0, l = l + Math.imul(be, Me) | 0, v = v + Math.imul(be, pt) | 0, b = b + Math.imul(oe, Xe) | 0, l = l + Math.imul(oe, yt) | 0, l = l + Math.imul(de, Xe) | 0, v = v + Math.imul(de, yt) | 0, b = b + Math.imul(S, He) | 0, l = l + Math.imul(S, dt) | 0, l = l + Math.imul(Y, He) | 0, v = v + Math.imul(Y, dt) | 0;
      var Pr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, b = Math.imul(z, Be), l = Math.imul(z, Ce), l = l + Math.imul(ee, Be) | 0, v = Math.imul(ee, Ce), b = b + Math.imul(xe, Me) | 0, l = l + Math.imul(xe, pt) | 0, l = l + Math.imul(Ne, Me) | 0, v = v + Math.imul(Ne, pt) | 0, b = b + Math.imul(ye, Xe) | 0, l = l + Math.imul(ye, yt) | 0, l = l + Math.imul(be, Xe) | 0, v = v + Math.imul(be, yt) | 0, b = b + Math.imul(oe, He) | 0, l = l + Math.imul(oe, dt) | 0, l = l + Math.imul(de, He) | 0, v = v + Math.imul(de, dt) | 0, b = b + Math.imul(S, Ze) | 0, l = l + Math.imul(S, mt) | 0, l = l + Math.imul(Y, Ze) | 0, v = v + Math.imul(Y, mt) | 0;
      var Lr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, b = Math.imul(me, Be), l = Math.imul(me, Ce), l = l + Math.imul(Ae, Be) | 0, v = Math.imul(Ae, Ce), b = b + Math.imul(z, Me) | 0, l = l + Math.imul(z, pt) | 0, l = l + Math.imul(ee, Me) | 0, v = v + Math.imul(ee, pt) | 0, b = b + Math.imul(xe, Xe) | 0, l = l + Math.imul(xe, yt) | 0, l = l + Math.imul(Ne, Xe) | 0, v = v + Math.imul(Ne, yt) | 0, b = b + Math.imul(ye, He) | 0, l = l + Math.imul(ye, dt) | 0, l = l + Math.imul(be, He) | 0, v = v + Math.imul(be, dt) | 0, b = b + Math.imul(oe, Ze) | 0, l = l + Math.imul(oe, mt) | 0, l = l + Math.imul(de, Ze) | 0, v = v + Math.imul(de, mt) | 0, b = b + Math.imul(S, Qe) | 0, l = l + Math.imul(S, tt) | 0, l = l + Math.imul(Y, Qe) | 0, v = v + Math.imul(Y, tt) | 0;
      var Kr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Kr >>> 26) | 0, Kr &= 67108863, b = Math.imul(ke, Be), l = Math.imul(ke, Ce), l = l + Math.imul(qe, Be) | 0, v = Math.imul(qe, Ce), b = b + Math.imul(me, Me) | 0, l = l + Math.imul(me, pt) | 0, l = l + Math.imul(Ae, Me) | 0, v = v + Math.imul(Ae, pt) | 0, b = b + Math.imul(z, Xe) | 0, l = l + Math.imul(z, yt) | 0, l = l + Math.imul(ee, Xe) | 0, v = v + Math.imul(ee, yt) | 0, b = b + Math.imul(xe, He) | 0, l = l + Math.imul(xe, dt) | 0, l = l + Math.imul(Ne, He) | 0, v = v + Math.imul(Ne, dt) | 0, b = b + Math.imul(ye, Ze) | 0, l = l + Math.imul(ye, mt) | 0, l = l + Math.imul(be, Ze) | 0, v = v + Math.imul(be, mt) | 0, b = b + Math.imul(oe, Qe) | 0, l = l + Math.imul(oe, tt) | 0, l = l + Math.imul(de, Qe) | 0, v = v + Math.imul(de, tt) | 0, b = b + Math.imul(S, q) | 0, l = l + Math.imul(S, Q) | 0, l = l + Math.imul(Y, q) | 0, v = v + Math.imul(Y, Q) | 0;
      var $r = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, b = Math.imul(Oe, Be), l = Math.imul(Oe, Ce), l = l + Math.imul(T, Be) | 0, v = Math.imul(T, Ce), b = b + Math.imul(ke, Me) | 0, l = l + Math.imul(ke, pt) | 0, l = l + Math.imul(qe, Me) | 0, v = v + Math.imul(qe, pt) | 0, b = b + Math.imul(me, Xe) | 0, l = l + Math.imul(me, yt) | 0, l = l + Math.imul(Ae, Xe) | 0, v = v + Math.imul(Ae, yt) | 0, b = b + Math.imul(z, He) | 0, l = l + Math.imul(z, dt) | 0, l = l + Math.imul(ee, He) | 0, v = v + Math.imul(ee, dt) | 0, b = b + Math.imul(xe, Ze) | 0, l = l + Math.imul(xe, mt) | 0, l = l + Math.imul(Ne, Ze) | 0, v = v + Math.imul(Ne, mt) | 0, b = b + Math.imul(ye, Qe) | 0, l = l + Math.imul(ye, tt) | 0, l = l + Math.imul(be, Qe) | 0, v = v + Math.imul(be, tt) | 0, b = b + Math.imul(oe, q) | 0, l = l + Math.imul(oe, Q) | 0, l = l + Math.imul(de, q) | 0, v = v + Math.imul(de, Q) | 0, b = b + Math.imul(S, k) | 0, l = l + Math.imul(S, re) | 0, l = l + Math.imul(Y, k) | 0, v = v + Math.imul(Y, re) | 0;
      var Fr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, b = Math.imul(E, Be), l = Math.imul(E, Ce), l = l + Math.imul(F, Be) | 0, v = Math.imul(F, Ce), b = b + Math.imul(Oe, Me) | 0, l = l + Math.imul(Oe, pt) | 0, l = l + Math.imul(T, Me) | 0, v = v + Math.imul(T, pt) | 0, b = b + Math.imul(ke, Xe) | 0, l = l + Math.imul(ke, yt) | 0, l = l + Math.imul(qe, Xe) | 0, v = v + Math.imul(qe, yt) | 0, b = b + Math.imul(me, He) | 0, l = l + Math.imul(me, dt) | 0, l = l + Math.imul(Ae, He) | 0, v = v + Math.imul(Ae, dt) | 0, b = b + Math.imul(z, Ze) | 0, l = l + Math.imul(z, mt) | 0, l = l + Math.imul(ee, Ze) | 0, v = v + Math.imul(ee, mt) | 0, b = b + Math.imul(xe, Qe) | 0, l = l + Math.imul(xe, tt) | 0, l = l + Math.imul(Ne, Qe) | 0, v = v + Math.imul(Ne, tt) | 0, b = b + Math.imul(ye, q) | 0, l = l + Math.imul(ye, Q) | 0, l = l + Math.imul(be, q) | 0, v = v + Math.imul(be, Q) | 0, b = b + Math.imul(oe, k) | 0, l = l + Math.imul(oe, re) | 0, l = l + Math.imul(de, k) | 0, v = v + Math.imul(de, re) | 0, b = b + Math.imul(S, pe) | 0, l = l + Math.imul(S, _e) | 0, l = l + Math.imul(Y, pe) | 0, v = v + Math.imul(Y, _e) | 0;
      var Ur = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, b = Math.imul(ne, Be), l = Math.imul(ne, Ce), l = l + Math.imul(ce, Be) | 0, v = Math.imul(ce, Ce), b = b + Math.imul(E, Me) | 0, l = l + Math.imul(E, pt) | 0, l = l + Math.imul(F, Me) | 0, v = v + Math.imul(F, pt) | 0, b = b + Math.imul(Oe, Xe) | 0, l = l + Math.imul(Oe, yt) | 0, l = l + Math.imul(T, Xe) | 0, v = v + Math.imul(T, yt) | 0, b = b + Math.imul(ke, He) | 0, l = l + Math.imul(ke, dt) | 0, l = l + Math.imul(qe, He) | 0, v = v + Math.imul(qe, dt) | 0, b = b + Math.imul(me, Ze) | 0, l = l + Math.imul(me, mt) | 0, l = l + Math.imul(Ae, Ze) | 0, v = v + Math.imul(Ae, mt) | 0, b = b + Math.imul(z, Qe) | 0, l = l + Math.imul(z, tt) | 0, l = l + Math.imul(ee, Qe) | 0, v = v + Math.imul(ee, tt) | 0, b = b + Math.imul(xe, q) | 0, l = l + Math.imul(xe, Q) | 0, l = l + Math.imul(Ne, q) | 0, v = v + Math.imul(Ne, Q) | 0, b = b + Math.imul(ye, k) | 0, l = l + Math.imul(ye, re) | 0, l = l + Math.imul(be, k) | 0, v = v + Math.imul(be, re) | 0, b = b + Math.imul(oe, pe) | 0, l = l + Math.imul(oe, _e) | 0, l = l + Math.imul(de, pe) | 0, v = v + Math.imul(de, _e) | 0, b = b + Math.imul(S, Te) | 0, l = l + Math.imul(S, Re) | 0, l = l + Math.imul(Y, Te) | 0, v = v + Math.imul(Y, Re) | 0;
      var ar = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, b = Math.imul(ne, Me), l = Math.imul(ne, pt), l = l + Math.imul(ce, Me) | 0, v = Math.imul(ce, pt), b = b + Math.imul(E, Xe) | 0, l = l + Math.imul(E, yt) | 0, l = l + Math.imul(F, Xe) | 0, v = v + Math.imul(F, yt) | 0, b = b + Math.imul(Oe, He) | 0, l = l + Math.imul(Oe, dt) | 0, l = l + Math.imul(T, He) | 0, v = v + Math.imul(T, dt) | 0, b = b + Math.imul(ke, Ze) | 0, l = l + Math.imul(ke, mt) | 0, l = l + Math.imul(qe, Ze) | 0, v = v + Math.imul(qe, mt) | 0, b = b + Math.imul(me, Qe) | 0, l = l + Math.imul(me, tt) | 0, l = l + Math.imul(Ae, Qe) | 0, v = v + Math.imul(Ae, tt) | 0, b = b + Math.imul(z, q) | 0, l = l + Math.imul(z, Q) | 0, l = l + Math.imul(ee, q) | 0, v = v + Math.imul(ee, Q) | 0, b = b + Math.imul(xe, k) | 0, l = l + Math.imul(xe, re) | 0, l = l + Math.imul(Ne, k) | 0, v = v + Math.imul(Ne, re) | 0, b = b + Math.imul(ye, pe) | 0, l = l + Math.imul(ye, _e) | 0, l = l + Math.imul(be, pe) | 0, v = v + Math.imul(be, _e) | 0, b = b + Math.imul(oe, Te) | 0, l = l + Math.imul(oe, Re) | 0, l = l + Math.imul(de, Te) | 0, v = v + Math.imul(de, Re) | 0;
      var gr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, b = Math.imul(ne, Xe), l = Math.imul(ne, yt), l = l + Math.imul(ce, Xe) | 0, v = Math.imul(ce, yt), b = b + Math.imul(E, He) | 0, l = l + Math.imul(E, dt) | 0, l = l + Math.imul(F, He) | 0, v = v + Math.imul(F, dt) | 0, b = b + Math.imul(Oe, Ze) | 0, l = l + Math.imul(Oe, mt) | 0, l = l + Math.imul(T, Ze) | 0, v = v + Math.imul(T, mt) | 0, b = b + Math.imul(ke, Qe) | 0, l = l + Math.imul(ke, tt) | 0, l = l + Math.imul(qe, Qe) | 0, v = v + Math.imul(qe, tt) | 0, b = b + Math.imul(me, q) | 0, l = l + Math.imul(me, Q) | 0, l = l + Math.imul(Ae, q) | 0, v = v + Math.imul(Ae, Q) | 0, b = b + Math.imul(z, k) | 0, l = l + Math.imul(z, re) | 0, l = l + Math.imul(ee, k) | 0, v = v + Math.imul(ee, re) | 0, b = b + Math.imul(xe, pe) | 0, l = l + Math.imul(xe, _e) | 0, l = l + Math.imul(Ne, pe) | 0, v = v + Math.imul(Ne, _e) | 0, b = b + Math.imul(ye, Te) | 0, l = l + Math.imul(ye, Re) | 0, l = l + Math.imul(be, Te) | 0, v = v + Math.imul(be, Re) | 0;
      var zt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, b = Math.imul(ne, He), l = Math.imul(ne, dt), l = l + Math.imul(ce, He) | 0, v = Math.imul(ce, dt), b = b + Math.imul(E, Ze) | 0, l = l + Math.imul(E, mt) | 0, l = l + Math.imul(F, Ze) | 0, v = v + Math.imul(F, mt) | 0, b = b + Math.imul(Oe, Qe) | 0, l = l + Math.imul(Oe, tt) | 0, l = l + Math.imul(T, Qe) | 0, v = v + Math.imul(T, tt) | 0, b = b + Math.imul(ke, q) | 0, l = l + Math.imul(ke, Q) | 0, l = l + Math.imul(qe, q) | 0, v = v + Math.imul(qe, Q) | 0, b = b + Math.imul(me, k) | 0, l = l + Math.imul(me, re) | 0, l = l + Math.imul(Ae, k) | 0, v = v + Math.imul(Ae, re) | 0, b = b + Math.imul(z, pe) | 0, l = l + Math.imul(z, _e) | 0, l = l + Math.imul(ee, pe) | 0, v = v + Math.imul(ee, _e) | 0, b = b + Math.imul(xe, Te) | 0, l = l + Math.imul(xe, Re) | 0, l = l + Math.imul(Ne, Te) | 0, v = v + Math.imul(Ne, Re) | 0;
      var lr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, b = Math.imul(ne, Ze), l = Math.imul(ne, mt), l = l + Math.imul(ce, Ze) | 0, v = Math.imul(ce, mt), b = b + Math.imul(E, Qe) | 0, l = l + Math.imul(E, tt) | 0, l = l + Math.imul(F, Qe) | 0, v = v + Math.imul(F, tt) | 0, b = b + Math.imul(Oe, q) | 0, l = l + Math.imul(Oe, Q) | 0, l = l + Math.imul(T, q) | 0, v = v + Math.imul(T, Q) | 0, b = b + Math.imul(ke, k) | 0, l = l + Math.imul(ke, re) | 0, l = l + Math.imul(qe, k) | 0, v = v + Math.imul(qe, re) | 0, b = b + Math.imul(me, pe) | 0, l = l + Math.imul(me, _e) | 0, l = l + Math.imul(Ae, pe) | 0, v = v + Math.imul(Ae, _e) | 0, b = b + Math.imul(z, Te) | 0, l = l + Math.imul(z, Re) | 0, l = l + Math.imul(ee, Te) | 0, v = v + Math.imul(ee, Re) | 0;
      var dr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, b = Math.imul(ne, Qe), l = Math.imul(ne, tt), l = l + Math.imul(ce, Qe) | 0, v = Math.imul(ce, tt), b = b + Math.imul(E, q) | 0, l = l + Math.imul(E, Q) | 0, l = l + Math.imul(F, q) | 0, v = v + Math.imul(F, Q) | 0, b = b + Math.imul(Oe, k) | 0, l = l + Math.imul(Oe, re) | 0, l = l + Math.imul(T, k) | 0, v = v + Math.imul(T, re) | 0, b = b + Math.imul(ke, pe) | 0, l = l + Math.imul(ke, _e) | 0, l = l + Math.imul(qe, pe) | 0, v = v + Math.imul(qe, _e) | 0, b = b + Math.imul(me, Te) | 0, l = l + Math.imul(me, Re) | 0, l = l + Math.imul(Ae, Te) | 0, v = v + Math.imul(Ae, Re) | 0;
      var wt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, b = Math.imul(ne, q), l = Math.imul(ne, Q), l = l + Math.imul(ce, q) | 0, v = Math.imul(ce, Q), b = b + Math.imul(E, k) | 0, l = l + Math.imul(E, re) | 0, l = l + Math.imul(F, k) | 0, v = v + Math.imul(F, re) | 0, b = b + Math.imul(Oe, pe) | 0, l = l + Math.imul(Oe, _e) | 0, l = l + Math.imul(T, pe) | 0, v = v + Math.imul(T, _e) | 0, b = b + Math.imul(ke, Te) | 0, l = l + Math.imul(ke, Re) | 0, l = l + Math.imul(qe, Te) | 0, v = v + Math.imul(qe, Re) | 0;
      var Le = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, b = Math.imul(ne, k), l = Math.imul(ne, re), l = l + Math.imul(ce, k) | 0, v = Math.imul(ce, re), b = b + Math.imul(E, pe) | 0, l = l + Math.imul(E, _e) | 0, l = l + Math.imul(F, pe) | 0, v = v + Math.imul(F, _e) | 0, b = b + Math.imul(Oe, Te) | 0, l = l + Math.imul(Oe, Re) | 0, l = l + Math.imul(T, Te) | 0, v = v + Math.imul(T, Re) | 0;
      var Fe = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, b = Math.imul(ne, pe), l = Math.imul(ne, _e), l = l + Math.imul(ce, pe) | 0, v = Math.imul(ce, _e), b = b + Math.imul(E, Te) | 0, l = l + Math.imul(E, Re) | 0, l = l + Math.imul(F, Te) | 0, v = v + Math.imul(F, Re) | 0;
      var gt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, b = Math.imul(ne, Te), l = Math.imul(ne, Re), l = l + Math.imul(ce, Te) | 0, v = Math.imul(ce, Re);
      var et = (R + b | 0) + ((l & 8191) << 13) | 0;
      return R = (v + (l >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, _[0] = Dr, _[1] = vt, _[2] = pr, _[3] = Pr, _[4] = Lr, _[5] = Kr, _[6] = $r, _[7] = Fr, _[8] = Ur, _[9] = ar, _[10] = gr, _[11] = zt, _[12] = lr, _[13] = dr, _[14] = wt, _[15] = Le, _[16] = Fe, _[17] = gt, _[18] = et, R !== 0 && (_[19] = R, g.length++), g;
    };
    Math.imul || (G = U);
    function D(x, u, h) {
      h.negative = u.negative ^ x.negative, h.length = x.length + u.length;
      for (var g = 0, y = 0, m = 0; m < h.length - 1; m++) {
        var _ = y;
        y = 0;
        for (var R = g & 67108863, b = Math.min(m, u.length - 1), l = Math.max(0, m - x.length + 1); l <= b; l++) {
          var v = m - l, X = x.words[v] | 0, S = u.words[l] | 0, Y = X * S, fe = Y & 67108863;
          _ = _ + (Y / 67108864 | 0) | 0, fe = fe + R | 0, R = fe & 67108863, _ = _ + (fe >>> 26) | 0, y += _ >>> 26, _ &= 67108863;
        }
        h.words[m] = R, g = _, _ = y;
      }
      return g !== 0 ? h.words[m] = g : h.length--, h._strip();
    }
    function Z(x, u, h) {
      return D(x, u, h);
    }
    a.prototype.mulTo = function(u, h) {
      var g, y = this.length + u.length;
      return this.length === 10 && u.length === 10 ? g = G(this, u, h) : y < 63 ? g = U(this, u, h) : y < 1024 ? g = D(this, u, h) : g = Z(this, u, h), g;
    }, a.prototype.mul = function(u) {
      var h = new a(null);
      return h.words = new Array(this.length + u.length), this.mulTo(u, h);
    }, a.prototype.mulf = function(u) {
      var h = new a(null);
      return h.words = new Array(this.length + u.length), Z(this, u, h);
    }, a.prototype.imul = function(u) {
      return this.clone().mulTo(u, this);
    }, a.prototype.imuln = function(u) {
      var h = u < 0;
      h && (u = -u), o(typeof u == "number"), o(u < 67108864);
      for (var g = 0, y = 0; y < this.length; y++) {
        var m = (this.words[y] | 0) * u, _ = (m & 67108863) + (g & 67108863);
        g >>= 26, g += m / 67108864 | 0, g += _ >>> 26, this.words[y] = _ & 67108863;
      }
      return g !== 0 && (this.words[y] = g, this.length++), h ? this.ineg() : this;
    }, a.prototype.muln = function(u) {
      return this.clone().imuln(u);
    }, a.prototype.sqr = function() {
      return this.mul(this);
    }, a.prototype.isqr = function() {
      return this.imul(this.clone());
    }, a.prototype.pow = function(u) {
      var h = P(u);
      if (h.length === 0)
        return new a(1);
      for (var g = this, y = 0; y < h.length && h[y] === 0; y++, g = g.sqr())
        ;
      if (++y < h.length)
        for (var m = g.sqr(); y < h.length; y++, m = m.sqr())
          h[y] !== 0 && (g = g.mul(m));
      return g;
    }, a.prototype.iushln = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26, y = 67108863 >>> 26 - h << 26 - h, m;
      if (h !== 0) {
        var _ = 0;
        for (m = 0; m < this.length; m++) {
          var R = this.words[m] & y, b = (this.words[m] | 0) - R << h;
          this.words[m] = b | _, _ = R >>> 26 - h;
        }
        _ && (this.words[m] = _, this.length++);
      }
      if (g !== 0) {
        for (m = this.length - 1; m >= 0; m--)
          this.words[m + g] = this.words[m];
        for (m = 0; m < g; m++)
          this.words[m] = 0;
        this.length += g;
      }
      return this._strip();
    }, a.prototype.ishln = function(u) {
      return o(this.negative === 0), this.iushln(u);
    }, a.prototype.iushrn = function(u, h, g) {
      o(typeof u == "number" && u >= 0);
      var y;
      h ? y = (h - h % 26) / 26 : y = 0;
      var m = u % 26, _ = Math.min((u - m) / 26, this.length), R = 67108863 ^ 67108863 >>> m << m, b = g;
      if (y -= _, y = Math.max(0, y), b) {
        for (var l = 0; l < _; l++)
          b.words[l] = this.words[l];
        b.length = _;
      }
      if (_ !== 0)
        if (this.length > _)
          for (this.length -= _, l = 0; l < this.length; l++)
            this.words[l] = this.words[l + _];
        else
          this.words[0] = 0, this.length = 1;
      var v = 0;
      for (l = this.length - 1; l >= 0 && (v !== 0 || l >= y); l--) {
        var X = this.words[l] | 0;
        this.words[l] = v << 26 - m | X >>> m, v = X & R;
      }
      return b && v !== 0 && (b.words[b.length++] = v), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, a.prototype.ishrn = function(u, h, g) {
      return o(this.negative === 0), this.iushrn(u, h, g);
    }, a.prototype.shln = function(u) {
      return this.clone().ishln(u);
    }, a.prototype.ushln = function(u) {
      return this.clone().iushln(u);
    }, a.prototype.shrn = function(u) {
      return this.clone().ishrn(u);
    }, a.prototype.ushrn = function(u) {
      return this.clone().iushrn(u);
    }, a.prototype.testn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26, y = 1 << h;
      if (this.length <= g)
        return !1;
      var m = this.words[g];
      return !!(m & y);
    }, a.prototype.imaskn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26;
      if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g)
        return this;
      if (h !== 0 && g++, this.length = Math.min(g, this.length), h !== 0) {
        var y = 67108863 ^ 67108863 >>> h << h;
        this.words[this.length - 1] &= y;
      }
      return this._strip();
    }, a.prototype.maskn = function(u) {
      return this.clone().imaskn(u);
    }, a.prototype.iaddn = function(u) {
      return o(typeof u == "number"), o(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
    }, a.prototype._iaddn = function(u) {
      this.words[0] += u;
      for (var h = 0; h < this.length && this.words[h] >= 67108864; h++)
        this.words[h] -= 67108864, h === this.length - 1 ? this.words[h + 1] = 1 : this.words[h + 1]++;
      return this.length = Math.max(this.length, h + 1), this;
    }, a.prototype.isubn = function(u) {
      if (o(typeof u == "number"), o(u < 67108864), u < 0)
        return this.iaddn(-u);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(u), this.negative = 1, this;
      if (this.words[0] -= u, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var h = 0; h < this.length && this.words[h] < 0; h++)
          this.words[h] += 67108864, this.words[h + 1] -= 1;
      return this._strip();
    }, a.prototype.addn = function(u) {
      return this.clone().iaddn(u);
    }, a.prototype.subn = function(u) {
      return this.clone().isubn(u);
    }, a.prototype.iabs = function() {
      return this.negative = 0, this;
    }, a.prototype.abs = function() {
      return this.clone().iabs();
    }, a.prototype._ishlnsubmul = function(u, h, g) {
      var y = u.length + g, m;
      this._expand(y);
      var _, R = 0;
      for (m = 0; m < u.length; m++) {
        _ = (this.words[m + g] | 0) + R;
        var b = (u.words[m] | 0) * h;
        _ -= b & 67108863, R = (_ >> 26) - (b / 67108864 | 0), this.words[m + g] = _ & 67108863;
      }
      for (; m < this.length - g; m++)
        _ = (this.words[m + g] | 0) + R, R = _ >> 26, this.words[m + g] = _ & 67108863;
      if (R === 0)
        return this._strip();
      for (o(R === -1), R = 0, m = 0; m < this.length; m++)
        _ = -(this.words[m] | 0) + R, R = _ >> 26, this.words[m] = _ & 67108863;
      return this.negative = 1, this._strip();
    }, a.prototype._wordDiv = function(u, h) {
      var g = this.length - u.length, y = this.clone(), m = u, _ = m.words[m.length - 1] | 0, R = this._countBits(_);
      g = 26 - R, g !== 0 && (m = m.ushln(g), y.iushln(g), _ = m.words[m.length - 1] | 0);
      var b = y.length - m.length, l;
      if (h !== "mod") {
        l = new a(null), l.length = b + 1, l.words = new Array(l.length);
        for (var v = 0; v < l.length; v++)
          l.words[v] = 0;
      }
      var X = y.clone()._ishlnsubmul(m, 1, b);
      X.negative === 0 && (y = X, l && (l.words[b] = 1));
      for (var S = b - 1; S >= 0; S--) {
        var Y = (y.words[m.length + S] | 0) * 67108864 + (y.words[m.length + S - 1] | 0);
        for (Y = Math.min(Y / _ | 0, 67108863), y._ishlnsubmul(m, Y, S); y.negative !== 0; )
          Y--, y.negative = 0, y._ishlnsubmul(m, 1, S), y.isZero() || (y.negative ^= 1);
        l && (l.words[S] = Y);
      }
      return l && l._strip(), y._strip(), h !== "div" && g !== 0 && y.iushrn(g), {
        div: l || null,
        mod: y
      };
    }, a.prototype.divmod = function(u, h, g) {
      if (o(!u.isZero()), this.isZero())
        return {
          div: new a(0),
          mod: new a(0)
        };
      var y, m, _;
      return this.negative !== 0 && u.negative === 0 ? (_ = this.neg().divmod(u, h), h !== "mod" && (y = _.div.neg()), h !== "div" && (m = _.mod.neg(), g && m.negative !== 0 && m.iadd(u)), {
        div: y,
        mod: m
      }) : this.negative === 0 && u.negative !== 0 ? (_ = this.divmod(u.neg(), h), h !== "mod" && (y = _.div.neg()), {
        div: y,
        mod: _.mod
      }) : (this.negative & u.negative) !== 0 ? (_ = this.neg().divmod(u.neg(), h), h !== "div" && (m = _.mod.neg(), g && m.negative !== 0 && m.isub(u)), {
        div: _.div,
        mod: m
      }) : u.length > this.length || this.cmp(u) < 0 ? {
        div: new a(0),
        mod: this
      } : u.length === 1 ? h === "div" ? {
        div: this.divn(u.words[0]),
        mod: null
      } : h === "mod" ? {
        div: null,
        mod: new a(this.modrn(u.words[0]))
      } : {
        div: this.divn(u.words[0]),
        mod: new a(this.modrn(u.words[0]))
      } : this._wordDiv(u, h);
    }, a.prototype.div = function(u) {
      return this.divmod(u, "div", !1).div;
    }, a.prototype.mod = function(u) {
      return this.divmod(u, "mod", !1).mod;
    }, a.prototype.umod = function(u) {
      return this.divmod(u, "mod", !0).mod;
    }, a.prototype.divRound = function(u) {
      var h = this.divmod(u);
      if (h.mod.isZero())
        return h.div;
      var g = h.div.negative !== 0 ? h.mod.isub(u) : h.mod, y = u.ushrn(1), m = u.andln(1), _ = g.cmp(y);
      return _ < 0 || m === 1 && _ === 0 ? h.div : h.div.negative !== 0 ? h.div.isubn(1) : h.div.iaddn(1);
    }, a.prototype.modrn = function(u) {
      var h = u < 0;
      h && (u = -u), o(u <= 67108863);
      for (var g = (1 << 26) % u, y = 0, m = this.length - 1; m >= 0; m--)
        y = (g * y + (this.words[m] | 0)) % u;
      return h ? -y : y;
    }, a.prototype.modn = function(u) {
      return this.modrn(u);
    }, a.prototype.idivn = function(u) {
      var h = u < 0;
      h && (u = -u), o(u <= 67108863);
      for (var g = 0, y = this.length - 1; y >= 0; y--) {
        var m = (this.words[y] | 0) + g * 67108864;
        this.words[y] = m / u | 0, g = m % u;
      }
      return this._strip(), h ? this.ineg() : this;
    }, a.prototype.divn = function(u) {
      return this.clone().idivn(u);
    }, a.prototype.egcd = function(u) {
      o(u.negative === 0), o(!u.isZero());
      var h = this, g = u.clone();
      h.negative !== 0 ? h = h.umod(u) : h = h.clone();
      for (var y = new a(1), m = new a(0), _ = new a(0), R = new a(1), b = 0; h.isEven() && g.isEven(); )
        h.iushrn(1), g.iushrn(1), ++b;
      for (var l = g.clone(), v = h.clone(); !h.isZero(); ) {
        for (var X = 0, S = 1; (h.words[0] & S) === 0 && X < 26; ++X, S <<= 1)
          ;
        if (X > 0)
          for (h.iushrn(X); X-- > 0; )
            (y.isOdd() || m.isOdd()) && (y.iadd(l), m.isub(v)), y.iushrn(1), m.iushrn(1);
        for (var Y = 0, fe = 1; (g.words[0] & fe) === 0 && Y < 26; ++Y, fe <<= 1)
          ;
        if (Y > 0)
          for (g.iushrn(Y); Y-- > 0; )
            (_.isOdd() || R.isOdd()) && (_.iadd(l), R.isub(v)), _.iushrn(1), R.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), y.isub(_), m.isub(R)) : (g.isub(h), _.isub(y), R.isub(m));
      }
      return {
        a: _,
        b: R,
        gcd: g.iushln(b)
      };
    }, a.prototype._invmp = function(u) {
      o(u.negative === 0), o(!u.isZero());
      var h = this, g = u.clone();
      h.negative !== 0 ? h = h.umod(u) : h = h.clone();
      for (var y = new a(1), m = new a(0), _ = g.clone(); h.cmpn(1) > 0 && g.cmpn(1) > 0; ) {
        for (var R = 0, b = 1; (h.words[0] & b) === 0 && R < 26; ++R, b <<= 1)
          ;
        if (R > 0)
          for (h.iushrn(R); R-- > 0; )
            y.isOdd() && y.iadd(_), y.iushrn(1);
        for (var l = 0, v = 1; (g.words[0] & v) === 0 && l < 26; ++l, v <<= 1)
          ;
        if (l > 0)
          for (g.iushrn(l); l-- > 0; )
            m.isOdd() && m.iadd(_), m.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), y.isub(m)) : (g.isub(h), m.isub(y));
      }
      var X;
      return h.cmpn(1) === 0 ? X = y : X = m, X.cmpn(0) < 0 && X.iadd(u), X;
    }, a.prototype.gcd = function(u) {
      if (this.isZero())
        return u.abs();
      if (u.isZero())
        return this.abs();
      var h = this.clone(), g = u.clone();
      h.negative = 0, g.negative = 0;
      for (var y = 0; h.isEven() && g.isEven(); y++)
        h.iushrn(1), g.iushrn(1);
      do {
        for (; h.isEven(); )
          h.iushrn(1);
        for (; g.isEven(); )
          g.iushrn(1);
        var m = h.cmp(g);
        if (m < 0) {
          var _ = h;
          h = g, g = _;
        } else if (m === 0 || g.cmpn(1) === 0)
          break;
        h.isub(g);
      } while (!0);
      return g.iushln(y);
    }, a.prototype.invm = function(u) {
      return this.egcd(u).a.umod(u);
    }, a.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, a.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, a.prototype.andln = function(u) {
      return this.words[0] & u;
    }, a.prototype.bincn = function(u) {
      o(typeof u == "number");
      var h = u % 26, g = (u - h) / 26, y = 1 << h;
      if (this.length <= g)
        return this._expand(g + 1), this.words[g] |= y, this;
      for (var m = y, _ = g; m !== 0 && _ < this.length; _++) {
        var R = this.words[_] | 0;
        R += m, m = R >>> 26, R &= 67108863, this.words[_] = R;
      }
      return m !== 0 && (this.words[_] = m, this.length++), this;
    }, a.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, a.prototype.cmpn = function(u) {
      var h = u < 0;
      if (this.negative !== 0 && !h)
        return -1;
      if (this.negative === 0 && h)
        return 1;
      this._strip();
      var g;
      if (this.length > 1)
        g = 1;
      else {
        h && (u = -u), o(u <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        g = y === u ? 0 : y < u ? -1 : 1;
      }
      return this.negative !== 0 ? -g | 0 : g;
    }, a.prototype.cmp = function(u) {
      if (this.negative !== 0 && u.negative === 0)
        return -1;
      if (this.negative === 0 && u.negative !== 0)
        return 1;
      var h = this.ucmp(u);
      return this.negative !== 0 ? -h | 0 : h;
    }, a.prototype.ucmp = function(u) {
      if (this.length > u.length)
        return 1;
      if (this.length < u.length)
        return -1;
      for (var h = 0, g = this.length - 1; g >= 0; g--) {
        var y = this.words[g] | 0, m = u.words[g] | 0;
        if (y !== m) {
          y < m ? h = -1 : y > m && (h = 1);
          break;
        }
      }
      return h;
    }, a.prototype.gtn = function(u) {
      return this.cmpn(u) === 1;
    }, a.prototype.gt = function(u) {
      return this.cmp(u) === 1;
    }, a.prototype.gten = function(u) {
      return this.cmpn(u) >= 0;
    }, a.prototype.gte = function(u) {
      return this.cmp(u) >= 0;
    }, a.prototype.ltn = function(u) {
      return this.cmpn(u) === -1;
    }, a.prototype.lt = function(u) {
      return this.cmp(u) === -1;
    }, a.prototype.lten = function(u) {
      return this.cmpn(u) <= 0;
    }, a.prototype.lte = function(u) {
      return this.cmp(u) <= 0;
    }, a.prototype.eqn = function(u) {
      return this.cmpn(u) === 0;
    }, a.prototype.eq = function(u) {
      return this.cmp(u) === 0;
    }, a.red = function(u) {
      return new O(u);
    }, a.prototype.toRed = function(u) {
      return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
    }, a.prototype.fromRed = function() {
      return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, a.prototype._forceRed = function(u) {
      return this.red = u, this;
    }, a.prototype.forceRed = function(u) {
      return o(!this.red, "Already a number in reduction context"), this._forceRed(u);
    }, a.prototype.redAdd = function(u) {
      return o(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
    }, a.prototype.redIAdd = function(u) {
      return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
    }, a.prototype.redSub = function(u) {
      return o(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
    }, a.prototype.redISub = function(u) {
      return o(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
    }, a.prototype.redShl = function(u) {
      return o(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
    }, a.prototype.redMul = function(u) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
    }, a.prototype.redIMul = function(u) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
    }, a.prototype.redSqr = function() {
      return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, a.prototype.redISqr = function() {
      return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, a.prototype.redSqrt = function() {
      return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, a.prototype.redInvm = function() {
      return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, a.prototype.redNeg = function() {
      return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, a.prototype.redPow = function(u) {
      return o(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
    };
    var J = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function te(x, u) {
      this.name = x, this.p = new a(u, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    te.prototype._tmp = function() {
      var u = new a(null);
      return u.words = new Array(Math.ceil(this.n / 13)), u;
    }, te.prototype.ireduce = function(u) {
      var h = u, g;
      do
        this.split(h, this.tmp), h = this.imulK(h), h = h.iadd(this.tmp), g = h.bitLength();
      while (g > this.n);
      var y = g < this.n ? -1 : h.ucmp(this.p);
      return y === 0 ? (h.words[0] = 0, h.length = 1) : y > 0 ? h.isub(this.p) : h.strip !== void 0 ? h.strip() : h._strip(), h;
    }, te.prototype.split = function(u, h) {
      u.iushrn(this.n, 0, h);
    }, te.prototype.imulK = function(u) {
      return u.imul(this.k);
    };
    function ue() {
      te.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    c(ue, te), ue.prototype.split = function(u, h) {
      for (var g = 4194303, y = Math.min(u.length, 9), m = 0; m < y; m++)
        h.words[m] = u.words[m];
      if (h.length = y, u.length <= 9) {
        u.words[0] = 0, u.length = 1;
        return;
      }
      var _ = u.words[9];
      for (h.words[h.length++] = _ & g, m = 10; m < u.length; m++) {
        var R = u.words[m] | 0;
        u.words[m - 10] = (R & g) << 4 | _ >>> 22, _ = R;
      }
      _ >>>= 22, u.words[m - 10] = _, _ === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
    }, ue.prototype.imulK = function(u) {
      u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
      for (var h = 0, g = 0; g < u.length; g++) {
        var y = u.words[g] | 0;
        h += y * 977, u.words[g] = h & 67108863, h = y * 64 + (h / 67108864 | 0);
      }
      return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
    };
    function he() {
      te.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    c(he, te);
    function Se() {
      te.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    c(Se, te);
    function C() {
      te.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    c(C, te), C.prototype.imulK = function(u) {
      for (var h = 0, g = 0; g < u.length; g++) {
        var y = (u.words[g] | 0) * 19 + h, m = y & 67108863;
        y >>>= 26, u.words[g] = m, h = y;
      }
      return h !== 0 && (u.words[u.length++] = h), u;
    }, a._prime = function(u) {
      if (J[u])
        return J[u];
      var h;
      if (u === "k256")
        h = new ue();
      else if (u === "p224")
        h = new he();
      else if (u === "p192")
        h = new Se();
      else if (u === "p25519")
        h = new C();
      else
        throw new Error("Unknown prime " + u);
      return J[u] = h, h;
    };
    function O(x) {
      if (typeof x == "string") {
        var u = a._prime(x);
        this.m = u.p, this.prime = u;
      } else
        o(x.gtn(1), "modulus must be greater than 1"), this.m = x, this.prime = null;
    }
    O.prototype._verify1 = function(u) {
      o(u.negative === 0, "red works only with positives"), o(u.red, "red works only with red numbers");
    }, O.prototype._verify2 = function(u, h) {
      o((u.negative | h.negative) === 0, "red works only with positives"), o(
        u.red && u.red === h.red,
        "red works only with red numbers"
      );
    }, O.prototype.imod = function(u) {
      return this.prime ? this.prime.ireduce(u)._forceRed(this) : (I(u, u.umod(this.m)._forceRed(this)), u);
    }, O.prototype.neg = function(u) {
      return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
    }, O.prototype.add = function(u, h) {
      this._verify2(u, h);
      var g = u.add(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
    }, O.prototype.iadd = function(u, h) {
      this._verify2(u, h);
      var g = u.iadd(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g;
    }, O.prototype.sub = function(u, h) {
      this._verify2(u, h);
      var g = u.sub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
    }, O.prototype.isub = function(u, h) {
      this._verify2(u, h);
      var g = u.isub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g;
    }, O.prototype.shl = function(u, h) {
      return this._verify1(u), this.imod(u.ushln(h));
    }, O.prototype.imul = function(u, h) {
      return this._verify2(u, h), this.imod(u.imul(h));
    }, O.prototype.mul = function(u, h) {
      return this._verify2(u, h), this.imod(u.mul(h));
    }, O.prototype.isqr = function(u) {
      return this.imul(u, u.clone());
    }, O.prototype.sqr = function(u) {
      return this.mul(u, u);
    }, O.prototype.sqrt = function(u) {
      if (u.isZero())
        return u.clone();
      var h = this.m.andln(3);
      if (o(h % 2 === 1), h === 3) {
        var g = this.m.add(new a(1)).iushrn(2);
        return this.pow(u, g);
      }
      for (var y = this.m.subn(1), m = 0; !y.isZero() && y.andln(1) === 0; )
        m++, y.iushrn(1);
      o(!y.isZero());
      var _ = new a(1).toRed(this), R = _.redNeg(), b = this.m.subn(1).iushrn(1), l = this.m.bitLength();
      for (l = new a(2 * l * l).toRed(this); this.pow(l, b).cmp(R) !== 0; )
        l.redIAdd(R);
      for (var v = this.pow(l, y), X = this.pow(u, y.addn(1).iushrn(1)), S = this.pow(u, y), Y = m; S.cmp(_) !== 0; ) {
        for (var fe = S, oe = 0; fe.cmp(_) !== 0; oe++)
          fe = fe.redSqr();
        o(oe < Y);
        var de = this.pow(v, new a(1).iushln(Y - oe - 1));
        X = X.redMul(de), v = de.redSqr(), S = S.redMul(v), Y = oe;
      }
      return X;
    }, O.prototype.invm = function(u) {
      var h = u._invmp(this.m);
      return h.negative !== 0 ? (h.negative = 0, this.imod(h).redNeg()) : this.imod(h);
    }, O.prototype.pow = function(u, h) {
      if (h.isZero())
        return new a(1).toRed(this);
      if (h.cmpn(1) === 0)
        return u.clone();
      var g = 4, y = new Array(1 << g);
      y[0] = new a(1).toRed(this), y[1] = u;
      for (var m = 2; m < y.length; m++)
        y[m] = this.mul(y[m - 1], u);
      var _ = y[0], R = 0, b = 0, l = h.bitLength() % 26;
      for (l === 0 && (l = 26), m = h.length - 1; m >= 0; m--) {
        for (var v = h.words[m], X = l - 1; X >= 0; X--) {
          var S = v >> X & 1;
          if (_ !== y[0] && (_ = this.sqr(_)), S === 0 && R === 0) {
            b = 0;
            continue;
          }
          R <<= 1, R |= S, b++, !(b !== g && (m !== 0 || X !== 0)) && (_ = this.mul(_, y[R]), b = 0, R = 0);
        }
        l = 26;
      }
      return _;
    }, O.prototype.convertTo = function(u) {
      var h = u.umod(this.m);
      return h === u ? h.clone() : h;
    }, O.prototype.convertFrom = function(u) {
      var h = u.clone();
      return h.red = null, h;
    }, a.mont = function(u) {
      return new V(u);
    };
    function V(x) {
      O.call(this, x), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    c(V, O), V.prototype.convertTo = function(u) {
      return this.imod(u.ushln(this.shift));
    }, V.prototype.convertFrom = function(u) {
      var h = this.imod(u.mul(this.rinv));
      return h.red = null, h;
    }, V.prototype.imul = function(u, h) {
      if (u.isZero() || h.isZero())
        return u.words[0] = 0, u.length = 1, u;
      var g = u.imul(h), y = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = g.isub(y).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, V.prototype.mul = function(u, h) {
      if (u.isZero() || h.isZero())
        return new a(0)._forceRed(this);
      var g = u.mul(h), y = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = g.isub(y).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, V.prototype.invm = function(u) {
      var h = this.imod(u._invmp(this.m).mul(this.r2));
      return h._forceRed(this);
    };
  })(n, commonjsGlobal);
})(bn$5);
var safeBuffer = { exports: {} }, buffer$1 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(n) {
  var e = n.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var t = n.indexOf("=");
  t === -1 && (t = e);
  var o = t === e ? 0 : 4 - t % 4;
  return [t, o];
}
function byteLength(n) {
  var e = getLens(n), t = e[0], o = e[1];
  return (t + o) * 3 / 4 - o;
}
function _byteLength(n, e, t) {
  return (e + t) * 3 / 4 - t;
}
function toByteArray(n) {
  var e, t = getLens(n), o = t[0], c = t[1], a = new Arr(_byteLength(n, o, c)), d = 0, p = c > 0 ? o - 4 : o, w;
  for (w = 0; w < p; w += 4)
    e = revLookup[n.charCodeAt(w)] << 18 | revLookup[n.charCodeAt(w + 1)] << 12 | revLookup[n.charCodeAt(w + 2)] << 6 | revLookup[n.charCodeAt(w + 3)], a[d++] = e >> 16 & 255, a[d++] = e >> 8 & 255, a[d++] = e & 255;
  return c === 2 && (e = revLookup[n.charCodeAt(w)] << 2 | revLookup[n.charCodeAt(w + 1)] >> 4, a[d++] = e & 255), c === 1 && (e = revLookup[n.charCodeAt(w)] << 10 | revLookup[n.charCodeAt(w + 1)] << 4 | revLookup[n.charCodeAt(w + 2)] >> 2, a[d++] = e >> 8 & 255, a[d++] = e & 255), a;
}
function tripletToBase64(n) {
  return lookup[n >> 18 & 63] + lookup[n >> 12 & 63] + lookup[n >> 6 & 63] + lookup[n & 63];
}
function encodeChunk(n, e, t) {
  for (var o, c = [], a = e; a < t; a += 3)
    o = (n[a] << 16 & 16711680) + (n[a + 1] << 8 & 65280) + (n[a + 2] & 255), c.push(tripletToBase64(o));
  return c.join("");
}
function fromByteArray(n) {
  for (var e, t = n.length, o = t % 3, c = [], a = 16383, d = 0, p = t - o; d < p; d += a)
    c.push(encodeChunk(n, d, d + a > p ? p : d + a));
  return o === 1 ? (e = n[t - 1], c.push(
    lookup[e >> 2] + lookup[e << 4 & 63] + "=="
  )) : o === 2 && (e = (n[t - 2] << 8) + n[t - 1], c.push(
    lookup[e >> 10] + lookup[e >> 4 & 63] + lookup[e << 2 & 63] + "="
  )), c.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(n, e, t, o, c) {
  var a, d, p = c * 8 - o - 1, w = (1 << p) - 1, M = w >> 1, I = -7, B = t ? c - 1 : 0, H = t ? -1 : 1, L = n[e + B];
  for (B += H, a = L & (1 << -I) - 1, L >>= -I, I += p; I > 0; a = a * 256 + n[e + B], B += H, I -= 8)
    ;
  for (d = a & (1 << -I) - 1, a >>= -I, I += o; I > 0; d = d * 256 + n[e + B], B += H, I -= 8)
    ;
  if (a === 0)
    a = 1 - M;
  else {
    if (a === w)
      return d ? NaN : (L ? -1 : 1) * (1 / 0);
    d = d + Math.pow(2, o), a = a - M;
  }
  return (L ? -1 : 1) * d * Math.pow(2, a - o);
};
ieee754.write = function(n, e, t, o, c, a) {
  var d, p, w, M = a * 8 - c - 1, I = (1 << M) - 1, B = I >> 1, H = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, L = o ? 0 : a - 1, W = o ? 1 : -1, $ = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (p = isNaN(e) ? 1 : 0, d = I) : (d = Math.floor(Math.log(e) / Math.LN2), e * (w = Math.pow(2, -d)) < 1 && (d--, w *= 2), d + B >= 1 ? e += H / w : e += H * Math.pow(2, 1 - B), e * w >= 2 && (d++, w /= 2), d + B >= I ? (p = 0, d = I) : d + B >= 1 ? (p = (e * w - 1) * Math.pow(2, c), d = d + B) : (p = e * Math.pow(2, B - 1) * Math.pow(2, c), d = 0)); c >= 8; n[t + L] = p & 255, L += W, p /= 256, c -= 8)
    ;
  for (d = d << c | p, M += c; M > 0; n[t + L] = d & 255, L += W, d /= 256, M -= 8)
    ;
  n[t + L - W] |= $ * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(n) {
  const e = base64Js, t = ieee754, o = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  n.Buffer = p, n.SlowBuffer = G, n.INSPECT_MAX_BYTES = 50;
  const c = 2147483647;
  n.kMaxLength = c, p.TYPED_ARRAY_SUPPORT = a(), !p.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a() {
    try {
      const T = new Uint8Array(1), A = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(A, Uint8Array.prototype), Object.setPrototypeOf(T, A), T.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(p.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (!!p.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(p.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (!!p.isBuffer(this))
        return this.byteOffset;
    }
  });
  function d(T) {
    if (T > c)
      throw new RangeError('The value "' + T + '" is invalid for option "size"');
    const A = new Uint8Array(T);
    return Object.setPrototypeOf(A, p.prototype), A;
  }
  function p(T, A, E) {
    if (typeof T == "number") {
      if (typeof A == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return B(T);
    }
    return w(T, A, E);
  }
  p.poolSize = 8192;
  function w(T, A, E) {
    if (typeof T == "string")
      return H(T, A);
    if (ArrayBuffer.isView(T))
      return W(T);
    if (T == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof T
      );
    if (it(T, ArrayBuffer) || T && it(T.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (it(T, SharedArrayBuffer) || T && it(T.buffer, SharedArrayBuffer)))
      return $(T, A, E);
    if (typeof T == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const F = T.valueOf && T.valueOf();
    if (F != null && F !== T)
      return p.from(F, A, E);
    const ie = P(T);
    if (ie)
      return ie;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof T[Symbol.toPrimitive] == "function")
      return p.from(T[Symbol.toPrimitive]("string"), A, E);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof T
    );
  }
  p.from = function(T, A, E) {
    return w(T, A, E);
  }, Object.setPrototypeOf(p.prototype, Uint8Array.prototype), Object.setPrototypeOf(p, Uint8Array);
  function M(T) {
    if (typeof T != "number")
      throw new TypeError('"size" argument must be of type number');
    if (T < 0)
      throw new RangeError('The value "' + T + '" is invalid for option "size"');
  }
  function I(T, A, E) {
    return M(T), T <= 0 ? d(T) : A !== void 0 ? typeof E == "string" ? d(T).fill(A, E) : d(T).fill(A) : d(T);
  }
  p.alloc = function(T, A, E) {
    return I(T, A, E);
  };
  function B(T) {
    return M(T), d(T < 0 ? 0 : U(T) | 0);
  }
  p.allocUnsafe = function(T) {
    return B(T);
  }, p.allocUnsafeSlow = function(T) {
    return B(T);
  };
  function H(T, A) {
    if ((typeof A != "string" || A === "") && (A = "utf8"), !p.isEncoding(A))
      throw new TypeError("Unknown encoding: " + A);
    const E = D(T, A) | 0;
    let F = d(E);
    const ie = F.write(T, A);
    return ie !== E && (F = F.slice(0, ie)), F;
  }
  function L(T) {
    const A = T.length < 0 ? 0 : U(T.length) | 0, E = d(A);
    for (let F = 0; F < A; F += 1)
      E[F] = T[F] & 255;
    return E;
  }
  function W(T) {
    if (it(T, Uint8Array)) {
      const A = new Uint8Array(T);
      return $(A.buffer, A.byteOffset, A.byteLength);
    }
    return L(T);
  }
  function $(T, A, E) {
    if (A < 0 || T.byteLength < A)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (T.byteLength < A + (E || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let F;
    return A === void 0 && E === void 0 ? F = new Uint8Array(T) : E === void 0 ? F = new Uint8Array(T, A) : F = new Uint8Array(T, A, E), Object.setPrototypeOf(F, p.prototype), F;
  }
  function P(T) {
    if (p.isBuffer(T)) {
      const A = U(T.length) | 0, E = d(A);
      return E.length === 0 || T.copy(E, 0, 0, A), E;
    }
    if (T.length !== void 0)
      return typeof T.length != "number" || ke(T.length) ? d(0) : L(T);
    if (T.type === "Buffer" && Array.isArray(T.data))
      return L(T.data);
  }
  function U(T) {
    if (T >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return T | 0;
  }
  function G(T) {
    return +T != T && (T = 0), p.alloc(+T);
  }
  p.isBuffer = function(A) {
    return A != null && A._isBuffer === !0 && A !== p.prototype;
  }, p.compare = function(A, E) {
    if (it(A, Uint8Array) && (A = p.from(A, A.offset, A.byteLength)), it(E, Uint8Array) && (E = p.from(E, E.offset, E.byteLength)), !p.isBuffer(A) || !p.isBuffer(E))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (A === E)
      return 0;
    let F = A.length, ie = E.length;
    for (let ne = 0, ce = Math.min(F, ie); ne < ce; ++ne)
      if (A[ne] !== E[ne]) {
        F = A[ne], ie = E[ne];
        break;
      }
    return F < ie ? -1 : ie < F ? 1 : 0;
  }, p.isEncoding = function(A) {
    switch (String(A).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, p.concat = function(A, E) {
    if (!Array.isArray(A))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (A.length === 0)
      return p.alloc(0);
    let F;
    if (E === void 0)
      for (E = 0, F = 0; F < A.length; ++F)
        E += A[F].length;
    const ie = p.allocUnsafe(E);
    let ne = 0;
    for (F = 0; F < A.length; ++F) {
      let ce = A[F];
      if (it(ce, Uint8Array))
        ne + ce.length > ie.length ? (p.isBuffer(ce) || (ce = p.from(ce)), ce.copy(ie, ne)) : Uint8Array.prototype.set.call(
          ie,
          ce,
          ne
        );
      else if (p.isBuffer(ce))
        ce.copy(ie, ne);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ne += ce.length;
    }
    return ie;
  };
  function D(T, A) {
    if (p.isBuffer(T))
      return T.length;
    if (ArrayBuffer.isView(T) || it(T, ArrayBuffer))
      return T.byteLength;
    if (typeof T != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof T
      );
    const E = T.length, F = arguments.length > 2 && arguments[2] === !0;
    if (!F && E === 0)
      return 0;
    let ie = !1;
    for (; ; )
      switch (A) {
        case "ascii":
        case "latin1":
        case "binary":
          return E;
        case "utf8":
        case "utf-8":
          return z(T).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return E * 2;
        case "hex":
          return E >>> 1;
        case "base64":
          return me(T).length;
        default:
          if (ie)
            return F ? -1 : z(T).length;
          A = ("" + A).toLowerCase(), ie = !0;
      }
  }
  p.byteLength = D;
  function Z(T, A, E) {
    let F = !1;
    if ((A === void 0 || A < 0) && (A = 0), A > this.length || ((E === void 0 || E > this.length) && (E = this.length), E <= 0) || (E >>>= 0, A >>>= 0, E <= A))
      return "";
    for (T || (T = "utf8"); ; )
      switch (T) {
        case "hex":
          return _(this, A, E);
        case "utf8":
        case "utf-8":
          return u(this, A, E);
        case "ascii":
          return y(this, A, E);
        case "latin1":
        case "binary":
          return m(this, A, E);
        case "base64":
          return x(this, A, E);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return R(this, A, E);
        default:
          if (F)
            throw new TypeError("Unknown encoding: " + T);
          T = (T + "").toLowerCase(), F = !0;
      }
  }
  p.prototype._isBuffer = !0;
  function J(T, A, E) {
    const F = T[A];
    T[A] = T[E], T[E] = F;
  }
  p.prototype.swap16 = function() {
    const A = this.length;
    if (A % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let E = 0; E < A; E += 2)
      J(this, E, E + 1);
    return this;
  }, p.prototype.swap32 = function() {
    const A = this.length;
    if (A % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let E = 0; E < A; E += 4)
      J(this, E, E + 3), J(this, E + 1, E + 2);
    return this;
  }, p.prototype.swap64 = function() {
    const A = this.length;
    if (A % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let E = 0; E < A; E += 8)
      J(this, E, E + 7), J(this, E + 1, E + 6), J(this, E + 2, E + 5), J(this, E + 3, E + 4);
    return this;
  }, p.prototype.toString = function() {
    const A = this.length;
    return A === 0 ? "" : arguments.length === 0 ? u(this, 0, A) : Z.apply(this, arguments);
  }, p.prototype.toLocaleString = p.prototype.toString, p.prototype.equals = function(A) {
    if (!p.isBuffer(A))
      throw new TypeError("Argument must be a Buffer");
    return this === A ? !0 : p.compare(this, A) === 0;
  }, p.prototype.inspect = function() {
    let A = "";
    const E = n.INSPECT_MAX_BYTES;
    return A = this.toString("hex", 0, E).replace(/(.{2})/g, "$1 ").trim(), this.length > E && (A += " ... "), "<Buffer " + A + ">";
  }, o && (p.prototype[o] = p.prototype.inspect), p.prototype.compare = function(A, E, F, ie, ne) {
    if (it(A, Uint8Array) && (A = p.from(A, A.offset, A.byteLength)), !p.isBuffer(A))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof A
      );
    if (E === void 0 && (E = 0), F === void 0 && (F = A ? A.length : 0), ie === void 0 && (ie = 0), ne === void 0 && (ne = this.length), E < 0 || F > A.length || ie < 0 || ne > this.length)
      throw new RangeError("out of range index");
    if (ie >= ne && E >= F)
      return 0;
    if (ie >= ne)
      return -1;
    if (E >= F)
      return 1;
    if (E >>>= 0, F >>>= 0, ie >>>= 0, ne >>>= 0, this === A)
      return 0;
    let ce = ne - ie, nt = F - E;
    const Be = Math.min(ce, nt), Ce = this.slice(ie, ne), _t = A.slice(E, F);
    for (let Me = 0; Me < Be; ++Me)
      if (Ce[Me] !== _t[Me]) {
        ce = Ce[Me], nt = _t[Me];
        break;
      }
    return ce < nt ? -1 : nt < ce ? 1 : 0;
  };
  function te(T, A, E, F, ie) {
    if (T.length === 0)
      return -1;
    if (typeof E == "string" ? (F = E, E = 0) : E > 2147483647 ? E = 2147483647 : E < -2147483648 && (E = -2147483648), E = +E, ke(E) && (E = ie ? 0 : T.length - 1), E < 0 && (E = T.length + E), E >= T.length) {
      if (ie)
        return -1;
      E = T.length - 1;
    } else if (E < 0)
      if (ie)
        E = 0;
      else
        return -1;
    if (typeof A == "string" && (A = p.from(A, F)), p.isBuffer(A))
      return A.length === 0 ? -1 : ue(T, A, E, F, ie);
    if (typeof A == "number")
      return A = A & 255, typeof Uint8Array.prototype.indexOf == "function" ? ie ? Uint8Array.prototype.indexOf.call(T, A, E) : Uint8Array.prototype.lastIndexOf.call(T, A, E) : ue(T, [A], E, F, ie);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ue(T, A, E, F, ie) {
    let ne = 1, ce = T.length, nt = A.length;
    if (F !== void 0 && (F = String(F).toLowerCase(), F === "ucs2" || F === "ucs-2" || F === "utf16le" || F === "utf-16le")) {
      if (T.length < 2 || A.length < 2)
        return -1;
      ne = 2, ce /= 2, nt /= 2, E /= 2;
    }
    function Be(_t, Me) {
      return ne === 1 ? _t[Me] : _t.readUInt16BE(Me * ne);
    }
    let Ce;
    if (ie) {
      let _t = -1;
      for (Ce = E; Ce < ce; Ce++)
        if (Be(T, Ce) === Be(A, _t === -1 ? 0 : Ce - _t)) {
          if (_t === -1 && (_t = Ce), Ce - _t + 1 === nt)
            return _t * ne;
        } else
          _t !== -1 && (Ce -= Ce - _t), _t = -1;
    } else
      for (E + nt > ce && (E = ce - nt), Ce = E; Ce >= 0; Ce--) {
        let _t = !0;
        for (let Me = 0; Me < nt; Me++)
          if (Be(T, Ce + Me) !== Be(A, Me)) {
            _t = !1;
            break;
          }
        if (_t)
          return Ce;
      }
    return -1;
  }
  p.prototype.includes = function(A, E, F) {
    return this.indexOf(A, E, F) !== -1;
  }, p.prototype.indexOf = function(A, E, F) {
    return te(this, A, E, F, !0);
  }, p.prototype.lastIndexOf = function(A, E, F) {
    return te(this, A, E, F, !1);
  };
  function he(T, A, E, F) {
    E = Number(E) || 0;
    const ie = T.length - E;
    F ? (F = Number(F), F > ie && (F = ie)) : F = ie;
    const ne = A.length;
    F > ne / 2 && (F = ne / 2);
    let ce;
    for (ce = 0; ce < F; ++ce) {
      const nt = parseInt(A.substr(ce * 2, 2), 16);
      if (ke(nt))
        return ce;
      T[E + ce] = nt;
    }
    return ce;
  }
  function Se(T, A, E, F) {
    return Ae(z(A, T.length - E), T, E, F);
  }
  function C(T, A, E, F) {
    return Ae(ee(A), T, E, F);
  }
  function O(T, A, E, F) {
    return Ae(me(A), T, E, F);
  }
  function V(T, A, E, F) {
    return Ae(ve(A, T.length - E), T, E, F);
  }
  p.prototype.write = function(A, E, F, ie) {
    if (E === void 0)
      ie = "utf8", F = this.length, E = 0;
    else if (F === void 0 && typeof E == "string")
      ie = E, F = this.length, E = 0;
    else if (isFinite(E))
      E = E >>> 0, isFinite(F) ? (F = F >>> 0, ie === void 0 && (ie = "utf8")) : (ie = F, F = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ne = this.length - E;
    if ((F === void 0 || F > ne) && (F = ne), A.length > 0 && (F < 0 || E < 0) || E > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ie || (ie = "utf8");
    let ce = !1;
    for (; ; )
      switch (ie) {
        case "hex":
          return he(this, A, E, F);
        case "utf8":
        case "utf-8":
          return Se(this, A, E, F);
        case "ascii":
        case "latin1":
        case "binary":
          return C(this, A, E, F);
        case "base64":
          return O(this, A, E, F);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return V(this, A, E, F);
        default:
          if (ce)
            throw new TypeError("Unknown encoding: " + ie);
          ie = ("" + ie).toLowerCase(), ce = !0;
      }
  }, p.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function x(T, A, E) {
    return A === 0 && E === T.length ? e.fromByteArray(T) : e.fromByteArray(T.slice(A, E));
  }
  function u(T, A, E) {
    E = Math.min(T.length, E);
    const F = [];
    let ie = A;
    for (; ie < E; ) {
      const ne = T[ie];
      let ce = null, nt = ne > 239 ? 4 : ne > 223 ? 3 : ne > 191 ? 2 : 1;
      if (ie + nt <= E) {
        let Be, Ce, _t, Me;
        switch (nt) {
          case 1:
            ne < 128 && (ce = ne);
            break;
          case 2:
            Be = T[ie + 1], (Be & 192) === 128 && (Me = (ne & 31) << 6 | Be & 63, Me > 127 && (ce = Me));
            break;
          case 3:
            Be = T[ie + 1], Ce = T[ie + 2], (Be & 192) === 128 && (Ce & 192) === 128 && (Me = (ne & 15) << 12 | (Be & 63) << 6 | Ce & 63, Me > 2047 && (Me < 55296 || Me > 57343) && (ce = Me));
            break;
          case 4:
            Be = T[ie + 1], Ce = T[ie + 2], _t = T[ie + 3], (Be & 192) === 128 && (Ce & 192) === 128 && (_t & 192) === 128 && (Me = (ne & 15) << 18 | (Be & 63) << 12 | (Ce & 63) << 6 | _t & 63, Me > 65535 && Me < 1114112 && (ce = Me));
        }
      }
      ce === null ? (ce = 65533, nt = 1) : ce > 65535 && (ce -= 65536, F.push(ce >>> 10 & 1023 | 55296), ce = 56320 | ce & 1023), F.push(ce), ie += nt;
    }
    return g(F);
  }
  const h = 4096;
  function g(T) {
    const A = T.length;
    if (A <= h)
      return String.fromCharCode.apply(String, T);
    let E = "", F = 0;
    for (; F < A; )
      E += String.fromCharCode.apply(
        String,
        T.slice(F, F += h)
      );
    return E;
  }
  function y(T, A, E) {
    let F = "";
    E = Math.min(T.length, E);
    for (let ie = A; ie < E; ++ie)
      F += String.fromCharCode(T[ie] & 127);
    return F;
  }
  function m(T, A, E) {
    let F = "";
    E = Math.min(T.length, E);
    for (let ie = A; ie < E; ++ie)
      F += String.fromCharCode(T[ie]);
    return F;
  }
  function _(T, A, E) {
    const F = T.length;
    (!A || A < 0) && (A = 0), (!E || E < 0 || E > F) && (E = F);
    let ie = "";
    for (let ne = A; ne < E; ++ne)
      ie += qe[T[ne]];
    return ie;
  }
  function R(T, A, E) {
    const F = T.slice(A, E);
    let ie = "";
    for (let ne = 0; ne < F.length - 1; ne += 2)
      ie += String.fromCharCode(F[ne] + F[ne + 1] * 256);
    return ie;
  }
  p.prototype.slice = function(A, E) {
    const F = this.length;
    A = ~~A, E = E === void 0 ? F : ~~E, A < 0 ? (A += F, A < 0 && (A = 0)) : A > F && (A = F), E < 0 ? (E += F, E < 0 && (E = 0)) : E > F && (E = F), E < A && (E = A);
    const ie = this.subarray(A, E);
    return Object.setPrototypeOf(ie, p.prototype), ie;
  };
  function b(T, A, E) {
    if (T % 1 !== 0 || T < 0)
      throw new RangeError("offset is not uint");
    if (T + A > E)
      throw new RangeError("Trying to access beyond buffer length");
  }
  p.prototype.readUintLE = p.prototype.readUIntLE = function(A, E, F) {
    A = A >>> 0, E = E >>> 0, F || b(A, E, this.length);
    let ie = this[A], ne = 1, ce = 0;
    for (; ++ce < E && (ne *= 256); )
      ie += this[A + ce] * ne;
    return ie;
  }, p.prototype.readUintBE = p.prototype.readUIntBE = function(A, E, F) {
    A = A >>> 0, E = E >>> 0, F || b(A, E, this.length);
    let ie = this[A + --E], ne = 1;
    for (; E > 0 && (ne *= 256); )
      ie += this[A + --E] * ne;
    return ie;
  }, p.prototype.readUint8 = p.prototype.readUInt8 = function(A, E) {
    return A = A >>> 0, E || b(A, 1, this.length), this[A];
  }, p.prototype.readUint16LE = p.prototype.readUInt16LE = function(A, E) {
    return A = A >>> 0, E || b(A, 2, this.length), this[A] | this[A + 1] << 8;
  }, p.prototype.readUint16BE = p.prototype.readUInt16BE = function(A, E) {
    return A = A >>> 0, E || b(A, 2, this.length), this[A] << 8 | this[A + 1];
  }, p.prototype.readUint32LE = p.prototype.readUInt32LE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), (this[A] | this[A + 1] << 8 | this[A + 2] << 16) + this[A + 3] * 16777216;
  }, p.prototype.readUint32BE = p.prototype.readUInt32BE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), this[A] * 16777216 + (this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3]);
  }, p.prototype.readBigUInt64LE = or(function(A) {
    A = A >>> 0, rt(A, "offset");
    const E = this[A], F = this[A + 7];
    (E === void 0 || F === void 0) && xe(A, this.length - 8);
    const ie = E + this[++A] * 2 ** 8 + this[++A] * 2 ** 16 + this[++A] * 2 ** 24, ne = this[++A] + this[++A] * 2 ** 8 + this[++A] * 2 ** 16 + F * 2 ** 24;
    return BigInt(ie) + (BigInt(ne) << BigInt(32));
  }), p.prototype.readBigUInt64BE = or(function(A) {
    A = A >>> 0, rt(A, "offset");
    const E = this[A], F = this[A + 7];
    (E === void 0 || F === void 0) && xe(A, this.length - 8);
    const ie = E * 2 ** 24 + this[++A] * 2 ** 16 + this[++A] * 2 ** 8 + this[++A], ne = this[++A] * 2 ** 24 + this[++A] * 2 ** 16 + this[++A] * 2 ** 8 + F;
    return (BigInt(ie) << BigInt(32)) + BigInt(ne);
  }), p.prototype.readIntLE = function(A, E, F) {
    A = A >>> 0, E = E >>> 0, F || b(A, E, this.length);
    let ie = this[A], ne = 1, ce = 0;
    for (; ++ce < E && (ne *= 256); )
      ie += this[A + ce] * ne;
    return ne *= 128, ie >= ne && (ie -= Math.pow(2, 8 * E)), ie;
  }, p.prototype.readIntBE = function(A, E, F) {
    A = A >>> 0, E = E >>> 0, F || b(A, E, this.length);
    let ie = E, ne = 1, ce = this[A + --ie];
    for (; ie > 0 && (ne *= 256); )
      ce += this[A + --ie] * ne;
    return ne *= 128, ce >= ne && (ce -= Math.pow(2, 8 * E)), ce;
  }, p.prototype.readInt8 = function(A, E) {
    return A = A >>> 0, E || b(A, 1, this.length), this[A] & 128 ? (255 - this[A] + 1) * -1 : this[A];
  }, p.prototype.readInt16LE = function(A, E) {
    A = A >>> 0, E || b(A, 2, this.length);
    const F = this[A] | this[A + 1] << 8;
    return F & 32768 ? F | 4294901760 : F;
  }, p.prototype.readInt16BE = function(A, E) {
    A = A >>> 0, E || b(A, 2, this.length);
    const F = this[A + 1] | this[A] << 8;
    return F & 32768 ? F | 4294901760 : F;
  }, p.prototype.readInt32LE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), this[A] | this[A + 1] << 8 | this[A + 2] << 16 | this[A + 3] << 24;
  }, p.prototype.readInt32BE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), this[A] << 24 | this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3];
  }, p.prototype.readBigInt64LE = or(function(A) {
    A = A >>> 0, rt(A, "offset");
    const E = this[A], F = this[A + 7];
    (E === void 0 || F === void 0) && xe(A, this.length - 8);
    const ie = this[A + 4] + this[A + 5] * 2 ** 8 + this[A + 6] * 2 ** 16 + (F << 24);
    return (BigInt(ie) << BigInt(32)) + BigInt(E + this[++A] * 2 ** 8 + this[++A] * 2 ** 16 + this[++A] * 2 ** 24);
  }), p.prototype.readBigInt64BE = or(function(A) {
    A = A >>> 0, rt(A, "offset");
    const E = this[A], F = this[A + 7];
    (E === void 0 || F === void 0) && xe(A, this.length - 8);
    const ie = (E << 24) + this[++A] * 2 ** 16 + this[++A] * 2 ** 8 + this[++A];
    return (BigInt(ie) << BigInt(32)) + BigInt(this[++A] * 2 ** 24 + this[++A] * 2 ** 16 + this[++A] * 2 ** 8 + F);
  }), p.prototype.readFloatLE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), t.read(this, A, !0, 23, 4);
  }, p.prototype.readFloatBE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), t.read(this, A, !1, 23, 4);
  }, p.prototype.readDoubleLE = function(A, E) {
    return A = A >>> 0, E || b(A, 8, this.length), t.read(this, A, !0, 52, 8);
  }, p.prototype.readDoubleBE = function(A, E) {
    return A = A >>> 0, E || b(A, 8, this.length), t.read(this, A, !1, 52, 8);
  };
  function l(T, A, E, F, ie, ne) {
    if (!p.isBuffer(T))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (A > ie || A < ne)
      throw new RangeError('"value" argument is out of bounds');
    if (E + F > T.length)
      throw new RangeError("Index out of range");
  }
  p.prototype.writeUintLE = p.prototype.writeUIntLE = function(A, E, F, ie) {
    if (A = +A, E = E >>> 0, F = F >>> 0, !ie) {
      const nt = Math.pow(2, 8 * F) - 1;
      l(this, A, E, F, nt, 0);
    }
    let ne = 1, ce = 0;
    for (this[E] = A & 255; ++ce < F && (ne *= 256); )
      this[E + ce] = A / ne & 255;
    return E + F;
  }, p.prototype.writeUintBE = p.prototype.writeUIntBE = function(A, E, F, ie) {
    if (A = +A, E = E >>> 0, F = F >>> 0, !ie) {
      const nt = Math.pow(2, 8 * F) - 1;
      l(this, A, E, F, nt, 0);
    }
    let ne = F - 1, ce = 1;
    for (this[E + ne] = A & 255; --ne >= 0 && (ce *= 256); )
      this[E + ne] = A / ce & 255;
    return E + F;
  }, p.prototype.writeUint8 = p.prototype.writeUInt8 = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 1, 255, 0), this[E] = A & 255, E + 1;
  }, p.prototype.writeUint16LE = p.prototype.writeUInt16LE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 2, 65535, 0), this[E] = A & 255, this[E + 1] = A >>> 8, E + 2;
  }, p.prototype.writeUint16BE = p.prototype.writeUInt16BE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 2, 65535, 0), this[E] = A >>> 8, this[E + 1] = A & 255, E + 2;
  }, p.prototype.writeUint32LE = p.prototype.writeUInt32LE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 4, 4294967295, 0), this[E + 3] = A >>> 24, this[E + 2] = A >>> 16, this[E + 1] = A >>> 8, this[E] = A & 255, E + 4;
  }, p.prototype.writeUint32BE = p.prototype.writeUInt32BE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 4, 4294967295, 0), this[E] = A >>> 24, this[E + 1] = A >>> 16, this[E + 2] = A >>> 8, this[E + 3] = A & 255, E + 4;
  };
  function v(T, A, E, F, ie) {
    be(A, F, ie, T, E, 7);
    let ne = Number(A & BigInt(4294967295));
    T[E++] = ne, ne = ne >> 8, T[E++] = ne, ne = ne >> 8, T[E++] = ne, ne = ne >> 8, T[E++] = ne;
    let ce = Number(A >> BigInt(32) & BigInt(4294967295));
    return T[E++] = ce, ce = ce >> 8, T[E++] = ce, ce = ce >> 8, T[E++] = ce, ce = ce >> 8, T[E++] = ce, E;
  }
  function X(T, A, E, F, ie) {
    be(A, F, ie, T, E, 7);
    let ne = Number(A & BigInt(4294967295));
    T[E + 7] = ne, ne = ne >> 8, T[E + 6] = ne, ne = ne >> 8, T[E + 5] = ne, ne = ne >> 8, T[E + 4] = ne;
    let ce = Number(A >> BigInt(32) & BigInt(4294967295));
    return T[E + 3] = ce, ce = ce >> 8, T[E + 2] = ce, ce = ce >> 8, T[E + 1] = ce, ce = ce >> 8, T[E] = ce, E + 8;
  }
  p.prototype.writeBigUInt64LE = or(function(A, E = 0) {
    return v(this, A, E, BigInt(0), BigInt("0xffffffffffffffff"));
  }), p.prototype.writeBigUInt64BE = or(function(A, E = 0) {
    return X(this, A, E, BigInt(0), BigInt("0xffffffffffffffff"));
  }), p.prototype.writeIntLE = function(A, E, F, ie) {
    if (A = +A, E = E >>> 0, !ie) {
      const Be = Math.pow(2, 8 * F - 1);
      l(this, A, E, F, Be - 1, -Be);
    }
    let ne = 0, ce = 1, nt = 0;
    for (this[E] = A & 255; ++ne < F && (ce *= 256); )
      A < 0 && nt === 0 && this[E + ne - 1] !== 0 && (nt = 1), this[E + ne] = (A / ce >> 0) - nt & 255;
    return E + F;
  }, p.prototype.writeIntBE = function(A, E, F, ie) {
    if (A = +A, E = E >>> 0, !ie) {
      const Be = Math.pow(2, 8 * F - 1);
      l(this, A, E, F, Be - 1, -Be);
    }
    let ne = F - 1, ce = 1, nt = 0;
    for (this[E + ne] = A & 255; --ne >= 0 && (ce *= 256); )
      A < 0 && nt === 0 && this[E + ne + 1] !== 0 && (nt = 1), this[E + ne] = (A / ce >> 0) - nt & 255;
    return E + F;
  }, p.prototype.writeInt8 = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 1, 127, -128), A < 0 && (A = 255 + A + 1), this[E] = A & 255, E + 1;
  }, p.prototype.writeInt16LE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 2, 32767, -32768), this[E] = A & 255, this[E + 1] = A >>> 8, E + 2;
  }, p.prototype.writeInt16BE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 2, 32767, -32768), this[E] = A >>> 8, this[E + 1] = A & 255, E + 2;
  }, p.prototype.writeInt32LE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 4, 2147483647, -2147483648), this[E] = A & 255, this[E + 1] = A >>> 8, this[E + 2] = A >>> 16, this[E + 3] = A >>> 24, E + 4;
  }, p.prototype.writeInt32BE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 4, 2147483647, -2147483648), A < 0 && (A = 4294967295 + A + 1), this[E] = A >>> 24, this[E + 1] = A >>> 16, this[E + 2] = A >>> 8, this[E + 3] = A & 255, E + 4;
  }, p.prototype.writeBigInt64LE = or(function(A, E = 0) {
    return v(this, A, E, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), p.prototype.writeBigInt64BE = or(function(A, E = 0) {
    return X(this, A, E, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function S(T, A, E, F, ie, ne) {
    if (E + F > T.length)
      throw new RangeError("Index out of range");
    if (E < 0)
      throw new RangeError("Index out of range");
  }
  function Y(T, A, E, F, ie) {
    return A = +A, E = E >>> 0, ie || S(T, A, E, 4), t.write(T, A, E, F, 23, 4), E + 4;
  }
  p.prototype.writeFloatLE = function(A, E, F) {
    return Y(this, A, E, !0, F);
  }, p.prototype.writeFloatBE = function(A, E, F) {
    return Y(this, A, E, !1, F);
  };
  function fe(T, A, E, F, ie) {
    return A = +A, E = E >>> 0, ie || S(T, A, E, 8), t.write(T, A, E, F, 52, 8), E + 8;
  }
  p.prototype.writeDoubleLE = function(A, E, F) {
    return fe(this, A, E, !0, F);
  }, p.prototype.writeDoubleBE = function(A, E, F) {
    return fe(this, A, E, !1, F);
  }, p.prototype.copy = function(A, E, F, ie) {
    if (!p.isBuffer(A))
      throw new TypeError("argument should be a Buffer");
    if (F || (F = 0), !ie && ie !== 0 && (ie = this.length), E >= A.length && (E = A.length), E || (E = 0), ie > 0 && ie < F && (ie = F), ie === F || A.length === 0 || this.length === 0)
      return 0;
    if (E < 0)
      throw new RangeError("targetStart out of bounds");
    if (F < 0 || F >= this.length)
      throw new RangeError("Index out of range");
    if (ie < 0)
      throw new RangeError("sourceEnd out of bounds");
    ie > this.length && (ie = this.length), A.length - E < ie - F && (ie = A.length - E + F);
    const ne = ie - F;
    return this === A && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(E, F, ie) : Uint8Array.prototype.set.call(
      A,
      this.subarray(F, ie),
      E
    ), ne;
  }, p.prototype.fill = function(A, E, F, ie) {
    if (typeof A == "string") {
      if (typeof E == "string" ? (ie = E, E = 0, F = this.length) : typeof F == "string" && (ie = F, F = this.length), ie !== void 0 && typeof ie != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ie == "string" && !p.isEncoding(ie))
        throw new TypeError("Unknown encoding: " + ie);
      if (A.length === 1) {
        const ce = A.charCodeAt(0);
        (ie === "utf8" && ce < 128 || ie === "latin1") && (A = ce);
      }
    } else
      typeof A == "number" ? A = A & 255 : typeof A == "boolean" && (A = Number(A));
    if (E < 0 || this.length < E || this.length < F)
      throw new RangeError("Out of range index");
    if (F <= E)
      return this;
    E = E >>> 0, F = F === void 0 ? this.length : F >>> 0, A || (A = 0);
    let ne;
    if (typeof A == "number")
      for (ne = E; ne < F; ++ne)
        this[ne] = A;
    else {
      const ce = p.isBuffer(A) ? A : p.from(A, ie), nt = ce.length;
      if (nt === 0)
        throw new TypeError('The value "' + A + '" is invalid for argument "value"');
      for (ne = 0; ne < F - E; ++ne)
        this[ne + E] = ce[ne % nt];
    }
    return this;
  };
  const oe = {};
  function de(T, A, E) {
    oe[T] = class extends E {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: A.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${T}]`, this.stack, delete this.name;
      }
      get code() {
        return T;
      }
      set code(ie) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ie,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${T}]: ${this.message}`;
      }
    };
  }
  de(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(T) {
      return T ? `${T} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), de(
    "ERR_INVALID_ARG_TYPE",
    function(T, A) {
      return `The "${T}" argument must be of type number. Received type ${typeof A}`;
    },
    TypeError
  ), de(
    "ERR_OUT_OF_RANGE",
    function(T, A, E) {
      let F = `The value of "${T}" is out of range.`, ie = E;
      return Number.isInteger(E) && Math.abs(E) > 2 ** 32 ? ie = Ie(String(E)) : typeof E == "bigint" && (ie = String(E), (E > BigInt(2) ** BigInt(32) || E < -(BigInt(2) ** BigInt(32))) && (ie = Ie(ie)), ie += "n"), F += ` It must be ${A}. Received ${ie}`, F;
    },
    RangeError
  );
  function Ie(T) {
    let A = "", E = T.length;
    const F = T[0] === "-" ? 1 : 0;
    for (; E >= F + 4; E -= 3)
      A = `_${T.slice(E - 3, E)}${A}`;
    return `${T.slice(0, E)}${A}`;
  }
  function ye(T, A, E) {
    rt(A, "offset"), (T[A] === void 0 || T[A + E] === void 0) && xe(A, T.length - (E + 1));
  }
  function be(T, A, E, F, ie, ne) {
    if (T > E || T < A) {
      const ce = typeof A == "bigint" ? "n" : "";
      let nt;
      throw ne > 3 ? A === 0 || A === BigInt(0) ? nt = `>= 0${ce} and < 2${ce} ** ${(ne + 1) * 8}${ce}` : nt = `>= -(2${ce} ** ${(ne + 1) * 8 - 1}${ce}) and < 2 ** ${(ne + 1) * 8 - 1}${ce}` : nt = `>= ${A}${ce} and <= ${E}${ce}`, new oe.ERR_OUT_OF_RANGE("value", nt, T);
    }
    ye(F, ie, ne);
  }
  function rt(T, A) {
    if (typeof T != "number")
      throw new oe.ERR_INVALID_ARG_TYPE(A, "number", T);
  }
  function xe(T, A, E) {
    throw Math.floor(T) !== T ? (rt(T, E), new oe.ERR_OUT_OF_RANGE(E || "offset", "an integer", T)) : A < 0 ? new oe.ERR_BUFFER_OUT_OF_BOUNDS() : new oe.ERR_OUT_OF_RANGE(
      E || "offset",
      `>= ${E ? 1 : 0} and <= ${A}`,
      T
    );
  }
  const Ne = /[^+/0-9A-Za-z-_]/g;
  function j(T) {
    if (T = T.split("=")[0], T = T.trim().replace(Ne, ""), T.length < 2)
      return "";
    for (; T.length % 4 !== 0; )
      T = T + "=";
    return T;
  }
  function z(T, A) {
    A = A || 1 / 0;
    let E;
    const F = T.length;
    let ie = null;
    const ne = [];
    for (let ce = 0; ce < F; ++ce) {
      if (E = T.charCodeAt(ce), E > 55295 && E < 57344) {
        if (!ie) {
          if (E > 56319) {
            (A -= 3) > -1 && ne.push(239, 191, 189);
            continue;
          } else if (ce + 1 === F) {
            (A -= 3) > -1 && ne.push(239, 191, 189);
            continue;
          }
          ie = E;
          continue;
        }
        if (E < 56320) {
          (A -= 3) > -1 && ne.push(239, 191, 189), ie = E;
          continue;
        }
        E = (ie - 55296 << 10 | E - 56320) + 65536;
      } else
        ie && (A -= 3) > -1 && ne.push(239, 191, 189);
      if (ie = null, E < 128) {
        if ((A -= 1) < 0)
          break;
        ne.push(E);
      } else if (E < 2048) {
        if ((A -= 2) < 0)
          break;
        ne.push(
          E >> 6 | 192,
          E & 63 | 128
        );
      } else if (E < 65536) {
        if ((A -= 3) < 0)
          break;
        ne.push(
          E >> 12 | 224,
          E >> 6 & 63 | 128,
          E & 63 | 128
        );
      } else if (E < 1114112) {
        if ((A -= 4) < 0)
          break;
        ne.push(
          E >> 18 | 240,
          E >> 12 & 63 | 128,
          E >> 6 & 63 | 128,
          E & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ne;
  }
  function ee(T) {
    const A = [];
    for (let E = 0; E < T.length; ++E)
      A.push(T.charCodeAt(E) & 255);
    return A;
  }
  function ve(T, A) {
    let E, F, ie;
    const ne = [];
    for (let ce = 0; ce < T.length && !((A -= 2) < 0); ++ce)
      E = T.charCodeAt(ce), F = E >> 8, ie = E % 256, ne.push(ie), ne.push(F);
    return ne;
  }
  function me(T) {
    return e.toByteArray(j(T));
  }
  function Ae(T, A, E, F) {
    let ie;
    for (ie = 0; ie < F && !(ie + E >= A.length || ie >= T.length); ++ie)
      A[ie + E] = T[ie];
    return ie;
  }
  function it(T, A) {
    return T instanceof A || T != null && T.constructor != null && T.constructor.name != null && T.constructor.name === A.name;
  }
  function ke(T) {
    return T !== T;
  }
  const qe = function() {
    const T = "0123456789abcdef", A = new Array(256);
    for (let E = 0; E < 16; ++E) {
      const F = E * 16;
      for (let ie = 0; ie < 16; ++ie)
        A[F + ie] = T[E] + T[ie];
    }
    return A;
  }();
  function or(T) {
    return typeof BigInt > "u" ? Oe : T;
  }
  function Oe() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(n, e) {
  var t = buffer$1, o = t.Buffer;
  function c(d, p) {
    for (var w in d)
      p[w] = d[w];
  }
  o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow ? n.exports = t : (c(t, e), e.Buffer = a);
  function a(d, p, w) {
    return o(d, p, w);
  }
  a.prototype = Object.create(o.prototype), c(o, a), a.from = function(d, p, w) {
    if (typeof d == "number")
      throw new TypeError("Argument must not be a number");
    return o(d, p, w);
  }, a.alloc = function(d, p, w) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    var M = o(d);
    return p !== void 0 ? typeof w == "string" ? M.fill(p, w) : M.fill(p) : M.fill(0), M;
  }, a.allocUnsafe = function(d) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    return o(d);
  }, a.allocUnsafeSlow = function(d) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    return t.SlowBuffer(d);
  };
})(safeBuffer, safeBuffer.exports);
var _Buffer = safeBuffer.exports.Buffer;
function base$1(n) {
  if (n.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), t = 0; t < e.length; t++)
    e[t] = 255;
  for (var o = 0; o < n.length; o++) {
    var c = n.charAt(o), a = c.charCodeAt(0);
    if (e[a] !== 255)
      throw new TypeError(c + " is ambiguous");
    e[a] = o;
  }
  var d = n.length, p = n.charAt(0), w = Math.log(d) / Math.log(256), M = Math.log(256) / Math.log(d);
  function I(L) {
    if ((Array.isArray(L) || L instanceof Uint8Array) && (L = _Buffer.from(L)), !_Buffer.isBuffer(L))
      throw new TypeError("Expected Buffer");
    if (L.length === 0)
      return "";
    for (var W = 0, $ = 0, P = 0, U = L.length; P !== U && L[P] === 0; )
      P++, W++;
    for (var G = (U - P) * M + 1 >>> 0, D = new Uint8Array(G); P !== U; ) {
      for (var Z = L[P], J = 0, te = G - 1; (Z !== 0 || J < $) && te !== -1; te--, J++)
        Z += 256 * D[te] >>> 0, D[te] = Z % d >>> 0, Z = Z / d >>> 0;
      if (Z !== 0)
        throw new Error("Non-zero carry");
      $ = J, P++;
    }
    for (var ue = G - $; ue !== G && D[ue] === 0; )
      ue++;
    for (var he = p.repeat(W); ue < G; ++ue)
      he += n.charAt(D[ue]);
    return he;
  }
  function B(L) {
    if (typeof L != "string")
      throw new TypeError("Expected String");
    if (L.length === 0)
      return _Buffer.alloc(0);
    for (var W = 0, $ = 0, P = 0; L[W] === p; )
      $++, W++;
    for (var U = (L.length - W) * w + 1 >>> 0, G = new Uint8Array(U); L[W]; ) {
      var D = e[L.charCodeAt(W)];
      if (D === 255)
        return;
      for (var Z = 0, J = U - 1; (D !== 0 || Z < P) && J !== -1; J--, Z++)
        D += d * G[J] >>> 0, G[J] = D % 256 >>> 0, D = D / 256 >>> 0;
      if (D !== 0)
        throw new Error("Non-zero carry");
      P = Z, W++;
    }
    for (var te = U - P; te !== U && G[te] === 0; )
      te++;
    var ue = _Buffer.allocUnsafe($ + (U - te));
    ue.fill(0, 0, $);
    for (var he = $; te !== U; )
      ue[he++] = G[te++];
    return ue;
  }
  function H(L) {
    var W = B(L);
    if (W)
      return W;
    throw new Error("Non-base" + d + " character");
  }
  return {
    encode: I,
    decodeUnsafe: B,
    decode: H
  };
}
var src = base$1, basex = src, ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", bs58 = basex(ALPHABET);
function inRange(n, e, t) {
  return e <= n && n <= t;
}
function ToDictionary(n) {
  if (n === void 0)
    return {};
  if (n === Object(n))
    return n;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(n) {
  for (var e = String(n), t = e.length, o = 0, c = []; o < t; ) {
    var a = e.charCodeAt(o);
    if (a < 55296 || a > 57343)
      c.push(a);
    else if (56320 <= a && a <= 57343)
      c.push(65533);
    else if (55296 <= a && a <= 56319)
      if (o === t - 1)
        c.push(65533);
      else {
        var d = n.charCodeAt(o + 1);
        if (56320 <= d && d <= 57343) {
          var p = a & 1023, w = d & 1023;
          c.push(65536 + (p << 10) + w), o += 1;
        } else
          c.push(65533);
      }
    o += 1;
  }
  return c;
}
function codePointsToString(n) {
  for (var e = "", t = 0; t < n.length; ++t) {
    var o = n[t];
    o <= 65535 ? e += String.fromCharCode(o) : (o -= 65536, e += String.fromCharCode(
      (o >> 10) + 55296,
      (o & 1023) + 56320
    ));
  }
  return e;
}
var end_of_stream = -1;
function Stream(n) {
  this.tokens = [].slice.call(n);
}
Stream.prototype = {
  endOfStream: function() {
    return !this.tokens.length;
  },
  read: function() {
    return this.tokens.length ? this.tokens.shift() : end_of_stream;
  },
  prepend: function(n) {
    if (Array.isArray(n))
      for (var e = n; e.length; )
        this.tokens.unshift(e.pop());
    else
      this.tokens.unshift(n);
  },
  push: function(n) {
    if (Array.isArray(n))
      for (var e = n; e.length; )
        this.tokens.push(e.shift());
    else
      this.tokens.push(n);
  }
};
var finished = -1;
function decoderError(n, e) {
  if (n)
    throw TypeError("Decoder error");
  return e || 65533;
}
var DEFAULT_ENCODING = "utf-8";
function TextDecoder$1(n, e) {
  if (!(this instanceof TextDecoder$1))
    return new TextDecoder$1(n, e);
  if (n = n !== void 0 ? String(n).toLowerCase() : DEFAULT_ENCODING, n !== DEFAULT_ENCODING)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  e = ToDictionary(e), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = Boolean(e.fatal), this._ignoreBOM = Boolean(e.ignoreBOM), Object.defineProperty(this, "encoding", { value: "utf-8" }), Object.defineProperty(this, "fatal", { value: this._fatal }), Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
TextDecoder$1.prototype = {
  decode: function(e, t) {
    var o;
    typeof e == "object" && e instanceof ArrayBuffer ? o = new Uint8Array(e) : typeof e == "object" && "buffer" in e && e.buffer instanceof ArrayBuffer ? o = new Uint8Array(
      e.buffer,
      e.byteOffset,
      e.byteLength
    ) : o = new Uint8Array(0), t = ToDictionary(t), this._streaming || (this._decoder = new UTF8Decoder({ fatal: this._fatal }), this._BOMseen = !1), this._streaming = Boolean(t.stream);
    for (var c = new Stream(o), a = [], d; !c.endOfStream() && (d = this._decoder.handler(c, c.read()), d !== finished); )
      d !== null && (Array.isArray(d) ? a.push.apply(a, d) : a.push(d));
    if (!this._streaming) {
      do {
        if (d = this._decoder.handler(c, c.read()), d === finished)
          break;
        d !== null && (Array.isArray(d) ? a.push.apply(a, d) : a.push(d));
      } while (!c.endOfStream());
      this._decoder = null;
    }
    return a.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (a[0] === 65279 ? (this._BOMseen = !0, a.shift()) : this._BOMseen = !0), codePointsToString(a);
  }
};
function TextEncoder$1(n, e) {
  if (!(this instanceof TextEncoder$1))
    return new TextEncoder$1(n, e);
  if (n = n !== void 0 ? String(n).toLowerCase() : DEFAULT_ENCODING, n !== DEFAULT_ENCODING)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  e = ToDictionary(e), this._streaming = !1, this._encoder = null, this._options = { fatal: Boolean(e.fatal) }, Object.defineProperty(this, "encoding", { value: "utf-8" });
}
TextEncoder$1.prototype = {
  encode: function(e, t) {
    e = e ? String(e) : "", t = ToDictionary(t), this._streaming || (this._encoder = new UTF8Encoder(this._options)), this._streaming = Boolean(t.stream);
    for (var o = [], c = new Stream(stringToCodePoints(e)), a; !c.endOfStream() && (a = this._encoder.handler(c, c.read()), a !== finished); )
      Array.isArray(a) ? o.push.apply(o, a) : o.push(a);
    if (!this._streaming) {
      for (; a = this._encoder.handler(c, c.read()), a !== finished; )
        Array.isArray(a) ? o.push.apply(o, a) : o.push(a);
      this._encoder = null;
    }
    return new Uint8Array(o);
  }
};
function UTF8Decoder(n) {
  var e = n.fatal, t = 0, o = 0, c = 0, a = 128, d = 191;
  this.handler = function(p, w) {
    if (w === end_of_stream && c !== 0)
      return c = 0, decoderError(e);
    if (w === end_of_stream)
      return finished;
    if (c === 0) {
      if (inRange(w, 0, 127))
        return w;
      if (inRange(w, 194, 223))
        c = 1, t = w - 192;
      else if (inRange(w, 224, 239))
        w === 224 && (a = 160), w === 237 && (d = 159), c = 2, t = w - 224;
      else if (inRange(w, 240, 244))
        w === 240 && (a = 144), w === 244 && (d = 143), c = 3, t = w - 240;
      else
        return decoderError(e);
      return t = t << 6 * c, null;
    }
    if (!inRange(w, a, d))
      return t = c = o = 0, a = 128, d = 191, p.prepend(w), decoderError(e);
    if (a = 128, d = 191, o += 1, t += w - 128 << 6 * (c - o), o !== c)
      return null;
    var M = t;
    return t = c = o = 0, M;
  };
}
function UTF8Encoder(n) {
  n.fatal, this.handler = function(e, t) {
    if (t === end_of_stream)
      return finished;
    if (inRange(t, 0, 127))
      return t;
    var o, c;
    inRange(t, 128, 2047) ? (o = 1, c = 192) : inRange(t, 2048, 65535) ? (o = 2, c = 224) : inRange(t, 65536, 1114111) && (o = 3, c = 240);
    for (var a = [(t >> 6 * o) + c]; o > 0; ) {
      var d = t >> 6 * (o - 1);
      a.push(128 | d & 63), o -= 1;
    }
    return a;
  };
}
const encoding$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TextEncoder: TextEncoder$1,
  TextDecoder: TextDecoder$1
}, Symbol.toStringTag, { value: "Module" })), require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(encoding$1);
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(n, e, t, o) {
  o === void 0 && (o = t), Object.defineProperty(n, o, { enumerable: !0, get: function() {
    return e[t];
  } });
} : function(n, e, t, o) {
  o === void 0 && (o = t), n[o] = e[t];
}), __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(n, e) {
  Object.defineProperty(n, "default", { enumerable: !0, value: e });
} : function(n, e) {
  n.default = e;
}), __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(n, e, t, o) {
  var c = arguments.length, a = c < 3 ? e : o === null ? o = Object.getOwnPropertyDescriptor(e, t) : o, d;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    a = Reflect.decorate(n, e, t, o);
  else
    for (var p = n.length - 1; p >= 0; p--)
      (d = n[p]) && (a = (c < 3 ? d(a) : c > 3 ? d(e, t, a) : d(e, t)) || a);
  return c > 3 && a && Object.defineProperty(e, t, a), a;
}, __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      t !== "default" && Object.hasOwnProperty.call(n, t) && __createBinding$1(e, n, t);
  return __setModuleDefault$1(e, n), e;
}, __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(lib$4, "__esModule", { value: !0 });
var deserializeUnchecked_1 = lib$4.deserializeUnchecked = deserialize_1 = lib$4.deserialize = serialize_1 = lib$4.serialize = lib$4.BinaryReader = lib$4.BinaryWriter = lib$4.BorshError = lib$4.baseDecode = lib$4.baseEncode = void 0;
const bn_js_1$2 = __importDefault$3(bn$5.exports), bs58_1 = __importDefault$3(bs58), encoding = __importStar$1(require$$2$2), ResolvedTextDecoder = typeof TextDecoder != "function" ? encoding.TextDecoder : TextDecoder, textDecoder = new ResolvedTextDecoder("utf-8", { fatal: !0 });
function baseEncode(n) {
  return typeof n == "string" && (n = Buffer.from(n, "utf8")), bs58_1.default.encode(Buffer.from(n));
}
lib$4.baseEncode = baseEncode;
function baseDecode(n) {
  return Buffer.from(bs58_1.default.decode(n));
}
lib$4.baseDecode = baseDecode;
const INITIAL_LENGTH = 1024;
class BorshError extends Error {
  constructor(e) {
    super(e), this.fieldPath = [], this.originalMessage = e;
  }
  addToFieldPath(e) {
    this.fieldPath.splice(0, 0, e), this.message = this.originalMessage + ": " + this.fieldPath.join(".");
  }
}
lib$4.BorshError = BorshError;
class BinaryWriter {
  constructor() {
    this.buf = Buffer.alloc(INITIAL_LENGTH), this.length = 0;
  }
  maybeResize() {
    this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]));
  }
  writeU8(e) {
    this.maybeResize(), this.buf.writeUInt8(e, this.length), this.length += 1;
  }
  writeU16(e) {
    this.maybeResize(), this.buf.writeUInt16LE(e, this.length), this.length += 2;
  }
  writeU32(e) {
    this.maybeResize(), this.buf.writeUInt32LE(e, this.length), this.length += 4;
  }
  writeU64(e) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$2.default(e).toArray("le", 8)));
  }
  writeU128(e) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$2.default(e).toArray("le", 16)));
  }
  writeU256(e) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$2.default(e).toArray("le", 32)));
  }
  writeU512(e) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$2.default(e).toArray("le", 64)));
  }
  writeBuffer(e) {
    this.buf = Buffer.concat([
      Buffer.from(this.buf.subarray(0, this.length)),
      e,
      Buffer.alloc(INITIAL_LENGTH)
    ]), this.length += e.length;
  }
  writeString(e) {
    this.maybeResize();
    const t = Buffer.from(e, "utf8");
    this.writeU32(t.length), this.writeBuffer(t);
  }
  writeFixedArray(e) {
    this.writeBuffer(Buffer.from(e));
  }
  writeArray(e, t) {
    this.maybeResize(), this.writeU32(e.length);
    for (const o of e)
      this.maybeResize(), t(o);
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
lib$4.BinaryWriter = BinaryWriter;
function handlingRangeError(n, e, t) {
  const o = t.value;
  t.value = function(...c) {
    try {
      return o.apply(this, c);
    } catch (a) {
      if (a instanceof RangeError) {
        const d = a.code;
        if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(d) >= 0)
          throw new BorshError("Reached the end of buffer when deserializing");
      }
      throw a;
    }
  };
}
class BinaryReader {
  constructor(e) {
    this.buf = e, this.offset = 0;
  }
  readU8() {
    const e = this.buf.readUInt8(this.offset);
    return this.offset += 1, e;
  }
  readU16() {
    const e = this.buf.readUInt16LE(this.offset);
    return this.offset += 2, e;
  }
  readU32() {
    const e = this.buf.readUInt32LE(this.offset);
    return this.offset += 4, e;
  }
  readU64() {
    const e = this.readBuffer(8);
    return new bn_js_1$2.default(e, "le");
  }
  readU128() {
    const e = this.readBuffer(16);
    return new bn_js_1$2.default(e, "le");
  }
  readU256() {
    const e = this.readBuffer(32);
    return new bn_js_1$2.default(e, "le");
  }
  readU512() {
    const e = this.readBuffer(64);
    return new bn_js_1$2.default(e, "le");
  }
  readBuffer(e) {
    if (this.offset + e > this.buf.length)
      throw new BorshError(`Expected buffer length ${e} isn't within bounds`);
    const t = this.buf.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  readString() {
    const e = this.readU32(), t = this.readBuffer(e);
    try {
      return textDecoder.decode(t);
    } catch (o) {
      throw new BorshError(`Error decoding UTF-8 string: ${o}`);
    }
  }
  readFixedArray(e) {
    return new Uint8Array(this.readBuffer(e));
  }
  readArray(e) {
    const t = this.readU32(), o = Array();
    for (let c = 0; c < t; ++c)
      o.push(e());
    return o;
  }
}
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU8", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU16", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU32", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU64", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU128", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU256", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU512", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readString", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readFixedArray", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readArray", null);
lib$4.BinaryReader = BinaryReader;
function capitalizeFirstLetter(n) {
  return n.charAt(0).toUpperCase() + n.slice(1);
}
function serializeField(n, e, t, o, c) {
  try {
    if (typeof o == "string")
      c[`write${capitalizeFirstLetter(o)}`](t);
    else if (o instanceof Array)
      if (typeof o[0] == "number") {
        if (t.length !== o[0])
          throw new BorshError(`Expecting byte array of length ${o[0]}, but got ${t.length} bytes`);
        c.writeFixedArray(t);
      } else if (o.length === 2 && typeof o[1] == "number") {
        if (t.length !== o[1])
          throw new BorshError(`Expecting byte array of length ${o[1]}, but got ${t.length} bytes`);
        for (let a = 0; a < o[1]; a++)
          serializeField(n, null, t[a], o[0], c);
      } else
        c.writeArray(t, (a) => {
          serializeField(n, e, a, o[0], c);
        });
    else if (o.kind !== void 0)
      switch (o.kind) {
        case "option": {
          t == null ? c.writeU8(0) : (c.writeU8(1), serializeField(n, e, t, o.type, c));
          break;
        }
        case "map": {
          c.writeU32(t.size), t.forEach((a, d) => {
            serializeField(n, e, d, o.key, c), serializeField(n, e, a, o.value, c);
          });
          break;
        }
        default:
          throw new BorshError(`FieldType ${o} unrecognized`);
      }
    else
      serializeStruct(n, t, c);
  } catch (a) {
    throw a instanceof BorshError && a.addToFieldPath(e), a;
  }
}
function serializeStruct(n, e, t) {
  if (typeof e.borshSerialize == "function") {
    e.borshSerialize(t);
    return;
  }
  const o = n.get(e.constructor);
  if (!o)
    throw new BorshError(`Class ${e.constructor.name} is missing in schema`);
  if (o.kind === "struct")
    o.fields.map(([c, a]) => {
      serializeField(n, c, e[c], a, t);
    });
  else if (o.kind === "enum") {
    const c = e[o.field];
    for (let a = 0; a < o.values.length; ++a) {
      const [d, p] = o.values[a];
      if (d === c) {
        t.writeU8(a), serializeField(n, d, e[d], p, t);
        break;
      }
    }
  } else
    throw new BorshError(`Unexpected schema kind: ${o.kind} for ${e.constructor.name}`);
}
function serialize$1(n, e, t = BinaryWriter) {
  const o = new t();
  return serializeStruct(n, e, o), o.toArray();
}
var serialize_1 = lib$4.serialize = serialize$1;
function deserializeField(n, e, t, o) {
  try {
    if (typeof t == "string")
      return o[`read${capitalizeFirstLetter(t)}`]();
    if (t instanceof Array) {
      if (typeof t[0] == "number")
        return o.readFixedArray(t[0]);
      if (typeof t[1] == "number") {
        const c = [];
        for (let a = 0; a < t[1]; a++)
          c.push(deserializeField(n, null, t[0], o));
        return c;
      } else
        return o.readArray(() => deserializeField(n, e, t[0], o));
    }
    if (t.kind === "option")
      return o.readU8() ? deserializeField(n, e, t.type, o) : void 0;
    if (t.kind === "map") {
      let c = /* @__PURE__ */ new Map();
      const a = o.readU32();
      for (let d = 0; d < a; d++) {
        const p = deserializeField(n, e, t.key, o), w = deserializeField(n, e, t.value, o);
        c.set(p, w);
      }
      return c;
    }
    return deserializeStruct(n, t, o);
  } catch (c) {
    throw c instanceof BorshError && c.addToFieldPath(e), c;
  }
}
function deserializeStruct(n, e, t) {
  if (typeof e.borshDeserialize == "function")
    return e.borshDeserialize(t);
  const o = n.get(e);
  if (!o)
    throw new BorshError(`Class ${e.name} is missing in schema`);
  if (o.kind === "struct") {
    const c = {};
    for (const [a, d] of n.get(e).fields)
      c[a] = deserializeField(n, a, d, t);
    return new e(c);
  }
  if (o.kind === "enum") {
    const c = t.readU8();
    if (c >= o.values.length)
      throw new BorshError(`Enum index: ${c} is out of range`);
    const [a, d] = o.values[c], p = deserializeField(n, a, d, t);
    return new e({ [a]: p });
  }
  throw new BorshError(`Unexpected schema kind: ${o.kind} for ${e.constructor.name}`);
}
function deserialize(n, e, t, o = BinaryReader) {
  const c = new o(t), a = deserializeStruct(n, e, c);
  if (c.offset < t.length)
    throw new BorshError(`Unexpected ${t.length - c.offset} bytes after deserialized data`);
  return a;
}
var deserialize_1 = lib$4.deserialize = deserialize;
function deserializeUnchecked(n, e, t, o = BinaryReader) {
  const c = new o(t);
  return deserializeStruct(n, e, c);
}
deserializeUnchecked_1 = lib$4.deserializeUnchecked = deserializeUnchecked;
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.BinaryReader = n.BinaryWriter = n.BorshError = n.deserialize = n.serialize = n.base_decode = n.base_encode = void 0;
  var e = lib$4;
  Object.defineProperty(n, "base_encode", { enumerable: !0, get: function() {
    return e.baseEncode;
  } }), Object.defineProperty(n, "base_decode", { enumerable: !0, get: function() {
    return e.baseDecode;
  } }), Object.defineProperty(n, "serialize", { enumerable: !0, get: function() {
    return e.serialize;
  } }), Object.defineProperty(n, "deserialize", { enumerable: !0, get: function() {
    return e.deserialize;
  } }), Object.defineProperty(n, "BorshError", { enumerable: !0, get: function() {
    return e.BorshError;
  } }), Object.defineProperty(n, "BinaryWriter", { enumerable: !0, get: function() {
    return e.BinaryWriter;
  } }), Object.defineProperty(n, "BinaryReader", { enumerable: !0, get: function() {
    return e.BinaryReader;
  } });
})(serialize$2);
var enums = {};
Object.defineProperty(enums, "__esModule", { value: !0 });
enums.Assignable = enums.Enum = void 0;
class Enum$1 {
  constructor(e) {
    if (Object.keys(e).length !== 1)
      throw new Error("Enum can only take single value");
    Object.keys(e).map((t) => {
      this[t] = e[t], this.enum = t;
    });
  }
}
enums.Enum = Enum$1;
class Assignable {
  constructor(e) {
    Object.keys(e).map((t) => {
      this[t] = e[t];
    });
  }
}
enums.Assignable = Assignable;
(function(n) {
  var e = commonjsGlobal && commonjsGlobal.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), n.KeyPairEd25519 = n.KeyPair = n.PublicKey = n.KeyType = void 0;
  const t = e(naclFast.exports), o = serialize$2, c = enums;
  var a;
  (function(B) {
    B[B.ED25519 = 0] = "ED25519";
  })(a = n.KeyType || (n.KeyType = {}));
  function d(B) {
    switch (B) {
      case a.ED25519:
        return "ed25519";
      default:
        throw new Error(`Unknown key type ${B}`);
    }
  }
  function p(B) {
    switch (B.toLowerCase()) {
      case "ed25519":
        return a.ED25519;
      default:
        throw new Error(`Unknown key type ${B}`);
    }
  }
  class w extends c.Assignable {
    static from(H) {
      return typeof H == "string" ? w.fromString(H) : H;
    }
    static fromString(H) {
      const L = H.split(":");
      if (L.length === 1)
        return new w({ keyType: a.ED25519, data: (0, o.base_decode)(L[0]) });
      if (L.length === 2)
        return new w({ keyType: p(L[0]), data: (0, o.base_decode)(L[1]) });
      throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
    }
    toString() {
      return `${d(this.keyType)}:${(0, o.base_encode)(this.data)}`;
    }
    verify(H, L) {
      switch (this.keyType) {
        case a.ED25519:
          return t.default.sign.detached.verify(H, L, this.data);
        default:
          throw new Error(`Unknown key type ${this.keyType}`);
      }
    }
  }
  n.PublicKey = w;
  class M {
    static fromRandom(H) {
      switch (H.toUpperCase()) {
        case "ED25519":
          return I.fromRandom();
        default:
          throw new Error(`Unknown curve ${H}`);
      }
    }
    static fromString(H) {
      const L = H.split(":");
      if (L.length === 1)
        return new I(L[0]);
      if (L.length === 2)
        switch (L[0].toUpperCase()) {
          case "ED25519":
            return new I(L[1]);
          default:
            throw new Error(`Unknown curve: ${L[0]}`);
        }
      else
        throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
    }
  }
  n.KeyPair = M;
  class I extends M {
    constructor(H) {
      super();
      const L = t.default.sign.keyPair.fromSecretKey((0, o.base_decode)(H));
      this.publicKey = new w({ keyType: a.ED25519, data: L.publicKey }), this.secretKey = H;
    }
    static fromRandom() {
      const H = t.default.sign.keyPair();
      return new I((0, o.base_encode)(H.secretKey));
    }
    sign(H) {
      return { signature: t.default.sign.detached(H, (0, o.base_decode)(this.secretKey)), publicKey: this.publicKey };
    }
    verify(H, L) {
      return this.publicKey.verify(H, L);
    }
    toString() {
      return `ed25519:${this.secretKey}`;
    }
    getPublicKey() {
      return this.publicKey;
    }
  }
  n.KeyPairEd25519 = I;
})(key_pair);
var __awaiter$d = commonjsGlobal && commonjsGlobal.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
Object.defineProperty(in_memory_key_store, "__esModule", { value: !0 });
in_memory_key_store.InMemoryKeyStore = void 0;
const keystore_1$2 = keystore, key_pair_1$2 = key_pair;
class InMemoryKeyStore extends keystore_1$2.KeyStore {
  constructor() {
    super(), this.keys = {};
  }
  setKey(e, t, o) {
    return __awaiter$d(this, void 0, void 0, function* () {
      this.keys[`${t}:${e}`] = o.toString();
    });
  }
  getKey(e, t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      const o = this.keys[`${t}:${e}`];
      return o ? key_pair_1$2.KeyPair.fromString(o) : null;
    });
  }
  removeKey(e, t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      delete this.keys[`${t}:${e}`];
    });
  }
  clear() {
    return __awaiter$d(this, void 0, void 0, function* () {
      this.keys = {};
    });
  }
  getNetworks() {
    return __awaiter$d(this, void 0, void 0, function* () {
      const e = /* @__PURE__ */ new Set();
      return Object.keys(this.keys).forEach((t) => {
        const o = t.split(":");
        e.add(o[1]);
      }), Array.from(e.values());
    });
  }
  getAccounts(e) {
    return __awaiter$d(this, void 0, void 0, function* () {
      const t = new Array();
      return Object.keys(this.keys).forEach((o) => {
        const c = o.split(":");
        c[c.length - 1] === e && t.push(c.slice(0, c.length - 1).join(":"));
      }), t;
    });
  }
  toString() {
    return "InMemoryKeyStore";
  }
}
in_memory_key_store.InMemoryKeyStore = InMemoryKeyStore;
var browser_local_storage_key_store = {}, __awaiter$c = commonjsGlobal && commonjsGlobal.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
Object.defineProperty(browser_local_storage_key_store, "__esModule", { value: !0 });
browser_local_storage_key_store.BrowserLocalStorageKeyStore = void 0;
const keystore_1$1 = keystore, key_pair_1$1 = key_pair, LOCAL_STORAGE_KEY_PREFIX = "near-api-js:keystore:";
class BrowserLocalStorageKeyStore extends keystore_1$1.KeyStore {
  constructor(e = window.localStorage, t = LOCAL_STORAGE_KEY_PREFIX) {
    super(), this.localStorage = e, this.prefix = t;
  }
  setKey(e, t, o) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this.localStorage.setItem(this.storageKeyForSecretKey(e, t), o.toString());
    });
  }
  getKey(e, t) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const o = this.localStorage.getItem(this.storageKeyForSecretKey(e, t));
      return o ? key_pair_1$1.KeyPair.fromString(o) : null;
    });
  }
  removeKey(e, t) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this.localStorage.removeItem(this.storageKeyForSecretKey(e, t));
    });
  }
  clear() {
    return __awaiter$c(this, void 0, void 0, function* () {
      for (const e of this.storageKeys())
        e.startsWith(this.prefix) && this.localStorage.removeItem(e);
    });
  }
  getNetworks() {
    return __awaiter$c(this, void 0, void 0, function* () {
      const e = /* @__PURE__ */ new Set();
      for (const t of this.storageKeys())
        if (t.startsWith(this.prefix)) {
          const o = t.substring(this.prefix.length).split(":");
          e.add(o[1]);
        }
      return Array.from(e.values());
    });
  }
  getAccounts(e) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const t = new Array();
      for (const o of this.storageKeys())
        if (o.startsWith(this.prefix)) {
          const c = o.substring(this.prefix.length).split(":");
          c[1] === e && t.push(c[0]);
        }
      return t;
    });
  }
  storageKeyForSecretKey(e, t) {
    return `${this.prefix}${t}:${e}`;
  }
  *storageKeys() {
    for (let e = 0; e < this.localStorage.length; e++)
      yield this.localStorage.key(e);
  }
}
browser_local_storage_key_store.BrowserLocalStorageKeyStore = BrowserLocalStorageKeyStore;
var merge_key_store = {}, __awaiter$b = commonjsGlobal && commonjsGlobal.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
Object.defineProperty(merge_key_store, "__esModule", { value: !0 });
merge_key_store.MergeKeyStore = void 0;
const keystore_1 = keystore;
class MergeKeyStore extends keystore_1.KeyStore {
  constructor(e, t = { writeKeyStoreIndex: 0 }) {
    super(), this.options = t, this.keyStores = e;
  }
  setKey(e, t, o) {
    return __awaiter$b(this, void 0, void 0, function* () {
      yield this.keyStores[this.options.writeKeyStoreIndex].setKey(e, t, o);
    });
  }
  getKey(e, t) {
    return __awaiter$b(this, void 0, void 0, function* () {
      for (const o of this.keyStores) {
        const c = yield o.getKey(e, t);
        if (c)
          return c;
      }
      return null;
    });
  }
  removeKey(e, t) {
    return __awaiter$b(this, void 0, void 0, function* () {
      for (const o of this.keyStores)
        yield o.removeKey(e, t);
    });
  }
  clear() {
    return __awaiter$b(this, void 0, void 0, function* () {
      for (const e of this.keyStores)
        yield e.clear();
    });
  }
  getNetworks() {
    return __awaiter$b(this, void 0, void 0, function* () {
      const e = /* @__PURE__ */ new Set();
      for (const t of this.keyStores)
        for (const o of yield t.getNetworks())
          e.add(o);
      return Array.from(e);
    });
  }
  getAccounts(e) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const t = /* @__PURE__ */ new Set();
      for (const o of this.keyStores)
        for (const c of yield o.getAccounts(e))
          t.add(c);
      return Array.from(t);
    });
  }
  toString() {
    return `MergeKeyStore(${this.keyStores.join(", ")})`;
  }
}
merge_key_store.MergeKeyStore = MergeKeyStore;
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.MergeKeyStore = n.BrowserLocalStorageKeyStore = n.InMemoryKeyStore = n.KeyStore = void 0;
  const e = keystore;
  Object.defineProperty(n, "KeyStore", { enumerable: !0, get: function() {
    return e.KeyStore;
  } });
  const t = in_memory_key_store;
  Object.defineProperty(n, "InMemoryKeyStore", { enumerable: !0, get: function() {
    return t.InMemoryKeyStore;
  } });
  const o = browser_local_storage_key_store;
  Object.defineProperty(n, "BrowserLocalStorageKeyStore", { enumerable: !0, get: function() {
    return o.BrowserLocalStorageKeyStore;
  } });
  const c = merge_key_store;
  Object.defineProperty(n, "MergeKeyStore", { enumerable: !0, get: function() {
    return c.MergeKeyStore;
  } });
})(browserIndex);
var commonIndex = {}, providers = {}, provider$1 = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.getTransactionLastResult = n.Provider = n.IdType = n.FinalExecutionStatusBasic = n.ExecutionStatusBasic = void 0, function(o) {
    o.Unknown = "Unknown", o.Pending = "Pending", o.Failure = "Failure";
  }(n.ExecutionStatusBasic || (n.ExecutionStatusBasic = {})), function(o) {
    o.NotStarted = "NotStarted", o.Started = "Started", o.Failure = "Failure";
  }(n.FinalExecutionStatusBasic || (n.FinalExecutionStatusBasic = {})), function(o) {
    o.Transaction = "transaction", o.Receipt = "receipt";
  }(n.IdType || (n.IdType = {}));
  class e {
  }
  n.Provider = e;
  function t(o) {
    if (typeof o.status == "object" && typeof o.status.SuccessValue == "string") {
      const c = Buffer.from(o.status.SuccessValue, "base64").toString();
      try {
        return JSON.parse(c);
      } catch {
        return c;
      }
    }
    return null;
  }
  n.getTransactionLastResult = t;
})(provider$1);
var jsonRpcProvider = {}, web = {}, httpErrors = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var browser$3 = depd$1;
function depd$1(n) {
  if (!n)
    throw new TypeError("argument namespace is required");
  function e(t) {
  }
  return e._file = void 0, e._ignored = !0, e._namespace = n, e._traced = !1, e._warned = /* @__PURE__ */ Object.create(null), e.function = wrapfunction$1, e.property = wrapproperty$1, e;
}
function wrapfunction$1(n, e) {
  if (typeof n != "function")
    throw new TypeError("argument fn must be a function");
  return n;
}
function wrapproperty$1(n, e, t) {
  if (!n || typeof n != "object" && typeof n != "function")
    throw new TypeError("argument obj must be object");
  var o = Object.getOwnPropertyDescriptor(n, e);
  if (!o)
    throw new TypeError("must call property on owner object");
  if (!o.configurable)
    throw new TypeError("property must be configurable");
}
var setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(n, e) {
  return n.__proto__ = e, n;
}
function mixinProperties(n, e) {
  for (var t in e)
    Object.prototype.hasOwnProperty.call(n, t) || (n[t] = e[t]);
  return n;
}
const require$$0$2 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  306: "(Unused)",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Unordered Collection",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var codes = require$$0$2, statuses = status;
status.STATUS_CODES = codes;
status.codes = populateStatusesMap(status, codes);
status.redirect = {
  300: !0,
  301: !0,
  302: !0,
  303: !0,
  305: !0,
  307: !0,
  308: !0
};
status.empty = {
  204: !0,
  205: !0,
  304: !0
};
status.retry = {
  502: !0,
  503: !0,
  504: !0
};
function populateStatusesMap(n, e) {
  var t = [];
  return Object.keys(e).forEach(function(c) {
    var a = e[c], d = Number(c);
    n[d] = a, n[a] = d, n[a.toLowerCase()] = d, t.push(d);
  }), t;
}
function status(n) {
  if (typeof n == "number") {
    if (!status[n])
      throw new Error("invalid status code: " + n);
    return n;
  }
  if (typeof n != "string")
    throw new TypeError("code must be a number or string");
  var e = parseInt(n, 10);
  if (!isNaN(e)) {
    if (!status[e])
      throw new Error("invalid status code: " + e);
    return e;
  }
  if (e = status[n.toLowerCase()], !e)
    throw new Error('invalid status message: "' + n + '"');
  return e;
}
var inherits_browser$1 = { exports: {} };
typeof Object.create == "function" ? inherits_browser$1.exports = function(e, t) {
  t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser$1.exports = function(e, t) {
  if (t) {
    e.super_ = t;
    var o = function() {
    };
    o.prototype = t.prototype, e.prototype = new o(), e.prototype.constructor = e;
  }
};
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier = toIdentifier;
function toIdentifier(n) {
  return n.split(" ").map(function(e) {
    return e.slice(0, 1).toUpperCase() + e.slice(1);
  }).join("").replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(n) {
  var e = browser$3("http-errors"), t = setprototypeof, o = statuses, c = inherits_browser$1.exports, a = toidentifier;
  n.exports = p, n.exports.HttpError = w(), n.exports.isHttpError = I(n.exports.HttpError), L(n.exports, o.codes, n.exports.HttpError);
  function d($) {
    return Number(String($).charAt(0) + "00");
  }
  function p() {
    for (var $, P, U = 500, G = {}, D = 0; D < arguments.length; D++) {
      var Z = arguments[D];
      if (Z instanceof Error) {
        $ = Z, U = $.status || $.statusCode || U;
        continue;
      }
      switch (typeof Z) {
        case "string":
          P = Z;
          break;
        case "number":
          U = Z;
          break;
        case "object":
          G = Z;
          break;
      }
    }
    (typeof U != "number" || !o[U] && (U < 400 || U >= 600)) && (U = 500);
    var J = p[U] || p[d(U)];
    $ || ($ = J ? new J(P) : new Error(P || o[U]), Error.captureStackTrace($, p)), (!J || !($ instanceof J) || $.status !== U) && ($.expose = U < 500, $.status = $.statusCode = U);
    for (var te in G)
      te !== "status" && te !== "statusCode" && ($[te] = G[te]);
    return $;
  }
  function w() {
    function $() {
      throw new TypeError("cannot construct abstract class");
    }
    return c($, Error), $;
  }
  function M($, P, U) {
    var G = W(P);
    function D(Z) {
      var J = Z != null ? Z : o[U], te = new Error(J);
      return Error.captureStackTrace(te, D), t(te, D.prototype), Object.defineProperty(te, "message", {
        enumerable: !0,
        configurable: !0,
        value: J,
        writable: !0
      }), Object.defineProperty(te, "name", {
        enumerable: !1,
        configurable: !0,
        value: G,
        writable: !0
      }), te;
    }
    return c(D, $), H(D, G), D.prototype.status = U, D.prototype.statusCode = U, D.prototype.expose = !0, D;
  }
  function I($) {
    return function(U) {
      return !U || typeof U != "object" ? !1 : U instanceof $ ? !0 : U instanceof Error && typeof U.expose == "boolean" && typeof U.statusCode == "number" && U.status === U.statusCode;
    };
  }
  function B($, P, U) {
    var G = W(P);
    function D(Z) {
      var J = Z != null ? Z : o[U], te = new Error(J);
      return Error.captureStackTrace(te, D), t(te, D.prototype), Object.defineProperty(te, "message", {
        enumerable: !0,
        configurable: !0,
        value: J,
        writable: !0
      }), Object.defineProperty(te, "name", {
        enumerable: !1,
        configurable: !0,
        value: G,
        writable: !0
      }), te;
    }
    return c(D, $), H(D, G), D.prototype.status = U, D.prototype.statusCode = U, D.prototype.expose = !1, D;
  }
  function H($, P) {
    var U = Object.getOwnPropertyDescriptor($, "name");
    U && U.configurable && (U.value = P, Object.defineProperty($, "name", U));
  }
  function L($, P, U) {
    P.forEach(function(D) {
      var Z, J = a(o[D]);
      switch (d(D)) {
        case 400:
          Z = M(U, J, D);
          break;
        case 500:
          Z = B(U, J, D);
          break;
      }
      Z && ($[D] = Z, $[J] = Z);
    }), $["I'mateapot"] = e.function(
      $.ImATeapot,
      `"I'mateapot"; use "ImATeapot" instead`
    );
  }
  function W($) {
    return $.substr(-5) !== "Error" ? $ + "Error" : $;
  }
})(httpErrors);
var exponentialBackoff$1 = {}, __awaiter$a = commonjsGlobal && commonjsGlobal.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
Object.defineProperty(exponentialBackoff$1, "__esModule", { value: !0 });
function exponentialBackoff(n, e, t, o) {
  return __awaiter$a(this, void 0, void 0, function* () {
    let c = n;
    for (let a = 0; a < e; a++) {
      const d = yield o();
      if (d)
        return d;
      yield sleep$1(c), c *= t;
    }
    return null;
  });
}
exponentialBackoff$1.default = exponentialBackoff;
function sleep$1(n) {
  return new Promise((e) => setTimeout(e, n));
}
var errors = {};
Object.defineProperty(errors, "__esModule", { value: !0 });
errors.logWarning = errors.ErrorContext = errors.TypedError = errors.ArgumentTypeError = errors.PositionalArgsError = void 0;
class PositionalArgsError extends Error {
  constructor() {
    super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
  }
}
errors.PositionalArgsError = PositionalArgsError;
class ArgumentTypeError extends Error {
  constructor(e, t, o) {
    super(`Expected ${t} for '${e}' argument, but got '${JSON.stringify(o)}'`);
  }
}
errors.ArgumentTypeError = ArgumentTypeError;
class TypedError extends Error {
  constructor(e, t, o) {
    super(e), this.type = t || "UntypedError", this.context = o;
  }
}
errors.TypedError = TypedError;
class ErrorContext {
  constructor(e) {
    this.transactionHash = e;
  }
}
errors.ErrorContext = ErrorContext;
function logWarning(...n) {
  process.env.NEAR_NO_LOGS || console.warn(...n);
}
errors.logWarning = logWarning;
var hasRequiredWeb;
function requireWeb() {
  if (hasRequiredWeb)
    return web;
  hasRequiredWeb = 1;
  var n = commonjsGlobal && commonjsGlobal.__awaiter || function(I, B, H, L) {
    function W($) {
      return $ instanceof H ? $ : new H(function(P) {
        P($);
      });
    }
    return new (H || (H = Promise))(function($, P) {
      function U(Z) {
        try {
          D(L.next(Z));
        } catch (J) {
          P(J);
        }
      }
      function G(Z) {
        try {
          D(L.throw(Z));
        } catch (J) {
          P(J);
        }
      }
      function D(Z) {
        Z.done ? $(Z.value) : W(Z.value).then(U, G);
      }
      D((L = L.apply(I, B || [])).next());
    });
  }, e = commonjsGlobal && commonjsGlobal.__importDefault || function(I) {
    return I && I.__esModule ? I : { default: I };
  };
  Object.defineProperty(web, "__esModule", { value: !0 }), web.fetchJson = void 0;
  const t = e(httpErrors.exports), o = e(exponentialBackoff$1), c = requireProviders(), a = errors, d = 1e3, p = 1.5, w = 10;
  function M(I, B) {
    return n(this, void 0, void 0, function* () {
      let H = { url: null };
      typeof I == "string" ? H.url = I : H = I;
      const L = yield (0, o.default)(d, w, p, () => n(this, void 0, void 0, function* () {
        try {
          const W = yield fetch(H.url, {
            method: B ? "POST" : "GET",
            body: B || void 0,
            headers: Object.assign(Object.assign({}, H.headers), { "Content-Type": "application/json" })
          });
          if (!W.ok) {
            if (W.status === 503)
              return (0, a.logWarning)(`Retrying HTTP request for ${H.url} as it's not available now`), null;
            throw (0, t.default)(W.status, yield W.text());
          }
          return W;
        } catch (W) {
          if (W.toString().includes("FetchError") || W.toString().includes("Failed to fetch"))
            return (0, a.logWarning)(`Retrying HTTP request for ${H.url} because of error: ${W}`), null;
          throw W;
        }
      }));
      if (!L)
        throw new c.TypedError(`Exceeded ${w} attempts for ${H.url}.`, "RetriesExceeded");
      return yield L.json();
    });
  }
  return web.fetchJson = M, web;
}
var rpc_errors = {}, mustache = { exports: {} };
(function(n, e) {
  (function(t, o) {
    n.exports = o();
  })(commonjsGlobal, function() {
    /*!
     * mustache.js - Logic-less {{mustache}} templates with JavaScript
     * http://github.com/janl/mustache.js
     */
    var t = Object.prototype.toString, o = Array.isArray || function(x) {
      return t.call(x) === "[object Array]";
    };
    function c(V) {
      return typeof V == "function";
    }
    function a(V) {
      return o(V) ? "array" : typeof V;
    }
    function d(V) {
      return V.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function p(V, x) {
      return V != null && typeof V == "object" && x in V;
    }
    function w(V, x) {
      return V != null && typeof V != "object" && V.hasOwnProperty && V.hasOwnProperty(x);
    }
    var M = RegExp.prototype.test;
    function I(V, x) {
      return M.call(V, x);
    }
    var B = /\S/;
    function H(V) {
      return !I(B, V);
    }
    var L = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    function W(V) {
      return String(V).replace(/[&<>"'`=\/]/g, function(u) {
        return L[u];
      });
    }
    var $ = /\s*/, P = /\s+/, U = /\s*=/, G = /\s*\}/, D = /#|\^|\/|>|\{|&|=|!/;
    function Z(V, x) {
      if (!V)
        return [];
      var u = !1, h = [], g = [], y = [], m = !1, _ = !1, R = "", b = 0;
      function l() {
        if (m && !_)
          for (; y.length; )
            delete g[y.pop()];
        else
          y = [];
        m = !1, _ = !1;
      }
      var v, X, S;
      function Y(j) {
        if (typeof j == "string" && (j = j.split(P, 2)), !o(j) || j.length !== 2)
          throw new Error("Invalid tags: " + j);
        v = new RegExp(d(j[0]) + "\\s*"), X = new RegExp("\\s*" + d(j[1])), S = new RegExp("\\s*" + d("}" + j[1]));
      }
      Y(x || C.tags);
      for (var fe = new ue(V), oe, de, Ie, ye, be, rt; !fe.eos(); ) {
        if (oe = fe.pos, Ie = fe.scanUntil(v), Ie)
          for (var xe = 0, Ne = Ie.length; xe < Ne; ++xe)
            ye = Ie.charAt(xe), H(ye) ? (y.push(g.length), R += ye) : (_ = !0, u = !0, R += " "), g.push(["text", ye, oe, oe + 1]), oe += 1, ye === `
` && (l(), R = "", b = 0, u = !1);
        if (!fe.scan(v))
          break;
        if (m = !0, de = fe.scan(D) || "name", fe.scan($), de === "=" ? (Ie = fe.scanUntil(U), fe.scan(U), fe.scanUntil(X)) : de === "{" ? (Ie = fe.scanUntil(S), fe.scan(G), fe.scanUntil(X), de = "&") : Ie = fe.scanUntil(X), !fe.scan(X))
          throw new Error("Unclosed tag at " + fe.pos);
        if (de == ">" ? be = [de, Ie, oe, fe.pos, R, b, u] : be = [de, Ie, oe, fe.pos], b++, g.push(be), de === "#" || de === "^")
          h.push(be);
        else if (de === "/") {
          if (rt = h.pop(), !rt)
            throw new Error('Unopened section "' + Ie + '" at ' + oe);
          if (rt[1] !== Ie)
            throw new Error('Unclosed section "' + rt[1] + '" at ' + oe);
        } else
          de === "name" || de === "{" || de === "&" ? _ = !0 : de === "=" && Y(Ie);
      }
      if (l(), rt = h.pop(), rt)
        throw new Error('Unclosed section "' + rt[1] + '" at ' + fe.pos);
      return te(J(g));
    }
    function J(V) {
      for (var x = [], u, h, g = 0, y = V.length; g < y; ++g)
        u = V[g], u && (u[0] === "text" && h && h[0] === "text" ? (h[1] += u[1], h[3] = u[3]) : (x.push(u), h = u));
      return x;
    }
    function te(V) {
      for (var x = [], u = x, h = [], g, y, m = 0, _ = V.length; m < _; ++m)
        switch (g = V[m], g[0]) {
          case "#":
          case "^":
            u.push(g), h.push(g), u = g[4] = [];
            break;
          case "/":
            y = h.pop(), y[5] = g[2], u = h.length > 0 ? h[h.length - 1][4] : x;
            break;
          default:
            u.push(g);
        }
      return x;
    }
    function ue(V) {
      this.string = V, this.tail = V, this.pos = 0;
    }
    ue.prototype.eos = function() {
      return this.tail === "";
    }, ue.prototype.scan = function(x) {
      var u = this.tail.match(x);
      if (!u || u.index !== 0)
        return "";
      var h = u[0];
      return this.tail = this.tail.substring(h.length), this.pos += h.length, h;
    }, ue.prototype.scanUntil = function(x) {
      var u = this.tail.search(x), h;
      switch (u) {
        case -1:
          h = this.tail, this.tail = "";
          break;
        case 0:
          h = "";
          break;
        default:
          h = this.tail.substring(0, u), this.tail = this.tail.substring(u);
      }
      return this.pos += h.length, h;
    };
    function he(V, x) {
      this.view = V, this.cache = { ".": this.view }, this.parent = x;
    }
    he.prototype.push = function(x) {
      return new he(x, this);
    }, he.prototype.lookup = function(x) {
      var u = this.cache, h;
      if (u.hasOwnProperty(x))
        h = u[x];
      else {
        for (var g = this, y, m, _, R = !1; g; ) {
          if (x.indexOf(".") > 0)
            for (y = g.view, m = x.split("."), _ = 0; y != null && _ < m.length; )
              _ === m.length - 1 && (R = p(y, m[_]) || w(y, m[_])), y = y[m[_++]];
          else
            y = g.view[x], R = p(g.view, x);
          if (R) {
            h = y;
            break;
          }
          g = g.parent;
        }
        u[x] = h;
      }
      return c(h) && (h = h.call(this.view)), h;
    };
    function Se() {
      this.templateCache = {
        _cache: {},
        set: function(x, u) {
          this._cache[x] = u;
        },
        get: function(x) {
          return this._cache[x];
        },
        clear: function() {
          this._cache = {};
        }
      };
    }
    Se.prototype.clearCache = function() {
      typeof this.templateCache < "u" && this.templateCache.clear();
    }, Se.prototype.parse = function(x, u) {
      var h = this.templateCache, g = x + ":" + (u || C.tags).join(":"), y = typeof h < "u", m = y ? h.get(g) : void 0;
      return m == null && (m = Z(x, u), y && h.set(g, m)), m;
    }, Se.prototype.render = function(x, u, h, g) {
      var y = this.getConfigTags(g), m = this.parse(x, y), _ = u instanceof he ? u : new he(u, void 0);
      return this.renderTokens(m, _, h, x, g);
    }, Se.prototype.renderTokens = function(x, u, h, g, y) {
      for (var m = "", _, R, b, l = 0, v = x.length; l < v; ++l)
        b = void 0, _ = x[l], R = _[0], R === "#" ? b = this.renderSection(_, u, h, g, y) : R === "^" ? b = this.renderInverted(_, u, h, g, y) : R === ">" ? b = this.renderPartial(_, u, h, y) : R === "&" ? b = this.unescapedValue(_, u) : R === "name" ? b = this.escapedValue(_, u, y) : R === "text" && (b = this.rawValue(_)), b !== void 0 && (m += b);
      return m;
    }, Se.prototype.renderSection = function(x, u, h, g, y) {
      var m = this, _ = "", R = u.lookup(x[1]);
      function b(X) {
        return m.render(X, u, h, y);
      }
      if (!!R) {
        if (o(R))
          for (var l = 0, v = R.length; l < v; ++l)
            _ += this.renderTokens(x[4], u.push(R[l]), h, g, y);
        else if (typeof R == "object" || typeof R == "string" || typeof R == "number")
          _ += this.renderTokens(x[4], u.push(R), h, g, y);
        else if (c(R)) {
          if (typeof g != "string")
            throw new Error("Cannot use higher-order sections without the original template");
          R = R.call(u.view, g.slice(x[3], x[5]), b), R != null && (_ += R);
        } else
          _ += this.renderTokens(x[4], u, h, g, y);
        return _;
      }
    }, Se.prototype.renderInverted = function(x, u, h, g, y) {
      var m = u.lookup(x[1]);
      if (!m || o(m) && m.length === 0)
        return this.renderTokens(x[4], u, h, g, y);
    }, Se.prototype.indentPartial = function(x, u, h) {
      for (var g = u.replace(/[^ \t]/g, ""), y = x.split(`
`), m = 0; m < y.length; m++)
        y[m].length && (m > 0 || !h) && (y[m] = g + y[m]);
      return y.join(`
`);
    }, Se.prototype.renderPartial = function(x, u, h, g) {
      if (!!h) {
        var y = this.getConfigTags(g), m = c(h) ? h(x[1]) : h[x[1]];
        if (m != null) {
          var _ = x[6], R = x[5], b = x[4], l = m;
          R == 0 && b && (l = this.indentPartial(m, b, _));
          var v = this.parse(l, y);
          return this.renderTokens(v, u, h, l, g);
        }
      }
    }, Se.prototype.unescapedValue = function(x, u) {
      var h = u.lookup(x[1]);
      if (h != null)
        return h;
    }, Se.prototype.escapedValue = function(x, u, h) {
      var g = this.getConfigEscape(h) || C.escape, y = u.lookup(x[1]);
      if (y != null)
        return typeof y == "number" && g === C.escape ? String(y) : g(y);
    }, Se.prototype.rawValue = function(x) {
      return x[1];
    }, Se.prototype.getConfigTags = function(x) {
      return o(x) ? x : x && typeof x == "object" ? x.tags : void 0;
    }, Se.prototype.getConfigEscape = function(x) {
      if (x && typeof x == "object" && !o(x))
        return x.escape;
    };
    var C = {
      name: "mustache.js",
      version: "4.2.0",
      tags: ["{{", "}}"],
      clearCache: void 0,
      escape: void 0,
      parse: void 0,
      render: void 0,
      Scanner: void 0,
      Context: void 0,
      Writer: void 0,
      set templateCache(V) {
        O.templateCache = V;
      },
      get templateCache() {
        return O.templateCache;
      }
    }, O = new Se();
    return C.clearCache = function() {
      return O.clearCache();
    }, C.parse = function(x, u) {
      return O.parse(x, u);
    }, C.render = function(x, u, h, g) {
      if (typeof x != "string")
        throw new TypeError('Invalid template! Template should be a "string" but "' + a(x) + '" was given as the first argument for mustache#render(template, view, partials)');
      return O.render(x, u, h, g);
    }, C.escape = W, C.Scanner = ue, C.Context = he, C.Writer = Se, C;
  });
})(mustache);
const schema = {
  BadUTF16: {
    name: "BadUTF16",
    subtypes: [],
    props: {}
  },
  BadUTF8: {
    name: "BadUTF8",
    subtypes: [],
    props: {}
  },
  BalanceExceeded: {
    name: "BalanceExceeded",
    subtypes: [],
    props: {}
  },
  BreakpointTrap: {
    name: "BreakpointTrap",
    subtypes: [],
    props: {}
  },
  CacheError: {
    name: "CacheError",
    subtypes: [
      "ReadError",
      "WriteError",
      "DeserializationError",
      "SerializationError"
    ],
    props: {}
  },
  CallIndirectOOB: {
    name: "CallIndirectOOB",
    subtypes: [],
    props: {}
  },
  CannotAppendActionToJointPromise: {
    name: "CannotAppendActionToJointPromise",
    subtypes: [],
    props: {}
  },
  CannotReturnJointPromise: {
    name: "CannotReturnJointPromise",
    subtypes: [],
    props: {}
  },
  CodeDoesNotExist: {
    name: "CodeDoesNotExist",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  CompilationError: {
    name: "CompilationError",
    subtypes: [
      "CodeDoesNotExist",
      "PrepareError",
      "WasmerCompileError"
    ],
    props: {}
  },
  ContractSizeExceeded: {
    name: "ContractSizeExceeded",
    subtypes: [],
    props: {
      limit: "",
      size: ""
    }
  },
  Deprecated: {
    name: "Deprecated",
    subtypes: [],
    props: {
      method_name: ""
    }
  },
  Deserialization: {
    name: "Deserialization",
    subtypes: [],
    props: {}
  },
  DeserializationError: {
    name: "DeserializationError",
    subtypes: [],
    props: {}
  },
  EmptyMethodName: {
    name: "EmptyMethodName",
    subtypes: [],
    props: {}
  },
  FunctionCallError: {
    name: "FunctionCallError",
    subtypes: [
      "CompilationError",
      "LinkError",
      "MethodResolveError",
      "WasmTrap",
      "WasmUnknownError",
      "HostError",
      "EvmError"
    ],
    props: {}
  },
  GasExceeded: {
    name: "GasExceeded",
    subtypes: [],
    props: {}
  },
  GasInstrumentation: {
    name: "GasInstrumentation",
    subtypes: [],
    props: {}
  },
  GasLimitExceeded: {
    name: "GasLimitExceeded",
    subtypes: [],
    props: {}
  },
  GenericTrap: {
    name: "GenericTrap",
    subtypes: [],
    props: {}
  },
  GuestPanic: {
    name: "GuestPanic",
    subtypes: [],
    props: {
      panic_msg: ""
    }
  },
  HostError: {
    name: "HostError",
    subtypes: [
      "BadUTF16",
      "BadUTF8",
      "GasExceeded",
      "GasLimitExceeded",
      "BalanceExceeded",
      "EmptyMethodName",
      "GuestPanic",
      "IntegerOverflow",
      "InvalidPromiseIndex",
      "CannotAppendActionToJointPromise",
      "CannotReturnJointPromise",
      "InvalidPromiseResultIndex",
      "InvalidRegisterId",
      "IteratorWasInvalidated",
      "MemoryAccessViolation",
      "InvalidReceiptIndex",
      "InvalidIteratorIndex",
      "InvalidAccountId",
      "InvalidMethodName",
      "InvalidPublicKey",
      "ProhibitedInView",
      "NumberOfLogsExceeded",
      "KeyLengthExceeded",
      "ValueLengthExceeded",
      "TotalLogLengthExceeded",
      "NumberPromisesExceeded",
      "NumberInputDataDependenciesExceeded",
      "ReturnedValueLengthExceeded",
      "ContractSizeExceeded",
      "Deprecated"
    ],
    props: {}
  },
  IllegalArithmetic: {
    name: "IllegalArithmetic",
    subtypes: [],
    props: {}
  },
  IncorrectCallIndirectSignature: {
    name: "IncorrectCallIndirectSignature",
    subtypes: [],
    props: {}
  },
  Instantiate: {
    name: "Instantiate",
    subtypes: [],
    props: {}
  },
  IntegerOverflow: {
    name: "IntegerOverflow",
    subtypes: [],
    props: {}
  },
  InternalMemoryDeclared: {
    name: "InternalMemoryDeclared",
    subtypes: [],
    props: {}
  },
  InvalidAccountId: {
    name: "InvalidAccountId",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  InvalidIteratorIndex: {
    name: "InvalidIteratorIndex",
    subtypes: [],
    props: {
      iterator_index: ""
    }
  },
  InvalidMethodName: {
    name: "InvalidMethodName",
    subtypes: [],
    props: {}
  },
  InvalidPromiseIndex: {
    name: "InvalidPromiseIndex",
    subtypes: [],
    props: {
      promise_idx: ""
    }
  },
  InvalidPromiseResultIndex: {
    name: "InvalidPromiseResultIndex",
    subtypes: [],
    props: {
      result_idx: ""
    }
  },
  InvalidPublicKey: {
    name: "InvalidPublicKey",
    subtypes: [],
    props: {}
  },
  InvalidReceiptIndex: {
    name: "InvalidReceiptIndex",
    subtypes: [],
    props: {
      receipt_index: ""
    }
  },
  InvalidRegisterId: {
    name: "InvalidRegisterId",
    subtypes: [],
    props: {
      register_id: ""
    }
  },
  IteratorWasInvalidated: {
    name: "IteratorWasInvalidated",
    subtypes: [],
    props: {
      iterator_index: ""
    }
  },
  KeyLengthExceeded: {
    name: "KeyLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  LinkError: {
    name: "LinkError",
    subtypes: [],
    props: {
      msg: ""
    }
  },
  Memory: {
    name: "Memory",
    subtypes: [],
    props: {}
  },
  MemoryAccessViolation: {
    name: "MemoryAccessViolation",
    subtypes: [],
    props: {}
  },
  MemoryOutOfBounds: {
    name: "MemoryOutOfBounds",
    subtypes: [],
    props: {}
  },
  MethodEmptyName: {
    name: "MethodEmptyName",
    subtypes: [],
    props: {}
  },
  MethodInvalidSignature: {
    name: "MethodInvalidSignature",
    subtypes: [],
    props: {}
  },
  MethodNotFound: {
    name: "MethodNotFound",
    subtypes: [],
    props: {}
  },
  MethodResolveError: {
    name: "MethodResolveError",
    subtypes: [
      "MethodEmptyName",
      "MethodUTF8Error",
      "MethodNotFound",
      "MethodInvalidSignature"
    ],
    props: {}
  },
  MethodUTF8Error: {
    name: "MethodUTF8Error",
    subtypes: [],
    props: {}
  },
  MisalignedAtomicAccess: {
    name: "MisalignedAtomicAccess",
    subtypes: [],
    props: {}
  },
  NumberInputDataDependenciesExceeded: {
    name: "NumberInputDataDependenciesExceeded",
    subtypes: [],
    props: {
      limit: "",
      number_of_input_data_dependencies: ""
    }
  },
  NumberOfLogsExceeded: {
    name: "NumberOfLogsExceeded",
    subtypes: [],
    props: {
      limit: ""
    }
  },
  NumberPromisesExceeded: {
    name: "NumberPromisesExceeded",
    subtypes: [],
    props: {
      limit: "",
      number_of_promises: ""
    }
  },
  PrepareError: {
    name: "PrepareError",
    subtypes: [
      "Serialization",
      "Deserialization",
      "InternalMemoryDeclared",
      "GasInstrumentation",
      "StackHeightInstrumentation",
      "Instantiate",
      "Memory"
    ],
    props: {}
  },
  ProhibitedInView: {
    name: "ProhibitedInView",
    subtypes: [],
    props: {
      method_name: ""
    }
  },
  ReadError: {
    name: "ReadError",
    subtypes: [],
    props: {}
  },
  ReturnedValueLengthExceeded: {
    name: "ReturnedValueLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  Serialization: {
    name: "Serialization",
    subtypes: [],
    props: {}
  },
  SerializationError: {
    name: "SerializationError",
    subtypes: [],
    props: {
      hash: ""
    }
  },
  StackHeightInstrumentation: {
    name: "StackHeightInstrumentation",
    subtypes: [],
    props: {}
  },
  StackOverflow: {
    name: "StackOverflow",
    subtypes: [],
    props: {}
  },
  TotalLogLengthExceeded: {
    name: "TotalLogLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  Unreachable: {
    name: "Unreachable",
    subtypes: [],
    props: {}
  },
  ValueLengthExceeded: {
    name: "ValueLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  WasmTrap: {
    name: "WasmTrap",
    subtypes: [
      "Unreachable",
      "IncorrectCallIndirectSignature",
      "MemoryOutOfBounds",
      "CallIndirectOOB",
      "IllegalArithmetic",
      "MisalignedAtomicAccess",
      "BreakpointTrap",
      "StackOverflow",
      "GenericTrap"
    ],
    props: {}
  },
  WasmUnknownError: {
    name: "WasmUnknownError",
    subtypes: [],
    props: {}
  },
  WasmerCompileError: {
    name: "WasmerCompileError",
    subtypes: [],
    props: {
      msg: ""
    }
  },
  WriteError: {
    name: "WriteError",
    subtypes: [],
    props: {}
  },
  AccessKeyNotFound: {
    name: "AccessKeyNotFound",
    subtypes: [],
    props: {
      account_id: "",
      public_key: ""
    }
  },
  AccountAlreadyExists: {
    name: "AccountAlreadyExists",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  AccountDoesNotExist: {
    name: "AccountDoesNotExist",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  ActionError: {
    name: "ActionError",
    subtypes: [
      "AccountAlreadyExists",
      "AccountDoesNotExist",
      "CreateAccountOnlyByRegistrar",
      "CreateAccountNotAllowed",
      "ActorNoPermission",
      "DeleteKeyDoesNotExist",
      "AddKeyAlreadyExists",
      "DeleteAccountStaking",
      "LackBalanceForState",
      "TriesToUnstake",
      "TriesToStake",
      "InsufficientStake",
      "FunctionCallError",
      "NewReceiptValidationError",
      "OnlyImplicitAccountCreationAllowed"
    ],
    props: {
      index: ""
    }
  },
  ActionsValidationError: {
    name: "ActionsValidationError",
    subtypes: [
      "DeleteActionMustBeFinal",
      "TotalPrepaidGasExceeded",
      "TotalNumberOfActionsExceeded",
      "AddKeyMethodNamesNumberOfBytesExceeded",
      "AddKeyMethodNameLengthExceeded",
      "IntegerOverflow",
      "InvalidAccountId",
      "ContractSizeExceeded",
      "FunctionCallMethodNameLengthExceeded",
      "FunctionCallArgumentsLengthExceeded",
      "UnsuitableStakingKey",
      "FunctionCallZeroAttachedGas"
    ],
    props: {}
  },
  ActorNoPermission: {
    name: "ActorNoPermission",
    subtypes: [],
    props: {
      account_id: "",
      actor_id: ""
    }
  },
  AddKeyAlreadyExists: {
    name: "AddKeyAlreadyExists",
    subtypes: [],
    props: {
      account_id: "",
      public_key: ""
    }
  },
  AddKeyMethodNameLengthExceeded: {
    name: "AddKeyMethodNameLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  AddKeyMethodNamesNumberOfBytesExceeded: {
    name: "AddKeyMethodNamesNumberOfBytesExceeded",
    subtypes: [],
    props: {
      limit: "",
      total_number_of_bytes: ""
    }
  },
  BalanceMismatchError: {
    name: "BalanceMismatchError",
    subtypes: [],
    props: {
      final_accounts_balance: "",
      final_postponed_receipts_balance: "",
      incoming_receipts_balance: "",
      incoming_validator_rewards: "",
      initial_accounts_balance: "",
      initial_postponed_receipts_balance: "",
      new_delayed_receipts_balance: "",
      other_burnt_amount: "",
      outgoing_receipts_balance: "",
      processed_delayed_receipts_balance: "",
      slashed_burnt_amount: "",
      tx_burnt_amount: ""
    }
  },
  CostOverflow: {
    name: "CostOverflow",
    subtypes: [],
    props: {}
  },
  CreateAccountNotAllowed: {
    name: "CreateAccountNotAllowed",
    subtypes: [],
    props: {
      account_id: "",
      predecessor_id: ""
    }
  },
  CreateAccountOnlyByRegistrar: {
    name: "CreateAccountOnlyByRegistrar",
    subtypes: [],
    props: {
      account_id: "",
      predecessor_id: "",
      registrar_account_id: ""
    }
  },
  DeleteAccountStaking: {
    name: "DeleteAccountStaking",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  DeleteActionMustBeFinal: {
    name: "DeleteActionMustBeFinal",
    subtypes: [],
    props: {}
  },
  DeleteKeyDoesNotExist: {
    name: "DeleteKeyDoesNotExist",
    subtypes: [],
    props: {
      account_id: "",
      public_key: ""
    }
  },
  DepositWithFunctionCall: {
    name: "DepositWithFunctionCall",
    subtypes: [],
    props: {}
  },
  Expired: {
    name: "Expired",
    subtypes: [],
    props: {}
  },
  FunctionCallArgumentsLengthExceeded: {
    name: "FunctionCallArgumentsLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  FunctionCallMethodNameLengthExceeded: {
    name: "FunctionCallMethodNameLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  FunctionCallZeroAttachedGas: {
    name: "FunctionCallZeroAttachedGas",
    subtypes: [],
    props: {}
  },
  InsufficientStake: {
    name: "InsufficientStake",
    subtypes: [],
    props: {
      account_id: "",
      minimum_stake: "",
      stake: ""
    }
  },
  InvalidAccessKeyError: {
    name: "InvalidAccessKeyError",
    subtypes: [
      "AccessKeyNotFound",
      "ReceiverMismatch",
      "MethodNameMismatch",
      "RequiresFullAccess",
      "NotEnoughAllowance",
      "DepositWithFunctionCall"
    ],
    props: {}
  },
  InvalidChain: {
    name: "InvalidChain",
    subtypes: [],
    props: {}
  },
  InvalidDataReceiverId: {
    name: "InvalidDataReceiverId",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  InvalidNonce: {
    name: "InvalidNonce",
    subtypes: [],
    props: {
      ak_nonce: "",
      tx_nonce: ""
    }
  },
  InvalidPredecessorId: {
    name: "InvalidPredecessorId",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  InvalidReceiverId: {
    name: "InvalidReceiverId",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  InvalidSignature: {
    name: "InvalidSignature",
    subtypes: [],
    props: {}
  },
  InvalidSignerId: {
    name: "InvalidSignerId",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  InvalidTxError: {
    name: "InvalidTxError",
    subtypes: [
      "InvalidAccessKeyError",
      "InvalidSignerId",
      "SignerDoesNotExist",
      "InvalidNonce",
      "InvalidReceiverId",
      "InvalidSignature",
      "NotEnoughBalance",
      "LackBalanceForState",
      "CostOverflow",
      "InvalidChain",
      "Expired",
      "ActionsValidation"
    ],
    props: {}
  },
  LackBalanceForState: {
    name: "LackBalanceForState",
    subtypes: [],
    props: {
      account_id: "",
      amount: ""
    }
  },
  MethodNameMismatch: {
    name: "MethodNameMismatch",
    subtypes: [],
    props: {
      method_name: ""
    }
  },
  NotEnoughAllowance: {
    name: "NotEnoughAllowance",
    subtypes: [],
    props: {
      account_id: "",
      allowance: "",
      cost: "",
      public_key: ""
    }
  },
  NotEnoughBalance: {
    name: "NotEnoughBalance",
    subtypes: [],
    props: {
      balance: "",
      cost: "",
      signer_id: ""
    }
  },
  OnlyImplicitAccountCreationAllowed: {
    name: "OnlyImplicitAccountCreationAllowed",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  ReceiptValidationError: {
    name: "ReceiptValidationError",
    subtypes: [
      "InvalidPredecessorId",
      "InvalidReceiverId",
      "InvalidSignerId",
      "InvalidDataReceiverId",
      "ReturnedValueLengthExceeded",
      "NumberInputDataDependenciesExceeded",
      "ActionsValidation"
    ],
    props: {}
  },
  ReceiverMismatch: {
    name: "ReceiverMismatch",
    subtypes: [],
    props: {
      ak_receiver: "",
      tx_receiver: ""
    }
  },
  RequiresFullAccess: {
    name: "RequiresFullAccess",
    subtypes: [],
    props: {}
  },
  SignerDoesNotExist: {
    name: "SignerDoesNotExist",
    subtypes: [],
    props: {
      signer_id: ""
    }
  },
  TotalNumberOfActionsExceeded: {
    name: "TotalNumberOfActionsExceeded",
    subtypes: [],
    props: {
      limit: "",
      total_number_of_actions: ""
    }
  },
  TotalPrepaidGasExceeded: {
    name: "TotalPrepaidGasExceeded",
    subtypes: [],
    props: {
      limit: "",
      total_prepaid_gas: ""
    }
  },
  TriesToStake: {
    name: "TriesToStake",
    subtypes: [],
    props: {
      account_id: "",
      balance: "",
      locked: "",
      stake: ""
    }
  },
  TriesToUnstake: {
    name: "TriesToUnstake",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  TxExecutionError: {
    name: "TxExecutionError",
    subtypes: [
      "ActionError",
      "InvalidTxError"
    ],
    props: {}
  },
  UnsuitableStakingKey: {
    name: "UnsuitableStakingKey",
    subtypes: [],
    props: {
      public_key: ""
    }
  },
  Closed: {
    name: "Closed",
    subtypes: [],
    props: {}
  },
  InternalError: {
    name: "InternalError",
    subtypes: [],
    props: {}
  },
  ServerError: {
    name: "ServerError",
    subtypes: [
      "TxExecutionError",
      "Timeout",
      "Closed",
      "InternalError"
    ],
    props: {}
  },
  Timeout: {
    name: "Timeout",
    subtypes: [],
    props: {}
  }
}, require$$1$2 = {
  schema
}, GasLimitExceeded = "Exceeded the maximum amount of gas allowed to burn per contract", MethodEmptyName = "Method name is empty", WasmerCompileError = "Wasmer compilation error: {{msg}}", GuestPanic = "Smart contract panicked: {{panic_msg}}", Memory = "Error creating Wasm memory", GasExceeded = "Exceeded the prepaid gas", MethodUTF8Error = "Method name is not valid UTF8 string", BadUTF16 = "String encoding is bad UTF-16 sequence", WasmTrap = "WebAssembly trap: {{msg}}", GasInstrumentation = "Gas instrumentation failed or contract has denied instructions.", InvalidPromiseIndex = "{{promise_idx}} does not correspond to existing promises", InvalidPromiseResultIndex = "Accessed invalid promise result index: {{result_idx}}", Deserialization = "Error happened while deserializing the module", MethodNotFound = "Contract method is not found", InvalidRegisterId = "Accessed invalid register id: {{register_id}}", InvalidReceiptIndex = "VM Logic returned an invalid receipt index: {{receipt_index}}", EmptyMethodName = "Method name is empty in contract call", CannotReturnJointPromise = "Returning joint promise is currently prohibited", StackHeightInstrumentation = "Stack instrumentation failed", CodeDoesNotExist = "Cannot find contract code for account {{account_id}}", MethodInvalidSignature = "Invalid method signature", IntegerOverflow = "Integer overflow happened during contract execution", MemoryAccessViolation = "MemoryAccessViolation", InvalidIteratorIndex = "Iterator index {{iterator_index}} does not exist", IteratorWasInvalidated = "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie", InvalidAccountId = "VM Logic returned an invalid account id", Serialization = "Error happened while serializing the module", CannotAppendActionToJointPromise = "Actions can only be appended to non-joint promise.", InternalMemoryDeclared = "Internal memory declaration has been found in the module", Instantiate = "Error happened during instantiation", ProhibitedInView = "{{method_name}} is not allowed in view calls", InvalidMethodName = "VM Logic returned an invalid method name", BadUTF8 = "String encoding is bad UTF-8 sequence", BalanceExceeded = "Exceeded the account balance", LinkError = "Wasm contract link error: {{msg}}", InvalidPublicKey = "VM Logic provided an invalid public key", ActorNoPermission = "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action", LackBalanceForState = "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more", ReceiverMismatch = "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.", CostOverflow = "Transaction gas or balance cost is too high", InvalidSignature = "Transaction is not signed with the given public key", AccessKeyNotFound = `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`, NotEnoughBalance = "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}", NotEnoughAllowance = "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}", Expired = "Transaction has expired", DeleteAccountStaking = "Account {{account_id}} is staking and can not be deleted", SignerDoesNotExist = "Signer {{signer_id}} does not exist", TriesToStake = "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}", AddKeyAlreadyExists = "The public key {{public_key}} is already used for an existing access key", InvalidSigner = "Invalid signer account ID {{signer_id}} according to requirements", CreateAccountNotAllowed = "The new account_id {{account_id}} can't be created by {{predecessor_id}}", RequiresFullAccess = "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key", TriesToUnstake = "Account {{account_id}} is not yet staked, but tried to unstake", InvalidNonce = "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}", AccountAlreadyExists = "Can't create a new account {{account_id}}, because it already exists", InvalidChain = "Transaction parent block hash doesn't belong to the current chain", AccountDoesNotExist = "Can't complete the action because account {{account_id}} doesn't exist", MethodNameMismatch = "Transaction method name {{method_name}} isn't allowed by the access key", DeleteAccountHasRent = "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent", DeleteAccountHasEnoughBalance = "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage", InvalidReceiver = "Invalid receiver account ID {{receiver_id}} according to requirements", DeleteKeyDoesNotExist = "Account {{account_id}} tries to remove an access key that doesn't exist", Timeout = "Timeout exceeded", Closed = "Connection closed", require$$2$1 = {
  GasLimitExceeded,
  MethodEmptyName,
  WasmerCompileError,
  GuestPanic,
  Memory,
  GasExceeded,
  MethodUTF8Error,
  BadUTF16,
  WasmTrap,
  GasInstrumentation,
  InvalidPromiseIndex,
  InvalidPromiseResultIndex,
  Deserialization,
  MethodNotFound,
  InvalidRegisterId,
  InvalidReceiptIndex,
  EmptyMethodName,
  CannotReturnJointPromise,
  StackHeightInstrumentation,
  CodeDoesNotExist,
  MethodInvalidSignature,
  IntegerOverflow,
  MemoryAccessViolation,
  InvalidIteratorIndex,
  IteratorWasInvalidated,
  InvalidAccountId,
  Serialization,
  CannotAppendActionToJointPromise,
  InternalMemoryDeclared,
  Instantiate,
  ProhibitedInView,
  InvalidMethodName,
  BadUTF8,
  BalanceExceeded,
  LinkError,
  InvalidPublicKey,
  ActorNoPermission,
  LackBalanceForState,
  ReceiverMismatch,
  CostOverflow,
  InvalidSignature,
  AccessKeyNotFound,
  NotEnoughBalance,
  NotEnoughAllowance,
  Expired,
  DeleteAccountStaking,
  SignerDoesNotExist,
  TriesToStake,
  AddKeyAlreadyExists,
  InvalidSigner,
  CreateAccountNotAllowed,
  RequiresFullAccess,
  TriesToUnstake,
  InvalidNonce,
  AccountAlreadyExists,
  InvalidChain,
  AccountDoesNotExist,
  MethodNameMismatch,
  DeleteAccountHasRent,
  DeleteAccountHasEnoughBalance,
  InvalidReceiver,
  DeleteKeyDoesNotExist,
  Timeout,
  Closed
};
var hasRequiredRpc_errors;
function requireRpc_errors() {
  if (hasRequiredRpc_errors)
    return rpc_errors;
  hasRequiredRpc_errors = 1;
  var n = commonjsGlobal && commonjsGlobal.__importDefault || function($) {
    return $ && $.__esModule ? $ : { default: $ };
  };
  Object.defineProperty(rpc_errors, "__esModule", { value: !0 }), rpc_errors.formatError = rpc_errors.parseResultError = rpc_errors.parseRpcError = rpc_errors.ServerError = void 0;
  const e = n(mustache.exports), t = n(require$$1$2), o = n(require$$2$1), c = requireCommonIndex(), a = errors, d = {
    formatNear: () => ($, P) => c.utils.format.formatNearAmount(P($))
  };
  class p extends a.TypedError {
  }
  rpc_errors.ServerError = p;
  class w extends p {
  }
  function M($) {
    const P = {}, U = H($, t.default.schema, P, ""), G = new p(B(U, P), U);
    return Object.assign(G, P), G;
  }
  rpc_errors.parseRpcError = M;
  function I($) {
    const P = M($.status.Failure), U = new w();
    return Object.assign(U, P), U.type = P.type, U.message = P.message, U.transaction_outcome = $.transaction_outcome, U;
  }
  rpc_errors.parseResultError = I;
  function B($, P) {
    return typeof o.default[$] == "string" ? e.default.render(o.default[$], Object.assign(Object.assign({}, P), d)) : JSON.stringify(P);
  }
  rpc_errors.formatError = B;
  function H($, P, U, G) {
    let D, Z, J;
    for (const te in P) {
      if (W($[te]))
        return $[te];
      if (L($[te]))
        D = $[te], Z = P[te], J = te;
      else if (L($.kind) && L($.kind[te]))
        D = $.kind[te], Z = P[te], J = te;
      else
        continue;
    }
    if (D && Z) {
      for (const te of Object.keys(Z.props))
        U[te] = D[te];
      return H(D, P, U, J);
    } else
      return U.kind = $, G;
  }
  function L($) {
    return Object.prototype.toString.call($) === "[object Object]";
  }
  function W($) {
    return Object.prototype.toString.call($) === "[object String]";
  }
  return rpc_errors;
}
var hasRequiredJsonRpcProvider;
function requireJsonRpcProvider() {
  return hasRequiredJsonRpcProvider || (hasRequiredJsonRpcProvider = 1, function(n) {
    var e = commonjsGlobal && commonjsGlobal.__awaiter || function($, P, U, G) {
      function D(Z) {
        return Z instanceof U ? Z : new U(function(J) {
          J(Z);
        });
      }
      return new (U || (U = Promise))(function(Z, J) {
        function te(Se) {
          try {
            he(G.next(Se));
          } catch (C) {
            J(C);
          }
        }
        function ue(Se) {
          try {
            he(G.throw(Se));
          } catch (C) {
            J(C);
          }
        }
        function he(Se) {
          Se.done ? Z(Se.value) : D(Se.value).then(te, ue);
        }
        he((G = G.apply($, P || [])).next());
      });
    }, t = commonjsGlobal && commonjsGlobal.__rest || function($, P) {
      var U = {};
      for (var G in $)
        Object.prototype.hasOwnProperty.call($, G) && P.indexOf(G) < 0 && (U[G] = $[G]);
      if ($ != null && typeof Object.getOwnPropertySymbols == "function")
        for (var D = 0, G = Object.getOwnPropertySymbols($); D < G.length; D++)
          P.indexOf(G[D]) < 0 && Object.prototype.propertyIsEnumerable.call($, G[D]) && (U[G[D]] = $[G[D]]);
      return U;
    }, o = commonjsGlobal && commonjsGlobal.__importDefault || function($) {
      return $ && $.__esModule ? $ : { default: $ };
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), n.JsonRpcProvider = n.ErrorContext = n.TypedError = void 0;
    const c = provider$1, a = requireWeb(), d = errors;
    Object.defineProperty(n, "TypedError", { enumerable: !0, get: function() {
      return d.TypedError;
    } }), Object.defineProperty(n, "ErrorContext", { enumerable: !0, get: function() {
      return d.ErrorContext;
    } });
    const p = lib$4, w = o(exponentialBackoff$1), M = requireRpc_errors(), I = 12, B = 500, H = 1.5;
    let L = 123;
    class W extends c.Provider {
      constructor(P) {
        super(), this.connection = P || { url: "" };
      }
      status() {
        return e(this, void 0, void 0, function* () {
          return this.sendJsonRpc("status", []);
        });
      }
      sendTransaction(P) {
        return e(this, void 0, void 0, function* () {
          const U = P.encode();
          return this.sendJsonRpc("broadcast_tx_commit", [Buffer.from(U).toString("base64")]);
        });
      }
      sendTransactionAsync(P) {
        return e(this, void 0, void 0, function* () {
          const U = P.encode();
          return this.sendJsonRpc("broadcast_tx_async", [Buffer.from(U).toString("base64")]);
        });
      }
      txStatus(P, U) {
        return e(this, void 0, void 0, function* () {
          return typeof P == "string" ? this.txStatusString(P, U) : this.txStatusUint8Array(P, U);
        });
      }
      txStatusUint8Array(P, U) {
        return e(this, void 0, void 0, function* () {
          return this.sendJsonRpc("tx", [(0, p.baseEncode)(P), U]);
        });
      }
      txStatusString(P, U) {
        return e(this, void 0, void 0, function* () {
          return this.sendJsonRpc("tx", [P, U]);
        });
      }
      txStatusReceipts(P, U) {
        return e(this, void 0, void 0, function* () {
          return typeof P == "string" ? this.sendJsonRpc("EXPERIMENTAL_tx_status", [P, U]) : this.sendJsonRpc("EXPERIMENTAL_tx_status", [(0, p.baseEncode)(P), U]);
        });
      }
      query(...P) {
        return e(this, void 0, void 0, function* () {
          let U;
          if (P.length === 1) {
            const G = P[0], { block_id: D, blockId: Z } = G, J = t(G, ["block_id", "blockId"]);
            U = yield this.sendJsonRpc("query", Object.assign(Object.assign({}, J), { block_id: D || Z }));
          } else {
            const [G, D] = P;
            U = yield this.sendJsonRpc("query", [G, D]);
          }
          if (U && U.error)
            throw new d.TypedError(`Querying failed: ${U.error}.
${JSON.stringify(U, null, 2)}`, U.error.name);
          return U;
        });
      }
      block(P) {
        return e(this, void 0, void 0, function* () {
          const { finality: U } = P, { blockId: G } = P;
          return this.sendJsonRpc("block", { block_id: G, finality: U });
        });
      }
      blockChanges(P) {
        return e(this, void 0, void 0, function* () {
          const { finality: U } = P, { blockId: G } = P;
          return this.sendJsonRpc("EXPERIMENTAL_changes_in_block", { block_id: G, finality: U });
        });
      }
      chunk(P) {
        return e(this, void 0, void 0, function* () {
          return this.sendJsonRpc("chunk", [P]);
        });
      }
      validators(P) {
        return e(this, void 0, void 0, function* () {
          return this.sendJsonRpc("validators", [P]);
        });
      }
      experimental_protocolConfig(P) {
        return e(this, void 0, void 0, function* () {
          const U = P, { blockId: G } = U, D = t(U, ["blockId"]);
          return yield this.sendJsonRpc("EXPERIMENTAL_protocol_config", Object.assign(Object.assign({}, D), { block_id: G }));
        });
      }
      lightClientProof(P) {
        return e(this, void 0, void 0, function* () {
          return yield this.sendJsonRpc("EXPERIMENTAL_light_client_proof", P);
        });
      }
      accessKeyChanges(P, U) {
        return e(this, void 0, void 0, function* () {
          const { finality: G } = U, { blockId: D } = U;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "all_access_key_changes",
            account_ids: P,
            block_id: D,
            finality: G
          });
        });
      }
      singleAccessKeyChanges(P, U) {
        return e(this, void 0, void 0, function* () {
          const { finality: G } = U, { blockId: D } = U;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "single_access_key_changes",
            keys: P,
            block_id: D,
            finality: G
          });
        });
      }
      accountChanges(P, U) {
        return e(this, void 0, void 0, function* () {
          const { finality: G } = U, { blockId: D } = U;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "account_changes",
            account_ids: P,
            block_id: D,
            finality: G
          });
        });
      }
      contractStateChanges(P, U, G = "") {
        return e(this, void 0, void 0, function* () {
          const { finality: D } = U, { blockId: Z } = U;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "data_changes",
            account_ids: P,
            key_prefix_base64: G,
            block_id: Z,
            finality: D
          });
        });
      }
      contractCodeChanges(P, U) {
        return e(this, void 0, void 0, function* () {
          const { finality: G } = U, { blockId: D } = U;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "contract_code_changes",
            account_ids: P,
            block_id: D,
            finality: G
          });
        });
      }
      gasPrice(P) {
        return e(this, void 0, void 0, function* () {
          return yield this.sendJsonRpc("gas_price", [P]);
        });
      }
      sendJsonRpc(P, U) {
        return e(this, void 0, void 0, function* () {
          const G = yield (0, w.default)(B, I, H, () => e(this, void 0, void 0, function* () {
            try {
              const Z = {
                method: P,
                params: U,
                id: L++,
                jsonrpc: "2.0"
              }, J = yield (0, a.fetchJson)(this.connection, JSON.stringify(Z));
              if (J.error) {
                if (typeof J.error.data == "object")
                  throw typeof J.error.data.error_message == "string" && typeof J.error.data.error_type == "string" ? new d.TypedError(J.error.data.error_message, J.error.data.error_type) : (0, M.parseRpcError)(J.error.data);
                {
                  const te = `[${J.error.code}] ${J.error.message}: ${J.error.data}`;
                  throw J.error.data === "Timeout" || te.includes("Timeout error") || te.includes("query has timed out") ? new d.TypedError(te, "TimeoutError") : new d.TypedError(te, J.error.name);
                }
              }
              return J;
            } catch (Z) {
              if (Z.type === "TimeoutError")
                return process.env.NEAR_NO_LOGS || console.warn(`Retrying request to ${P} as it has timed out`, U), null;
              throw Z;
            }
          })), { result: D } = G;
          if (typeof D > "u")
            throw new d.TypedError(`Exceeded ${I} attempts for request to ${P}.`, "RetriesExceeded");
          return D;
        });
      }
    }
    n.JsonRpcProvider = W;
  }(jsonRpcProvider)), jsonRpcProvider;
}
var hasRequiredProviders;
function requireProviders() {
  return hasRequiredProviders || (hasRequiredProviders = 1, function(n) {
    Object.defineProperty(n, "__esModule", { value: !0 }), n.ErrorContext = n.TypedError = n.getTransactionLastResult = n.FinalExecutionStatusBasic = n.JsonRpcProvider = n.Provider = void 0;
    const e = provider$1;
    Object.defineProperty(n, "Provider", { enumerable: !0, get: function() {
      return e.Provider;
    } }), Object.defineProperty(n, "getTransactionLastResult", { enumerable: !0, get: function() {
      return e.getTransactionLastResult;
    } }), Object.defineProperty(n, "FinalExecutionStatusBasic", { enumerable: !0, get: function() {
      return e.FinalExecutionStatusBasic;
    } });
    const t = requireJsonRpcProvider();
    Object.defineProperty(n, "JsonRpcProvider", { enumerable: !0, get: function() {
      return t.JsonRpcProvider;
    } }), Object.defineProperty(n, "TypedError", { enumerable: !0, get: function() {
      return t.TypedError;
    } }), Object.defineProperty(n, "ErrorContext", { enumerable: !0, get: function() {
      return t.ErrorContext;
    } });
  }(providers)), providers;
}
var utils$d = {}, format = {}, bn$4 = { exports: {} };
(function(n) {
  (function(e, t) {
    function o(x, u) {
      if (!x)
        throw new Error(u || "Assertion failed");
    }
    function c(x, u) {
      x.super_ = u;
      var h = function() {
      };
      h.prototype = u.prototype, x.prototype = new h(), x.prototype.constructor = x;
    }
    function a(x, u, h) {
      if (a.isBN(x))
        return x;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, x !== null && ((u === "le" || u === "be") && (h = u, u = 10), this._init(x || 0, u || 10, h || "be"));
    }
    typeof e == "object" ? e.exports = a : t.BN = a, a.BN = a, a.wordSize = 26;
    var d;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? d = window.Buffer : d = require$$0$3.Buffer;
    } catch {
    }
    a.isBN = function(u) {
      return u instanceof a ? !0 : u !== null && typeof u == "object" && u.constructor.wordSize === a.wordSize && Array.isArray(u.words);
    }, a.max = function(u, h) {
      return u.cmp(h) > 0 ? u : h;
    }, a.min = function(u, h) {
      return u.cmp(h) < 0 ? u : h;
    }, a.prototype._init = function(u, h, g) {
      if (typeof u == "number")
        return this._initNumber(u, h, g);
      if (typeof u == "object")
        return this._initArray(u, h, g);
      h === "hex" && (h = 16), o(h === (h | 0) && h >= 2 && h <= 36), u = u.toString().replace(/\s+/g, "");
      var y = 0;
      u[0] === "-" && (y++, this.negative = 1), y < u.length && (h === 16 ? this._parseHex(u, y, g) : (this._parseBase(u, h, y), g === "le" && this._initArray(this.toArray(), h, g)));
    }, a.prototype._initNumber = function(u, h, g) {
      u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [
        u & 67108863,
        u / 67108864 & 67108863
      ], this.length = 2) : (o(u < 9007199254740992), this.words = [
        u & 67108863,
        u / 67108864 & 67108863,
        1
      ], this.length = 3), g === "le" && this._initArray(this.toArray(), h, g);
    }, a.prototype._initArray = function(u, h, g) {
      if (o(typeof u.length == "number"), u.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var m, _, R = 0;
      if (g === "be")
        for (y = u.length - 1, m = 0; y >= 0; y -= 3)
          _ = u[y] | u[y - 1] << 8 | u[y - 2] << 16, this.words[m] |= _ << R & 67108863, this.words[m + 1] = _ >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, m++);
      else if (g === "le")
        for (y = 0, m = 0; y < u.length; y += 3)
          _ = u[y] | u[y + 1] << 8 | u[y + 2] << 16, this.words[m] |= _ << R & 67108863, this.words[m + 1] = _ >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, m++);
      return this._strip();
    };
    function p(x, u) {
      var h = x.charCodeAt(u);
      if (h >= 48 && h <= 57)
        return h - 48;
      if (h >= 65 && h <= 70)
        return h - 55;
      if (h >= 97 && h <= 102)
        return h - 87;
      o(!1, "Invalid character in " + x);
    }
    function w(x, u, h) {
      var g = p(x, h);
      return h - 1 >= u && (g |= p(x, h - 1) << 4), g;
    }
    a.prototype._parseHex = function(u, h, g) {
      this.length = Math.ceil((u.length - h) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var m = 0, _ = 0, R;
      if (g === "be")
        for (y = u.length - 1; y >= h; y -= 2)
          R = w(u, h, y) << m, this.words[_] |= R & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= R >>> 26) : m += 8;
      else {
        var b = u.length - h;
        for (y = b % 2 === 0 ? h + 1 : h; y < u.length; y += 2)
          R = w(u, h, y) << m, this.words[_] |= R & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= R >>> 26) : m += 8;
      }
      this._strip();
    };
    function M(x, u, h, g) {
      for (var y = 0, m = 0, _ = Math.min(x.length, h), R = u; R < _; R++) {
        var b = x.charCodeAt(R) - 48;
        y *= g, b >= 49 ? m = b - 49 + 10 : b >= 17 ? m = b - 17 + 10 : m = b, o(b >= 0 && m < g, "Invalid character"), y += m;
      }
      return y;
    }
    a.prototype._parseBase = function(u, h, g) {
      this.words = [0], this.length = 1;
      for (var y = 0, m = 1; m <= 67108863; m *= h)
        y++;
      y--, m = m / h | 0;
      for (var _ = u.length - g, R = _ % y, b = Math.min(_, _ - R) + g, l = 0, v = g; v < b; v += y)
        l = M(u, v, v + y, h), this.imuln(m), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      if (R !== 0) {
        var X = 1;
        for (l = M(u, v, u.length, h), v = 0; v < R; v++)
          X *= h;
        this.imuln(X), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      }
      this._strip();
    }, a.prototype.copy = function(u) {
      u.words = new Array(this.length);
      for (var h = 0; h < this.length; h++)
        u.words[h] = this.words[h];
      u.length = this.length, u.negative = this.negative, u.red = this.red;
    };
    function I(x, u) {
      x.words = u.words, x.length = u.length, x.negative = u.negative, x.red = u.red;
    }
    if (a.prototype._move = function(u) {
      I(u, this);
    }, a.prototype.clone = function() {
      var u = new a(null);
      return this.copy(u), u;
    }, a.prototype._expand = function(u) {
      for (; this.length < u; )
        this.words[this.length++] = 0;
      return this;
    }, a.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, a.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        a.prototype[Symbol.for("nodejs.util.inspect.custom")] = B;
      } catch {
        a.prototype.inspect = B;
      }
    else
      a.prototype.inspect = B;
    function B() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var H = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], L = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], W = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    a.prototype.toString = function(u, h) {
      u = u || 10, h = h | 0 || 1;
      var g;
      if (u === 16 || u === "hex") {
        g = "";
        for (var y = 0, m = 0, _ = 0; _ < this.length; _++) {
          var R = this.words[_], b = ((R << y | m) & 16777215).toString(16);
          m = R >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, _--), m !== 0 || _ !== this.length - 1 ? g = H[6 - b.length] + b + g : g = b + g;
        }
        for (m !== 0 && (g = m.toString(16) + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      if (u === (u | 0) && u >= 2 && u <= 36) {
        var l = L[u], v = W[u];
        g = "";
        var X = this.clone();
        for (X.negative = 0; !X.isZero(); ) {
          var S = X.modrn(v).toString(u);
          X = X.idivn(v), X.isZero() ? g = S + g : g = H[l - S.length] + S + g;
        }
        for (this.isZero() && (g = "0" + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      o(!1, "Base should be between 2 and 36");
    }, a.prototype.toNumber = function() {
      var u = this.words[0];
      return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
    }, a.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, d && (a.prototype.toBuffer = function(u, h) {
      return this.toArrayLike(d, u, h);
    }), a.prototype.toArray = function(u, h) {
      return this.toArrayLike(Array, u, h);
    };
    var $ = function(u, h) {
      return u.allocUnsafe ? u.allocUnsafe(h) : new u(h);
    };
    a.prototype.toArrayLike = function(u, h, g) {
      this._strip();
      var y = this.byteLength(), m = g || Math.max(1, y);
      o(y <= m, "byte array longer than desired length"), o(m > 0, "Requested array length <= 0");
      var _ = $(u, m), R = h === "le" ? "LE" : "BE";
      return this["_toArrayLike" + R](_, y), _;
    }, a.prototype._toArrayLikeLE = function(u, h) {
      for (var g = 0, y = 0, m = 0, _ = 0; m < this.length; m++) {
        var R = this.words[m] << _ | y;
        u[g++] = R & 255, g < u.length && (u[g++] = R >> 8 & 255), g < u.length && (u[g++] = R >> 16 & 255), _ === 6 ? (g < u.length && (u[g++] = R >> 24 & 255), y = 0, _ = 0) : (y = R >>> 24, _ += 2);
      }
      if (g < u.length)
        for (u[g++] = y; g < u.length; )
          u[g++] = 0;
    }, a.prototype._toArrayLikeBE = function(u, h) {
      for (var g = u.length - 1, y = 0, m = 0, _ = 0; m < this.length; m++) {
        var R = this.words[m] << _ | y;
        u[g--] = R & 255, g >= 0 && (u[g--] = R >> 8 & 255), g >= 0 && (u[g--] = R >> 16 & 255), _ === 6 ? (g >= 0 && (u[g--] = R >> 24 & 255), y = 0, _ = 0) : (y = R >>> 24, _ += 2);
      }
      if (g >= 0)
        for (u[g--] = y; g >= 0; )
          u[g--] = 0;
    }, Math.clz32 ? a.prototype._countBits = function(u) {
      return 32 - Math.clz32(u);
    } : a.prototype._countBits = function(u) {
      var h = u, g = 0;
      return h >= 4096 && (g += 13, h >>>= 13), h >= 64 && (g += 7, h >>>= 7), h >= 8 && (g += 4, h >>>= 4), h >= 2 && (g += 2, h >>>= 2), g + h;
    }, a.prototype._zeroBits = function(u) {
      if (u === 0)
        return 26;
      var h = u, g = 0;
      return (h & 8191) === 0 && (g += 13, h >>>= 13), (h & 127) === 0 && (g += 7, h >>>= 7), (h & 15) === 0 && (g += 4, h >>>= 4), (h & 3) === 0 && (g += 2, h >>>= 2), (h & 1) === 0 && g++, g;
    }, a.prototype.bitLength = function() {
      var u = this.words[this.length - 1], h = this._countBits(u);
      return (this.length - 1) * 26 + h;
    };
    function P(x) {
      for (var u = new Array(x.bitLength()), h = 0; h < u.length; h++) {
        var g = h / 26 | 0, y = h % 26;
        u[h] = x.words[g] >>> y & 1;
      }
      return u;
    }
    a.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var u = 0, h = 0; h < this.length; h++) {
        var g = this._zeroBits(this.words[h]);
        if (u += g, g !== 26)
          break;
      }
      return u;
    }, a.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, a.prototype.toTwos = function(u) {
      return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
    }, a.prototype.fromTwos = function(u) {
      return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
    }, a.prototype.isNeg = function() {
      return this.negative !== 0;
    }, a.prototype.neg = function() {
      return this.clone().ineg();
    }, a.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, a.prototype.iuor = function(u) {
      for (; this.length < u.length; )
        this.words[this.length++] = 0;
      for (var h = 0; h < u.length; h++)
        this.words[h] = this.words[h] | u.words[h];
      return this._strip();
    }, a.prototype.ior = function(u) {
      return o((this.negative | u.negative) === 0), this.iuor(u);
    }, a.prototype.or = function(u) {
      return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
    }, a.prototype.uor = function(u) {
      return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
    }, a.prototype.iuand = function(u) {
      var h;
      this.length > u.length ? h = u : h = this;
      for (var g = 0; g < h.length; g++)
        this.words[g] = this.words[g] & u.words[g];
      return this.length = h.length, this._strip();
    }, a.prototype.iand = function(u) {
      return o((this.negative | u.negative) === 0), this.iuand(u);
    }, a.prototype.and = function(u) {
      return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
    }, a.prototype.uand = function(u) {
      return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
    }, a.prototype.iuxor = function(u) {
      var h, g;
      this.length > u.length ? (h = this, g = u) : (h = u, g = this);
      for (var y = 0; y < g.length; y++)
        this.words[y] = h.words[y] ^ g.words[y];
      if (this !== h)
        for (; y < h.length; y++)
          this.words[y] = h.words[y];
      return this.length = h.length, this._strip();
    }, a.prototype.ixor = function(u) {
      return o((this.negative | u.negative) === 0), this.iuxor(u);
    }, a.prototype.xor = function(u) {
      return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
    }, a.prototype.uxor = function(u) {
      return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
    }, a.prototype.inotn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = Math.ceil(u / 26) | 0, g = u % 26;
      this._expand(h), g > 0 && h--;
      for (var y = 0; y < h; y++)
        this.words[y] = ~this.words[y] & 67108863;
      return g > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - g), this._strip();
    }, a.prototype.notn = function(u) {
      return this.clone().inotn(u);
    }, a.prototype.setn = function(u, h) {
      o(typeof u == "number" && u >= 0);
      var g = u / 26 | 0, y = u % 26;
      return this._expand(g + 1), h ? this.words[g] = this.words[g] | 1 << y : this.words[g] = this.words[g] & ~(1 << y), this._strip();
    }, a.prototype.iadd = function(u) {
      var h;
      if (this.negative !== 0 && u.negative === 0)
        return this.negative = 0, h = this.isub(u), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && u.negative !== 0)
        return u.negative = 0, h = this.isub(u), u.negative = 1, h._normSign();
      var g, y;
      this.length > u.length ? (g = this, y = u) : (g = u, y = this);
      for (var m = 0, _ = 0; _ < y.length; _++)
        h = (g.words[_] | 0) + (y.words[_] | 0) + m, this.words[_] = h & 67108863, m = h >>> 26;
      for (; m !== 0 && _ < g.length; _++)
        h = (g.words[_] | 0) + m, this.words[_] = h & 67108863, m = h >>> 26;
      if (this.length = g.length, m !== 0)
        this.words[this.length] = m, this.length++;
      else if (g !== this)
        for (; _ < g.length; _++)
          this.words[_] = g.words[_];
      return this;
    }, a.prototype.add = function(u) {
      var h;
      return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, h = this.sub(u), u.negative ^= 1, h) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, h = u.sub(this), this.negative = 1, h) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
    }, a.prototype.isub = function(u) {
      if (u.negative !== 0) {
        u.negative = 0;
        var h = this.iadd(u);
        return u.negative = 1, h._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
      var g = this.cmp(u);
      if (g === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, m;
      g > 0 ? (y = this, m = u) : (y = u, m = this);
      for (var _ = 0, R = 0; R < m.length; R++)
        h = (y.words[R] | 0) - (m.words[R] | 0) + _, _ = h >> 26, this.words[R] = h & 67108863;
      for (; _ !== 0 && R < y.length; R++)
        h = (y.words[R] | 0) + _, _ = h >> 26, this.words[R] = h & 67108863;
      if (_ === 0 && R < y.length && y !== this)
        for (; R < y.length; R++)
          this.words[R] = y.words[R];
      return this.length = Math.max(this.length, R), y !== this && (this.negative = 1), this._strip();
    }, a.prototype.sub = function(u) {
      return this.clone().isub(u);
    };
    function U(x, u, h) {
      h.negative = u.negative ^ x.negative;
      var g = x.length + u.length | 0;
      h.length = g, g = g - 1 | 0;
      var y = x.words[0] | 0, m = u.words[0] | 0, _ = y * m, R = _ & 67108863, b = _ / 67108864 | 0;
      h.words[0] = R;
      for (var l = 1; l < g; l++) {
        for (var v = b >>> 26, X = b & 67108863, S = Math.min(l, u.length - 1), Y = Math.max(0, l - x.length + 1); Y <= S; Y++) {
          var fe = l - Y | 0;
          y = x.words[fe] | 0, m = u.words[Y] | 0, _ = y * m + X, v += _ / 67108864 | 0, X = _ & 67108863;
        }
        h.words[l] = X | 0, b = v | 0;
      }
      return b !== 0 ? h.words[l] = b | 0 : h.length--, h._strip();
    }
    var G = function(u, h, g) {
      var y = u.words, m = h.words, _ = g.words, R = 0, b, l, v, X = y[0] | 0, S = X & 8191, Y = X >>> 13, fe = y[1] | 0, oe = fe & 8191, de = fe >>> 13, Ie = y[2] | 0, ye = Ie & 8191, be = Ie >>> 13, rt = y[3] | 0, xe = rt & 8191, Ne = rt >>> 13, j = y[4] | 0, z = j & 8191, ee = j >>> 13, ve = y[5] | 0, me = ve & 8191, Ae = ve >>> 13, it = y[6] | 0, ke = it & 8191, qe = it >>> 13, or = y[7] | 0, Oe = or & 8191, T = or >>> 13, A = y[8] | 0, E = A & 8191, F = A >>> 13, ie = y[9] | 0, ne = ie & 8191, ce = ie >>> 13, nt = m[0] | 0, Be = nt & 8191, Ce = nt >>> 13, _t = m[1] | 0, Me = _t & 8191, pt = _t >>> 13, qr = m[2] | 0, Xe = qr & 8191, yt = qr >>> 13, Zr = m[3] | 0, He = Zr & 8191, dt = Zr >>> 13, Hr = m[4] | 0, Ze = Hr & 8191, mt = Hr >>> 13, zr = m[5] | 0, Qe = zr & 8191, tt = zr >>> 13, Wr = m[6] | 0, q = Wr & 8191, Q = Wr >>> 13, ae = m[7] | 0, k = ae & 8191, re = ae >>> 13, Ee = m[8] | 0, pe = Ee & 8191, _e = Ee >>> 13, bt = m[9] | 0, Te = bt & 8191, Re = bt >>> 13;
      g.negative = u.negative ^ h.negative, g.length = 19, b = Math.imul(S, Be), l = Math.imul(S, Ce), l = l + Math.imul(Y, Be) | 0, v = Math.imul(Y, Ce);
      var Dr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, b = Math.imul(oe, Be), l = Math.imul(oe, Ce), l = l + Math.imul(de, Be) | 0, v = Math.imul(de, Ce), b = b + Math.imul(S, Me) | 0, l = l + Math.imul(S, pt) | 0, l = l + Math.imul(Y, Me) | 0, v = v + Math.imul(Y, pt) | 0;
      var vt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, b = Math.imul(ye, Be), l = Math.imul(ye, Ce), l = l + Math.imul(be, Be) | 0, v = Math.imul(be, Ce), b = b + Math.imul(oe, Me) | 0, l = l + Math.imul(oe, pt) | 0, l = l + Math.imul(de, Me) | 0, v = v + Math.imul(de, pt) | 0, b = b + Math.imul(S, Xe) | 0, l = l + Math.imul(S, yt) | 0, l = l + Math.imul(Y, Xe) | 0, v = v + Math.imul(Y, yt) | 0;
      var pr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, b = Math.imul(xe, Be), l = Math.imul(xe, Ce), l = l + Math.imul(Ne, Be) | 0, v = Math.imul(Ne, Ce), b = b + Math.imul(ye, Me) | 0, l = l + Math.imul(ye, pt) | 0, l = l + Math.imul(be, Me) | 0, v = v + Math.imul(be, pt) | 0, b = b + Math.imul(oe, Xe) | 0, l = l + Math.imul(oe, yt) | 0, l = l + Math.imul(de, Xe) | 0, v = v + Math.imul(de, yt) | 0, b = b + Math.imul(S, He) | 0, l = l + Math.imul(S, dt) | 0, l = l + Math.imul(Y, He) | 0, v = v + Math.imul(Y, dt) | 0;
      var Pr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, b = Math.imul(z, Be), l = Math.imul(z, Ce), l = l + Math.imul(ee, Be) | 0, v = Math.imul(ee, Ce), b = b + Math.imul(xe, Me) | 0, l = l + Math.imul(xe, pt) | 0, l = l + Math.imul(Ne, Me) | 0, v = v + Math.imul(Ne, pt) | 0, b = b + Math.imul(ye, Xe) | 0, l = l + Math.imul(ye, yt) | 0, l = l + Math.imul(be, Xe) | 0, v = v + Math.imul(be, yt) | 0, b = b + Math.imul(oe, He) | 0, l = l + Math.imul(oe, dt) | 0, l = l + Math.imul(de, He) | 0, v = v + Math.imul(de, dt) | 0, b = b + Math.imul(S, Ze) | 0, l = l + Math.imul(S, mt) | 0, l = l + Math.imul(Y, Ze) | 0, v = v + Math.imul(Y, mt) | 0;
      var Lr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, b = Math.imul(me, Be), l = Math.imul(me, Ce), l = l + Math.imul(Ae, Be) | 0, v = Math.imul(Ae, Ce), b = b + Math.imul(z, Me) | 0, l = l + Math.imul(z, pt) | 0, l = l + Math.imul(ee, Me) | 0, v = v + Math.imul(ee, pt) | 0, b = b + Math.imul(xe, Xe) | 0, l = l + Math.imul(xe, yt) | 0, l = l + Math.imul(Ne, Xe) | 0, v = v + Math.imul(Ne, yt) | 0, b = b + Math.imul(ye, He) | 0, l = l + Math.imul(ye, dt) | 0, l = l + Math.imul(be, He) | 0, v = v + Math.imul(be, dt) | 0, b = b + Math.imul(oe, Ze) | 0, l = l + Math.imul(oe, mt) | 0, l = l + Math.imul(de, Ze) | 0, v = v + Math.imul(de, mt) | 0, b = b + Math.imul(S, Qe) | 0, l = l + Math.imul(S, tt) | 0, l = l + Math.imul(Y, Qe) | 0, v = v + Math.imul(Y, tt) | 0;
      var Kr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Kr >>> 26) | 0, Kr &= 67108863, b = Math.imul(ke, Be), l = Math.imul(ke, Ce), l = l + Math.imul(qe, Be) | 0, v = Math.imul(qe, Ce), b = b + Math.imul(me, Me) | 0, l = l + Math.imul(me, pt) | 0, l = l + Math.imul(Ae, Me) | 0, v = v + Math.imul(Ae, pt) | 0, b = b + Math.imul(z, Xe) | 0, l = l + Math.imul(z, yt) | 0, l = l + Math.imul(ee, Xe) | 0, v = v + Math.imul(ee, yt) | 0, b = b + Math.imul(xe, He) | 0, l = l + Math.imul(xe, dt) | 0, l = l + Math.imul(Ne, He) | 0, v = v + Math.imul(Ne, dt) | 0, b = b + Math.imul(ye, Ze) | 0, l = l + Math.imul(ye, mt) | 0, l = l + Math.imul(be, Ze) | 0, v = v + Math.imul(be, mt) | 0, b = b + Math.imul(oe, Qe) | 0, l = l + Math.imul(oe, tt) | 0, l = l + Math.imul(de, Qe) | 0, v = v + Math.imul(de, tt) | 0, b = b + Math.imul(S, q) | 0, l = l + Math.imul(S, Q) | 0, l = l + Math.imul(Y, q) | 0, v = v + Math.imul(Y, Q) | 0;
      var $r = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, b = Math.imul(Oe, Be), l = Math.imul(Oe, Ce), l = l + Math.imul(T, Be) | 0, v = Math.imul(T, Ce), b = b + Math.imul(ke, Me) | 0, l = l + Math.imul(ke, pt) | 0, l = l + Math.imul(qe, Me) | 0, v = v + Math.imul(qe, pt) | 0, b = b + Math.imul(me, Xe) | 0, l = l + Math.imul(me, yt) | 0, l = l + Math.imul(Ae, Xe) | 0, v = v + Math.imul(Ae, yt) | 0, b = b + Math.imul(z, He) | 0, l = l + Math.imul(z, dt) | 0, l = l + Math.imul(ee, He) | 0, v = v + Math.imul(ee, dt) | 0, b = b + Math.imul(xe, Ze) | 0, l = l + Math.imul(xe, mt) | 0, l = l + Math.imul(Ne, Ze) | 0, v = v + Math.imul(Ne, mt) | 0, b = b + Math.imul(ye, Qe) | 0, l = l + Math.imul(ye, tt) | 0, l = l + Math.imul(be, Qe) | 0, v = v + Math.imul(be, tt) | 0, b = b + Math.imul(oe, q) | 0, l = l + Math.imul(oe, Q) | 0, l = l + Math.imul(de, q) | 0, v = v + Math.imul(de, Q) | 0, b = b + Math.imul(S, k) | 0, l = l + Math.imul(S, re) | 0, l = l + Math.imul(Y, k) | 0, v = v + Math.imul(Y, re) | 0;
      var Fr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, b = Math.imul(E, Be), l = Math.imul(E, Ce), l = l + Math.imul(F, Be) | 0, v = Math.imul(F, Ce), b = b + Math.imul(Oe, Me) | 0, l = l + Math.imul(Oe, pt) | 0, l = l + Math.imul(T, Me) | 0, v = v + Math.imul(T, pt) | 0, b = b + Math.imul(ke, Xe) | 0, l = l + Math.imul(ke, yt) | 0, l = l + Math.imul(qe, Xe) | 0, v = v + Math.imul(qe, yt) | 0, b = b + Math.imul(me, He) | 0, l = l + Math.imul(me, dt) | 0, l = l + Math.imul(Ae, He) | 0, v = v + Math.imul(Ae, dt) | 0, b = b + Math.imul(z, Ze) | 0, l = l + Math.imul(z, mt) | 0, l = l + Math.imul(ee, Ze) | 0, v = v + Math.imul(ee, mt) | 0, b = b + Math.imul(xe, Qe) | 0, l = l + Math.imul(xe, tt) | 0, l = l + Math.imul(Ne, Qe) | 0, v = v + Math.imul(Ne, tt) | 0, b = b + Math.imul(ye, q) | 0, l = l + Math.imul(ye, Q) | 0, l = l + Math.imul(be, q) | 0, v = v + Math.imul(be, Q) | 0, b = b + Math.imul(oe, k) | 0, l = l + Math.imul(oe, re) | 0, l = l + Math.imul(de, k) | 0, v = v + Math.imul(de, re) | 0, b = b + Math.imul(S, pe) | 0, l = l + Math.imul(S, _e) | 0, l = l + Math.imul(Y, pe) | 0, v = v + Math.imul(Y, _e) | 0;
      var Ur = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, b = Math.imul(ne, Be), l = Math.imul(ne, Ce), l = l + Math.imul(ce, Be) | 0, v = Math.imul(ce, Ce), b = b + Math.imul(E, Me) | 0, l = l + Math.imul(E, pt) | 0, l = l + Math.imul(F, Me) | 0, v = v + Math.imul(F, pt) | 0, b = b + Math.imul(Oe, Xe) | 0, l = l + Math.imul(Oe, yt) | 0, l = l + Math.imul(T, Xe) | 0, v = v + Math.imul(T, yt) | 0, b = b + Math.imul(ke, He) | 0, l = l + Math.imul(ke, dt) | 0, l = l + Math.imul(qe, He) | 0, v = v + Math.imul(qe, dt) | 0, b = b + Math.imul(me, Ze) | 0, l = l + Math.imul(me, mt) | 0, l = l + Math.imul(Ae, Ze) | 0, v = v + Math.imul(Ae, mt) | 0, b = b + Math.imul(z, Qe) | 0, l = l + Math.imul(z, tt) | 0, l = l + Math.imul(ee, Qe) | 0, v = v + Math.imul(ee, tt) | 0, b = b + Math.imul(xe, q) | 0, l = l + Math.imul(xe, Q) | 0, l = l + Math.imul(Ne, q) | 0, v = v + Math.imul(Ne, Q) | 0, b = b + Math.imul(ye, k) | 0, l = l + Math.imul(ye, re) | 0, l = l + Math.imul(be, k) | 0, v = v + Math.imul(be, re) | 0, b = b + Math.imul(oe, pe) | 0, l = l + Math.imul(oe, _e) | 0, l = l + Math.imul(de, pe) | 0, v = v + Math.imul(de, _e) | 0, b = b + Math.imul(S, Te) | 0, l = l + Math.imul(S, Re) | 0, l = l + Math.imul(Y, Te) | 0, v = v + Math.imul(Y, Re) | 0;
      var ar = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, b = Math.imul(ne, Me), l = Math.imul(ne, pt), l = l + Math.imul(ce, Me) | 0, v = Math.imul(ce, pt), b = b + Math.imul(E, Xe) | 0, l = l + Math.imul(E, yt) | 0, l = l + Math.imul(F, Xe) | 0, v = v + Math.imul(F, yt) | 0, b = b + Math.imul(Oe, He) | 0, l = l + Math.imul(Oe, dt) | 0, l = l + Math.imul(T, He) | 0, v = v + Math.imul(T, dt) | 0, b = b + Math.imul(ke, Ze) | 0, l = l + Math.imul(ke, mt) | 0, l = l + Math.imul(qe, Ze) | 0, v = v + Math.imul(qe, mt) | 0, b = b + Math.imul(me, Qe) | 0, l = l + Math.imul(me, tt) | 0, l = l + Math.imul(Ae, Qe) | 0, v = v + Math.imul(Ae, tt) | 0, b = b + Math.imul(z, q) | 0, l = l + Math.imul(z, Q) | 0, l = l + Math.imul(ee, q) | 0, v = v + Math.imul(ee, Q) | 0, b = b + Math.imul(xe, k) | 0, l = l + Math.imul(xe, re) | 0, l = l + Math.imul(Ne, k) | 0, v = v + Math.imul(Ne, re) | 0, b = b + Math.imul(ye, pe) | 0, l = l + Math.imul(ye, _e) | 0, l = l + Math.imul(be, pe) | 0, v = v + Math.imul(be, _e) | 0, b = b + Math.imul(oe, Te) | 0, l = l + Math.imul(oe, Re) | 0, l = l + Math.imul(de, Te) | 0, v = v + Math.imul(de, Re) | 0;
      var gr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, b = Math.imul(ne, Xe), l = Math.imul(ne, yt), l = l + Math.imul(ce, Xe) | 0, v = Math.imul(ce, yt), b = b + Math.imul(E, He) | 0, l = l + Math.imul(E, dt) | 0, l = l + Math.imul(F, He) | 0, v = v + Math.imul(F, dt) | 0, b = b + Math.imul(Oe, Ze) | 0, l = l + Math.imul(Oe, mt) | 0, l = l + Math.imul(T, Ze) | 0, v = v + Math.imul(T, mt) | 0, b = b + Math.imul(ke, Qe) | 0, l = l + Math.imul(ke, tt) | 0, l = l + Math.imul(qe, Qe) | 0, v = v + Math.imul(qe, tt) | 0, b = b + Math.imul(me, q) | 0, l = l + Math.imul(me, Q) | 0, l = l + Math.imul(Ae, q) | 0, v = v + Math.imul(Ae, Q) | 0, b = b + Math.imul(z, k) | 0, l = l + Math.imul(z, re) | 0, l = l + Math.imul(ee, k) | 0, v = v + Math.imul(ee, re) | 0, b = b + Math.imul(xe, pe) | 0, l = l + Math.imul(xe, _e) | 0, l = l + Math.imul(Ne, pe) | 0, v = v + Math.imul(Ne, _e) | 0, b = b + Math.imul(ye, Te) | 0, l = l + Math.imul(ye, Re) | 0, l = l + Math.imul(be, Te) | 0, v = v + Math.imul(be, Re) | 0;
      var zt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, b = Math.imul(ne, He), l = Math.imul(ne, dt), l = l + Math.imul(ce, He) | 0, v = Math.imul(ce, dt), b = b + Math.imul(E, Ze) | 0, l = l + Math.imul(E, mt) | 0, l = l + Math.imul(F, Ze) | 0, v = v + Math.imul(F, mt) | 0, b = b + Math.imul(Oe, Qe) | 0, l = l + Math.imul(Oe, tt) | 0, l = l + Math.imul(T, Qe) | 0, v = v + Math.imul(T, tt) | 0, b = b + Math.imul(ke, q) | 0, l = l + Math.imul(ke, Q) | 0, l = l + Math.imul(qe, q) | 0, v = v + Math.imul(qe, Q) | 0, b = b + Math.imul(me, k) | 0, l = l + Math.imul(me, re) | 0, l = l + Math.imul(Ae, k) | 0, v = v + Math.imul(Ae, re) | 0, b = b + Math.imul(z, pe) | 0, l = l + Math.imul(z, _e) | 0, l = l + Math.imul(ee, pe) | 0, v = v + Math.imul(ee, _e) | 0, b = b + Math.imul(xe, Te) | 0, l = l + Math.imul(xe, Re) | 0, l = l + Math.imul(Ne, Te) | 0, v = v + Math.imul(Ne, Re) | 0;
      var lr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, b = Math.imul(ne, Ze), l = Math.imul(ne, mt), l = l + Math.imul(ce, Ze) | 0, v = Math.imul(ce, mt), b = b + Math.imul(E, Qe) | 0, l = l + Math.imul(E, tt) | 0, l = l + Math.imul(F, Qe) | 0, v = v + Math.imul(F, tt) | 0, b = b + Math.imul(Oe, q) | 0, l = l + Math.imul(Oe, Q) | 0, l = l + Math.imul(T, q) | 0, v = v + Math.imul(T, Q) | 0, b = b + Math.imul(ke, k) | 0, l = l + Math.imul(ke, re) | 0, l = l + Math.imul(qe, k) | 0, v = v + Math.imul(qe, re) | 0, b = b + Math.imul(me, pe) | 0, l = l + Math.imul(me, _e) | 0, l = l + Math.imul(Ae, pe) | 0, v = v + Math.imul(Ae, _e) | 0, b = b + Math.imul(z, Te) | 0, l = l + Math.imul(z, Re) | 0, l = l + Math.imul(ee, Te) | 0, v = v + Math.imul(ee, Re) | 0;
      var dr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, b = Math.imul(ne, Qe), l = Math.imul(ne, tt), l = l + Math.imul(ce, Qe) | 0, v = Math.imul(ce, tt), b = b + Math.imul(E, q) | 0, l = l + Math.imul(E, Q) | 0, l = l + Math.imul(F, q) | 0, v = v + Math.imul(F, Q) | 0, b = b + Math.imul(Oe, k) | 0, l = l + Math.imul(Oe, re) | 0, l = l + Math.imul(T, k) | 0, v = v + Math.imul(T, re) | 0, b = b + Math.imul(ke, pe) | 0, l = l + Math.imul(ke, _e) | 0, l = l + Math.imul(qe, pe) | 0, v = v + Math.imul(qe, _e) | 0, b = b + Math.imul(me, Te) | 0, l = l + Math.imul(me, Re) | 0, l = l + Math.imul(Ae, Te) | 0, v = v + Math.imul(Ae, Re) | 0;
      var wt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, b = Math.imul(ne, q), l = Math.imul(ne, Q), l = l + Math.imul(ce, q) | 0, v = Math.imul(ce, Q), b = b + Math.imul(E, k) | 0, l = l + Math.imul(E, re) | 0, l = l + Math.imul(F, k) | 0, v = v + Math.imul(F, re) | 0, b = b + Math.imul(Oe, pe) | 0, l = l + Math.imul(Oe, _e) | 0, l = l + Math.imul(T, pe) | 0, v = v + Math.imul(T, _e) | 0, b = b + Math.imul(ke, Te) | 0, l = l + Math.imul(ke, Re) | 0, l = l + Math.imul(qe, Te) | 0, v = v + Math.imul(qe, Re) | 0;
      var Le = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, b = Math.imul(ne, k), l = Math.imul(ne, re), l = l + Math.imul(ce, k) | 0, v = Math.imul(ce, re), b = b + Math.imul(E, pe) | 0, l = l + Math.imul(E, _e) | 0, l = l + Math.imul(F, pe) | 0, v = v + Math.imul(F, _e) | 0, b = b + Math.imul(Oe, Te) | 0, l = l + Math.imul(Oe, Re) | 0, l = l + Math.imul(T, Te) | 0, v = v + Math.imul(T, Re) | 0;
      var Fe = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, b = Math.imul(ne, pe), l = Math.imul(ne, _e), l = l + Math.imul(ce, pe) | 0, v = Math.imul(ce, _e), b = b + Math.imul(E, Te) | 0, l = l + Math.imul(E, Re) | 0, l = l + Math.imul(F, Te) | 0, v = v + Math.imul(F, Re) | 0;
      var gt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, b = Math.imul(ne, Te), l = Math.imul(ne, Re), l = l + Math.imul(ce, Te) | 0, v = Math.imul(ce, Re);
      var et = (R + b | 0) + ((l & 8191) << 13) | 0;
      return R = (v + (l >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, _[0] = Dr, _[1] = vt, _[2] = pr, _[3] = Pr, _[4] = Lr, _[5] = Kr, _[6] = $r, _[7] = Fr, _[8] = Ur, _[9] = ar, _[10] = gr, _[11] = zt, _[12] = lr, _[13] = dr, _[14] = wt, _[15] = Le, _[16] = Fe, _[17] = gt, _[18] = et, R !== 0 && (_[19] = R, g.length++), g;
    };
    Math.imul || (G = U);
    function D(x, u, h) {
      h.negative = u.negative ^ x.negative, h.length = x.length + u.length;
      for (var g = 0, y = 0, m = 0; m < h.length - 1; m++) {
        var _ = y;
        y = 0;
        for (var R = g & 67108863, b = Math.min(m, u.length - 1), l = Math.max(0, m - x.length + 1); l <= b; l++) {
          var v = m - l, X = x.words[v] | 0, S = u.words[l] | 0, Y = X * S, fe = Y & 67108863;
          _ = _ + (Y / 67108864 | 0) | 0, fe = fe + R | 0, R = fe & 67108863, _ = _ + (fe >>> 26) | 0, y += _ >>> 26, _ &= 67108863;
        }
        h.words[m] = R, g = _, _ = y;
      }
      return g !== 0 ? h.words[m] = g : h.length--, h._strip();
    }
    function Z(x, u, h) {
      return D(x, u, h);
    }
    a.prototype.mulTo = function(u, h) {
      var g, y = this.length + u.length;
      return this.length === 10 && u.length === 10 ? g = G(this, u, h) : y < 63 ? g = U(this, u, h) : y < 1024 ? g = D(this, u, h) : g = Z(this, u, h), g;
    }, a.prototype.mul = function(u) {
      var h = new a(null);
      return h.words = new Array(this.length + u.length), this.mulTo(u, h);
    }, a.prototype.mulf = function(u) {
      var h = new a(null);
      return h.words = new Array(this.length + u.length), Z(this, u, h);
    }, a.prototype.imul = function(u) {
      return this.clone().mulTo(u, this);
    }, a.prototype.imuln = function(u) {
      var h = u < 0;
      h && (u = -u), o(typeof u == "number"), o(u < 67108864);
      for (var g = 0, y = 0; y < this.length; y++) {
        var m = (this.words[y] | 0) * u, _ = (m & 67108863) + (g & 67108863);
        g >>= 26, g += m / 67108864 | 0, g += _ >>> 26, this.words[y] = _ & 67108863;
      }
      return g !== 0 && (this.words[y] = g, this.length++), h ? this.ineg() : this;
    }, a.prototype.muln = function(u) {
      return this.clone().imuln(u);
    }, a.prototype.sqr = function() {
      return this.mul(this);
    }, a.prototype.isqr = function() {
      return this.imul(this.clone());
    }, a.prototype.pow = function(u) {
      var h = P(u);
      if (h.length === 0)
        return new a(1);
      for (var g = this, y = 0; y < h.length && h[y] === 0; y++, g = g.sqr())
        ;
      if (++y < h.length)
        for (var m = g.sqr(); y < h.length; y++, m = m.sqr())
          h[y] !== 0 && (g = g.mul(m));
      return g;
    }, a.prototype.iushln = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26, y = 67108863 >>> 26 - h << 26 - h, m;
      if (h !== 0) {
        var _ = 0;
        for (m = 0; m < this.length; m++) {
          var R = this.words[m] & y, b = (this.words[m] | 0) - R << h;
          this.words[m] = b | _, _ = R >>> 26 - h;
        }
        _ && (this.words[m] = _, this.length++);
      }
      if (g !== 0) {
        for (m = this.length - 1; m >= 0; m--)
          this.words[m + g] = this.words[m];
        for (m = 0; m < g; m++)
          this.words[m] = 0;
        this.length += g;
      }
      return this._strip();
    }, a.prototype.ishln = function(u) {
      return o(this.negative === 0), this.iushln(u);
    }, a.prototype.iushrn = function(u, h, g) {
      o(typeof u == "number" && u >= 0);
      var y;
      h ? y = (h - h % 26) / 26 : y = 0;
      var m = u % 26, _ = Math.min((u - m) / 26, this.length), R = 67108863 ^ 67108863 >>> m << m, b = g;
      if (y -= _, y = Math.max(0, y), b) {
        for (var l = 0; l < _; l++)
          b.words[l] = this.words[l];
        b.length = _;
      }
      if (_ !== 0)
        if (this.length > _)
          for (this.length -= _, l = 0; l < this.length; l++)
            this.words[l] = this.words[l + _];
        else
          this.words[0] = 0, this.length = 1;
      var v = 0;
      for (l = this.length - 1; l >= 0 && (v !== 0 || l >= y); l--) {
        var X = this.words[l] | 0;
        this.words[l] = v << 26 - m | X >>> m, v = X & R;
      }
      return b && v !== 0 && (b.words[b.length++] = v), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, a.prototype.ishrn = function(u, h, g) {
      return o(this.negative === 0), this.iushrn(u, h, g);
    }, a.prototype.shln = function(u) {
      return this.clone().ishln(u);
    }, a.prototype.ushln = function(u) {
      return this.clone().iushln(u);
    }, a.prototype.shrn = function(u) {
      return this.clone().ishrn(u);
    }, a.prototype.ushrn = function(u) {
      return this.clone().iushrn(u);
    }, a.prototype.testn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26, y = 1 << h;
      if (this.length <= g)
        return !1;
      var m = this.words[g];
      return !!(m & y);
    }, a.prototype.imaskn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26;
      if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g)
        return this;
      if (h !== 0 && g++, this.length = Math.min(g, this.length), h !== 0) {
        var y = 67108863 ^ 67108863 >>> h << h;
        this.words[this.length - 1] &= y;
      }
      return this._strip();
    }, a.prototype.maskn = function(u) {
      return this.clone().imaskn(u);
    }, a.prototype.iaddn = function(u) {
      return o(typeof u == "number"), o(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
    }, a.prototype._iaddn = function(u) {
      this.words[0] += u;
      for (var h = 0; h < this.length && this.words[h] >= 67108864; h++)
        this.words[h] -= 67108864, h === this.length - 1 ? this.words[h + 1] = 1 : this.words[h + 1]++;
      return this.length = Math.max(this.length, h + 1), this;
    }, a.prototype.isubn = function(u) {
      if (o(typeof u == "number"), o(u < 67108864), u < 0)
        return this.iaddn(-u);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(u), this.negative = 1, this;
      if (this.words[0] -= u, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var h = 0; h < this.length && this.words[h] < 0; h++)
          this.words[h] += 67108864, this.words[h + 1] -= 1;
      return this._strip();
    }, a.prototype.addn = function(u) {
      return this.clone().iaddn(u);
    }, a.prototype.subn = function(u) {
      return this.clone().isubn(u);
    }, a.prototype.iabs = function() {
      return this.negative = 0, this;
    }, a.prototype.abs = function() {
      return this.clone().iabs();
    }, a.prototype._ishlnsubmul = function(u, h, g) {
      var y = u.length + g, m;
      this._expand(y);
      var _, R = 0;
      for (m = 0; m < u.length; m++) {
        _ = (this.words[m + g] | 0) + R;
        var b = (u.words[m] | 0) * h;
        _ -= b & 67108863, R = (_ >> 26) - (b / 67108864 | 0), this.words[m + g] = _ & 67108863;
      }
      for (; m < this.length - g; m++)
        _ = (this.words[m + g] | 0) + R, R = _ >> 26, this.words[m + g] = _ & 67108863;
      if (R === 0)
        return this._strip();
      for (o(R === -1), R = 0, m = 0; m < this.length; m++)
        _ = -(this.words[m] | 0) + R, R = _ >> 26, this.words[m] = _ & 67108863;
      return this.negative = 1, this._strip();
    }, a.prototype._wordDiv = function(u, h) {
      var g = this.length - u.length, y = this.clone(), m = u, _ = m.words[m.length - 1] | 0, R = this._countBits(_);
      g = 26 - R, g !== 0 && (m = m.ushln(g), y.iushln(g), _ = m.words[m.length - 1] | 0);
      var b = y.length - m.length, l;
      if (h !== "mod") {
        l = new a(null), l.length = b + 1, l.words = new Array(l.length);
        for (var v = 0; v < l.length; v++)
          l.words[v] = 0;
      }
      var X = y.clone()._ishlnsubmul(m, 1, b);
      X.negative === 0 && (y = X, l && (l.words[b] = 1));
      for (var S = b - 1; S >= 0; S--) {
        var Y = (y.words[m.length + S] | 0) * 67108864 + (y.words[m.length + S - 1] | 0);
        for (Y = Math.min(Y / _ | 0, 67108863), y._ishlnsubmul(m, Y, S); y.negative !== 0; )
          Y--, y.negative = 0, y._ishlnsubmul(m, 1, S), y.isZero() || (y.negative ^= 1);
        l && (l.words[S] = Y);
      }
      return l && l._strip(), y._strip(), h !== "div" && g !== 0 && y.iushrn(g), {
        div: l || null,
        mod: y
      };
    }, a.prototype.divmod = function(u, h, g) {
      if (o(!u.isZero()), this.isZero())
        return {
          div: new a(0),
          mod: new a(0)
        };
      var y, m, _;
      return this.negative !== 0 && u.negative === 0 ? (_ = this.neg().divmod(u, h), h !== "mod" && (y = _.div.neg()), h !== "div" && (m = _.mod.neg(), g && m.negative !== 0 && m.iadd(u)), {
        div: y,
        mod: m
      }) : this.negative === 0 && u.negative !== 0 ? (_ = this.divmod(u.neg(), h), h !== "mod" && (y = _.div.neg()), {
        div: y,
        mod: _.mod
      }) : (this.negative & u.negative) !== 0 ? (_ = this.neg().divmod(u.neg(), h), h !== "div" && (m = _.mod.neg(), g && m.negative !== 0 && m.isub(u)), {
        div: _.div,
        mod: m
      }) : u.length > this.length || this.cmp(u) < 0 ? {
        div: new a(0),
        mod: this
      } : u.length === 1 ? h === "div" ? {
        div: this.divn(u.words[0]),
        mod: null
      } : h === "mod" ? {
        div: null,
        mod: new a(this.modrn(u.words[0]))
      } : {
        div: this.divn(u.words[0]),
        mod: new a(this.modrn(u.words[0]))
      } : this._wordDiv(u, h);
    }, a.prototype.div = function(u) {
      return this.divmod(u, "div", !1).div;
    }, a.prototype.mod = function(u) {
      return this.divmod(u, "mod", !1).mod;
    }, a.prototype.umod = function(u) {
      return this.divmod(u, "mod", !0).mod;
    }, a.prototype.divRound = function(u) {
      var h = this.divmod(u);
      if (h.mod.isZero())
        return h.div;
      var g = h.div.negative !== 0 ? h.mod.isub(u) : h.mod, y = u.ushrn(1), m = u.andln(1), _ = g.cmp(y);
      return _ < 0 || m === 1 && _ === 0 ? h.div : h.div.negative !== 0 ? h.div.isubn(1) : h.div.iaddn(1);
    }, a.prototype.modrn = function(u) {
      var h = u < 0;
      h && (u = -u), o(u <= 67108863);
      for (var g = (1 << 26) % u, y = 0, m = this.length - 1; m >= 0; m--)
        y = (g * y + (this.words[m] | 0)) % u;
      return h ? -y : y;
    }, a.prototype.modn = function(u) {
      return this.modrn(u);
    }, a.prototype.idivn = function(u) {
      var h = u < 0;
      h && (u = -u), o(u <= 67108863);
      for (var g = 0, y = this.length - 1; y >= 0; y--) {
        var m = (this.words[y] | 0) + g * 67108864;
        this.words[y] = m / u | 0, g = m % u;
      }
      return this._strip(), h ? this.ineg() : this;
    }, a.prototype.divn = function(u) {
      return this.clone().idivn(u);
    }, a.prototype.egcd = function(u) {
      o(u.negative === 0), o(!u.isZero());
      var h = this, g = u.clone();
      h.negative !== 0 ? h = h.umod(u) : h = h.clone();
      for (var y = new a(1), m = new a(0), _ = new a(0), R = new a(1), b = 0; h.isEven() && g.isEven(); )
        h.iushrn(1), g.iushrn(1), ++b;
      for (var l = g.clone(), v = h.clone(); !h.isZero(); ) {
        for (var X = 0, S = 1; (h.words[0] & S) === 0 && X < 26; ++X, S <<= 1)
          ;
        if (X > 0)
          for (h.iushrn(X); X-- > 0; )
            (y.isOdd() || m.isOdd()) && (y.iadd(l), m.isub(v)), y.iushrn(1), m.iushrn(1);
        for (var Y = 0, fe = 1; (g.words[0] & fe) === 0 && Y < 26; ++Y, fe <<= 1)
          ;
        if (Y > 0)
          for (g.iushrn(Y); Y-- > 0; )
            (_.isOdd() || R.isOdd()) && (_.iadd(l), R.isub(v)), _.iushrn(1), R.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), y.isub(_), m.isub(R)) : (g.isub(h), _.isub(y), R.isub(m));
      }
      return {
        a: _,
        b: R,
        gcd: g.iushln(b)
      };
    }, a.prototype._invmp = function(u) {
      o(u.negative === 0), o(!u.isZero());
      var h = this, g = u.clone();
      h.negative !== 0 ? h = h.umod(u) : h = h.clone();
      for (var y = new a(1), m = new a(0), _ = g.clone(); h.cmpn(1) > 0 && g.cmpn(1) > 0; ) {
        for (var R = 0, b = 1; (h.words[0] & b) === 0 && R < 26; ++R, b <<= 1)
          ;
        if (R > 0)
          for (h.iushrn(R); R-- > 0; )
            y.isOdd() && y.iadd(_), y.iushrn(1);
        for (var l = 0, v = 1; (g.words[0] & v) === 0 && l < 26; ++l, v <<= 1)
          ;
        if (l > 0)
          for (g.iushrn(l); l-- > 0; )
            m.isOdd() && m.iadd(_), m.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), y.isub(m)) : (g.isub(h), m.isub(y));
      }
      var X;
      return h.cmpn(1) === 0 ? X = y : X = m, X.cmpn(0) < 0 && X.iadd(u), X;
    }, a.prototype.gcd = function(u) {
      if (this.isZero())
        return u.abs();
      if (u.isZero())
        return this.abs();
      var h = this.clone(), g = u.clone();
      h.negative = 0, g.negative = 0;
      for (var y = 0; h.isEven() && g.isEven(); y++)
        h.iushrn(1), g.iushrn(1);
      do {
        for (; h.isEven(); )
          h.iushrn(1);
        for (; g.isEven(); )
          g.iushrn(1);
        var m = h.cmp(g);
        if (m < 0) {
          var _ = h;
          h = g, g = _;
        } else if (m === 0 || g.cmpn(1) === 0)
          break;
        h.isub(g);
      } while (!0);
      return g.iushln(y);
    }, a.prototype.invm = function(u) {
      return this.egcd(u).a.umod(u);
    }, a.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, a.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, a.prototype.andln = function(u) {
      return this.words[0] & u;
    }, a.prototype.bincn = function(u) {
      o(typeof u == "number");
      var h = u % 26, g = (u - h) / 26, y = 1 << h;
      if (this.length <= g)
        return this._expand(g + 1), this.words[g] |= y, this;
      for (var m = y, _ = g; m !== 0 && _ < this.length; _++) {
        var R = this.words[_] | 0;
        R += m, m = R >>> 26, R &= 67108863, this.words[_] = R;
      }
      return m !== 0 && (this.words[_] = m, this.length++), this;
    }, a.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, a.prototype.cmpn = function(u) {
      var h = u < 0;
      if (this.negative !== 0 && !h)
        return -1;
      if (this.negative === 0 && h)
        return 1;
      this._strip();
      var g;
      if (this.length > 1)
        g = 1;
      else {
        h && (u = -u), o(u <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        g = y === u ? 0 : y < u ? -1 : 1;
      }
      return this.negative !== 0 ? -g | 0 : g;
    }, a.prototype.cmp = function(u) {
      if (this.negative !== 0 && u.negative === 0)
        return -1;
      if (this.negative === 0 && u.negative !== 0)
        return 1;
      var h = this.ucmp(u);
      return this.negative !== 0 ? -h | 0 : h;
    }, a.prototype.ucmp = function(u) {
      if (this.length > u.length)
        return 1;
      if (this.length < u.length)
        return -1;
      for (var h = 0, g = this.length - 1; g >= 0; g--) {
        var y = this.words[g] | 0, m = u.words[g] | 0;
        if (y !== m) {
          y < m ? h = -1 : y > m && (h = 1);
          break;
        }
      }
      return h;
    }, a.prototype.gtn = function(u) {
      return this.cmpn(u) === 1;
    }, a.prototype.gt = function(u) {
      return this.cmp(u) === 1;
    }, a.prototype.gten = function(u) {
      return this.cmpn(u) >= 0;
    }, a.prototype.gte = function(u) {
      return this.cmp(u) >= 0;
    }, a.prototype.ltn = function(u) {
      return this.cmpn(u) === -1;
    }, a.prototype.lt = function(u) {
      return this.cmp(u) === -1;
    }, a.prototype.lten = function(u) {
      return this.cmpn(u) <= 0;
    }, a.prototype.lte = function(u) {
      return this.cmp(u) <= 0;
    }, a.prototype.eqn = function(u) {
      return this.cmpn(u) === 0;
    }, a.prototype.eq = function(u) {
      return this.cmp(u) === 0;
    }, a.red = function(u) {
      return new O(u);
    }, a.prototype.toRed = function(u) {
      return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
    }, a.prototype.fromRed = function() {
      return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, a.prototype._forceRed = function(u) {
      return this.red = u, this;
    }, a.prototype.forceRed = function(u) {
      return o(!this.red, "Already a number in reduction context"), this._forceRed(u);
    }, a.prototype.redAdd = function(u) {
      return o(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
    }, a.prototype.redIAdd = function(u) {
      return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
    }, a.prototype.redSub = function(u) {
      return o(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
    }, a.prototype.redISub = function(u) {
      return o(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
    }, a.prototype.redShl = function(u) {
      return o(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
    }, a.prototype.redMul = function(u) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
    }, a.prototype.redIMul = function(u) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
    }, a.prototype.redSqr = function() {
      return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, a.prototype.redISqr = function() {
      return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, a.prototype.redSqrt = function() {
      return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, a.prototype.redInvm = function() {
      return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, a.prototype.redNeg = function() {
      return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, a.prototype.redPow = function(u) {
      return o(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
    };
    var J = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function te(x, u) {
      this.name = x, this.p = new a(u, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    te.prototype._tmp = function() {
      var u = new a(null);
      return u.words = new Array(Math.ceil(this.n / 13)), u;
    }, te.prototype.ireduce = function(u) {
      var h = u, g;
      do
        this.split(h, this.tmp), h = this.imulK(h), h = h.iadd(this.tmp), g = h.bitLength();
      while (g > this.n);
      var y = g < this.n ? -1 : h.ucmp(this.p);
      return y === 0 ? (h.words[0] = 0, h.length = 1) : y > 0 ? h.isub(this.p) : h.strip !== void 0 ? h.strip() : h._strip(), h;
    }, te.prototype.split = function(u, h) {
      u.iushrn(this.n, 0, h);
    }, te.prototype.imulK = function(u) {
      return u.imul(this.k);
    };
    function ue() {
      te.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    c(ue, te), ue.prototype.split = function(u, h) {
      for (var g = 4194303, y = Math.min(u.length, 9), m = 0; m < y; m++)
        h.words[m] = u.words[m];
      if (h.length = y, u.length <= 9) {
        u.words[0] = 0, u.length = 1;
        return;
      }
      var _ = u.words[9];
      for (h.words[h.length++] = _ & g, m = 10; m < u.length; m++) {
        var R = u.words[m] | 0;
        u.words[m - 10] = (R & g) << 4 | _ >>> 22, _ = R;
      }
      _ >>>= 22, u.words[m - 10] = _, _ === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
    }, ue.prototype.imulK = function(u) {
      u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
      for (var h = 0, g = 0; g < u.length; g++) {
        var y = u.words[g] | 0;
        h += y * 977, u.words[g] = h & 67108863, h = y * 64 + (h / 67108864 | 0);
      }
      return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
    };
    function he() {
      te.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    c(he, te);
    function Se() {
      te.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    c(Se, te);
    function C() {
      te.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    c(C, te), C.prototype.imulK = function(u) {
      for (var h = 0, g = 0; g < u.length; g++) {
        var y = (u.words[g] | 0) * 19 + h, m = y & 67108863;
        y >>>= 26, u.words[g] = m, h = y;
      }
      return h !== 0 && (u.words[u.length++] = h), u;
    }, a._prime = function(u) {
      if (J[u])
        return J[u];
      var h;
      if (u === "k256")
        h = new ue();
      else if (u === "p224")
        h = new he();
      else if (u === "p192")
        h = new Se();
      else if (u === "p25519")
        h = new C();
      else
        throw new Error("Unknown prime " + u);
      return J[u] = h, h;
    };
    function O(x) {
      if (typeof x == "string") {
        var u = a._prime(x);
        this.m = u.p, this.prime = u;
      } else
        o(x.gtn(1), "modulus must be greater than 1"), this.m = x, this.prime = null;
    }
    O.prototype._verify1 = function(u) {
      o(u.negative === 0, "red works only with positives"), o(u.red, "red works only with red numbers");
    }, O.prototype._verify2 = function(u, h) {
      o((u.negative | h.negative) === 0, "red works only with positives"), o(
        u.red && u.red === h.red,
        "red works only with red numbers"
      );
    }, O.prototype.imod = function(u) {
      return this.prime ? this.prime.ireduce(u)._forceRed(this) : (I(u, u.umod(this.m)._forceRed(this)), u);
    }, O.prototype.neg = function(u) {
      return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
    }, O.prototype.add = function(u, h) {
      this._verify2(u, h);
      var g = u.add(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
    }, O.prototype.iadd = function(u, h) {
      this._verify2(u, h);
      var g = u.iadd(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g;
    }, O.prototype.sub = function(u, h) {
      this._verify2(u, h);
      var g = u.sub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
    }, O.prototype.isub = function(u, h) {
      this._verify2(u, h);
      var g = u.isub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g;
    }, O.prototype.shl = function(u, h) {
      return this._verify1(u), this.imod(u.ushln(h));
    }, O.prototype.imul = function(u, h) {
      return this._verify2(u, h), this.imod(u.imul(h));
    }, O.prototype.mul = function(u, h) {
      return this._verify2(u, h), this.imod(u.mul(h));
    }, O.prototype.isqr = function(u) {
      return this.imul(u, u.clone());
    }, O.prototype.sqr = function(u) {
      return this.mul(u, u);
    }, O.prototype.sqrt = function(u) {
      if (u.isZero())
        return u.clone();
      var h = this.m.andln(3);
      if (o(h % 2 === 1), h === 3) {
        var g = this.m.add(new a(1)).iushrn(2);
        return this.pow(u, g);
      }
      for (var y = this.m.subn(1), m = 0; !y.isZero() && y.andln(1) === 0; )
        m++, y.iushrn(1);
      o(!y.isZero());
      var _ = new a(1).toRed(this), R = _.redNeg(), b = this.m.subn(1).iushrn(1), l = this.m.bitLength();
      for (l = new a(2 * l * l).toRed(this); this.pow(l, b).cmp(R) !== 0; )
        l.redIAdd(R);
      for (var v = this.pow(l, y), X = this.pow(u, y.addn(1).iushrn(1)), S = this.pow(u, y), Y = m; S.cmp(_) !== 0; ) {
        for (var fe = S, oe = 0; fe.cmp(_) !== 0; oe++)
          fe = fe.redSqr();
        o(oe < Y);
        var de = this.pow(v, new a(1).iushln(Y - oe - 1));
        X = X.redMul(de), v = de.redSqr(), S = S.redMul(v), Y = oe;
      }
      return X;
    }, O.prototype.invm = function(u) {
      var h = u._invmp(this.m);
      return h.negative !== 0 ? (h.negative = 0, this.imod(h).redNeg()) : this.imod(h);
    }, O.prototype.pow = function(u, h) {
      if (h.isZero())
        return new a(1).toRed(this);
      if (h.cmpn(1) === 0)
        return u.clone();
      var g = 4, y = new Array(1 << g);
      y[0] = new a(1).toRed(this), y[1] = u;
      for (var m = 2; m < y.length; m++)
        y[m] = this.mul(y[m - 1], u);
      var _ = y[0], R = 0, b = 0, l = h.bitLength() % 26;
      for (l === 0 && (l = 26), m = h.length - 1; m >= 0; m--) {
        for (var v = h.words[m], X = l - 1; X >= 0; X--) {
          var S = v >> X & 1;
          if (_ !== y[0] && (_ = this.sqr(_)), S === 0 && R === 0) {
            b = 0;
            continue;
          }
          R <<= 1, R |= S, b++, !(b !== g && (m !== 0 || X !== 0)) && (_ = this.mul(_, y[R]), b = 0, R = 0);
        }
        l = 26;
      }
      return _;
    }, O.prototype.convertTo = function(u) {
      var h = u.umod(this.m);
      return h === u ? h.clone() : h;
    }, O.prototype.convertFrom = function(u) {
      var h = u.clone();
      return h.red = null, h;
    }, a.mont = function(u) {
      return new V(u);
    };
    function V(x) {
      O.call(this, x), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    c(V, O), V.prototype.convertTo = function(u) {
      return this.imod(u.ushln(this.shift));
    }, V.prototype.convertFrom = function(u) {
      var h = this.imod(u.mul(this.rinv));
      return h.red = null, h;
    }, V.prototype.imul = function(u, h) {
      if (u.isZero() || h.isZero())
        return u.words[0] = 0, u.length = 1, u;
      var g = u.imul(h), y = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = g.isub(y).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, V.prototype.mul = function(u, h) {
      if (u.isZero() || h.isZero())
        return new a(0)._forceRed(this);
      var g = u.mul(h), y = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = g.isub(y).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, V.prototype.invm = function(u) {
      var h = this.imod(u._invmp(this.m).mul(this.r2));
      return h._forceRed(this);
    };
  })(n, commonjsGlobal);
})(bn$4);
(function(n) {
  var e = commonjsGlobal && commonjsGlobal.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), n.parseNearAmount = n.formatNearAmount = n.NEAR_NOMINATION = n.NEAR_NOMINATION_EXP = void 0;
  const t = e(bn$4.exports);
  n.NEAR_NOMINATION_EXP = 24, n.NEAR_NOMINATION = new t.default("10", 10).pow(new t.default(n.NEAR_NOMINATION_EXP, 10));
  const o = [], c = new t.default(10);
  for (let B = 0, H = new t.default(5); B < n.NEAR_NOMINATION_EXP; B++, H = H.mul(c))
    o[B] = H;
  function a(B, H = n.NEAR_NOMINATION_EXP) {
    const L = new t.default(B, 10);
    if (H !== n.NEAR_NOMINATION_EXP) {
      const P = n.NEAR_NOMINATION_EXP - H - 1;
      P > 0 && L.iadd(o[P]);
    }
    B = L.toString();
    const W = B.substring(0, B.length - n.NEAR_NOMINATION_EXP) || "0", $ = B.substring(B.length - n.NEAR_NOMINATION_EXP).padStart(n.NEAR_NOMINATION_EXP, "0").substring(0, H);
    return w(`${I(W)}.${$}`);
  }
  n.formatNearAmount = a;
  function d(B) {
    if (!B)
      return null;
    B = p(B);
    const H = B.split("."), L = H[0], W = H[1] || "";
    if (H.length > 2 || W.length > n.NEAR_NOMINATION_EXP)
      throw new Error(`Cannot parse '${B}' as NEAR amount`);
    return M(L + W.padEnd(n.NEAR_NOMINATION_EXP, "0"));
  }
  n.parseNearAmount = d;
  function p(B) {
    return B.replace(/,/g, "").trim();
  }
  function w(B) {
    return B.replace(/\.?0*$/, "");
  }
  function M(B) {
    return B = B.replace(/^0+/, ""), B === "" ? "0" : B;
  }
  function I(B) {
    const H = /(-?\d+)(\d{3})/;
    for (; H.test(B); )
      B = B.replace(H, "$1,$2");
    return B;
  }
})(format);
var hasRequiredUtils;
function requireUtils() {
  return hasRequiredUtils || (hasRequiredUtils = 1, function(n) {
    var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(H, L, W, $) {
      $ === void 0 && ($ = W);
      var P = Object.getOwnPropertyDescriptor(L, W);
      (!P || ("get" in P ? !L.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
        return L[W];
      } }), Object.defineProperty(H, $, P);
    } : function(H, L, W, $) {
      $ === void 0 && ($ = W), H[$] = L[W];
    }), t = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(H, L) {
      Object.defineProperty(H, "default", { enumerable: !0, value: L });
    } : function(H, L) {
      H.default = L;
    }), o = commonjsGlobal && commonjsGlobal.__importStar || function(H) {
      if (H && H.__esModule)
        return H;
      var L = {};
      if (H != null)
        for (var W in H)
          W !== "default" && Object.prototype.hasOwnProperty.call(H, W) && e(L, H, W);
      return t(L, H), L;
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), n.logWarning = n.rpc_errors = n.KeyPairEd25519 = n.KeyPair = n.PublicKey = n.format = n.enums = n.web = n.serialize = n.key_pair = void 0;
    const c = o(key_pair);
    n.key_pair = c;
    const a = o(serialize$2);
    n.serialize = a;
    const d = o(requireWeb());
    n.web = d;
    const p = o(enums);
    n.enums = p;
    const w = o(format);
    n.format = w;
    const M = o(requireRpc_errors());
    n.rpc_errors = M;
    const I = key_pair;
    Object.defineProperty(n, "PublicKey", { enumerable: !0, get: function() {
      return I.PublicKey;
    } }), Object.defineProperty(n, "KeyPair", { enumerable: !0, get: function() {
      return I.KeyPair;
    } }), Object.defineProperty(n, "KeyPairEd25519", { enumerable: !0, get: function() {
      return I.KeyPairEd25519;
    } });
    const B = errors;
    Object.defineProperty(n, "logWarning", { enumerable: !0, get: function() {
      return B.logWarning;
    } });
  }(utils$d)), utils$d;
}
var transaction = {}, sha256$3 = { exports: {} };
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
(function(module) {
  (function() {
    var ERROR = "input is invalid type", WINDOW = typeof window == "object", root = WINDOW ? window : {};
    root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
    var WEB_WORKER = !WINDOW && typeof self == "object", NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    NODE_JS ? root = commonjsGlobal : WEB_WORKER && (root = self);
    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && !0 && module.exports, ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [-2147483648, 8388608, 32768, 128], SHIFT = [24, 16, 8, 0], K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ], OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"], blocks = [];
    (root.JS_SHA256_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(n) {
      return Object.prototype.toString.call(n) === "[object Array]";
    }), ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(n) {
      return typeof n == "object" && n.buffer && n.buffer.constructor === ArrayBuffer;
    });
    var createOutputMethod = function(n, e) {
      return function(t) {
        return new Sha256(e, !0).update(t)[n]();
      };
    }, createMethod = function(n) {
      var e = createOutputMethod("hex", n);
      NODE_JS && (e = nodeWrap(e, n)), e.create = function() {
        return new Sha256(n);
      }, e.update = function(c) {
        return e.create().update(c);
      };
      for (var t = 0; t < OUTPUT_TYPES.length; ++t) {
        var o = OUTPUT_TYPES[t];
        e[o] = createOutputMethod(o, n);
      }
      return e;
    }, nodeWrap = function(method, is224) {
      var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), algorithm = is224 ? "sha224" : "sha256", nodeMethod = function(n) {
        if (typeof n == "string")
          return crypto.createHash(algorithm).update(n, "utf8").digest("hex");
        if (n == null)
          throw new Error(ERROR);
        return n.constructor === ArrayBuffer && (n = new Uint8Array(n)), Array.isArray(n) || ArrayBuffer.isView(n) || n.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(n)).digest("hex") : method(n);
      };
      return nodeMethod;
    }, createHmacOutputMethod = function(n, e) {
      return function(t, o) {
        return new HmacSha256(t, e, !0).update(o)[n]();
      };
    }, createHmacMethod = function(n) {
      var e = createHmacOutputMethod("hex", n);
      e.create = function(c) {
        return new HmacSha256(c, n);
      }, e.update = function(c, a) {
        return e.create(c).update(a);
      };
      for (var t = 0; t < OUTPUT_TYPES.length; ++t) {
        var o = OUTPUT_TYPES[t];
        e[o] = createHmacOutputMethod(o, n);
      }
      return e;
    };
    function Sha256(n, e) {
      e ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = n;
    }
    Sha256.prototype.update = function(n) {
      if (!this.finalized) {
        var e, t = typeof n;
        if (t !== "string") {
          if (t === "object") {
            if (n === null)
              throw new Error(ERROR);
            if (ARRAY_BUFFER && n.constructor === ArrayBuffer)
              n = new Uint8Array(n);
            else if (!Array.isArray(n) && (!ARRAY_BUFFER || !ArrayBuffer.isView(n)))
              throw new Error(ERROR);
          } else
            throw new Error(ERROR);
          e = !0;
        }
        for (var o, c = 0, a, d = n.length, p = this.blocks; c < d; ) {
          if (this.hashed && (this.hashed = !1, p[0] = this.block, p[16] = p[1] = p[2] = p[3] = p[4] = p[5] = p[6] = p[7] = p[8] = p[9] = p[10] = p[11] = p[12] = p[13] = p[14] = p[15] = 0), e)
            for (a = this.start; c < d && a < 64; ++c)
              p[a >> 2] |= n[c] << SHIFT[a++ & 3];
          else
            for (a = this.start; c < d && a < 64; ++c)
              o = n.charCodeAt(c), o < 128 ? p[a >> 2] |= o << SHIFT[a++ & 3] : o < 2048 ? (p[a >> 2] |= (192 | o >> 6) << SHIFT[a++ & 3], p[a >> 2] |= (128 | o & 63) << SHIFT[a++ & 3]) : o < 55296 || o >= 57344 ? (p[a >> 2] |= (224 | o >> 12) << SHIFT[a++ & 3], p[a >> 2] |= (128 | o >> 6 & 63) << SHIFT[a++ & 3], p[a >> 2] |= (128 | o & 63) << SHIFT[a++ & 3]) : (o = 65536 + ((o & 1023) << 10 | n.charCodeAt(++c) & 1023), p[a >> 2] |= (240 | o >> 18) << SHIFT[a++ & 3], p[a >> 2] |= (128 | o >> 12 & 63) << SHIFT[a++ & 3], p[a >> 2] |= (128 | o >> 6 & 63) << SHIFT[a++ & 3], p[a >> 2] |= (128 | o & 63) << SHIFT[a++ & 3]);
          this.lastByteIndex = a, this.bytes += a - this.start, a >= 64 ? (this.block = p[16], this.start = a - 64, this.hash(), this.hashed = !0) : this.start = a;
        }
        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
      }
    }, Sha256.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var n = this.blocks, e = this.lastByteIndex;
        n[16] = this.block, n[e >> 2] |= EXTRA[e & 3], this.block = n[16], e >= 56 && (this.hashed || this.hash(), n[0] = this.block, n[16] = n[1] = n[2] = n[3] = n[4] = n[5] = n[6] = n[7] = n[8] = n[9] = n[10] = n[11] = n[12] = n[13] = n[14] = n[15] = 0), n[14] = this.hBytes << 3 | this.bytes >>> 29, n[15] = this.bytes << 3, this.hash();
      }
    }, Sha256.prototype.hash = function() {
      var n = this.h0, e = this.h1, t = this.h2, o = this.h3, c = this.h4, a = this.h5, d = this.h6, p = this.h7, w = this.blocks, M, I, B, H, L, W, $, P, U, G, D;
      for (M = 16; M < 64; ++M)
        L = w[M - 15], I = (L >>> 7 | L << 25) ^ (L >>> 18 | L << 14) ^ L >>> 3, L = w[M - 2], B = (L >>> 17 | L << 15) ^ (L >>> 19 | L << 13) ^ L >>> 10, w[M] = w[M - 16] + I + w[M - 7] + B << 0;
      for (D = e & t, M = 0; M < 64; M += 4)
        this.first ? (this.is224 ? (P = 300032, L = w[0] - 1413257819, p = L - 150054599 << 0, o = L + 24177077 << 0) : (P = 704751109, L = w[0] - 210244248, p = L - 1521486534 << 0, o = L + 143694565 << 0), this.first = !1) : (I = (n >>> 2 | n << 30) ^ (n >>> 13 | n << 19) ^ (n >>> 22 | n << 10), B = (c >>> 6 | c << 26) ^ (c >>> 11 | c << 21) ^ (c >>> 25 | c << 7), P = n & e, H = P ^ n & t ^ D, $ = c & a ^ ~c & d, L = p + B + $ + K[M] + w[M], W = I + H, p = o + L << 0, o = L + W << 0), I = (o >>> 2 | o << 30) ^ (o >>> 13 | o << 19) ^ (o >>> 22 | o << 10), B = (p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7), U = o & n, H = U ^ o & e ^ P, $ = p & c ^ ~p & a, L = d + B + $ + K[M + 1] + w[M + 1], W = I + H, d = t + L << 0, t = L + W << 0, I = (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10), B = (d >>> 6 | d << 26) ^ (d >>> 11 | d << 21) ^ (d >>> 25 | d << 7), G = t & o, H = G ^ t & n ^ U, $ = d & p ^ ~d & c, L = a + B + $ + K[M + 2] + w[M + 2], W = I + H, a = e + L << 0, e = L + W << 0, I = (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10), B = (a >>> 6 | a << 26) ^ (a >>> 11 | a << 21) ^ (a >>> 25 | a << 7), D = e & t, H = D ^ e & o ^ G, $ = a & d ^ ~a & p, L = c + B + $ + K[M + 3] + w[M + 3], W = I + H, c = n + L << 0, n = L + W << 0;
      this.h0 = this.h0 + n << 0, this.h1 = this.h1 + e << 0, this.h2 = this.h2 + t << 0, this.h3 = this.h3 + o << 0, this.h4 = this.h4 + c << 0, this.h5 = this.h5 + a << 0, this.h6 = this.h6 + d << 0, this.h7 = this.h7 + p << 0;
    }, Sha256.prototype.hex = function() {
      this.finalize();
      var n = this.h0, e = this.h1, t = this.h2, o = this.h3, c = this.h4, a = this.h5, d = this.h6, p = this.h7, w = HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[n & 15] + HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 4 & 15] + HEX_CHARS[e & 15] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[t & 15] + HEX_CHARS[o >> 28 & 15] + HEX_CHARS[o >> 24 & 15] + HEX_CHARS[o >> 20 & 15] + HEX_CHARS[o >> 16 & 15] + HEX_CHARS[o >> 12 & 15] + HEX_CHARS[o >> 8 & 15] + HEX_CHARS[o >> 4 & 15] + HEX_CHARS[o & 15] + HEX_CHARS[c >> 28 & 15] + HEX_CHARS[c >> 24 & 15] + HEX_CHARS[c >> 20 & 15] + HEX_CHARS[c >> 16 & 15] + HEX_CHARS[c >> 12 & 15] + HEX_CHARS[c >> 8 & 15] + HEX_CHARS[c >> 4 & 15] + HEX_CHARS[c & 15] + HEX_CHARS[a >> 28 & 15] + HEX_CHARS[a >> 24 & 15] + HEX_CHARS[a >> 20 & 15] + HEX_CHARS[a >> 16 & 15] + HEX_CHARS[a >> 12 & 15] + HEX_CHARS[a >> 8 & 15] + HEX_CHARS[a >> 4 & 15] + HEX_CHARS[a & 15] + HEX_CHARS[d >> 28 & 15] + HEX_CHARS[d >> 24 & 15] + HEX_CHARS[d >> 20 & 15] + HEX_CHARS[d >> 16 & 15] + HEX_CHARS[d >> 12 & 15] + HEX_CHARS[d >> 8 & 15] + HEX_CHARS[d >> 4 & 15] + HEX_CHARS[d & 15];
      return this.is224 || (w += HEX_CHARS[p >> 28 & 15] + HEX_CHARS[p >> 24 & 15] + HEX_CHARS[p >> 20 & 15] + HEX_CHARS[p >> 16 & 15] + HEX_CHARS[p >> 12 & 15] + HEX_CHARS[p >> 8 & 15] + HEX_CHARS[p >> 4 & 15] + HEX_CHARS[p & 15]), w;
    }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
      this.finalize();
      var n = this.h0, e = this.h1, t = this.h2, o = this.h3, c = this.h4, a = this.h5, d = this.h6, p = this.h7, w = [
        n >> 24 & 255,
        n >> 16 & 255,
        n >> 8 & 255,
        n & 255,
        e >> 24 & 255,
        e >> 16 & 255,
        e >> 8 & 255,
        e & 255,
        t >> 24 & 255,
        t >> 16 & 255,
        t >> 8 & 255,
        t & 255,
        o >> 24 & 255,
        o >> 16 & 255,
        o >> 8 & 255,
        o & 255,
        c >> 24 & 255,
        c >> 16 & 255,
        c >> 8 & 255,
        c & 255,
        a >> 24 & 255,
        a >> 16 & 255,
        a >> 8 & 255,
        a & 255,
        d >> 24 & 255,
        d >> 16 & 255,
        d >> 8 & 255,
        d & 255
      ];
      return this.is224 || w.push(p >> 24 & 255, p >> 16 & 255, p >> 8 & 255, p & 255), w;
    }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var n = new ArrayBuffer(this.is224 ? 28 : 32), e = new DataView(n);
      return e.setUint32(0, this.h0), e.setUint32(4, this.h1), e.setUint32(8, this.h2), e.setUint32(12, this.h3), e.setUint32(16, this.h4), e.setUint32(20, this.h5), e.setUint32(24, this.h6), this.is224 || e.setUint32(28, this.h7), n;
    };
    function HmacSha256(n, e, t) {
      var o, c = typeof n;
      if (c === "string") {
        var a = [], d = n.length, p = 0, w;
        for (o = 0; o < d; ++o)
          w = n.charCodeAt(o), w < 128 ? a[p++] = w : w < 2048 ? (a[p++] = 192 | w >> 6, a[p++] = 128 | w & 63) : w < 55296 || w >= 57344 ? (a[p++] = 224 | w >> 12, a[p++] = 128 | w >> 6 & 63, a[p++] = 128 | w & 63) : (w = 65536 + ((w & 1023) << 10 | n.charCodeAt(++o) & 1023), a[p++] = 240 | w >> 18, a[p++] = 128 | w >> 12 & 63, a[p++] = 128 | w >> 6 & 63, a[p++] = 128 | w & 63);
        n = a;
      } else if (c === "object") {
        if (n === null)
          throw new Error(ERROR);
        if (ARRAY_BUFFER && n.constructor === ArrayBuffer)
          n = new Uint8Array(n);
        else if (!Array.isArray(n) && (!ARRAY_BUFFER || !ArrayBuffer.isView(n)))
          throw new Error(ERROR);
      } else
        throw new Error(ERROR);
      n.length > 64 && (n = new Sha256(e, !0).update(n).array());
      var M = [], I = [];
      for (o = 0; o < 64; ++o) {
        var B = n[o] || 0;
        M[o] = 92 ^ B, I[o] = 54 ^ B;
      }
      Sha256.call(this, e, t), this.update(I), this.oKeyPad = M, this.inner = !0, this.sharedMemory = t;
    }
    HmacSha256.prototype = new Sha256(), HmacSha256.prototype.finalize = function() {
      if (Sha256.prototype.finalize.call(this), this.inner) {
        this.inner = !1;
        var n = this.array();
        Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(n), Sha256.prototype.finalize.call(this);
      }
    };
    var exports = createMethod();
    exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224);
  })();
})(sha256$3);
(function(n) {
  var e = commonjsGlobal && commonjsGlobal.__awaiter || function(l, v, X, S) {
    function Y(fe) {
      return fe instanceof X ? fe : new X(function(oe) {
        oe(fe);
      });
    }
    return new (X || (X = Promise))(function(fe, oe) {
      function de(be) {
        try {
          ye(S.next(be));
        } catch (rt) {
          oe(rt);
        }
      }
      function Ie(be) {
        try {
          ye(S.throw(be));
        } catch (rt) {
          oe(rt);
        }
      }
      function ye(be) {
        be.done ? fe(be.value) : Y(be.value).then(de, Ie);
      }
      ye((S = S.apply(l, v || [])).next());
    });
  }, t = commonjsGlobal && commonjsGlobal.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), n.signTransaction = n.createTransaction = n.SCHEMA = n.Action = n.SignedTransaction = n.Transaction = n.Signature = n.deleteAccount = n.deleteKey = n.addKey = n.stake = n.transfer = n.functionCall = n.stringifyJsonOrBytes = n.deployContract = n.createAccount = n.DeleteAccount = n.DeleteKey = n.AddKey = n.Stake = n.Transfer = n.FunctionCall = n.DeployContract = n.CreateAccount = n.IAction = n.functionCallAccessKey = n.fullAccessKey = n.AccessKey = n.AccessKeyPermission = n.FullAccessPermission = n.FunctionCallPermission = void 0;
  const o = t(sha256$3.exports), c = enums, a = lib$4, d = key_pair;
  class p extends c.Assignable {
  }
  n.FunctionCallPermission = p;
  class w extends c.Assignable {
  }
  n.FullAccessPermission = w;
  class M extends c.Enum {
  }
  n.AccessKeyPermission = M;
  class I extends c.Assignable {
  }
  n.AccessKey = I;
  function B() {
    return new I({ permission: new M({ fullAccess: new w({}) }) });
  }
  n.fullAccessKey = B;
  function H(l, v, X) {
    return new I({ permission: new M({ functionCall: new p({ receiverId: l, allowance: X, methodNames: v }) }) });
  }
  n.functionCallAccessKey = H;
  class L extends c.Assignable {
  }
  n.IAction = L;
  class W extends L {
  }
  n.CreateAccount = W;
  class $ extends L {
  }
  n.DeployContract = $;
  class P extends L {
  }
  n.FunctionCall = P;
  class U extends L {
  }
  n.Transfer = U;
  class G extends L {
  }
  n.Stake = G;
  class D extends L {
  }
  n.AddKey = D;
  class Z extends L {
  }
  n.DeleteKey = Z;
  class J extends L {
  }
  n.DeleteAccount = J;
  function te() {
    return new m({ createAccount: new W({}) });
  }
  n.createAccount = te;
  function ue(l) {
    return new m({ deployContract: new $({ code: l }) });
  }
  n.deployContract = ue;
  function he(l) {
    return l.byteLength !== void 0 && l.byteLength === l.length ? l : Buffer.from(JSON.stringify(l));
  }
  n.stringifyJsonOrBytes = he;
  function Se(l, v, X, S, Y = he, fe = !1) {
    return fe ? new m({ functionCall: new P({ methodName: l, args: v, gas: X, deposit: S }) }) : new m({ functionCall: new P({ methodName: l, args: Y(v), gas: X, deposit: S }) });
  }
  n.functionCall = Se;
  function C(l) {
    return new m({ transfer: new U({ deposit: l }) });
  }
  n.transfer = C;
  function O(l, v) {
    return new m({ stake: new G({ stake: l, publicKey: v }) });
  }
  n.stake = O;
  function V(l, v) {
    return new m({ addKey: new D({ publicKey: l, accessKey: v }) });
  }
  n.addKey = V;
  function x(l) {
    return new m({ deleteKey: new Z({ publicKey: l }) });
  }
  n.deleteKey = x;
  function u(l) {
    return new m({ deleteAccount: new J({ beneficiaryId: l }) });
  }
  n.deleteAccount = u;
  class h extends c.Assignable {
  }
  n.Signature = h;
  class g extends c.Assignable {
    encode() {
      return (0, a.serialize)(n.SCHEMA, this);
    }
    static decode(v) {
      return (0, a.deserialize)(n.SCHEMA, g, v);
    }
  }
  n.Transaction = g;
  class y extends c.Assignable {
    encode() {
      return (0, a.serialize)(n.SCHEMA, this);
    }
    static decode(v) {
      return (0, a.deserialize)(n.SCHEMA, y, v);
    }
  }
  n.SignedTransaction = y;
  class m extends c.Enum {
  }
  n.Action = m, n.SCHEMA = /* @__PURE__ */ new Map([
    [h, { kind: "struct", fields: [
      ["keyType", "u8"],
      ["data", [64]]
    ] }],
    [y, { kind: "struct", fields: [
      ["transaction", g],
      ["signature", h]
    ] }],
    [g, { kind: "struct", fields: [
      ["signerId", "string"],
      ["publicKey", d.PublicKey],
      ["nonce", "u64"],
      ["receiverId", "string"],
      ["blockHash", [32]],
      ["actions", [m]]
    ] }],
    [d.PublicKey, { kind: "struct", fields: [
      ["keyType", "u8"],
      ["data", [32]]
    ] }],
    [I, { kind: "struct", fields: [
      ["nonce", "u64"],
      ["permission", M]
    ] }],
    [M, { kind: "enum", field: "enum", values: [
      ["functionCall", p],
      ["fullAccess", w]
    ] }],
    [p, { kind: "struct", fields: [
      ["allowance", { kind: "option", type: "u128" }],
      ["receiverId", "string"],
      ["methodNames", ["string"]]
    ] }],
    [w, { kind: "struct", fields: [] }],
    [m, { kind: "enum", field: "enum", values: [
      ["createAccount", W],
      ["deployContract", $],
      ["functionCall", P],
      ["transfer", U],
      ["stake", G],
      ["addKey", D],
      ["deleteKey", Z],
      ["deleteAccount", J]
    ] }],
    [W, { kind: "struct", fields: [] }],
    [$, { kind: "struct", fields: [
      ["code", ["u8"]]
    ] }],
    [P, { kind: "struct", fields: [
      ["methodName", "string"],
      ["args", ["u8"]],
      ["gas", "u64"],
      ["deposit", "u128"]
    ] }],
    [U, { kind: "struct", fields: [
      ["deposit", "u128"]
    ] }],
    [G, { kind: "struct", fields: [
      ["stake", "u128"],
      ["publicKey", d.PublicKey]
    ] }],
    [D, { kind: "struct", fields: [
      ["publicKey", d.PublicKey],
      ["accessKey", I]
    ] }],
    [Z, { kind: "struct", fields: [
      ["publicKey", d.PublicKey]
    ] }],
    [J, { kind: "struct", fields: [
      ["beneficiaryId", "string"]
    ] }]
  ]);
  function _(l, v, X, S, Y, fe) {
    return new g({ signerId: l, publicKey: v, nonce: S, receiverId: X, actions: Y, blockHash: fe });
  }
  n.createTransaction = _;
  function R(l, v, X, S) {
    return e(this, void 0, void 0, function* () {
      const Y = (0, a.serialize)(n.SCHEMA, l), fe = new Uint8Array(o.default.sha256.array(Y)), oe = yield v.signMessage(Y, X, S), de = new y({
        transaction: l,
        signature: new h({ keyType: l.publicKey.keyType, data: oe.signature })
      });
      return [fe, de];
    });
  }
  function b(...l) {
    return e(this, void 0, void 0, function* () {
      if (l[0].constructor === g) {
        const [v, X, S, Y] = l;
        return R(v, X, S, Y);
      } else {
        const [v, X, S, Y, fe, oe, de] = l, Ie = yield fe.getPublicKey(oe, de), ye = _(oe, Ie, v, X, S, Y);
        return R(ye, fe, oe, de);
      }
    });
  }
  n.signTransaction = b;
})(transaction);
var validators = {};
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var browser$2 = depd;
function depd(n) {
  if (!n)
    throw new TypeError("argument namespace is required");
  function e(t) {
  }
  return e._file = void 0, e._ignored = !0, e._namespace = n, e._traced = !1, e._warned = /* @__PURE__ */ Object.create(null), e.function = wrapfunction, e.property = wrapproperty, e;
}
function wrapfunction(n, e) {
  if (typeof n != "function")
    throw new TypeError("argument fn must be a function");
  return n;
}
function wrapproperty(n, e, t) {
  if (!n || typeof n != "object" && typeof n != "function")
    throw new TypeError("argument obj must be object");
  var o = Object.getOwnPropertyDescriptor(n, e);
  if (!o)
    throw new TypeError("must call property on owner object");
  if (!o.configurable)
    throw new TypeError("property must be configurable");
}
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(validators, "__esModule", { value: !0 });
validators.diffEpochValidators = validators.findSeatPrice = void 0;
const bn_js_1$1 = __importDefault$2(bn$4.exports), depd_1 = __importDefault$2(browser$2);
function findSeatPrice(n, e, t, o) {
  return o && o < 49 ? findSeatPriceForProtocolBefore49(n, e) : (t || ((0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)")("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead"), t = [1, 6250]), findSeatPriceForProtocolAfter49(n, e, t));
}
validators.findSeatPrice = findSeatPrice;
function findSeatPriceForProtocolBefore49(n, e) {
  const t = n.map((p) => new bn_js_1$1.default(p.stake, 10)).sort((p, w) => p.cmp(w)), o = new bn_js_1$1.default(e), c = t.reduce((p, w) => p.add(w));
  if (c.lt(o))
    throw new Error("Stakes are below seats");
  let a = new bn_js_1$1.default(1), d = c.add(new bn_js_1$1.default(1));
  for (; !a.eq(d.sub(new bn_js_1$1.default(1))); ) {
    const p = a.add(d).div(new bn_js_1$1.default(2));
    let w = !1, M = new bn_js_1$1.default(0);
    for (let I = 0; I < t.length; ++I)
      if (M = M.add(t[I].div(p)), M.gte(o)) {
        a = p, w = !0;
        break;
      }
    w || (d = p);
  }
  return a;
}
function findSeatPriceForProtocolAfter49(n, e, t) {
  if (t.length != 2)
    throw Error("minimumStakeRatio should have 2 elements");
  const o = n.map((a) => new bn_js_1$1.default(a.stake, 10)).sort((a, d) => a.cmp(d)), c = o.reduce((a, d) => a.add(d));
  return n.length < e ? c.mul(new bn_js_1$1.default(t[0])).div(new bn_js_1$1.default(t[1])) : o[0].add(new bn_js_1$1.default(1));
}
function diffEpochValidators(n, e) {
  const t = /* @__PURE__ */ new Map();
  n.forEach((c) => t.set(c.account_id, c));
  const o = new Set(e.map((c) => c.account_id));
  return {
    newValidators: e.filter((c) => !t.has(c.account_id)),
    removedValidators: n.filter((c) => !o.has(c.account_id)),
    changedValidators: e.filter((c) => t.has(c.account_id) && t.get(c.account_id).stake != c.stake).map((c) => ({ current: t.get(c.account_id), next: c }))
  };
}
validators.diffEpochValidators = diffEpochValidators;
var account = {}, constants = {}, __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(constants, "__esModule", { value: !0 });
constants.DEFAULT_FUNCTION_CALL_GAS = void 0;
const bn_js_1 = __importDefault$1(bn$4.exports);
constants.DEFAULT_FUNCTION_CALL_GAS = new bn_js_1.default("30000000000000");
var hasRequiredAccount;
function requireAccount() {
  if (hasRequiredAccount)
    return account;
  hasRequiredAccount = 1;
  var n = commonjsGlobal && commonjsGlobal.__awaiter || function(G, D, Z, J) {
    function te(ue) {
      return ue instanceof Z ? ue : new Z(function(he) {
        he(ue);
      });
    }
    return new (Z || (Z = Promise))(function(ue, he) {
      function Se(V) {
        try {
          O(J.next(V));
        } catch (x) {
          he(x);
        }
      }
      function C(V) {
        try {
          O(J.throw(V));
        } catch (x) {
          he(x);
        }
      }
      function O(V) {
        V.done ? ue(V.value) : te(V.value).then(Se, C);
      }
      O((J = J.apply(G, D || [])).next());
    });
  }, e = commonjsGlobal && commonjsGlobal.__importDefault || function(G) {
    return G && G.__esModule ? G : { default: G };
  };
  Object.defineProperty(account, "__esModule", { value: !0 }), account.Account = void 0;
  const t = e(bn$4.exports), o = e(browser$2), c = transaction, a = requireProviders(), d = lib$4, p = key_pair, w = errors, M = requireRpc_errors(), I = constants, B = e(exponentialBackoff$1), H = 12, L = 500, W = 1.5;
  function $(G) {
    return JSON.parse(Buffer.from(G).toString());
  }
  function P(G) {
    return Buffer.from(JSON.stringify(G));
  }
  class U {
    constructor(D, Z) {
      this.accessKeyByPublicKeyCache = {}, this.connection = D, this.accountId = Z;
    }
    state() {
      return n(this, void 0, void 0, function* () {
        return this.connection.provider.query({
          request_type: "view_account",
          account_id: this.accountId,
          finality: "optimistic"
        });
      });
    }
    printLogsAndFailures(D, Z) {
      if (!process.env.NEAR_NO_LOGS)
        for (const J of Z)
          console.log(`Receipt${J.receiptIds.length > 1 ? "s" : ""}: ${J.receiptIds.join(", ")}`), this.printLogs(D, J.logs, "	"), J.failure && console.warn(`	Failure [${D}]: ${J.failure}`);
    }
    printLogs(D, Z, J = "") {
      if (!process.env.NEAR_NO_LOGS)
        for (const te of Z)
          console.log(`${J}Log [${D}]: ${te}`);
    }
    signTransaction(D, Z) {
      return n(this, void 0, void 0, function* () {
        const J = yield this.findAccessKey(D, Z);
        if (!J)
          throw new a.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`, "KeyNotFound");
        const { accessKey: te } = J, he = (yield this.connection.provider.block({ finality: "final" })).header.hash, Se = te.nonce.add(new t.default(1));
        return yield (0, c.signTransaction)(D, Se, Z, (0, d.baseDecode)(he), this.connection.signer, this.accountId, this.connection.networkId);
      });
    }
    signAndSendTransaction({ receiverId: D, actions: Z, returnError: J }) {
      return n(this, void 0, void 0, function* () {
        let te, ue;
        const he = yield (0, B.default)(L, H, W, () => n(this, void 0, void 0, function* () {
          [te, ue] = yield this.signTransaction(D, Z);
          const C = ue.transaction.publicKey;
          try {
            return yield this.connection.provider.sendTransaction(ue);
          } catch (O) {
            if (O.type === "InvalidNonce")
              return (0, w.logWarning)(`Retrying transaction ${D}:${(0, d.baseEncode)(te)} with new nonce.`), delete this.accessKeyByPublicKeyCache[C.toString()], null;
            if (O.type === "Expired")
              return (0, w.logWarning)(`Retrying transaction ${D}:${(0, d.baseEncode)(te)} due to expired block hash`), null;
            throw O.context = new a.ErrorContext((0, d.baseEncode)(te)), O;
          }
        }));
        if (!he)
          throw new a.TypedError("nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.", "RetriesExceeded");
        const Se = [he.transaction_outcome, ...he.receipts_outcome].reduce((C, O) => O.outcome.logs.length || typeof O.outcome.status == "object" && typeof O.outcome.status.Failure == "object" ? C.concat({
          receiptIds: O.outcome.receipt_ids,
          logs: O.outcome.logs,
          failure: typeof O.outcome.status.Failure < "u" ? (0, M.parseRpcError)(O.outcome.status.Failure) : null
        }) : C, []);
        if (this.printLogsAndFailures(ue.transaction.receiverId, Se), !J && typeof he.status == "object" && typeof he.status.Failure == "object" && he.status.Failure !== null)
          throw he.status.Failure.error_message && he.status.Failure.error_type ? new a.TypedError(`Transaction ${he.transaction_outcome.id} failed. ${he.status.Failure.error_message}`, he.status.Failure.error_type) : (0, M.parseResultError)(he);
        return he;
      });
    }
    findAccessKey(D, Z) {
      return n(this, void 0, void 0, function* () {
        const J = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
        if (!J)
          throw new a.TypedError(`no matching key pair found in ${this.connection.signer}`, "PublicKeyNotFound");
        const te = this.accessKeyByPublicKeyCache[J.toString()];
        if (te !== void 0)
          return { publicKey: J, accessKey: te };
        try {
          const ue = yield this.connection.provider.query({
            request_type: "view_access_key",
            account_id: this.accountId,
            public_key: J.toString(),
            finality: "optimistic"
          }), he = Object.assign(Object.assign({}, ue), { nonce: new t.default(ue.nonce) });
          return this.accessKeyByPublicKeyCache[J.toString()] ? { publicKey: J, accessKey: this.accessKeyByPublicKeyCache[J.toString()] } : (this.accessKeyByPublicKeyCache[J.toString()] = he, { publicKey: J, accessKey: he });
        } catch (ue) {
          if (ue.type == "AccessKeyDoesNotExist")
            return null;
          throw ue;
        }
      });
    }
    createAndDeployContract(D, Z, J, te) {
      return n(this, void 0, void 0, function* () {
        const ue = (0, c.fullAccessKey)();
        return yield this.signAndSendTransaction({
          receiverId: D,
          actions: [(0, c.createAccount)(), (0, c.transfer)(te), (0, c.addKey)(p.PublicKey.from(Z), ue), (0, c.deployContract)(J)]
        }), new U(this.connection, D);
      });
    }
    sendMoney(D, Z) {
      return n(this, void 0, void 0, function* () {
        return this.signAndSendTransaction({
          receiverId: D,
          actions: [(0, c.transfer)(Z)]
        });
      });
    }
    createAccount(D, Z, J) {
      return n(this, void 0, void 0, function* () {
        const te = (0, c.fullAccessKey)();
        return this.signAndSendTransaction({
          receiverId: D,
          actions: [(0, c.createAccount)(), (0, c.transfer)(J), (0, c.addKey)(p.PublicKey.from(Z), te)]
        });
      });
    }
    deleteAccount(D) {
      return n(this, void 0, void 0, function* () {
        return process.env.NEAR_NO_LOGS || console.log("Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting."), this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, c.deleteAccount)(D)]
        });
      });
    }
    deployContract(D) {
      return n(this, void 0, void 0, function* () {
        return this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, c.deployContract)(D)]
        });
      });
    }
    encodeJSContractArgs(D, Z, J) {
      return Buffer.concat([Buffer.from(D), Buffer.from([0]), Buffer.from(Z), Buffer.from([0]), Buffer.from(J)]);
    }
    functionCall({ contractId: D, methodName: Z, args: J = {}, gas: te = I.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit: ue, walletMeta: he, walletCallbackUrl: Se, stringify: C, jsContract: O }) {
      return n(this, void 0, void 0, function* () {
        this.validateArgs(J);
        let V;
        if (O) {
          const x = this.encodeJSContractArgs(D, Z, JSON.stringify(J));
          V = ["call_js_contract", x, te, ue, null, !0];
        } else {
          const x = C === void 0 ? c.stringifyJsonOrBytes : C;
          V = [Z, J, te, ue, x, !1];
        }
        return this.signAndSendTransaction({
          receiverId: O ? this.connection.jsvmAccountId : D,
          actions: [c.functionCall.apply(void 0, V)],
          walletMeta: he,
          walletCallbackUrl: Se
        });
      });
    }
    addKey(D, Z, J, te) {
      return n(this, void 0, void 0, function* () {
        J || (J = []), Array.isArray(J) || (J = [J]);
        let ue;
        return Z ? ue = (0, c.functionCallAccessKey)(Z, J, te) : ue = (0, c.fullAccessKey)(), this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, c.addKey)(p.PublicKey.from(D), ue)]
        });
      });
    }
    deleteKey(D) {
      return n(this, void 0, void 0, function* () {
        return this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, c.deleteKey)(p.PublicKey.from(D))]
        });
      });
    }
    stake(D, Z) {
      return n(this, void 0, void 0, function* () {
        return this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, c.stake)(Z, p.PublicKey.from(D))]
        });
      });
    }
    validateArgs(D) {
      if (!(D.byteLength !== void 0 && D.byteLength === D.length) && (Array.isArray(D) || typeof D != "object"))
        throw new w.PositionalArgsError();
    }
    viewFunction(...D) {
      return n(this, void 0, void 0, function* () {
        if (typeof D[0] == "string") {
          const Z = D[0], J = D[1], te = D[2], ue = D[3];
          return yield this.viewFunctionV1(Z, J, te, ue);
        } else
          return yield this.viewFunctionV2(D[0]);
      });
    }
    viewFunctionV1(D, Z, J = {}, { parse: te = $, stringify: ue = P, jsContract: he = !1, blockQuery: Se = { finality: "optimistic" } } = {}) {
      return n(this, void 0, void 0, function* () {
        return (0, o.default)("Account.viewFunction(contractId, methodName, args, options)")("use `Account.viewFunction(ViewFunctionCallOptions)` instead"), this.viewFunctionV2({ contractId: D, methodName: Z, args: J, parse: te, stringify: ue, jsContract: he, blockQuery: Se });
      });
    }
    viewFunctionV2({ contractId: D, methodName: Z, args: J, parse: te = $, stringify: ue = P, jsContract: he = !1, blockQuery: Se = { finality: "optimistic" } }) {
      return n(this, void 0, void 0, function* () {
        let C;
        this.validateArgs(J), he ? C = this.encodeJSContractArgs(D, Z, Object.keys(J).length > 0 ? JSON.stringify(J) : "") : C = ue(J);
        const O = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: "call_function" }, Se), { account_id: he ? this.connection.jsvmAccountId : D, method_name: he ? "view_js_contract" : Z, args_base64: C.toString("base64") }));
        return O.logs && this.printLogs(D, O.logs), O.result && O.result.length > 0 && te(Buffer.from(O.result));
      });
    }
    viewState(D, Z = { finality: "optimistic" }) {
      return n(this, void 0, void 0, function* () {
        const { values: J } = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: "view_state" }, Z), { account_id: this.accountId, prefix_base64: Buffer.from(D).toString("base64") }));
        return J.map(({ key: te, value: ue }) => ({
          key: Buffer.from(te, "base64"),
          value: Buffer.from(ue, "base64")
        }));
      });
    }
    getAccessKeys() {
      var D;
      return n(this, void 0, void 0, function* () {
        const Z = yield this.connection.provider.query({
          request_type: "view_access_key_list",
          account_id: this.accountId,
          finality: "optimistic"
        });
        return (D = Z == null ? void 0 : Z.keys) === null || D === void 0 ? void 0 : D.map((J) => Object.assign(Object.assign({}, J), { access_key: Object.assign(Object.assign({}, J.access_key), { nonce: new t.default(J.access_key.nonce) }) }));
      });
    }
    getAccountDetails() {
      return n(this, void 0, void 0, function* () {
        return { authorizedApps: (yield this.getAccessKeys()).filter((J) => J.access_key.permission !== "FullAccess").map((J) => {
          const te = J.access_key.permission;
          return {
            contractId: te.FunctionCall.receiver_id,
            amount: te.FunctionCall.allowance,
            publicKey: J.public_key
          };
        }) };
      });
    }
    getAccountBalance() {
      return n(this, void 0, void 0, function* () {
        const D = yield this.connection.provider.experimental_protocolConfig({ finality: "final" }), Z = yield this.state(), J = new t.default(D.runtime_config.storage_amount_per_byte), te = new t.default(Z.storage_usage).mul(J), ue = new t.default(Z.locked), he = new t.default(Z.amount).add(ue), Se = he.sub(t.default.max(ue, te));
        return {
          total: he.toString(),
          stateStaked: te.toString(),
          staked: ue.toString(),
          available: Se.toString()
        };
      });
    }
    getActiveDelegatedStakeBalance() {
      return n(this, void 0, void 0, function* () {
        const D = yield this.connection.provider.block({ finality: "final" }), Z = D.header.hash, J = D.header.epoch_id, { current_validators: te, next_validators: ue, current_proposals: he } = yield this.connection.provider.validators(J), Se = /* @__PURE__ */ new Set();
        [...te, ...ue, ...he].forEach((h) => Se.add(h.account_id));
        const C = [...Se], O = C.map((h) => this.viewFunction({
          contractId: h,
          methodName: "get_account_total_balance",
          args: { account_id: this.accountId },
          blockQuery: { blockId: Z }
        })), V = yield Promise.allSettled(O);
        if (V.some((h) => h.status === "rejected" && h.reason.type === "TimeoutError"))
          throw new Error("Failed to get delegated stake balance");
        const u = V.reduce((h, g, y) => {
          const m = C[y];
          if (g.status === "fulfilled") {
            const _ = new t.default(g.value);
            if (!_.isZero())
              return Object.assign(Object.assign({}, h), { stakedValidators: [...h.stakedValidators, { validatorId: m, amount: _.toString() }], total: h.total.add(_) });
          }
          return g.status === "rejected" ? Object.assign(Object.assign({}, h), { failedValidators: [...h.failedValidators, { validatorId: m, error: g.reason }] }) : h;
        }, { stakedValidators: [], failedValidators: [], total: new t.default(0) });
        return Object.assign(Object.assign({}, u), { total: u.total.toString() });
      });
    }
  }
  return account.Account = U, account;
}
var account_multisig = {}, hasRequiredAccount_multisig;
function requireAccount_multisig() {
  return hasRequiredAccount_multisig || (hasRequiredAccount_multisig = 1, function(n) {
    var e = commonjsGlobal && commonjsGlobal.__awaiter || function(D, Z, J, te) {
      function ue(he) {
        return he instanceof J ? he : new J(function(Se) {
          Se(he);
        });
      }
      return new (J || (J = Promise))(function(he, Se) {
        function C(x) {
          try {
            V(te.next(x));
          } catch (u) {
            Se(u);
          }
        }
        function O(x) {
          try {
            V(te.throw(x));
          } catch (u) {
            Se(u);
          }
        }
        function V(x) {
          x.done ? he(x.value) : ue(x.value).then(C, O);
        }
        V((te = te.apply(D, Z || [])).next());
      });
    }, t = commonjsGlobal && commonjsGlobal.__importDefault || function(D) {
      return D && D.__esModule ? D : { default: D };
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), n.Account2FA = n.AccountMultisig = n.MultisigStateStatus = n.MultisigDeleteRequestRejectionError = n.MULTISIG_CONFIRM_METHODS = n.MULTISIG_CHANGE_METHODS = n.MULTISIG_DEPOSIT = n.MULTISIG_GAS = n.MULTISIG_ALLOWANCE = n.MULTISIG_STORAGE_KEY = void 0;
    const o = t(bn$4.exports), c = requireAccount(), a = format, d = key_pair, p = transaction, w = requireProviders(), M = requireWeb();
    n.MULTISIG_STORAGE_KEY = "__multisigRequest", n.MULTISIG_ALLOWANCE = new o.default((0, a.parseNearAmount)("1")), n.MULTISIG_GAS = new o.default("100000000000000"), n.MULTISIG_DEPOSIT = new o.default("0"), n.MULTISIG_CHANGE_METHODS = ["add_request", "add_request_and_confirm", "delete_request", "confirm"], n.MULTISIG_CONFIRM_METHODS = ["confirm"];
    var I;
    (function(D) {
      D.CANNOT_DESERIALIZE_STATE = "Cannot deserialize the contract state", D.MULTISIG_NOT_INITIALIZED = "Smart contract panicked: Multisig contract should be initialized before usage", D.NO_SUCH_REQUEST = "Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'", D.REQUEST_COOLDOWN_ERROR = "Request cannot be deleted immediately after creation.", D.METHOD_NOT_FOUND = "Contract method is not found";
    })(I = n.MultisigDeleteRequestRejectionError || (n.MultisigDeleteRequestRejectionError = {}));
    var B;
    (function(D) {
      D[D.INVALID_STATE = 0] = "INVALID_STATE", D[D.STATE_NOT_INITIALIZED = 1] = "STATE_NOT_INITIALIZED", D[D.VALID_STATE = 2] = "VALID_STATE", D[D.UNKNOWN_STATE = 3] = "UNKNOWN_STATE";
    })(B = n.MultisigStateStatus || (n.MultisigStateStatus = {}));
    var H;
    (function(D) {
      D[D.INVALID_CODE = 0] = "INVALID_CODE", D[D.VALID_CODE = 1] = "VALID_CODE", D[D.UNKNOWN_CODE = 2] = "UNKNOWN_CODE";
    })(H || (H = {}));
    const L = {
      [n.MULTISIG_STORAGE_KEY]: null
    };
    class W extends c.Account {
      constructor(Z, J, te) {
        super(Z, J), this.storage = te.storage, this.onAddRequestResult = te.onAddRequestResult;
      }
      signAndSendTransactionWithAccount(Z, J) {
        const te = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction }
        });
        return e(this, void 0, void 0, function* () {
          return te.signAndSendTransaction.call(this, { receiverId: Z, actions: J });
        });
      }
      signAndSendTransaction({ receiverId: Z, actions: J }) {
        const te = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction }
        });
        return e(this, void 0, void 0, function* () {
          const { accountId: ue } = this, he = Buffer.from(JSON.stringify({
            request: {
              receiver_id: Z,
              actions: G(J, ue, Z)
            }
          }));
          let Se;
          try {
            Se = yield te.signAndSendTransaction.call(this, {
              receiverId: ue,
              actions: [
                (0, p.functionCall)("add_request_and_confirm", he, n.MULTISIG_GAS, n.MULTISIG_DEPOSIT)
              ]
            });
          } catch (O) {
            if (O.toString().includes("Account has too many active requests. Confirm or delete some"))
              return yield this.deleteUnconfirmedRequests(), yield this.signAndSendTransaction({ receiverId: Z, actions: J });
            throw O;
          }
          if (!Se.status)
            throw new Error("Request failed");
          const C = Object.assign({}, Se.status);
          if (!C.SuccessValue || typeof C.SuccessValue != "string")
            throw new Error("Request failed");
          return this.setRequest({
            accountId: ue,
            actions: J,
            requestId: parseInt(Buffer.from(C.SuccessValue, "base64").toString("ascii"), 10)
          }), this.onAddRequestResult && (yield this.onAddRequestResult(Se)), this.deleteUnconfirmedRequests(), Se;
        });
      }
      checkMultisigCodeAndStateStatus(Z) {
        const J = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction }
        });
        return e(this, void 0, void 0, function* () {
          const ue = Z ? H.UNKNOWN_CODE : H.VALID_CODE;
          try {
            return Z ? yield J.signAndSendTransaction.call(this, {
              receiverId: this.accountId,
              actions: [
                (0, p.deployContract)(Z),
                (0, p.functionCall)("delete_request", { request_id: 4294967295 }, n.MULTISIG_GAS, n.MULTISIG_DEPOSIT)
              ]
            }) : yield this.deleteRequest(4294967295), { codeStatus: H.VALID_CODE, stateStatus: B.VALID_STATE };
          } catch (he) {
            if (new RegExp(I.CANNOT_DESERIALIZE_STATE).test(he && he.kind && he.kind.ExecutionError))
              return { codeStatus: ue, stateStatus: B.INVALID_STATE };
            if (new RegExp(I.MULTISIG_NOT_INITIALIZED).test(he && he.kind && he.kind.ExecutionError))
              return { codeStatus: ue, stateStatus: B.STATE_NOT_INITIALIZED };
            if (new RegExp(I.NO_SUCH_REQUEST).test(he && he.kind && he.kind.ExecutionError))
              return { codeStatus: ue, stateStatus: B.VALID_STATE };
            if (new RegExp(I.METHOD_NOT_FOUND).test(he && he.message))
              return { codeStatus: H.INVALID_CODE, stateStatus: B.UNKNOWN_STATE };
            throw he;
          }
        });
      }
      deleteRequest(Z) {
        return super.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, p.functionCall)("delete_request", { request_id: Z }, n.MULTISIG_GAS, n.MULTISIG_DEPOSIT)]
        });
      }
      deleteAllRequests() {
        return e(this, void 0, void 0, function* () {
          const Z = yield this.getRequestIds();
          Z.length && (yield Promise.all(Z.map((J) => this.deleteRequest(J))));
        });
      }
      deleteUnconfirmedRequests() {
        const Z = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction }
        });
        return e(this, void 0, void 0, function* () {
          const J = yield this.getRequestIds(), { requestId: te } = this.getRequest();
          for (const ue of J)
            if (ue != te)
              try {
                yield Z.signAndSendTransaction.call(this, {
                  receiverId: this.accountId,
                  actions: [(0, p.functionCall)("delete_request", { request_id: ue }, n.MULTISIG_GAS, n.MULTISIG_DEPOSIT)]
                });
              } catch {
                console.warn("Attempt to delete an earlier request before 15 minutes failed. Will try again.");
              }
        });
      }
      getRequestIds() {
        return e(this, void 0, void 0, function* () {
          return this.viewFunction(this.accountId, "list_request_ids");
        });
      }
      getRequest() {
        return this.storage ? JSON.parse(this.storage.getItem(n.MULTISIG_STORAGE_KEY) || "{}") : L[n.MULTISIG_STORAGE_KEY];
      }
      setRequest(Z) {
        if (this.storage)
          return this.storage.setItem(n.MULTISIG_STORAGE_KEY, JSON.stringify(Z));
        L[n.MULTISIG_STORAGE_KEY] = Z;
      }
    }
    n.AccountMultisig = W;
    class $ extends W {
      constructor(Z, J, te) {
        super(Z, J, te), this.helperUrl = "https://helper.testnet.near.org", this.helperUrl = te.helperUrl || this.helperUrl, this.storage = te.storage, this.sendCode = te.sendCode || this.sendCodeDefault, this.getCode = te.getCode || this.getCodeDefault, this.verifyCode = te.verifyCode || this.verifyCodeDefault, this.onConfirmResult = te.onConfirmResult;
      }
      signAndSendTransaction({ receiverId: Z, actions: J }) {
        const te = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction }
        });
        return e(this, void 0, void 0, function* () {
          yield te.signAndSendTransaction.call(this, { receiverId: Z, actions: J }), yield this.sendCode();
          const ue = yield this.promptAndVerify();
          return this.onConfirmResult && (yield this.onConfirmResult(ue)), ue;
        });
      }
      deployMultisig(Z) {
        const J = Object.create(null, {
          signAndSendTransactionWithAccount: { get: () => super.signAndSendTransactionWithAccount }
        });
        return e(this, void 0, void 0, function* () {
          const { accountId: te } = this, ue = (yield this.getRecoveryMethods()).data.filter(({ kind: u, publicKey: h }) => (u === "phrase" || u === "ledger") && h !== null).map((u) => u.publicKey), he = (yield this.getAccessKeys()).filter(({ public_key: u, access_key: { permission: h } }) => h === "FullAccess" && !ue.includes(u)).map((u) => u.public_key).map(P), Se = P((yield this.postSignedJson("/2fa/getAccessKey", { accountId: te })).publicKey), C = Buffer.from(JSON.stringify({ num_confirmations: 2 })), O = [
            ...he.map((u) => (0, p.deleteKey)(u)),
            ...he.map((u) => (0, p.addKey)(u, (0, p.functionCallAccessKey)(te, n.MULTISIG_CHANGE_METHODS, null))),
            (0, p.addKey)(Se, (0, p.functionCallAccessKey)(te, n.MULTISIG_CONFIRM_METHODS, null)),
            (0, p.deployContract)(Z)
          ], V = O.concat((0, p.functionCall)("new", C, n.MULTISIG_GAS, n.MULTISIG_DEPOSIT));
          console.log("deploying multisig contract for", te);
          const { stateStatus: x } = yield this.checkMultisigCodeAndStateStatus(Z);
          switch (x) {
            case B.STATE_NOT_INITIALIZED:
              return yield J.signAndSendTransactionWithAccount.call(this, te, V);
            case B.VALID_STATE:
              return yield J.signAndSendTransactionWithAccount.call(this, te, O);
            case B.INVALID_STATE:
              throw new w.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState");
            default:
              throw new w.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
          }
        });
      }
      disableWithFAK({ contractBytes: Z, cleanupContractBytes: J }) {
        return e(this, void 0, void 0, function* () {
          let te = [];
          J && (yield this.deleteAllRequests().catch((C) => C), te = yield this.get2faDisableCleanupActions(J));
          const ue = yield this.get2faDisableKeyConversionActions(), he = [
            ...te,
            ...ue,
            (0, p.deployContract)(Z)
          ], Se = yield this.findAccessKey(this.accountId, he);
          if (Se && Se.accessKey && Se.accessKey.permission !== "FullAccess")
            throw new w.TypedError("No full access key found in keystore. Unable to bypass multisig", "NoFAKFound");
          return this.signAndSendTransactionWithAccount(this.accountId, he);
        });
      }
      get2faDisableCleanupActions(Z) {
        return e(this, void 0, void 0, function* () {
          const J = yield this.viewState("").catch((ue) => {
            const he = ue.cause && ue.cause.name;
            if (he == "NO_CONTRACT_CODE")
              return [];
            throw he == "TOO_LARGE_CONTRACT_STATE" ? new w.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState") : ue;
          }), te = J.map(({ key: ue }) => ue.toString("base64"));
          return J.length ? [
            (0, p.deployContract)(Z),
            (0, p.functionCall)("clean", { keys: te }, n.MULTISIG_GAS, new o.default("0"))
          ] : [];
        });
      }
      get2faDisableKeyConversionActions() {
        return e(this, void 0, void 0, function* () {
          const { accountId: Z } = this, te = (yield this.getAccessKeys()).filter(({ access_key: he }) => he.permission !== "FullAccess").filter(({ access_key: he }) => {
            const Se = he.permission.FunctionCall;
            return Se.receiver_id === Z && Se.method_names.length === 4 && Se.method_names.includes("add_request_and_confirm");
          }), ue = d.PublicKey.from((yield this.postSignedJson("/2fa/getAccessKey", { accountId: Z })).publicKey);
          return [
            (0, p.deleteKey)(ue),
            ...te.map(({ public_key: he }) => (0, p.deleteKey)(d.PublicKey.from(he))),
            ...te.map(({ public_key: he }) => (0, p.addKey)(d.PublicKey.from(he), (0, p.fullAccessKey)()))
          ];
        });
      }
      disable(Z, J) {
        return e(this, void 0, void 0, function* () {
          const { stateStatus: te } = yield this.checkMultisigCodeAndStateStatus();
          if (te !== B.VALID_STATE && te !== B.STATE_NOT_INITIALIZED)
            throw new w.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
          let ue;
          yield this.deleteAllRequests().catch((C) => ue = C);
          const Se = [
            ...yield this.get2faDisableCleanupActions(J).catch((C) => {
              throw C.type === "ContractHasExistingState" && ue || C;
            }),
            ...yield this.get2faDisableKeyConversionActions(),
            (0, p.deployContract)(Z)
          ];
          return console.log("disabling 2fa for", this.accountId), yield this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: Se
          });
        });
      }
      sendCodeDefault() {
        return e(this, void 0, void 0, function* () {
          const { accountId: Z } = this, { requestId: J } = this.getRequest(), te = yield this.get2faMethod();
          return yield this.postSignedJson("/2fa/send", {
            accountId: Z,
            method: te,
            requestId: J
          }), J;
        });
      }
      getCodeDefault() {
        return e(this, void 0, void 0, function* () {
          throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is "email" or "phone".');
        });
      }
      promptAndVerify() {
        return e(this, void 0, void 0, function* () {
          const Z = yield this.get2faMethod(), J = yield this.getCode(Z);
          try {
            return yield this.verifyCode(J);
          } catch (te) {
            if (console.warn("Error validating security code:", te), te.toString().includes("invalid 2fa code provided") || te.toString().includes("2fa code not valid"))
              return yield this.promptAndVerify();
            throw te;
          }
        });
      }
      verifyCodeDefault(Z) {
        return e(this, void 0, void 0, function* () {
          const { accountId: J } = this, te = this.getRequest();
          if (!te)
            throw new Error("no request pending");
          const { requestId: ue } = te;
          return yield this.postSignedJson("/2fa/verify", {
            accountId: J,
            securityCode: Z,
            requestId: ue
          });
        });
      }
      getRecoveryMethods() {
        return e(this, void 0, void 0, function* () {
          const { accountId: Z } = this;
          return {
            accountId: Z,
            data: yield this.postSignedJson("/account/recoveryMethods", { accountId: Z })
          };
        });
      }
      get2faMethod() {
        return e(this, void 0, void 0, function* () {
          let { data: Z } = yield this.getRecoveryMethods();
          if (Z && Z.length && (Z = Z.find((ue) => ue.kind.indexOf("2fa-") === 0)), !Z)
            return null;
          const { kind: J, detail: te } = Z;
          return { kind: J, detail: te };
        });
      }
      signatureFor() {
        return e(this, void 0, void 0, function* () {
          const { accountId: Z } = this, te = (yield this.connection.provider.block({ finality: "final" })).header.height.toString(), ue = yield this.connection.signer.signMessage(Buffer.from(te), Z, this.connection.networkId), he = Buffer.from(ue.signature).toString("base64");
          return { blockNumber: te, blockNumberSignature: he };
        });
      }
      postSignedJson(Z, J) {
        return e(this, void 0, void 0, function* () {
          return yield (0, M.fetchJson)(this.helperUrl + Z, JSON.stringify(Object.assign(Object.assign({}, J), yield this.signatureFor())));
        });
      }
    }
    n.Account2FA = $;
    const P = (D) => d.PublicKey.from(D), U = (D) => D.toString().replace("ed25519:", ""), G = (D, Z, J) => D.map((te) => {
      const ue = te.enum, { gas: he, publicKey: Se, methodName: C, args: O, deposit: V, accessKey: x, code: u } = te[ue], h = {
        type: ue[0].toUpperCase() + ue.substr(1),
        gas: he && he.toString() || void 0,
        public_key: Se && U(Se) || void 0,
        method_name: C,
        args: O && Buffer.from(O).toString("base64") || void 0,
        code: u && Buffer.from(u).toString("base64") || void 0,
        amount: V && V.toString() || void 0,
        deposit: V && V.toString() || "0",
        permission: void 0
      };
      if (x && (J === Z && x.permission.enum !== "fullAccess" && (h.permission = {
        receiver_id: Z,
        allowance: n.MULTISIG_ALLOWANCE.toString(),
        method_names: n.MULTISIG_CHANGE_METHODS
      }), x.permission.enum === "functionCall")) {
        const { receiverId: g, methodNames: y, allowance: m } = x.permission.functionCall;
        h.permission = {
          receiver_id: g,
          allowance: m && m.toString() || void 0,
          method_names: y
        };
      }
      return h;
    });
  }(account_multisig)), account_multisig;
}
var account_creator = {}, hasRequiredAccount_creator;
function requireAccount_creator() {
  if (hasRequiredAccount_creator)
    return account_creator;
  hasRequiredAccount_creator = 1;
  var n = commonjsGlobal && commonjsGlobal.__awaiter || function(a, d, p, w) {
    function M(I) {
      return I instanceof p ? I : new p(function(B) {
        B(I);
      });
    }
    return new (p || (p = Promise))(function(I, B) {
      function H($) {
        try {
          W(w.next($));
        } catch (P) {
          B(P);
        }
      }
      function L($) {
        try {
          W(w.throw($));
        } catch (P) {
          B(P);
        }
      }
      function W($) {
        $.done ? I($.value) : M($.value).then(H, L);
      }
      W((w = w.apply(a, d || [])).next());
    });
  };
  Object.defineProperty(account_creator, "__esModule", { value: !0 }), account_creator.UrlAccountCreator = account_creator.LocalAccountCreator = account_creator.AccountCreator = void 0;
  const e = requireWeb();
  class t {
  }
  account_creator.AccountCreator = t;
  class o extends t {
    constructor(d, p) {
      super(), this.masterAccount = d, this.initialBalance = p;
    }
    createAccount(d, p) {
      return n(this, void 0, void 0, function* () {
        yield this.masterAccount.createAccount(d, p, this.initialBalance);
      });
    }
  }
  account_creator.LocalAccountCreator = o;
  class c extends t {
    constructor(d, p) {
      super(), this.connection = d, this.helperUrl = p;
    }
    createAccount(d, p) {
      return n(this, void 0, void 0, function* () {
        yield (0, e.fetchJson)(`${this.helperUrl}/account`, JSON.stringify({ newAccountId: d, newAccountPublicKey: p.toString() }));
      });
    }
  }
  return account_creator.UrlAccountCreator = c, account_creator;
}
var connection = {}, signer = {}, __awaiter$9 = commonjsGlobal && commonjsGlobal.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
}, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.InMemorySigner = signer.Signer = void 0;
const js_sha256_1 = __importDefault(sha256$3.exports), key_pair_1 = key_pair, in_memory_key_store_1 = in_memory_key_store;
class Signer$1 {
}
signer.Signer = Signer$1;
class InMemorySigner extends Signer$1 {
  constructor(e) {
    super(), this.keyStore = e;
  }
  static fromKeyPair(e, t, o) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const c = new in_memory_key_store_1.InMemoryKeyStore();
      return yield c.setKey(e, t, o), new InMemorySigner(c);
    });
  }
  createKey(e, t) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const o = key_pair_1.KeyPair.fromRandom("ed25519");
      return yield this.keyStore.setKey(t, e, o), o.getPublicKey();
    });
  }
  getPublicKey(e, t) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const o = yield this.keyStore.getKey(t, e);
      return o === null ? null : o.getPublicKey();
    });
  }
  signMessage(e, t, o) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const c = new Uint8Array(js_sha256_1.default.sha256.array(e));
      if (!t)
        throw new Error("InMemorySigner requires provided account id");
      const a = yield this.keyStore.getKey(o, t);
      if (a === null)
        throw new Error(`Key for ${t} not found in ${o}`);
      return a.sign(c);
    });
  }
  toString() {
    return `InMemorySigner(${this.keyStore})`;
  }
}
signer.InMemorySigner = InMemorySigner;
var hasRequiredConnection;
function requireConnection() {
  if (hasRequiredConnection)
    return connection;
  hasRequiredConnection = 1, Object.defineProperty(connection, "__esModule", { value: !0 }), connection.Connection = void 0;
  const n = requireProviders(), e = signer;
  function t(a) {
    switch (a.type) {
      case void 0:
        return a;
      case "JsonRpcProvider":
        return new n.JsonRpcProvider(Object.assign({}, a.args));
      default:
        throw new Error(`Unknown provider type ${a.type}`);
    }
  }
  function o(a) {
    switch (a.type) {
      case void 0:
        return a;
      case "InMemorySigner":
        return new e.InMemorySigner(a.keyStore);
      default:
        throw new Error(`Unknown signer type ${a.type}`);
    }
  }
  class c {
    constructor(d, p, w, M) {
      this.networkId = d, this.provider = p, this.signer = w, this.jsvmAccountId = M;
    }
    static fromConfig(d) {
      const p = t(d.provider), w = o(d.signer);
      return new c(d.networkId, p, w, d.jsvmAccountId);
    }
  }
  return connection.Connection = c, connection;
}
var contract = {}, hasRequiredContract;
function requireContract() {
  if (hasRequiredContract)
    return contract;
  hasRequiredContract = 1;
  var n = commonjsGlobal && commonjsGlobal.__awaiter || function(B, H, L, W) {
    function $(P) {
      return P instanceof L ? P : new L(function(U) {
        U(P);
      });
    }
    return new (L || (L = Promise))(function(P, U) {
      function G(J) {
        try {
          Z(W.next(J));
        } catch (te) {
          U(te);
        }
      }
      function D(J) {
        try {
          Z(W.throw(J));
        } catch (te) {
          U(te);
        }
      }
      function Z(J) {
        J.done ? P(J.value) : $(J.value).then(G, D);
      }
      Z((W = W.apply(B, H || [])).next());
    });
  }, e = commonjsGlobal && commonjsGlobal.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(contract, "__esModule", { value: !0 }), contract.Contract = void 0;
  const t = e(bn$4.exports), o = e(browser$2), c = requireProviders(), a = errors;
  function d(B, H) {
    return {
      [B](...L) {
        return H(...L);
      }
    }[B];
  }
  const p = (B) => B && B.byteLength !== void 0 && B.byteLength === B.length, w = (B) => Object.prototype.toString.call(B) === "[object Object]";
  class M {
    constructor(H, L, W) {
      this.account = H, this.contractId = L;
      const { viewMethods: $ = [], changeMethods: P = [] } = W;
      $.forEach((U) => {
        Object.defineProperty(this, U, {
          writable: !1,
          enumerable: !0,
          value: d(U, (G = {}, D = {}, ...Z) => n(this, void 0, void 0, function* () {
            if (Z.length || !(w(G) || p(G)) || !w(D))
              throw new a.PositionalArgsError();
            return this.account.viewFunction(this.contractId, U, G, D);
          }))
        });
      }), P.forEach((U) => {
        Object.defineProperty(this, U, {
          writable: !1,
          enumerable: !0,
          value: d(U, (...G) => n(this, void 0, void 0, function* () {
            if (G.length && (G.length > 3 || !(w(G[0]) || p(G[0]))))
              throw new a.PositionalArgsError();
            return G.length > 1 || !(G[0] && G[0].args) ? ((0, o.default)("contract.methodName(args, gas, amount)")("use `contract.methodName({ args, gas?, amount?, callbackUrl?, meta? })` instead"), this._changeMethod({
              methodName: U,
              args: G[0],
              gas: G[1],
              amount: G[2]
            })) : this._changeMethod(Object.assign({ methodName: U }, G[0]));
          }))
        });
      });
    }
    _changeMethod({ args: H, methodName: L, gas: W, amount: $, meta: P, callbackUrl: U }) {
      return n(this, void 0, void 0, function* () {
        I({ gas: W, amount: $ });
        const G = yield this.account.functionCall({
          contractId: this.contractId,
          methodName: L,
          args: H,
          gas: W,
          attachedDeposit: $,
          walletMeta: P,
          walletCallbackUrl: U
        });
        return (0, c.getTransactionLastResult)(G);
      });
    }
  }
  contract.Contract = M;
  function I(B) {
    const H = "number, decimal string or BN";
    for (const L of Object.keys(B)) {
      const W = B[L];
      if (W && !t.default.isBN(W) && isNaN(W))
        throw new a.ArgumentTypeError(L, H, W);
    }
  }
  return contract;
}
var near = {}, hasRequiredNear;
function requireNear() {
  if (hasRequiredNear)
    return near;
  hasRequiredNear = 1;
  var n = commonjsGlobal && commonjsGlobal.__awaiter || function(p, w, M, I) {
    function B(H) {
      return H instanceof M ? H : new M(function(L) {
        L(H);
      });
    }
    return new (M || (M = Promise))(function(H, L) {
      function W(U) {
        try {
          P(I.next(U));
        } catch (G) {
          L(G);
        }
      }
      function $(U) {
        try {
          P(I.throw(U));
        } catch (G) {
          L(G);
        }
      }
      function P(U) {
        U.done ? H(U.value) : B(U.value).then(W, $);
      }
      P((I = I.apply(p, w || [])).next());
    });
  }, e = commonjsGlobal && commonjsGlobal.__importDefault || function(p) {
    return p && p.__esModule ? p : { default: p };
  };
  Object.defineProperty(near, "__esModule", { value: !0 }), near.Near = void 0;
  const t = e(bn$4.exports), o = requireAccount(), c = requireConnection(), a = requireAccount_creator();
  class d {
    constructor(w) {
      if (this.config = w, this.connection = c.Connection.fromConfig({
        networkId: w.networkId,
        provider: { type: "JsonRpcProvider", args: { url: w.nodeUrl, headers: w.headers } },
        signer: w.signer || { type: "InMemorySigner", keyStore: w.keyStore },
        jsvmAccountId: w.jsvmAccountId || `jsvm.${w.networkId}`
      }), w.masterAccount) {
        const M = w.initialBalance ? new t.default(w.initialBalance) : new t.default("500000000000000000000000000");
        this.accountCreator = new a.LocalAccountCreator(new o.Account(this.connection, w.masterAccount), M);
      } else
        w.helperUrl ? this.accountCreator = new a.UrlAccountCreator(this.connection, w.helperUrl) : this.accountCreator = null;
    }
    account(w) {
      return n(this, void 0, void 0, function* () {
        return new o.Account(this.connection, w);
      });
    }
    createAccount(w, M) {
      return n(this, void 0, void 0, function* () {
        if (!this.accountCreator)
          throw new Error("Must specify account creator, either via masterAccount or helperUrl configuration settings.");
        return yield this.accountCreator.createAccount(w, M), new o.Account(this.connection, w);
      });
    }
  }
  return near.Near = d, near;
}
var walletAccount = {}, hasRequiredWalletAccount;
function requireWalletAccount() {
  if (hasRequiredWalletAccount)
    return walletAccount;
  hasRequiredWalletAccount = 1;
  var n = commonjsGlobal && commonjsGlobal.__awaiter || function(W, $, P, U) {
    function G(D) {
      return D instanceof P ? D : new P(function(Z) {
        Z(D);
      });
    }
    return new (P || (P = Promise))(function(D, Z) {
      function J(he) {
        try {
          ue(U.next(he));
        } catch (Se) {
          Z(Se);
        }
      }
      function te(he) {
        try {
          ue(U.throw(he));
        } catch (Se) {
          Z(Se);
        }
      }
      function ue(he) {
        he.done ? D(he.value) : G(he.value).then(J, te);
      }
      ue((U = U.apply(W, $ || [])).next());
    });
  }, e = commonjsGlobal && commonjsGlobal.__importDefault || function(W) {
    return W && W.__esModule ? W : { default: W };
  };
  Object.defineProperty(walletAccount, "__esModule", { value: !0 }), walletAccount.ConnectedWalletAccount = walletAccount.WalletConnection = void 0;
  const t = requireAccount(), o = transaction, c = requireUtils(), a = lib$4, d = lib$4, p = e(bn$4.exports), w = "/login/", M = "add_request_and_confirm", I = "_wallet_auth_key", B = "pending_key";
  class H {
    constructor($, P) {
      if (typeof window > "u")
        return new Proxy(this, {
          get(D, Z) {
            return Z === "isSignedIn" ? () => !1 : Z === "getAccountId" ? () => "" : D[Z] && typeof D[Z] == "function" ? () => {
              throw new Error("No window found in context, please ensure you are using WalletConnection on the browser");
            } : D[Z];
          }
        });
      this._near = $;
      const U = P + I, G = JSON.parse(window.localStorage.getItem(U));
      this._networkId = $.config.networkId, this._walletBaseUrl = $.config.walletUrl, P = P || $.config.contractName || "default", this._keyStore = $.connection.signer.keyStore, this._authData = G || { allKeys: [] }, this._authDataKey = U, this.isSignedIn() || (this._completeSignInPromise = this._completeSignInWithAccessKey());
    }
    isSignedIn() {
      return !!this._authData.accountId;
    }
    isSignedInAsync() {
      return n(this, void 0, void 0, function* () {
        return this._completeSignInPromise ? (yield this._completeSignInPromise, this.isSignedIn()) : this.isSignedIn();
      });
    }
    getAccountId() {
      return this._authData.accountId || "";
    }
    requestSignIn({ contractId: $, methodNames: P, successUrl: U, failureUrl: G }) {
      return n(this, void 0, void 0, function* () {
        const D = new URL(window.location.href), Z = new URL(this._walletBaseUrl + w);
        if (Z.searchParams.set("success_url", U || D.href), Z.searchParams.set("failure_url", G || D.href), $) {
          yield (yield this._near.account($)).state(), Z.searchParams.set("contract_id", $);
          const te = c.KeyPair.fromRandom("ed25519");
          Z.searchParams.set("public_key", te.getPublicKey().toString()), yield this._keyStore.setKey(this._networkId, B + te.getPublicKey(), te);
        }
        P && P.forEach((J) => {
          Z.searchParams.append("methodNames", J);
        }), window.location.assign(Z.toString());
      });
    }
    requestSignTransactions({ transactions: $, meta: P, callbackUrl: U }) {
      return n(this, void 0, void 0, function* () {
        const G = new URL(window.location.href), D = new URL("sign", this._walletBaseUrl);
        D.searchParams.set("transactions", $.map((Z) => (0, d.serialize)(o.SCHEMA, Z)).map((Z) => Buffer.from(Z).toString("base64")).join(",")), D.searchParams.set("callbackUrl", U || G.href), P && D.searchParams.set("meta", P), window.location.assign(D.toString());
      });
    }
    _completeSignInWithAccessKey() {
      return n(this, void 0, void 0, function* () {
        const $ = new URL(window.location.href), P = $.searchParams.get("public_key") || "", U = ($.searchParams.get("all_keys") || "").split(","), G = $.searchParams.get("account_id") || "";
        if (G) {
          const D = {
            accountId: G,
            allKeys: U
          };
          window.localStorage.setItem(this._authDataKey, JSON.stringify(D)), P && (yield this._moveKeyFromTempToPermanent(G, P)), this._authData = D;
        }
        $.searchParams.delete("public_key"), $.searchParams.delete("all_keys"), $.searchParams.delete("account_id"), $.searchParams.delete("meta"), $.searchParams.delete("transactionHashes"), window.history.replaceState({}, document.title, $.toString());
      });
    }
    _moveKeyFromTempToPermanent($, P) {
      return n(this, void 0, void 0, function* () {
        const U = yield this._keyStore.getKey(this._networkId, B + P);
        yield this._keyStore.setKey(this._networkId, $, U), yield this._keyStore.removeKey(this._networkId, B + P);
      });
    }
    signOut() {
      this._authData = {}, window.localStorage.removeItem(this._authDataKey);
    }
    account() {
      return this._connectedAccount || (this._connectedAccount = new L(this, this._near.connection, this._authData.accountId)), this._connectedAccount;
    }
  }
  walletAccount.WalletConnection = H;
  class L extends t.Account {
    constructor($, P, U) {
      super(P, U), this.walletConnection = $;
    }
    signAndSendTransaction({ receiverId: $, actions: P, walletMeta: U, walletCallbackUrl: G = window.location.href }) {
      const D = Object.create(null, {
        signAndSendTransaction: { get: () => super.signAndSendTransaction }
      });
      return n(this, void 0, void 0, function* () {
        const Z = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
        let J = yield this.accessKeyForTransaction($, P, Z);
        if (!J)
          throw new Error(`Cannot find matching key for transaction sent to ${$}`);
        if (Z && Z.toString() === J.public_key)
          try {
            return yield D.signAndSendTransaction.call(this, { receiverId: $, actions: P });
          } catch (O) {
            if (O.type === "NotEnoughAllowance")
              J = yield this.accessKeyForTransaction($, P);
            else
              throw O;
          }
        const te = yield this.connection.provider.block({ finality: "final" }), ue = (0, a.baseDecode)(te.header.hash), he = c.PublicKey.from(J.public_key), Se = J.access_key.nonce.add(new p.default(1)), C = (0, o.createTransaction)(this.accountId, he, $, Se, P, ue);
        return yield this.walletConnection.requestSignTransactions({
          transactions: [C],
          meta: U,
          callbackUrl: G
        }), new Promise((O, V) => {
          setTimeout(() => {
            V(new Error("Failed to redirect to sign transaction"));
          }, 1e3);
        });
      });
    }
    accessKeyMatchesTransaction($, P, U) {
      return n(this, void 0, void 0, function* () {
        const { access_key: { permission: G } } = $;
        if (G === "FullAccess")
          return !0;
        if (G.FunctionCall) {
          const { receiver_id: D, method_names: Z } = G.FunctionCall;
          if (D === this.accountId && Z.includes(M))
            return !0;
          if (D === P) {
            if (U.length !== 1)
              return !1;
            const [{ functionCall: J }] = U;
            return J && (!J.deposit || J.deposit.toString() === "0") && (Z.length === 0 || Z.includes(J.methodName));
          }
        }
        return !1;
      });
    }
    accessKeyForTransaction($, P, U) {
      return n(this, void 0, void 0, function* () {
        const G = yield this.getAccessKeys();
        if (U) {
          const Z = G.find((J) => J.public_key.toString() === U.toString());
          if (Z && (yield this.accessKeyMatchesTransaction(Z, $, P)))
            return Z;
        }
        const D = this.walletConnection._authData.allKeys;
        for (const Z of G)
          if (D.indexOf(Z.public_key) !== -1 && (yield this.accessKeyMatchesTransaction(Z, $, P)))
            return Z;
        return null;
      });
    }
  }
  return walletAccount.ConnectedWalletAccount = L, walletAccount;
}
var hasRequiredCommonIndex;
function requireCommonIndex() {
  return hasRequiredCommonIndex || (hasRequiredCommonIndex = 1, function(n) {
    var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(U, G, D, Z) {
      Z === void 0 && (Z = D);
      var J = Object.getOwnPropertyDescriptor(G, D);
      (!J || ("get" in J ? !G.__esModule : J.writable || J.configurable)) && (J = { enumerable: !0, get: function() {
        return G[D];
      } }), Object.defineProperty(U, Z, J);
    } : function(U, G, D, Z) {
      Z === void 0 && (Z = D), U[Z] = G[D];
    }), t = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(U, G) {
      Object.defineProperty(U, "default", { enumerable: !0, value: G });
    } : function(U, G) {
      U.default = G;
    }), o = commonjsGlobal && commonjsGlobal.__importStar || function(U) {
      if (U && U.__esModule)
        return U;
      var G = {};
      if (U != null)
        for (var D in U)
          D !== "default" && Object.prototype.hasOwnProperty.call(U, D) && e(G, U, D);
      return t(G, U), G;
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), n.WalletConnection = n.ConnectedWalletAccount = n.Near = n.KeyPair = n.Signer = n.InMemorySigner = n.Contract = n.Connection = n.Account = n.multisig = n.validators = n.transactions = n.utils = n.providers = n.accountCreator = void 0;
    const c = o(requireProviders());
    n.providers = c;
    const a = o(requireUtils());
    n.utils = a;
    const d = o(transaction);
    n.transactions = d;
    const p = o(validators);
    n.validators = p;
    const w = requireAccount();
    Object.defineProperty(n, "Account", { enumerable: !0, get: function() {
      return w.Account;
    } });
    const M = o(requireAccount_multisig());
    n.multisig = M;
    const I = o(requireAccount_creator());
    n.accountCreator = I;
    const B = requireConnection();
    Object.defineProperty(n, "Connection", { enumerable: !0, get: function() {
      return B.Connection;
    } });
    const H = signer;
    Object.defineProperty(n, "Signer", { enumerable: !0, get: function() {
      return H.Signer;
    } }), Object.defineProperty(n, "InMemorySigner", { enumerable: !0, get: function() {
      return H.InMemorySigner;
    } });
    const L = requireContract();
    Object.defineProperty(n, "Contract", { enumerable: !0, get: function() {
      return L.Contract;
    } });
    const W = key_pair;
    Object.defineProperty(n, "KeyPair", { enumerable: !0, get: function() {
      return W.KeyPair;
    } });
    const $ = requireNear();
    Object.defineProperty(n, "Near", { enumerable: !0, get: function() {
      return $.Near;
    } });
    const P = requireWalletAccount();
    Object.defineProperty(n, "ConnectedWalletAccount", { enumerable: !0, get: function() {
      return P.ConnectedWalletAccount;
    } }), Object.defineProperty(n, "WalletConnection", { enumerable: !0, get: function() {
      return P.WalletConnection;
    } });
  }(commonIndex)), commonIndex;
}
var browserConnect = {}, __awaiter$8 = commonjsGlobal && commonjsGlobal.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
Object.defineProperty(browserConnect, "__esModule", { value: !0 });
browserConnect.connect = void 0;
const near_1 = requireNear();
function connect(n) {
  return __awaiter$8(this, void 0, void 0, function* () {
    return new near_1.Near(n);
  });
}
browserConnect.connect = connect;
var errorPolyfill = { exports: {} }, capability$3 = { exports: {} }, CapabilityDetector$1 = function() {
  this.tests = {}, this.cache = {};
};
CapabilityDetector$1.prototype = {
  constructor: CapabilityDetector$1,
  define: function(n, e) {
    if (typeof n != "string" || !(e instanceof Function))
      throw new Error("Invalid capability definition.");
    if (this.tests[n])
      throw new Error('Duplicated capability definition by "' + n + '".');
    this.tests[n] = e;
  },
  check: function(n) {
    if (!this.test(n))
      throw new Error('The current environment does not support "' + n + '", therefore we cannot continue.');
  },
  test: function(n) {
    if (this.cache[n] !== void 0)
      return this.cache[n];
    if (!this.tests[n])
      throw new Error('Unknown capability with name "' + n + '".');
    var e = this.tests[n];
    return this.cache[n] = !!e(), this.cache[n];
  }
};
var CapabilityDetector_1 = CapabilityDetector$1, CapabilityDetector = CapabilityDetector_1, detector = new CapabilityDetector(), capability$2 = function(n) {
  return detector.test(n);
};
capability$2.define = function(n, e) {
  detector.define(n, e);
};
capability$2.check = function(n) {
  detector.check(n);
};
capability$2.test = capability$2;
var lib$3 = capability$2, capability$1 = lib$3, define$1 = capability$1.define, test = capability$1.test;
define$1("strict mode", function() {
  return this === void 0;
});
define$1("arguments.callee.caller", function() {
  try {
    return function() {
      return arguments.callee.caller;
    }() === arguments.callee;
  } catch {
    return !1;
  }
});
define$1("es5", function() {
  return test("Array.prototype.forEach") && test("Array.prototype.map") && test("Function.prototype.bind") && test("Object.create") && test("Object.defineProperties") && test("Object.defineProperty") && test("Object.prototype.hasOwnProperty");
});
define$1("Array.prototype.forEach", function() {
  return Array.prototype.forEach;
});
define$1("Array.prototype.map", function() {
  return Array.prototype.map;
});
define$1("Function.prototype.bind", function() {
  return Function.prototype.bind;
});
define$1("Object.create", function() {
  return Object.create;
});
define$1("Object.defineProperties", function() {
  return Object.defineProperties;
});
define$1("Object.defineProperty", function() {
  return Object.defineProperty;
});
define$1("Object.prototype.hasOwnProperty", function() {
  return Object.prototype.hasOwnProperty;
});
define$1("Error.captureStackTrace", function() {
  return Error.captureStackTrace;
});
define$1("Error.prototype.stack", function() {
  try {
    throw new Error();
  } catch (n) {
    return n.stack || n.stacktrace;
  }
});
(function(n) {
  n.exports = lib$3;
})(capability$3);
capability$3.exports.check("es5");
var prepareStackTrace_1, hasRequiredPrepareStackTrace;
function requirePrepareStackTrace() {
  if (hasRequiredPrepareStackTrace)
    return prepareStackTrace_1;
  hasRequiredPrepareStackTrace = 1;
  var n = function(e, t, o) {
    var c = "";
    if (c += e.name || "Error", c += ": " + (e.message || ""), o instanceof Array)
      for (var a in o) {
        var d = o[a];
        c += `
   # ` + d;
      }
    for (var p in t) {
      var w = t[p];
      c += `
   at ` + w.toString();
    }
    return c;
  };
  return prepareStackTrace_1 = n, prepareStackTrace_1;
}
var v8, hasRequiredV8;
function requireV8() {
  if (hasRequiredV8)
    return v8;
  hasRequiredV8 = 1;
  var n = requirePrepareStackTrace();
  return v8 = function() {
    return Error.getStackTrace = function(e) {
      return e.stack;
    }, {
      prepareStackTrace: n
    };
  }, v8;
}
var o3 = { exports: {} }, Class_1, hasRequiredClass;
function requireClass() {
  if (hasRequiredClass)
    return Class_1;
  hasRequiredClass = 1;
  var n = function() {
    var e = /* @__PURE__ */ Object.create({
      Source: Object,
      config: {},
      buildArgs: []
    });
    function t(w) {
      var M = "config";
      if (w instanceof Function)
        M = "Source";
      else if (w instanceof Array)
        M = "buildArgs";
      else if (w instanceof Object)
        M = "config";
      else
        throw new Error("Invalid configuration option.");
      if (e.hasOwnProperty(M))
        throw new Error("Duplicated configuration option: " + M + ".");
      e[M] = w;
    }
    for (var o = 0, c = arguments.length; o < c; ++o)
      t(arguments[o]);
    var a = e.Source, d = e.config, p = e.buildArgs;
    return (a.extend || n.extend).call(a, d, p);
  };
  return n.factory = function() {
    return function() {
      var e = this;
      e.build instanceof Function && e.build.apply(e, arguments), e.init instanceof Function && e.init.apply(e, arguments);
    };
  }, n.extend = function(e, t) {
    var o = this;
    e || (e = {});
    var c;
    return e.prototype instanceof Object && e.prototype.constructor !== Object ? c = e.prototype.constructor : e.factory instanceof Function && (c = e.factory.call(o)), c = (o.clone || n.clone).call(o, c, t), (c.merge || n.merge).call(c, e), c;
  }, n.prototype.extend = function(e, t) {
    var o = this, c = (o.clone || n.prototype.clone).apply(o, t);
    return (c.merge || n.prototype.merge).call(c, e), c;
  }, n.clone = function(e, t) {
    var o = this;
    e instanceof Function || (e = (o.factory || n.factory).call(o)), e.prototype = (o.prototype.clone || n.prototype.clone).apply(o.prototype, t || []), e.prototype.constructor = e;
    for (var c in o)
      c !== "prototype" && (e[c] = o[c]);
    return e;
  }, n.prototype.clone = function() {
    var e = this, t = Object.create(e);
    return t.build instanceof Function && t.build.apply(t, arguments), t;
  }, n.merge = function(e) {
    var t = this;
    for (var o in e)
      o !== "prototype" && (t[o] = e[o]);
    return e.prototype instanceof Object && (t.prototype.merge || n.prototype.merge).call(t.prototype, e.prototype), t;
  }, n.prototype.merge = function(e) {
    var t = this;
    for (var o in e)
      o !== "constructor" && (t[o] = e[o]);
    return t;
  }, n.absorb = function(e) {
    var t = this;
    for (var o in e)
      o !== "prototype" && (t[o] === void 0 || t[o] === Function.prototype[o]) && (t[o] = e[o]);
    return e.prototype instanceof Object && (t.prototype.absorb || n.prototype.absorb).call(t.prototype, e.prototype), t;
  }, n.prototype.absorb = function(e) {
    var t = this;
    for (var o in e)
      o !== "constructor" && (t[o] === void 0 || t[o] === Object.prototype[o]) && (t[o] = e[o]);
    return t;
  }, n.getAncestor = function() {
    var e = this;
    if (e !== e.prototype.constructor)
      return e.prototype.constructor;
  }, n.newInstance = function() {
    var e = this, t = Object.create(this.prototype);
    return e.apply(t, arguments), t;
  }, Class_1 = n, Class_1;
}
var abstractMethod, hasRequiredAbstractMethod;
function requireAbstractMethod() {
  return hasRequiredAbstractMethod || (hasRequiredAbstractMethod = 1, abstractMethod = function() {
    throw new Error("Not implemented.");
  }), abstractMethod;
}
var lib$2, hasRequiredLib$1;
function requireLib$1() {
  return hasRequiredLib$1 || (hasRequiredLib$1 = 1, lib$2 = {
    Class: requireClass(),
    abstractMethod: requireAbstractMethod()
  }), lib$2;
}
var hasRequiredO3;
function requireO3() {
  return hasRequiredO3 || (hasRequiredO3 = 1, function(n) {
    n.exports = requireLib$1();
  }(o3)), o3.exports;
}
var u3 = { exports: {} }, cache_1, hasRequiredCache;
function requireCache() {
  if (hasRequiredCache)
    return cache_1;
  hasRequiredCache = 1;
  var n = function(e) {
    var t = !1, o;
    return e instanceof Function || (t = !0, o = e, e = null), function() {
      return t || (t = !0, o = e.apply(this, arguments), e = null), o;
    };
  };
  return cache_1 = n, cache_1;
}
var eachCombination, hasRequiredEachCombination;
function requireEachCombination() {
  return hasRequiredEachCombination || (hasRequiredEachCombination = 1, eachCombination = function n(e, t, o) {
    if (o || (o = []), o.length < e.length) {
      var c = e[o.length];
      for (var a in c)
        o[o.length] = c[a], n(e, t, o), --o.length;
    } else
      t.apply(null, o);
  }), eachCombination;
}
var lib$1, hasRequiredLib;
function requireLib() {
  return hasRequiredLib || (hasRequiredLib = 1, lib$1 = {
    cache: requireCache(),
    eachCombination: requireEachCombination()
  }), lib$1;
}
var hasRequiredU3;
function requireU3() {
  return hasRequiredU3 || (hasRequiredU3 = 1, function(n) {
    n.exports = requireLib();
  }(u3)), u3.exports;
}
var FrameStringSource, hasRequiredFrameStringSource;
function requireFrameStringSource() {
  if (hasRequiredFrameStringSource)
    return FrameStringSource;
  hasRequiredFrameStringSource = 1;
  var n = requireO3().Class, e = requireO3().abstractMethod, t = requireU3().eachCombination, o = requireU3().cache, c = capability$3.exports, a = n(Object, {
    prototype: {
      captureFrameStrings: function(p) {
        var w = this.createError();
        p.unshift(this.captureFrameStrings), p.unshift(this.createError);
        var M = this.getFrameStrings(w), I = M.slice(p.length), B = [];
        if (c("arguments.callee.caller")) {
          var H = [
            this.createError,
            this.captureFrameStrings
          ];
          try {
            for (var L = arguments.callee; L = L.caller; )
              H.push(L);
          } catch {
          }
          B = H.slice(p.length);
        }
        return {
          frameStrings: I,
          functionValues: B
        };
      },
      getFrameStrings: function(p) {
        var w = p.message || "", M = p.name || "", I = this.getStackString(p);
        if (I !== void 0) {
          var B = I.split(`
`), H = 0, L = B.length;
          return this.hasHeader && (H += M.split(`
`).length + w.split(`
`).length - 1), this.hasFooter && (L -= 1), B.slice(H, L);
        }
      },
      createError: e,
      getStackString: e,
      hasHeader: void 0,
      hasFooter: void 0
    }
  }), d = n(Object, {
    prototype: {
      calibrateClass: function(p) {
        return this.calibrateMethods(p) && this.calibrateEnvelope(p);
      },
      calibrateMethods: function(p) {
        try {
          t([[
            function(w) {
              return new Error(w);
            },
            function(w) {
              try {
                throw new Error(w);
              } catch (M) {
                return M;
              }
            }
          ], [
            function(w) {
              return w.stack;
            },
            function(w) {
              return w.stacktrace;
            }
          ]], function(w, M) {
            if (M(w()))
              throw {
                getStackString: M,
                createError: w
              };
          });
        } catch (w) {
          return n.merge.call(p, {
            prototype: w
          }), !0;
        }
        return !1;
      },
      calibrateEnvelope: function(p) {
        var w = p.prototype.getStackString, M = p.prototype.createError, I = w(M("marker")), B = I.split(`
`);
        return n.merge.call(p, {
          prototype: {
            hasHeader: /marker/.test(B[0]),
            hasFooter: B[B.length - 1] === ""
          }
        }), !0;
      }
    }
  });
  return FrameStringSource = {
    getClass: o(function() {
      var p;
      if (p)
        return p;
      p = n(a, {});
      var w = new d();
      if (!w.calibrateClass(p))
        throw new Error("Cannot read Error.prototype.stack in this environment.");
      return p;
    }),
    getInstance: o(function() {
      var p = this.getClass(), w = new p();
      return w;
    })
  }, FrameStringSource;
}
var Frame_1, hasRequiredFrame;
function requireFrame() {
  if (hasRequiredFrame)
    return Frame_1;
  hasRequiredFrame = 1;
  var n = requireO3().Class, e = requireO3().abstractMethod, t = n(Object, {
    prototype: {
      init: n.prototype.merge,
      frameString: void 0,
      toString: function() {
        return this.frameString;
      },
      functionValue: void 0,
      getThis: e,
      getTypeName: e,
      getFunction: function() {
        return this.functionValue;
      },
      getFunctionName: e,
      getMethodName: e,
      getFileName: e,
      getLineNumber: e,
      getColumnNumber: e,
      getEvalOrigin: e,
      isTopLevel: e,
      isEval: e,
      isNative: e,
      isConstructor: e
    }
  });
  return Frame_1 = t, Frame_1;
}
var FrameStringParser_1, hasRequiredFrameStringParser;
function requireFrameStringParser() {
  if (hasRequiredFrameStringParser)
    return FrameStringParser_1;
  hasRequiredFrameStringParser = 1;
  var n = requireO3().Class, e = requireFrame(), t = requireU3().cache, o = n(Object, {
    prototype: {
      stackParser: null,
      frameParser: null,
      locationParsers: null,
      constructor: function(c) {
        n.prototype.merge.call(this, c);
      },
      getFrames: function(c, a) {
        for (var d = [], p = 0, w = c.length; p < w; ++p)
          d[p] = this.getFrame(c[p], a[p]);
        return d;
      },
      getFrame: function(c, a) {
        var d = {
          frameString: c,
          functionValue: a
        };
        return new e(d);
      }
    }
  });
  return FrameStringParser_1 = {
    getClass: t(function() {
      return o;
    }),
    getInstance: t(function() {
      var c = this.getClass(), a = new c();
      return a;
    })
  }, FrameStringParser_1;
}
var nonV8, hasRequiredNonV8;
function requireNonV8() {
  if (hasRequiredNonV8)
    return nonV8;
  hasRequiredNonV8 = 1;
  var n = requireFrameStringSource(), e = requireFrameStringParser(), t = requireU3().cache, o = requirePrepareStackTrace();
  return nonV8 = function() {
    return Error.captureStackTrace = function c(a, d) {
      var p, w = [
        c
      ];
      d && w.push(d);
      var M = n.getInstance().captureFrameStrings(w);
      Object.defineProperties(a, {
        stack: {
          configurable: !0,
          get: t(function() {
            var I = e.getInstance().getFrames(M.frameStrings, M.functionValues);
            return (Error.prepareStackTrace || o)(a, I, p);
          })
        },
        cachedStack: {
          configurable: !0,
          writable: !0,
          enumerable: !1,
          value: !0
        }
      });
    }, Error.getStackTrace = function(c) {
      if (c.cachedStack)
        return c.stack;
      var a = n.getInstance().getFrameStrings(c), d = [], p;
      a ? d = e.getInstance().getFrames(a, []) : p = [
        "The stack is not readable by unthrown errors in this environment."
      ];
      var w = (Error.prepareStackTrace || o)(c, d, p);
      if (a)
        try {
          Object.defineProperties(c, {
            stack: {
              configurable: !0,
              writable: !0,
              enumerable: !1,
              value: w
            },
            cachedStack: {
              configurable: !0,
              writable: !0,
              enumerable: !1,
              value: !0
            }
          });
        } catch {
        }
      return w;
    }, {
      prepareStackTrace: o
    };
  }, nonV8;
}
var unsupported, hasRequiredUnsupported;
function requireUnsupported() {
  if (hasRequiredUnsupported)
    return unsupported;
  hasRequiredUnsupported = 1;
  var n = requireU3().cache, e = requirePrepareStackTrace();
  return unsupported = function() {
    return Error.captureStackTrace = function(t, o) {
      Object.defineProperties(t, {
        stack: {
          configurable: !0,
          get: n(function() {
            return (Error.prepareStackTrace || e)(t, []);
          })
        },
        cachedStack: {
          configurable: !0,
          writable: !0,
          enumerable: !1,
          value: !0
        }
      });
    }, Error.getStackTrace = function(t) {
      if (t.cachedStack)
        return t.stack;
      var o = (Error.prepareStackTrace || e)(t, []);
      try {
        Object.defineProperties(t, {
          stack: {
            configurable: !0,
            writable: !0,
            enumerable: !1,
            value: o
          },
          cachedStack: {
            configurable: !0,
            writable: !0,
            enumerable: !1,
            value: !0
          }
        });
      } catch {
      }
      return o;
    }, {
      prepareStackTrace: e
    };
  }, unsupported;
}
var capability = capability$3.exports, polyfill;
capability("Error.captureStackTrace") ? polyfill = requireV8() : capability("Error.prototype.stack") ? polyfill = requireNonV8() : polyfill = requireUnsupported();
var lib = polyfill();
(function(n) {
  n.exports = lib;
})(errorPolyfill);
(function(n) {
  var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(a, d, p, w) {
    w === void 0 && (w = p);
    var M = Object.getOwnPropertyDescriptor(d, p);
    (!M || ("get" in M ? !d.__esModule : M.writable || M.configurable)) && (M = { enumerable: !0, get: function() {
      return d[p];
    } }), Object.defineProperty(a, w, M);
  } : function(a, d, p, w) {
    w === void 0 && (w = p), a[w] = d[p];
  }), t = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(a, d) {
    Object.defineProperty(a, "default", { enumerable: !0, value: d });
  } : function(a, d) {
    a.default = d;
  }), o = commonjsGlobal && commonjsGlobal.__importStar || function(a) {
    if (a && a.__esModule)
      return a;
    var d = {};
    if (a != null)
      for (var p in a)
        p !== "default" && Object.prototype.hasOwnProperty.call(a, p) && e(d, a, p);
    return t(d, a), d;
  }, c = commonjsGlobal && commonjsGlobal.__exportStar || function(a, d) {
    for (var p in a)
      p !== "default" && !Object.prototype.hasOwnProperty.call(d, p) && e(d, a, p);
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), n.keyStores = void 0, n.keyStores = o(browserIndex), c(requireCommonIndex(), n), c(browserConnect, n);
})(browserIndex$1);
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(n, e, t, o) {
  o === void 0 && (o = t);
  var c = Object.getOwnPropertyDescriptor(e, t);
  (!c || ("get" in c ? !e.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
    return e[t];
  } }), Object.defineProperty(n, o, c);
} : function(n, e, t, o) {
  o === void 0 && (o = t), n[o] = e[t];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(n, e) {
  Object.defineProperty(n, "default", { enumerable: !0, value: e });
} : function(n, e) {
  n.default = e;
}), __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      t !== "default" && Object.prototype.hasOwnProperty.call(n, t) && __createBinding(e, n, t);
  return __setModuleDefault(e, n), e;
};
Object.defineProperty(NearProvider$1, "__esModule", { value: !0 });
NearProvider$1.NearProvider = void 0;
const face_types_1$3 = dist, ethers_1 = require$$1$3, nearAPI = __importStar(browserIndex$1);
class NearProvider {
  constructor(e) {
    this.internal = e;
  }
  async getPublicKeys() {
    return (await this.internal.getAddresses(face_types_1$3.Blockchain.NEAR)).map((t) => nearAPI.utils.PublicKey.fromString(nearAPI.utils.serialize.base_encode(Buffer.from(t, "hex"))));
  }
  async getBalance(e, t) {
    const o = await this.internal.sendRpc({
      method: face_types_1$3.JsonRpcMethod.near_get_balance,
      params: [e, t]
    });
    return ethers_1.BigNumber.from(o);
  }
  async signAndSendTransaction(e) {
    const t = {
      serializedHex: Buffer.from(nearAPI.utils.serialize.serialize(nearAPI.transactions.SCHEMA, e)).toString("hex")
    };
    return await this.internal.sendRpc({
      method: "near_broadcast_tx_async",
      params: [t]
    });
  }
}
NearProvider$1.NearProvider = NearProvider;
Object.defineProperty(Near$1, "__esModule", { value: !0 });
Near$1.Near = void 0;
const NearProvider_1 = NearProvider$1;
class Near {
  constructor(e) {
    this.internal = e;
  }
  getProvider() {
    return new NearProvider_1.NearProvider(this.internal);
  }
}
Near$1.Near = Near;
var Solana$1 = {}, SolanaProvider$1 = {}, buffer = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(n) {
  const e = base64Js, t = ieee754, o = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  n.Buffer = p, n.SlowBuffer = G, n.INSPECT_MAX_BYTES = 50;
  const c = 2147483647;
  n.kMaxLength = c, p.TYPED_ARRAY_SUPPORT = a(), !p.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a() {
    try {
      const T = new Uint8Array(1), A = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(A, Uint8Array.prototype), Object.setPrototypeOf(T, A), T.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(p.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (!!p.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(p.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (!!p.isBuffer(this))
        return this.byteOffset;
    }
  });
  function d(T) {
    if (T > c)
      throw new RangeError('The value "' + T + '" is invalid for option "size"');
    const A = new Uint8Array(T);
    return Object.setPrototypeOf(A, p.prototype), A;
  }
  function p(T, A, E) {
    if (typeof T == "number") {
      if (typeof A == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return B(T);
    }
    return w(T, A, E);
  }
  p.poolSize = 8192;
  function w(T, A, E) {
    if (typeof T == "string")
      return H(T, A);
    if (ArrayBuffer.isView(T))
      return W(T);
    if (T == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof T
      );
    if (it(T, ArrayBuffer) || T && it(T.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (it(T, SharedArrayBuffer) || T && it(T.buffer, SharedArrayBuffer)))
      return $(T, A, E);
    if (typeof T == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const F = T.valueOf && T.valueOf();
    if (F != null && F !== T)
      return p.from(F, A, E);
    const ie = P(T);
    if (ie)
      return ie;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof T[Symbol.toPrimitive] == "function")
      return p.from(T[Symbol.toPrimitive]("string"), A, E);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof T
    );
  }
  p.from = function(T, A, E) {
    return w(T, A, E);
  }, Object.setPrototypeOf(p.prototype, Uint8Array.prototype), Object.setPrototypeOf(p, Uint8Array);
  function M(T) {
    if (typeof T != "number")
      throw new TypeError('"size" argument must be of type number');
    if (T < 0)
      throw new RangeError('The value "' + T + '" is invalid for option "size"');
  }
  function I(T, A, E) {
    return M(T), T <= 0 ? d(T) : A !== void 0 ? typeof E == "string" ? d(T).fill(A, E) : d(T).fill(A) : d(T);
  }
  p.alloc = function(T, A, E) {
    return I(T, A, E);
  };
  function B(T) {
    return M(T), d(T < 0 ? 0 : U(T) | 0);
  }
  p.allocUnsafe = function(T) {
    return B(T);
  }, p.allocUnsafeSlow = function(T) {
    return B(T);
  };
  function H(T, A) {
    if ((typeof A != "string" || A === "") && (A = "utf8"), !p.isEncoding(A))
      throw new TypeError("Unknown encoding: " + A);
    const E = D(T, A) | 0;
    let F = d(E);
    const ie = F.write(T, A);
    return ie !== E && (F = F.slice(0, ie)), F;
  }
  function L(T) {
    const A = T.length < 0 ? 0 : U(T.length) | 0, E = d(A);
    for (let F = 0; F < A; F += 1)
      E[F] = T[F] & 255;
    return E;
  }
  function W(T) {
    if (it(T, Uint8Array)) {
      const A = new Uint8Array(T);
      return $(A.buffer, A.byteOffset, A.byteLength);
    }
    return L(T);
  }
  function $(T, A, E) {
    if (A < 0 || T.byteLength < A)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (T.byteLength < A + (E || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let F;
    return A === void 0 && E === void 0 ? F = new Uint8Array(T) : E === void 0 ? F = new Uint8Array(T, A) : F = new Uint8Array(T, A, E), Object.setPrototypeOf(F, p.prototype), F;
  }
  function P(T) {
    if (p.isBuffer(T)) {
      const A = U(T.length) | 0, E = d(A);
      return E.length === 0 || T.copy(E, 0, 0, A), E;
    }
    if (T.length !== void 0)
      return typeof T.length != "number" || ke(T.length) ? d(0) : L(T);
    if (T.type === "Buffer" && Array.isArray(T.data))
      return L(T.data);
  }
  function U(T) {
    if (T >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return T | 0;
  }
  function G(T) {
    return +T != T && (T = 0), p.alloc(+T);
  }
  p.isBuffer = function(A) {
    return A != null && A._isBuffer === !0 && A !== p.prototype;
  }, p.compare = function(A, E) {
    if (it(A, Uint8Array) && (A = p.from(A, A.offset, A.byteLength)), it(E, Uint8Array) && (E = p.from(E, E.offset, E.byteLength)), !p.isBuffer(A) || !p.isBuffer(E))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (A === E)
      return 0;
    let F = A.length, ie = E.length;
    for (let ne = 0, ce = Math.min(F, ie); ne < ce; ++ne)
      if (A[ne] !== E[ne]) {
        F = A[ne], ie = E[ne];
        break;
      }
    return F < ie ? -1 : ie < F ? 1 : 0;
  }, p.isEncoding = function(A) {
    switch (String(A).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, p.concat = function(A, E) {
    if (!Array.isArray(A))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (A.length === 0)
      return p.alloc(0);
    let F;
    if (E === void 0)
      for (E = 0, F = 0; F < A.length; ++F)
        E += A[F].length;
    const ie = p.allocUnsafe(E);
    let ne = 0;
    for (F = 0; F < A.length; ++F) {
      let ce = A[F];
      if (it(ce, Uint8Array))
        ne + ce.length > ie.length ? (p.isBuffer(ce) || (ce = p.from(ce)), ce.copy(ie, ne)) : Uint8Array.prototype.set.call(
          ie,
          ce,
          ne
        );
      else if (p.isBuffer(ce))
        ce.copy(ie, ne);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ne += ce.length;
    }
    return ie;
  };
  function D(T, A) {
    if (p.isBuffer(T))
      return T.length;
    if (ArrayBuffer.isView(T) || it(T, ArrayBuffer))
      return T.byteLength;
    if (typeof T != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof T
      );
    const E = T.length, F = arguments.length > 2 && arguments[2] === !0;
    if (!F && E === 0)
      return 0;
    let ie = !1;
    for (; ; )
      switch (A) {
        case "ascii":
        case "latin1":
        case "binary":
          return E;
        case "utf8":
        case "utf-8":
          return z(T).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return E * 2;
        case "hex":
          return E >>> 1;
        case "base64":
          return me(T).length;
        default:
          if (ie)
            return F ? -1 : z(T).length;
          A = ("" + A).toLowerCase(), ie = !0;
      }
  }
  p.byteLength = D;
  function Z(T, A, E) {
    let F = !1;
    if ((A === void 0 || A < 0) && (A = 0), A > this.length || ((E === void 0 || E > this.length) && (E = this.length), E <= 0) || (E >>>= 0, A >>>= 0, E <= A))
      return "";
    for (T || (T = "utf8"); ; )
      switch (T) {
        case "hex":
          return _(this, A, E);
        case "utf8":
        case "utf-8":
          return u(this, A, E);
        case "ascii":
          return y(this, A, E);
        case "latin1":
        case "binary":
          return m(this, A, E);
        case "base64":
          return x(this, A, E);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return R(this, A, E);
        default:
          if (F)
            throw new TypeError("Unknown encoding: " + T);
          T = (T + "").toLowerCase(), F = !0;
      }
  }
  p.prototype._isBuffer = !0;
  function J(T, A, E) {
    const F = T[A];
    T[A] = T[E], T[E] = F;
  }
  p.prototype.swap16 = function() {
    const A = this.length;
    if (A % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let E = 0; E < A; E += 2)
      J(this, E, E + 1);
    return this;
  }, p.prototype.swap32 = function() {
    const A = this.length;
    if (A % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let E = 0; E < A; E += 4)
      J(this, E, E + 3), J(this, E + 1, E + 2);
    return this;
  }, p.prototype.swap64 = function() {
    const A = this.length;
    if (A % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let E = 0; E < A; E += 8)
      J(this, E, E + 7), J(this, E + 1, E + 6), J(this, E + 2, E + 5), J(this, E + 3, E + 4);
    return this;
  }, p.prototype.toString = function() {
    const A = this.length;
    return A === 0 ? "" : arguments.length === 0 ? u(this, 0, A) : Z.apply(this, arguments);
  }, p.prototype.toLocaleString = p.prototype.toString, p.prototype.equals = function(A) {
    if (!p.isBuffer(A))
      throw new TypeError("Argument must be a Buffer");
    return this === A ? !0 : p.compare(this, A) === 0;
  }, p.prototype.inspect = function() {
    let A = "";
    const E = n.INSPECT_MAX_BYTES;
    return A = this.toString("hex", 0, E).replace(/(.{2})/g, "$1 ").trim(), this.length > E && (A += " ... "), "<Buffer " + A + ">";
  }, o && (p.prototype[o] = p.prototype.inspect), p.prototype.compare = function(A, E, F, ie, ne) {
    if (it(A, Uint8Array) && (A = p.from(A, A.offset, A.byteLength)), !p.isBuffer(A))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof A
      );
    if (E === void 0 && (E = 0), F === void 0 && (F = A ? A.length : 0), ie === void 0 && (ie = 0), ne === void 0 && (ne = this.length), E < 0 || F > A.length || ie < 0 || ne > this.length)
      throw new RangeError("out of range index");
    if (ie >= ne && E >= F)
      return 0;
    if (ie >= ne)
      return -1;
    if (E >= F)
      return 1;
    if (E >>>= 0, F >>>= 0, ie >>>= 0, ne >>>= 0, this === A)
      return 0;
    let ce = ne - ie, nt = F - E;
    const Be = Math.min(ce, nt), Ce = this.slice(ie, ne), _t = A.slice(E, F);
    for (let Me = 0; Me < Be; ++Me)
      if (Ce[Me] !== _t[Me]) {
        ce = Ce[Me], nt = _t[Me];
        break;
      }
    return ce < nt ? -1 : nt < ce ? 1 : 0;
  };
  function te(T, A, E, F, ie) {
    if (T.length === 0)
      return -1;
    if (typeof E == "string" ? (F = E, E = 0) : E > 2147483647 ? E = 2147483647 : E < -2147483648 && (E = -2147483648), E = +E, ke(E) && (E = ie ? 0 : T.length - 1), E < 0 && (E = T.length + E), E >= T.length) {
      if (ie)
        return -1;
      E = T.length - 1;
    } else if (E < 0)
      if (ie)
        E = 0;
      else
        return -1;
    if (typeof A == "string" && (A = p.from(A, F)), p.isBuffer(A))
      return A.length === 0 ? -1 : ue(T, A, E, F, ie);
    if (typeof A == "number")
      return A = A & 255, typeof Uint8Array.prototype.indexOf == "function" ? ie ? Uint8Array.prototype.indexOf.call(T, A, E) : Uint8Array.prototype.lastIndexOf.call(T, A, E) : ue(T, [A], E, F, ie);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ue(T, A, E, F, ie) {
    let ne = 1, ce = T.length, nt = A.length;
    if (F !== void 0 && (F = String(F).toLowerCase(), F === "ucs2" || F === "ucs-2" || F === "utf16le" || F === "utf-16le")) {
      if (T.length < 2 || A.length < 2)
        return -1;
      ne = 2, ce /= 2, nt /= 2, E /= 2;
    }
    function Be(_t, Me) {
      return ne === 1 ? _t[Me] : _t.readUInt16BE(Me * ne);
    }
    let Ce;
    if (ie) {
      let _t = -1;
      for (Ce = E; Ce < ce; Ce++)
        if (Be(T, Ce) === Be(A, _t === -1 ? 0 : Ce - _t)) {
          if (_t === -1 && (_t = Ce), Ce - _t + 1 === nt)
            return _t * ne;
        } else
          _t !== -1 && (Ce -= Ce - _t), _t = -1;
    } else
      for (E + nt > ce && (E = ce - nt), Ce = E; Ce >= 0; Ce--) {
        let _t = !0;
        for (let Me = 0; Me < nt; Me++)
          if (Be(T, Ce + Me) !== Be(A, Me)) {
            _t = !1;
            break;
          }
        if (_t)
          return Ce;
      }
    return -1;
  }
  p.prototype.includes = function(A, E, F) {
    return this.indexOf(A, E, F) !== -1;
  }, p.prototype.indexOf = function(A, E, F) {
    return te(this, A, E, F, !0);
  }, p.prototype.lastIndexOf = function(A, E, F) {
    return te(this, A, E, F, !1);
  };
  function he(T, A, E, F) {
    E = Number(E) || 0;
    const ie = T.length - E;
    F ? (F = Number(F), F > ie && (F = ie)) : F = ie;
    const ne = A.length;
    F > ne / 2 && (F = ne / 2);
    let ce;
    for (ce = 0; ce < F; ++ce) {
      const nt = parseInt(A.substr(ce * 2, 2), 16);
      if (ke(nt))
        return ce;
      T[E + ce] = nt;
    }
    return ce;
  }
  function Se(T, A, E, F) {
    return Ae(z(A, T.length - E), T, E, F);
  }
  function C(T, A, E, F) {
    return Ae(ee(A), T, E, F);
  }
  function O(T, A, E, F) {
    return Ae(me(A), T, E, F);
  }
  function V(T, A, E, F) {
    return Ae(ve(A, T.length - E), T, E, F);
  }
  p.prototype.write = function(A, E, F, ie) {
    if (E === void 0)
      ie = "utf8", F = this.length, E = 0;
    else if (F === void 0 && typeof E == "string")
      ie = E, F = this.length, E = 0;
    else if (isFinite(E))
      E = E >>> 0, isFinite(F) ? (F = F >>> 0, ie === void 0 && (ie = "utf8")) : (ie = F, F = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ne = this.length - E;
    if ((F === void 0 || F > ne) && (F = ne), A.length > 0 && (F < 0 || E < 0) || E > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ie || (ie = "utf8");
    let ce = !1;
    for (; ; )
      switch (ie) {
        case "hex":
          return he(this, A, E, F);
        case "utf8":
        case "utf-8":
          return Se(this, A, E, F);
        case "ascii":
        case "latin1":
        case "binary":
          return C(this, A, E, F);
        case "base64":
          return O(this, A, E, F);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return V(this, A, E, F);
        default:
          if (ce)
            throw new TypeError("Unknown encoding: " + ie);
          ie = ("" + ie).toLowerCase(), ce = !0;
      }
  }, p.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function x(T, A, E) {
    return A === 0 && E === T.length ? e.fromByteArray(T) : e.fromByteArray(T.slice(A, E));
  }
  function u(T, A, E) {
    E = Math.min(T.length, E);
    const F = [];
    let ie = A;
    for (; ie < E; ) {
      const ne = T[ie];
      let ce = null, nt = ne > 239 ? 4 : ne > 223 ? 3 : ne > 191 ? 2 : 1;
      if (ie + nt <= E) {
        let Be, Ce, _t, Me;
        switch (nt) {
          case 1:
            ne < 128 && (ce = ne);
            break;
          case 2:
            Be = T[ie + 1], (Be & 192) === 128 && (Me = (ne & 31) << 6 | Be & 63, Me > 127 && (ce = Me));
            break;
          case 3:
            Be = T[ie + 1], Ce = T[ie + 2], (Be & 192) === 128 && (Ce & 192) === 128 && (Me = (ne & 15) << 12 | (Be & 63) << 6 | Ce & 63, Me > 2047 && (Me < 55296 || Me > 57343) && (ce = Me));
            break;
          case 4:
            Be = T[ie + 1], Ce = T[ie + 2], _t = T[ie + 3], (Be & 192) === 128 && (Ce & 192) === 128 && (_t & 192) === 128 && (Me = (ne & 15) << 18 | (Be & 63) << 12 | (Ce & 63) << 6 | _t & 63, Me > 65535 && Me < 1114112 && (ce = Me));
        }
      }
      ce === null ? (ce = 65533, nt = 1) : ce > 65535 && (ce -= 65536, F.push(ce >>> 10 & 1023 | 55296), ce = 56320 | ce & 1023), F.push(ce), ie += nt;
    }
    return g(F);
  }
  const h = 4096;
  function g(T) {
    const A = T.length;
    if (A <= h)
      return String.fromCharCode.apply(String, T);
    let E = "", F = 0;
    for (; F < A; )
      E += String.fromCharCode.apply(
        String,
        T.slice(F, F += h)
      );
    return E;
  }
  function y(T, A, E) {
    let F = "";
    E = Math.min(T.length, E);
    for (let ie = A; ie < E; ++ie)
      F += String.fromCharCode(T[ie] & 127);
    return F;
  }
  function m(T, A, E) {
    let F = "";
    E = Math.min(T.length, E);
    for (let ie = A; ie < E; ++ie)
      F += String.fromCharCode(T[ie]);
    return F;
  }
  function _(T, A, E) {
    const F = T.length;
    (!A || A < 0) && (A = 0), (!E || E < 0 || E > F) && (E = F);
    let ie = "";
    for (let ne = A; ne < E; ++ne)
      ie += qe[T[ne]];
    return ie;
  }
  function R(T, A, E) {
    const F = T.slice(A, E);
    let ie = "";
    for (let ne = 0; ne < F.length - 1; ne += 2)
      ie += String.fromCharCode(F[ne] + F[ne + 1] * 256);
    return ie;
  }
  p.prototype.slice = function(A, E) {
    const F = this.length;
    A = ~~A, E = E === void 0 ? F : ~~E, A < 0 ? (A += F, A < 0 && (A = 0)) : A > F && (A = F), E < 0 ? (E += F, E < 0 && (E = 0)) : E > F && (E = F), E < A && (E = A);
    const ie = this.subarray(A, E);
    return Object.setPrototypeOf(ie, p.prototype), ie;
  };
  function b(T, A, E) {
    if (T % 1 !== 0 || T < 0)
      throw new RangeError("offset is not uint");
    if (T + A > E)
      throw new RangeError("Trying to access beyond buffer length");
  }
  p.prototype.readUintLE = p.prototype.readUIntLE = function(A, E, F) {
    A = A >>> 0, E = E >>> 0, F || b(A, E, this.length);
    let ie = this[A], ne = 1, ce = 0;
    for (; ++ce < E && (ne *= 256); )
      ie += this[A + ce] * ne;
    return ie;
  }, p.prototype.readUintBE = p.prototype.readUIntBE = function(A, E, F) {
    A = A >>> 0, E = E >>> 0, F || b(A, E, this.length);
    let ie = this[A + --E], ne = 1;
    for (; E > 0 && (ne *= 256); )
      ie += this[A + --E] * ne;
    return ie;
  }, p.prototype.readUint8 = p.prototype.readUInt8 = function(A, E) {
    return A = A >>> 0, E || b(A, 1, this.length), this[A];
  }, p.prototype.readUint16LE = p.prototype.readUInt16LE = function(A, E) {
    return A = A >>> 0, E || b(A, 2, this.length), this[A] | this[A + 1] << 8;
  }, p.prototype.readUint16BE = p.prototype.readUInt16BE = function(A, E) {
    return A = A >>> 0, E || b(A, 2, this.length), this[A] << 8 | this[A + 1];
  }, p.prototype.readUint32LE = p.prototype.readUInt32LE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), (this[A] | this[A + 1] << 8 | this[A + 2] << 16) + this[A + 3] * 16777216;
  }, p.prototype.readUint32BE = p.prototype.readUInt32BE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), this[A] * 16777216 + (this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3]);
  }, p.prototype.readBigUInt64LE = or(function(A) {
    A = A >>> 0, rt(A, "offset");
    const E = this[A], F = this[A + 7];
    (E === void 0 || F === void 0) && xe(A, this.length - 8);
    const ie = E + this[++A] * 2 ** 8 + this[++A] * 2 ** 16 + this[++A] * 2 ** 24, ne = this[++A] + this[++A] * 2 ** 8 + this[++A] * 2 ** 16 + F * 2 ** 24;
    return BigInt(ie) + (BigInt(ne) << BigInt(32));
  }), p.prototype.readBigUInt64BE = or(function(A) {
    A = A >>> 0, rt(A, "offset");
    const E = this[A], F = this[A + 7];
    (E === void 0 || F === void 0) && xe(A, this.length - 8);
    const ie = E * 2 ** 24 + this[++A] * 2 ** 16 + this[++A] * 2 ** 8 + this[++A], ne = this[++A] * 2 ** 24 + this[++A] * 2 ** 16 + this[++A] * 2 ** 8 + F;
    return (BigInt(ie) << BigInt(32)) + BigInt(ne);
  }), p.prototype.readIntLE = function(A, E, F) {
    A = A >>> 0, E = E >>> 0, F || b(A, E, this.length);
    let ie = this[A], ne = 1, ce = 0;
    for (; ++ce < E && (ne *= 256); )
      ie += this[A + ce] * ne;
    return ne *= 128, ie >= ne && (ie -= Math.pow(2, 8 * E)), ie;
  }, p.prototype.readIntBE = function(A, E, F) {
    A = A >>> 0, E = E >>> 0, F || b(A, E, this.length);
    let ie = E, ne = 1, ce = this[A + --ie];
    for (; ie > 0 && (ne *= 256); )
      ce += this[A + --ie] * ne;
    return ne *= 128, ce >= ne && (ce -= Math.pow(2, 8 * E)), ce;
  }, p.prototype.readInt8 = function(A, E) {
    return A = A >>> 0, E || b(A, 1, this.length), this[A] & 128 ? (255 - this[A] + 1) * -1 : this[A];
  }, p.prototype.readInt16LE = function(A, E) {
    A = A >>> 0, E || b(A, 2, this.length);
    const F = this[A] | this[A + 1] << 8;
    return F & 32768 ? F | 4294901760 : F;
  }, p.prototype.readInt16BE = function(A, E) {
    A = A >>> 0, E || b(A, 2, this.length);
    const F = this[A + 1] | this[A] << 8;
    return F & 32768 ? F | 4294901760 : F;
  }, p.prototype.readInt32LE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), this[A] | this[A + 1] << 8 | this[A + 2] << 16 | this[A + 3] << 24;
  }, p.prototype.readInt32BE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), this[A] << 24 | this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3];
  }, p.prototype.readBigInt64LE = or(function(A) {
    A = A >>> 0, rt(A, "offset");
    const E = this[A], F = this[A + 7];
    (E === void 0 || F === void 0) && xe(A, this.length - 8);
    const ie = this[A + 4] + this[A + 5] * 2 ** 8 + this[A + 6] * 2 ** 16 + (F << 24);
    return (BigInt(ie) << BigInt(32)) + BigInt(E + this[++A] * 2 ** 8 + this[++A] * 2 ** 16 + this[++A] * 2 ** 24);
  }), p.prototype.readBigInt64BE = or(function(A) {
    A = A >>> 0, rt(A, "offset");
    const E = this[A], F = this[A + 7];
    (E === void 0 || F === void 0) && xe(A, this.length - 8);
    const ie = (E << 24) + this[++A] * 2 ** 16 + this[++A] * 2 ** 8 + this[++A];
    return (BigInt(ie) << BigInt(32)) + BigInt(this[++A] * 2 ** 24 + this[++A] * 2 ** 16 + this[++A] * 2 ** 8 + F);
  }), p.prototype.readFloatLE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), t.read(this, A, !0, 23, 4);
  }, p.prototype.readFloatBE = function(A, E) {
    return A = A >>> 0, E || b(A, 4, this.length), t.read(this, A, !1, 23, 4);
  }, p.prototype.readDoubleLE = function(A, E) {
    return A = A >>> 0, E || b(A, 8, this.length), t.read(this, A, !0, 52, 8);
  }, p.prototype.readDoubleBE = function(A, E) {
    return A = A >>> 0, E || b(A, 8, this.length), t.read(this, A, !1, 52, 8);
  };
  function l(T, A, E, F, ie, ne) {
    if (!p.isBuffer(T))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (A > ie || A < ne)
      throw new RangeError('"value" argument is out of bounds');
    if (E + F > T.length)
      throw new RangeError("Index out of range");
  }
  p.prototype.writeUintLE = p.prototype.writeUIntLE = function(A, E, F, ie) {
    if (A = +A, E = E >>> 0, F = F >>> 0, !ie) {
      const nt = Math.pow(2, 8 * F) - 1;
      l(this, A, E, F, nt, 0);
    }
    let ne = 1, ce = 0;
    for (this[E] = A & 255; ++ce < F && (ne *= 256); )
      this[E + ce] = A / ne & 255;
    return E + F;
  }, p.prototype.writeUintBE = p.prototype.writeUIntBE = function(A, E, F, ie) {
    if (A = +A, E = E >>> 0, F = F >>> 0, !ie) {
      const nt = Math.pow(2, 8 * F) - 1;
      l(this, A, E, F, nt, 0);
    }
    let ne = F - 1, ce = 1;
    for (this[E + ne] = A & 255; --ne >= 0 && (ce *= 256); )
      this[E + ne] = A / ce & 255;
    return E + F;
  }, p.prototype.writeUint8 = p.prototype.writeUInt8 = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 1, 255, 0), this[E] = A & 255, E + 1;
  }, p.prototype.writeUint16LE = p.prototype.writeUInt16LE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 2, 65535, 0), this[E] = A & 255, this[E + 1] = A >>> 8, E + 2;
  }, p.prototype.writeUint16BE = p.prototype.writeUInt16BE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 2, 65535, 0), this[E] = A >>> 8, this[E + 1] = A & 255, E + 2;
  }, p.prototype.writeUint32LE = p.prototype.writeUInt32LE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 4, 4294967295, 0), this[E + 3] = A >>> 24, this[E + 2] = A >>> 16, this[E + 1] = A >>> 8, this[E] = A & 255, E + 4;
  }, p.prototype.writeUint32BE = p.prototype.writeUInt32BE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 4, 4294967295, 0), this[E] = A >>> 24, this[E + 1] = A >>> 16, this[E + 2] = A >>> 8, this[E + 3] = A & 255, E + 4;
  };
  function v(T, A, E, F, ie) {
    be(A, F, ie, T, E, 7);
    let ne = Number(A & BigInt(4294967295));
    T[E++] = ne, ne = ne >> 8, T[E++] = ne, ne = ne >> 8, T[E++] = ne, ne = ne >> 8, T[E++] = ne;
    let ce = Number(A >> BigInt(32) & BigInt(4294967295));
    return T[E++] = ce, ce = ce >> 8, T[E++] = ce, ce = ce >> 8, T[E++] = ce, ce = ce >> 8, T[E++] = ce, E;
  }
  function X(T, A, E, F, ie) {
    be(A, F, ie, T, E, 7);
    let ne = Number(A & BigInt(4294967295));
    T[E + 7] = ne, ne = ne >> 8, T[E + 6] = ne, ne = ne >> 8, T[E + 5] = ne, ne = ne >> 8, T[E + 4] = ne;
    let ce = Number(A >> BigInt(32) & BigInt(4294967295));
    return T[E + 3] = ce, ce = ce >> 8, T[E + 2] = ce, ce = ce >> 8, T[E + 1] = ce, ce = ce >> 8, T[E] = ce, E + 8;
  }
  p.prototype.writeBigUInt64LE = or(function(A, E = 0) {
    return v(this, A, E, BigInt(0), BigInt("0xffffffffffffffff"));
  }), p.prototype.writeBigUInt64BE = or(function(A, E = 0) {
    return X(this, A, E, BigInt(0), BigInt("0xffffffffffffffff"));
  }), p.prototype.writeIntLE = function(A, E, F, ie) {
    if (A = +A, E = E >>> 0, !ie) {
      const Be = Math.pow(2, 8 * F - 1);
      l(this, A, E, F, Be - 1, -Be);
    }
    let ne = 0, ce = 1, nt = 0;
    for (this[E] = A & 255; ++ne < F && (ce *= 256); )
      A < 0 && nt === 0 && this[E + ne - 1] !== 0 && (nt = 1), this[E + ne] = (A / ce >> 0) - nt & 255;
    return E + F;
  }, p.prototype.writeIntBE = function(A, E, F, ie) {
    if (A = +A, E = E >>> 0, !ie) {
      const Be = Math.pow(2, 8 * F - 1);
      l(this, A, E, F, Be - 1, -Be);
    }
    let ne = F - 1, ce = 1, nt = 0;
    for (this[E + ne] = A & 255; --ne >= 0 && (ce *= 256); )
      A < 0 && nt === 0 && this[E + ne + 1] !== 0 && (nt = 1), this[E + ne] = (A / ce >> 0) - nt & 255;
    return E + F;
  }, p.prototype.writeInt8 = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 1, 127, -128), A < 0 && (A = 255 + A + 1), this[E] = A & 255, E + 1;
  }, p.prototype.writeInt16LE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 2, 32767, -32768), this[E] = A & 255, this[E + 1] = A >>> 8, E + 2;
  }, p.prototype.writeInt16BE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 2, 32767, -32768), this[E] = A >>> 8, this[E + 1] = A & 255, E + 2;
  }, p.prototype.writeInt32LE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 4, 2147483647, -2147483648), this[E] = A & 255, this[E + 1] = A >>> 8, this[E + 2] = A >>> 16, this[E + 3] = A >>> 24, E + 4;
  }, p.prototype.writeInt32BE = function(A, E, F) {
    return A = +A, E = E >>> 0, F || l(this, A, E, 4, 2147483647, -2147483648), A < 0 && (A = 4294967295 + A + 1), this[E] = A >>> 24, this[E + 1] = A >>> 16, this[E + 2] = A >>> 8, this[E + 3] = A & 255, E + 4;
  }, p.prototype.writeBigInt64LE = or(function(A, E = 0) {
    return v(this, A, E, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), p.prototype.writeBigInt64BE = or(function(A, E = 0) {
    return X(this, A, E, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function S(T, A, E, F, ie, ne) {
    if (E + F > T.length)
      throw new RangeError("Index out of range");
    if (E < 0)
      throw new RangeError("Index out of range");
  }
  function Y(T, A, E, F, ie) {
    return A = +A, E = E >>> 0, ie || S(T, A, E, 4), t.write(T, A, E, F, 23, 4), E + 4;
  }
  p.prototype.writeFloatLE = function(A, E, F) {
    return Y(this, A, E, !0, F);
  }, p.prototype.writeFloatBE = function(A, E, F) {
    return Y(this, A, E, !1, F);
  };
  function fe(T, A, E, F, ie) {
    return A = +A, E = E >>> 0, ie || S(T, A, E, 8), t.write(T, A, E, F, 52, 8), E + 8;
  }
  p.prototype.writeDoubleLE = function(A, E, F) {
    return fe(this, A, E, !0, F);
  }, p.prototype.writeDoubleBE = function(A, E, F) {
    return fe(this, A, E, !1, F);
  }, p.prototype.copy = function(A, E, F, ie) {
    if (!p.isBuffer(A))
      throw new TypeError("argument should be a Buffer");
    if (F || (F = 0), !ie && ie !== 0 && (ie = this.length), E >= A.length && (E = A.length), E || (E = 0), ie > 0 && ie < F && (ie = F), ie === F || A.length === 0 || this.length === 0)
      return 0;
    if (E < 0)
      throw new RangeError("targetStart out of bounds");
    if (F < 0 || F >= this.length)
      throw new RangeError("Index out of range");
    if (ie < 0)
      throw new RangeError("sourceEnd out of bounds");
    ie > this.length && (ie = this.length), A.length - E < ie - F && (ie = A.length - E + F);
    const ne = ie - F;
    return this === A && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(E, F, ie) : Uint8Array.prototype.set.call(
      A,
      this.subarray(F, ie),
      E
    ), ne;
  }, p.prototype.fill = function(A, E, F, ie) {
    if (typeof A == "string") {
      if (typeof E == "string" ? (ie = E, E = 0, F = this.length) : typeof F == "string" && (ie = F, F = this.length), ie !== void 0 && typeof ie != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ie == "string" && !p.isEncoding(ie))
        throw new TypeError("Unknown encoding: " + ie);
      if (A.length === 1) {
        const ce = A.charCodeAt(0);
        (ie === "utf8" && ce < 128 || ie === "latin1") && (A = ce);
      }
    } else
      typeof A == "number" ? A = A & 255 : typeof A == "boolean" && (A = Number(A));
    if (E < 0 || this.length < E || this.length < F)
      throw new RangeError("Out of range index");
    if (F <= E)
      return this;
    E = E >>> 0, F = F === void 0 ? this.length : F >>> 0, A || (A = 0);
    let ne;
    if (typeof A == "number")
      for (ne = E; ne < F; ++ne)
        this[ne] = A;
    else {
      const ce = p.isBuffer(A) ? A : p.from(A, ie), nt = ce.length;
      if (nt === 0)
        throw new TypeError('The value "' + A + '" is invalid for argument "value"');
      for (ne = 0; ne < F - E; ++ne)
        this[ne + E] = ce[ne % nt];
    }
    return this;
  };
  const oe = {};
  function de(T, A, E) {
    oe[T] = class extends E {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: A.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${T}]`, this.stack, delete this.name;
      }
      get code() {
        return T;
      }
      set code(ie) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ie,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${T}]: ${this.message}`;
      }
    };
  }
  de(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(T) {
      return T ? `${T} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), de(
    "ERR_INVALID_ARG_TYPE",
    function(T, A) {
      return `The "${T}" argument must be of type number. Received type ${typeof A}`;
    },
    TypeError
  ), de(
    "ERR_OUT_OF_RANGE",
    function(T, A, E) {
      let F = `The value of "${T}" is out of range.`, ie = E;
      return Number.isInteger(E) && Math.abs(E) > 2 ** 32 ? ie = Ie(String(E)) : typeof E == "bigint" && (ie = String(E), (E > BigInt(2) ** BigInt(32) || E < -(BigInt(2) ** BigInt(32))) && (ie = Ie(ie)), ie += "n"), F += ` It must be ${A}. Received ${ie}`, F;
    },
    RangeError
  );
  function Ie(T) {
    let A = "", E = T.length;
    const F = T[0] === "-" ? 1 : 0;
    for (; E >= F + 4; E -= 3)
      A = `_${T.slice(E - 3, E)}${A}`;
    return `${T.slice(0, E)}${A}`;
  }
  function ye(T, A, E) {
    rt(A, "offset"), (T[A] === void 0 || T[A + E] === void 0) && xe(A, T.length - (E + 1));
  }
  function be(T, A, E, F, ie, ne) {
    if (T > E || T < A) {
      const ce = typeof A == "bigint" ? "n" : "";
      let nt;
      throw ne > 3 ? A === 0 || A === BigInt(0) ? nt = `>= 0${ce} and < 2${ce} ** ${(ne + 1) * 8}${ce}` : nt = `>= -(2${ce} ** ${(ne + 1) * 8 - 1}${ce}) and < 2 ** ${(ne + 1) * 8 - 1}${ce}` : nt = `>= ${A}${ce} and <= ${E}${ce}`, new oe.ERR_OUT_OF_RANGE("value", nt, T);
    }
    ye(F, ie, ne);
  }
  function rt(T, A) {
    if (typeof T != "number")
      throw new oe.ERR_INVALID_ARG_TYPE(A, "number", T);
  }
  function xe(T, A, E) {
    throw Math.floor(T) !== T ? (rt(T, E), new oe.ERR_OUT_OF_RANGE(E || "offset", "an integer", T)) : A < 0 ? new oe.ERR_BUFFER_OUT_OF_BOUNDS() : new oe.ERR_OUT_OF_RANGE(
      E || "offset",
      `>= ${E ? 1 : 0} and <= ${A}`,
      T
    );
  }
  const Ne = /[^+/0-9A-Za-z-_]/g;
  function j(T) {
    if (T = T.split("=")[0], T = T.trim().replace(Ne, ""), T.length < 2)
      return "";
    for (; T.length % 4 !== 0; )
      T = T + "=";
    return T;
  }
  function z(T, A) {
    A = A || 1 / 0;
    let E;
    const F = T.length;
    let ie = null;
    const ne = [];
    for (let ce = 0; ce < F; ++ce) {
      if (E = T.charCodeAt(ce), E > 55295 && E < 57344) {
        if (!ie) {
          if (E > 56319) {
            (A -= 3) > -1 && ne.push(239, 191, 189);
            continue;
          } else if (ce + 1 === F) {
            (A -= 3) > -1 && ne.push(239, 191, 189);
            continue;
          }
          ie = E;
          continue;
        }
        if (E < 56320) {
          (A -= 3) > -1 && ne.push(239, 191, 189), ie = E;
          continue;
        }
        E = (ie - 55296 << 10 | E - 56320) + 65536;
      } else
        ie && (A -= 3) > -1 && ne.push(239, 191, 189);
      if (ie = null, E < 128) {
        if ((A -= 1) < 0)
          break;
        ne.push(E);
      } else if (E < 2048) {
        if ((A -= 2) < 0)
          break;
        ne.push(
          E >> 6 | 192,
          E & 63 | 128
        );
      } else if (E < 65536) {
        if ((A -= 3) < 0)
          break;
        ne.push(
          E >> 12 | 224,
          E >> 6 & 63 | 128,
          E & 63 | 128
        );
      } else if (E < 1114112) {
        if ((A -= 4) < 0)
          break;
        ne.push(
          E >> 18 | 240,
          E >> 12 & 63 | 128,
          E >> 6 & 63 | 128,
          E & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ne;
  }
  function ee(T) {
    const A = [];
    for (let E = 0; E < T.length; ++E)
      A.push(T.charCodeAt(E) & 255);
    return A;
  }
  function ve(T, A) {
    let E, F, ie;
    const ne = [];
    for (let ce = 0; ce < T.length && !((A -= 2) < 0); ++ce)
      E = T.charCodeAt(ce), F = E >> 8, ie = E % 256, ne.push(ie), ne.push(F);
    return ne;
  }
  function me(T) {
    return e.toByteArray(j(T));
  }
  function Ae(T, A, E, F) {
    let ie;
    for (ie = 0; ie < F && !(ie + E >= A.length || ie >= T.length); ++ie)
      A[ie + E] = T[ie];
    return ie;
  }
  function it(T, A) {
    return T instanceof A || T != null && T.constructor != null && T.constructor.name != null && T.constructor.name === A.name;
  }
  function ke(T) {
    return T !== T;
  }
  const qe = function() {
    const T = "0123456789abcdef", A = new Array(256);
    for (let E = 0; E < 16; ++E) {
      const F = E * 16;
      for (let ie = 0; ie < 16; ++ie)
        A[F + ie] = T[E] + T[ie];
    }
    return A;
  }();
  function or(T) {
    return typeof BigInt > "u" ? Oe : T;
  }
  function Oe() {
    throw new Error("BigInt not supported");
  }
})(buffer);
function number$1(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(n) {
  if (typeof n != "boolean")
    throw new Error(`Expected boolean, not ${n}`);
}
function bytes(n, ...e) {
  if (!(n instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (e.length > 0 && !e.includes(n.length))
    throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${n.length}`);
}
function hash$1(n) {
  if (typeof n != "function" || typeof n.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(n.outputLen), number$1(n.blockLen);
}
function exists(n, e = !0) {
  if (n.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && n.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(n, e) {
  bytes(n);
  const t = e.outputLen;
  if (n.length < t)
    throw new Error(`digestInto() expects output buffer of length at least ${t}`);
}
const assert$e = {
  number: number$1,
  bool,
  bytes,
  hash: hash$1,
  exists,
  output
};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32$1 = (n) => new Uint32Array(n.buffer, n.byteOffset, Math.floor(n.byteLength / 4)), createView = (n) => new DataView(n.buffer, n.byteOffset, n.byteLength), rotr = (n, e) => n << 32 - e | n >>> e, isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (n, e) => e.toString(16).padStart(2, "0"));
function utf8ToBytes(n) {
  if (typeof n != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof n}`);
  return new TextEncoder().encode(n);
}
function toBytes(n) {
  if (typeof n == "string" && (n = utf8ToBytes(n)), !(n instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof n})`);
  return n;
}
class Hash {
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(n) {
  const e = (o) => n().update(toBytes(o)).digest(), t = n();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => n(), e;
}
function wrapConstructorWithOpts(n) {
  const e = (o, c) => n(c).update(toBytes(o)).digest(), t = n({});
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = (o) => n(o), e;
}
function setBigUint64(n, e, t, o) {
  if (typeof n.setBigUint64 == "function")
    return n.setBigUint64(e, t, o);
  const c = BigInt(32), a = BigInt(4294967295), d = Number(t >> c & a), p = Number(t & a), w = o ? 4 : 0, M = o ? 0 : 4;
  n.setUint32(e + w, d, o), n.setUint32(e + M, p, o);
}
class SHA2 extends Hash {
  constructor(e, t, o, c) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = o, this.isLE = c, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = createView(this.buffer);
  }
  update(e) {
    assert$e.exists(this);
    const { view: t, buffer: o, blockLen: c } = this;
    e = toBytes(e);
    const a = e.length;
    for (let d = 0; d < a; ) {
      const p = Math.min(c - this.pos, a - d);
      if (p === c) {
        const w = createView(e);
        for (; c <= a - d; d += c)
          this.process(w, d);
        continue;
      }
      o.set(e.subarray(d, d + p), this.pos), this.pos += p, d += p, this.pos === c && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    assert$e.exists(this), assert$e.output(e, this), this.finished = !0;
    const { buffer: t, view: o, blockLen: c, isLE: a } = this;
    let { pos: d } = this;
    t[d++] = 128, this.buffer.subarray(d).fill(0), this.padOffset > c - d && (this.process(o, 0), d = 0);
    for (let B = d; B < c; B++)
      t[B] = 0;
    setBigUint64(o, c - 8, BigInt(this.length * 8), a), this.process(o, 0);
    const p = createView(e), w = this.outputLen;
    if (w % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const M = this.get(), I = w / 4;
    if (I > M.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let B = 0; B < I; B++)
      p.setUint32(4 * B, M[B], a);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const o = e.slice(0, t);
    return this.destroy(), o;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: o, length: c, finished: a, destroyed: d, pos: p } = this;
    return e.length = c, e.pos = p, e.finished = a, e.destroyed = d, c % t && e.buffer.set(o), e;
  }
}
const U32_MASK64 = BigInt(2 ** 32 - 1), _32n = BigInt(32);
function fromBig(n, e = !1) {
  return e ? { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) } : { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(n, e = !1) {
  let t = new Uint32Array(n.length), o = new Uint32Array(n.length);
  for (let c = 0; c < n.length; c++) {
    const { h: a, l: d } = fromBig(n[c], e);
    [t[c], o[c]] = [a, d];
  }
  return [t, o];
}
const toBig = (n, e) => BigInt(n >>> 0) << _32n | BigInt(e >>> 0), shrSH = (n, e, t) => n >>> t, shrSL = (n, e, t) => n << 32 - t | e >>> t, rotrSH = (n, e, t) => n >>> t | e << 32 - t, rotrSL = (n, e, t) => n << 32 - t | e >>> t, rotrBH = (n, e, t) => n << 64 - t | e >>> t - 32, rotrBL = (n, e, t) => n >>> t - 32 | e << 64 - t, rotr32H = (n, e) => e, rotr32L = (n, e) => n, rotlSH = (n, e, t) => n << t | e >>> 32 - t, rotlSL = (n, e, t) => e << t | n >>> 32 - t, rotlBH = (n, e, t) => e << t - 32 | n >>> 64 - t, rotlBL = (n, e, t) => n << t - 32 | e >>> 64 - t;
function add(n, e, t, o) {
  const c = (e >>> 0) + (o >>> 0);
  return { h: n + t + (c / 2 ** 32 | 0) | 0, l: c | 0 };
}
const add3L = (n, e, t) => (n >>> 0) + (e >>> 0) + (t >>> 0), add3H = (n, e, t, o) => e + t + o + (n / 2 ** 32 | 0) | 0, add4L = (n, e, t, o) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (o >>> 0), add4H = (n, e, t, o, c) => e + t + o + c + (n / 2 ** 32 | 0) | 0, add5L = (n, e, t, o, c) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (o >>> 0) + (c >>> 0), add5H = (n, e, t, o, c, a) => e + t + o + c + a + (n / 2 ** 32 | 0) | 0, u64$1 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
}, [SHA512_Kh, SHA512_Kl] = u64$1.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))), SHA512_W_H = new Uint32Array(80), SHA512_W_L = new Uint32Array(80);
class SHA512$2 extends SHA2 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e, Al: t, Bh: o, Bl: c, Ch: a, Cl: d, Dh: p, Dl: w, Eh: M, El: I, Fh: B, Fl: H, Gh: L, Gl: W, Hh: $, Hl: P } = this;
    return [e, t, o, c, a, d, p, w, M, I, B, H, L, W, $, P];
  }
  set(e, t, o, c, a, d, p, w, M, I, B, H, L, W, $, P) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = o | 0, this.Bl = c | 0, this.Ch = a | 0, this.Cl = d | 0, this.Dh = p | 0, this.Dl = w | 0, this.Eh = M | 0, this.El = I | 0, this.Fh = B | 0, this.Fl = H | 0, this.Gh = L | 0, this.Gl = W | 0, this.Hh = $ | 0, this.Hl = P | 0;
  }
  process(e, t) {
    for (let D = 0; D < 16; D++, t += 4)
      SHA512_W_H[D] = e.getUint32(t), SHA512_W_L[D] = e.getUint32(t += 4);
    for (let D = 16; D < 80; D++) {
      const Z = SHA512_W_H[D - 15] | 0, J = SHA512_W_L[D - 15] | 0, te = u64$1.rotrSH(Z, J, 1) ^ u64$1.rotrSH(Z, J, 8) ^ u64$1.shrSH(Z, J, 7), ue = u64$1.rotrSL(Z, J, 1) ^ u64$1.rotrSL(Z, J, 8) ^ u64$1.shrSL(Z, J, 7), he = SHA512_W_H[D - 2] | 0, Se = SHA512_W_L[D - 2] | 0, C = u64$1.rotrSH(he, Se, 19) ^ u64$1.rotrBH(he, Se, 61) ^ u64$1.shrSH(he, Se, 6), O = u64$1.rotrSL(he, Se, 19) ^ u64$1.rotrBL(he, Se, 61) ^ u64$1.shrSL(he, Se, 6), V = u64$1.add4L(ue, O, SHA512_W_L[D - 7], SHA512_W_L[D - 16]), x = u64$1.add4H(V, te, C, SHA512_W_H[D - 7], SHA512_W_H[D - 16]);
      SHA512_W_H[D] = x | 0, SHA512_W_L[D] = V | 0;
    }
    let { Ah: o, Al: c, Bh: a, Bl: d, Ch: p, Cl: w, Dh: M, Dl: I, Eh: B, El: H, Fh: L, Fl: W, Gh: $, Gl: P, Hh: U, Hl: G } = this;
    for (let D = 0; D < 80; D++) {
      const Z = u64$1.rotrSH(B, H, 14) ^ u64$1.rotrSH(B, H, 18) ^ u64$1.rotrBH(B, H, 41), J = u64$1.rotrSL(B, H, 14) ^ u64$1.rotrSL(B, H, 18) ^ u64$1.rotrBL(B, H, 41), te = B & L ^ ~B & $, ue = H & W ^ ~H & P, he = u64$1.add5L(G, J, ue, SHA512_Kl[D], SHA512_W_L[D]), Se = u64$1.add5H(he, U, Z, te, SHA512_Kh[D], SHA512_W_H[D]), C = he | 0, O = u64$1.rotrSH(o, c, 28) ^ u64$1.rotrBH(o, c, 34) ^ u64$1.rotrBH(o, c, 39), V = u64$1.rotrSL(o, c, 28) ^ u64$1.rotrBL(o, c, 34) ^ u64$1.rotrBL(o, c, 39), x = o & a ^ o & p ^ a & p, u = c & d ^ c & w ^ d & w;
      U = $ | 0, G = P | 0, $ = L | 0, P = W | 0, L = B | 0, W = H | 0, { h: B, l: H } = u64$1.add(M | 0, I | 0, Se | 0, C | 0), M = p | 0, I = w | 0, p = a | 0, w = d | 0, a = o | 0, d = c | 0;
      const h = u64$1.add3L(C, V, u);
      o = u64$1.add3H(h, Se, O, x), c = h | 0;
    }
    ({ h: o, l: c } = u64$1.add(this.Ah | 0, this.Al | 0, o | 0, c | 0)), { h: a, l: d } = u64$1.add(this.Bh | 0, this.Bl | 0, a | 0, d | 0), { h: p, l: w } = u64$1.add(this.Ch | 0, this.Cl | 0, p | 0, w | 0), { h: M, l: I } = u64$1.add(this.Dh | 0, this.Dl | 0, M | 0, I | 0), { h: B, l: H } = u64$1.add(this.Eh | 0, this.El | 0, B | 0, H | 0), { h: L, l: W } = u64$1.add(this.Fh | 0, this.Fl | 0, L | 0, W | 0), { h: $, l: P } = u64$1.add(this.Gh | 0, this.Gl | 0, $ | 0, P | 0), { h: U, l: G } = u64$1.add(this.Hh | 0, this.Hl | 0, U | 0, G | 0), this.set(o, c, a, d, p, w, M, I, B, H, L, W, $, P, U, G);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class SHA512_256 extends SHA512$2 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
class SHA384$1 extends SHA512$2 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
const sha512$1 = wrapConstructor(() => new SHA512$2());
wrapConstructor(() => new SHA512_256());
wrapConstructor(() => new SHA384$1());
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$2 = BigInt(1), _2n$2 = BigInt(2), CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), CURVE$1 = Object.freeze({
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
  l: CU_O,
  n: CU_O,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
}), POW_2_256$1 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"), SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
const SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
class ExtendedPoint {
  constructor(e, t, o, c) {
    this.x = e, this.y = t, this.z = o, this.t = c;
  }
  static fromAffine(e) {
    if (!(e instanceof Point$2))
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    return e.equals(Point$2.ZERO) ? ExtendedPoint.ZERO : new ExtendedPoint(e.x, e.y, _1n$2, mod$1(e.x * e.y));
  }
  static toAffineBatch(e) {
    const t = invertBatch$1(e.map((o) => o.z));
    return e.map((o, c) => o.toAffine(t[c]));
  }
  static normalizeZ(e) {
    return this.toAffineBatch(e).map(this.fromAffine);
  }
  equals(e) {
    assertExtPoint(e);
    const { x: t, y: o, z: c } = this, { x: a, y: d, z: p } = e, w = mod$1(t * p), M = mod$1(a * c), I = mod$1(o * p), B = mod$1(d * c);
    return w === M && I === B;
  }
  negate() {
    return new ExtendedPoint(mod$1(-this.x), this.y, this.z, mod$1(-this.t));
  }
  double() {
    const { x: e, y: t, z: o } = this, { a: c } = CURVE$1, a = mod$1(e * e), d = mod$1(t * t), p = mod$1(_2n$2 * mod$1(o * o)), w = mod$1(c * a), M = e + t, I = mod$1(mod$1(M * M) - a - d), B = w + d, H = B - p, L = w - d, W = mod$1(I * H), $ = mod$1(B * L), P = mod$1(I * L), U = mod$1(H * B);
    return new ExtendedPoint(W, $, U, P);
  }
  add(e) {
    assertExtPoint(e);
    const { x: t, y: o, z: c, t: a } = this, { x: d, y: p, z: w, t: M } = e, I = mod$1((o - t) * (p + d)), B = mod$1((o + t) * (p - d)), H = mod$1(B - I);
    if (H === _0n$2)
      return this.double();
    const L = mod$1(c * _2n$2 * M), W = mod$1(a * _2n$2 * w), $ = W + L, P = B + I, U = W - L, G = mod$1($ * H), D = mod$1(P * U), Z = mod$1($ * U), J = mod$1(H * P);
    return new ExtendedPoint(G, D, J, Z);
  }
  subtract(e) {
    return this.add(e.negate());
  }
  precomputeWindow(e) {
    const t = 1 + 256 / e, o = [];
    let c = this, a = c;
    for (let d = 0; d < t; d++) {
      a = c, o.push(a);
      for (let p = 1; p < 2 ** (e - 1); p++)
        a = a.add(c), o.push(a);
      c = a.double();
    }
    return o;
  }
  wNAF(e, t) {
    !t && this.equals(ExtendedPoint.BASE) && (t = Point$2.BASE);
    const o = t && t._WINDOW_SIZE || 1;
    if (256 % o)
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    let c = t && pointPrecomputes$1.get(t);
    c || (c = this.precomputeWindow(o), t && o !== 1 && (c = ExtendedPoint.normalizeZ(c), pointPrecomputes$1.set(t, c)));
    let a = ExtendedPoint.ZERO, d = ExtendedPoint.ZERO;
    const p = 1 + 256 / o, w = 2 ** (o - 1), M = BigInt(2 ** o - 1), I = 2 ** o, B = BigInt(o);
    for (let H = 0; H < p; H++) {
      const L = H * w;
      let W = Number(e & M);
      if (e >>= B, W > w && (W -= I, e += _1n$2), W === 0) {
        let $ = c[L];
        H % 2 && ($ = $.negate()), d = d.add($);
      } else {
        let $ = c[L + Math.abs(W) - 1];
        W < 0 && ($ = $.negate()), a = a.add($);
      }
    }
    return ExtendedPoint.normalizeZ([a, d])[0];
  }
  multiply(e, t) {
    return this.wNAF(normalizeScalar$1(e, CURVE$1.l), t);
  }
  multiplyUnsafe(e) {
    let t = normalizeScalar$1(e, CURVE$1.l, !1);
    const o = ExtendedPoint.BASE, c = ExtendedPoint.ZERO;
    if (t === _0n$2)
      return c;
    if (this.equals(c) || t === _1n$2)
      return this;
    if (this.equals(o))
      return this.wNAF(t);
    let a = c, d = this;
    for (; t > _0n$2; )
      t & _1n$2 && (a = a.add(d)), d = d.double(), t >>= _1n$2;
    return a;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    return this.multiplyUnsafe(CURVE$1.l).equals(ExtendedPoint.ZERO);
  }
  toAffine(e = invert$1(this.z)) {
    const { x: t, y: o, z: c } = this, a = mod$1(t * e), d = mod$1(o * e);
    if (mod$1(c * e) !== _1n$2)
      throw new Error("invZ was invalid");
    return new Point$2(a, d);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
}
ExtendedPoint.BASE = new ExtendedPoint(CURVE$1.Gx, CURVE$1.Gy, _1n$2, mod$1(CURVE$1.Gx * CURVE$1.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n$2, _1n$2, _1n$2, _0n$2);
function assertExtPoint(n) {
  if (!(n instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(n) {
  if (!(n instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
class RistrettoPoint {
  constructor(e) {
    this.ep = e;
  }
  static calcElligatorRistrettoMap(e) {
    const { d: t } = CURVE$1, o = mod$1(SQRT_M1 * e * e), c = mod$1((o + _1n$2) * ONE_MINUS_D_SQ);
    let a = BigInt(-1);
    const d = mod$1((a - t * o) * mod$1(o + t));
    let { isValid: p, value: w } = uvRatio(c, d), M = mod$1(w * e);
    edIsNegative(M) || (M = mod$1(-M)), p || (w = M), p || (a = o);
    const I = mod$1(a * (o - _1n$2) * D_MINUS_ONE_SQ - d), B = w * w, H = mod$1((w + w) * d), L = mod$1(I * SQRT_AD_MINUS_ONE), W = mod$1(_1n$2 - B), $ = mod$1(_1n$2 + B);
    return new ExtendedPoint(mod$1(H * $), mod$1(W * L), mod$1(L * $), mod$1(H * W));
  }
  static hashToCurve(e) {
    e = ensureBytes$1(e, 64);
    const t = bytes255ToNumberLE(e.slice(0, 32)), o = this.calcElligatorRistrettoMap(t), c = bytes255ToNumberLE(e.slice(32, 64)), a = this.calcElligatorRistrettoMap(c);
    return new RistrettoPoint(o.add(a));
  }
  static fromHex(e) {
    e = ensureBytes$1(e, 32);
    const { a: t, d: o } = CURVE$1, c = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", a = bytes255ToNumberLE(e);
    if (!equalBytes(numberTo32BytesLE(a), e) || edIsNegative(a))
      throw new Error(c);
    const d = mod$1(a * a), p = mod$1(_1n$2 + t * d), w = mod$1(_1n$2 - t * d), M = mod$1(p * p), I = mod$1(w * w), B = mod$1(t * o * M - I), { isValid: H, value: L } = invertSqrt(mod$1(B * I)), W = mod$1(L * w), $ = mod$1(L * W * B);
    let P = mod$1((a + a) * W);
    edIsNegative(P) && (P = mod$1(-P));
    const U = mod$1(p * $), G = mod$1(P * U);
    if (!H || edIsNegative(G) || U === _0n$2)
      throw new Error(c);
    return new RistrettoPoint(new ExtendedPoint(P, U, _1n$2, G));
  }
  toRawBytes() {
    let { x: e, y: t, z: o, t: c } = this.ep;
    const a = mod$1(mod$1(o + t) * mod$1(o - t)), d = mod$1(e * t), p = mod$1(d * d), { value: w } = invertSqrt(mod$1(a * p)), M = mod$1(w * a), I = mod$1(w * d), B = mod$1(M * I * c);
    let H;
    if (edIsNegative(c * B)) {
      let W = mod$1(t * SQRT_M1), $ = mod$1(e * SQRT_M1);
      e = W, t = $, H = mod$1(M * INVSQRT_A_MINUS_D);
    } else
      H = I;
    edIsNegative(e * B) && (t = mod$1(-t));
    let L = mod$1((o - t) * H);
    return edIsNegative(L) && (L = mod$1(-L)), numberTo32BytesLE(L);
  }
  toHex() {
    return bytesToHex$1(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(e) {
    assertRstPoint(e);
    const t = this.ep, o = e.ep, c = mod$1(t.x * o.y) === mod$1(t.y * o.x), a = mod$1(t.y * o.y) === mod$1(t.x * o.x);
    return c || a;
  }
  add(e) {
    return assertRstPoint(e), new RistrettoPoint(this.ep.add(e.ep));
  }
  subtract(e) {
    return assertRstPoint(e), new RistrettoPoint(this.ep.subtract(e.ep));
  }
  multiply(e) {
    return new RistrettoPoint(this.ep.multiply(e));
  }
  multiplyUnsafe(e) {
    return new RistrettoPoint(this.ep.multiplyUnsafe(e));
  }
}
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
const pointPrecomputes$1 = /* @__PURE__ */ new WeakMap();
class Point$2 {
  constructor(e, t) {
    this.x = e, this.y = t;
  }
  _setWindowSize(e) {
    this._WINDOW_SIZE = e, pointPrecomputes$1.delete(this);
  }
  static fromHex(e, t = !0) {
    const { d: o, P: c } = CURVE$1;
    e = ensureBytes$1(e, 32);
    const a = e.slice();
    a[31] = e[31] & -129;
    const d = bytesToNumberLE(a);
    if (t && d >= c)
      throw new Error("Expected 0 < hex < P");
    if (!t && d >= POW_2_256$1)
      throw new Error("Expected 0 < hex < 2**256");
    const p = mod$1(d * d), w = mod$1(p - _1n$2), M = mod$1(o * p + _1n$2);
    let { isValid: I, value: B } = uvRatio(w, M);
    if (!I)
      throw new Error("Point.fromHex: invalid y coordinate");
    const H = (B & _1n$2) === _1n$2;
    return (e[31] & 128) !== 0 !== H && (B = mod$1(-B)), new Point$2(B, d);
  }
  static async fromPrivateKey(e) {
    return (await getExtendedPublicKey(e)).point;
  }
  toRawBytes() {
    const e = numberTo32BytesLE(this.y);
    return e[31] |= this.x & _1n$2 ? 128 : 0, e;
  }
  toHex() {
    return bytesToHex$1(this.toRawBytes());
  }
  toX25519() {
    const { y: e } = this, t = mod$1((_1n$2 + e) * invert$1(_1n$2 - e));
    return numberTo32BytesLE(t);
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(e) {
    return this.x === e.x && this.y === e.y;
  }
  negate() {
    return new Point$2(mod$1(-this.x), this.y);
  }
  add(e) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(e)).toAffine();
  }
  subtract(e) {
    return this.add(e.negate());
  }
  multiply(e) {
    return ExtendedPoint.fromAffine(this).multiply(e, this).toAffine();
  }
}
Point$2.BASE = new Point$2(CURVE$1.Gx, CURVE$1.Gy);
Point$2.ZERO = new Point$2(_0n$2, _1n$2);
class Signature$2 {
  constructor(e, t) {
    this.r = e, this.s = t, this.assertValidity();
  }
  static fromHex(e) {
    const t = ensureBytes$1(e, 64), o = Point$2.fromHex(t.slice(0, 32), !1), c = bytesToNumberLE(t.slice(32, 64));
    return new Signature$2(o, c);
  }
  assertValidity() {
    const { r: e, s: t } = this;
    if (!(e instanceof Point$2))
      throw new Error("Expected Point instance");
    return normalizeScalar$1(t, CURVE$1.l, !1), this;
  }
  toRawBytes() {
    const e = new Uint8Array(64);
    return e.set(this.r.toRawBytes()), e.set(numberTo32BytesLE(this.s), 32), e;
  }
  toHex() {
    return bytesToHex$1(this.toRawBytes());
  }
}
function concatBytes$1(...n) {
  if (!n.every((o) => o instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (n.length === 1)
    return n[0];
  const e = n.reduce((o, c) => o + c.length, 0), t = new Uint8Array(e);
  for (let o = 0, c = 0; o < n.length; o++) {
    const a = n[o];
    t.set(a, c), c += a.length;
  }
  return t;
}
const hexes$1 = Array.from({ length: 256 }, (n, e) => e.toString(16).padStart(2, "0"));
function bytesToHex$1(n) {
  if (!(n instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let t = 0; t < n.length; t++)
    e += hexes$1[n[t]];
  return e;
}
function hexToBytes$1(n) {
  if (typeof n != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof n);
  if (n.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const e = new Uint8Array(n.length / 2);
  for (let t = 0; t < e.length; t++) {
    const o = t * 2, c = n.slice(o, o + 2), a = Number.parseInt(c, 16);
    if (Number.isNaN(a) || a < 0)
      throw new Error("Invalid byte sequence");
    e[t] = a;
  }
  return e;
}
function numberTo32BytesBE(n) {
  const t = n.toString(16).padStart(64, "0");
  return hexToBytes$1(t);
}
function numberTo32BytesLE(n) {
  return numberTo32BytesBE(n).reverse();
}
function edIsNegative(n) {
  return (mod$1(n) & _1n$2) === _1n$2;
}
function bytesToNumberLE(n) {
  if (!(n instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex$1(Uint8Array.from(n).reverse()));
}
const MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bytes255ToNumberLE(n) {
  return mod$1(bytesToNumberLE(n) & MAX_255B);
}
function mod$1(n, e = CURVE$1.P) {
  const t = n % e;
  return t >= _0n$2 ? t : e + t;
}
function invert$1(n, e = CURVE$1.P) {
  if (n === _0n$2 || e <= _0n$2)
    throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);
  let t = mod$1(n, e), o = e, c = _0n$2, a = _1n$2;
  for (; t !== _0n$2; ) {
    const p = o / t, w = o % t, M = c - a * p;
    o = t, t = w, c = a, a = M;
  }
  if (o !== _1n$2)
    throw new Error("invert: does not exist");
  return mod$1(c, e);
}
function invertBatch$1(n, e = CURVE$1.P) {
  const t = new Array(n.length), o = n.reduce((a, d, p) => d === _0n$2 ? a : (t[p] = a, mod$1(a * d, e)), _1n$2), c = invert$1(o, e);
  return n.reduceRight((a, d, p) => d === _0n$2 ? a : (t[p] = mod$1(a * t[p], e), mod$1(a * d, e)), c), t;
}
function pow2$1(n, e) {
  const { P: t } = CURVE$1;
  let o = n;
  for (; e-- > _0n$2; )
    o *= o, o %= t;
  return o;
}
function pow_2_252_3(n) {
  const { P: e } = CURVE$1, t = BigInt(5), o = BigInt(10), c = BigInt(20), a = BigInt(40), d = BigInt(80), w = n * n % e * n % e, M = pow2$1(w, _2n$2) * w % e, I = pow2$1(M, _1n$2) * n % e, B = pow2$1(I, t) * I % e, H = pow2$1(B, o) * B % e, L = pow2$1(H, c) * H % e, W = pow2$1(L, a) * L % e, $ = pow2$1(W, d) * W % e, P = pow2$1($, d) * W % e, U = pow2$1(P, o) * B % e;
  return { pow_p_5_8: pow2$1(U, _2n$2) * n % e, b2: w };
}
function uvRatio(n, e) {
  const t = mod$1(e * e * e), o = mod$1(t * t * e), c = pow_2_252_3(n * o).pow_p_5_8;
  let a = mod$1(n * t * c);
  const d = mod$1(e * a * a), p = a, w = mod$1(a * SQRT_M1), M = d === n, I = d === mod$1(-n), B = d === mod$1(-n * SQRT_M1);
  return M && (a = p), (I || B) && (a = w), edIsNegative(a) && (a = mod$1(-a)), { isValid: M || I, value: a };
}
function invertSqrt(n) {
  return uvRatio(_1n$2, n);
}
function modlLE(n) {
  return mod$1(bytesToNumberLE(n), CURVE$1.l);
}
function equalBytes(n, e) {
  if (n.length !== e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}
function ensureBytes$1(n, e) {
  const t = n instanceof Uint8Array ? Uint8Array.from(n) : hexToBytes$1(n);
  if (typeof e == "number" && t.length !== e)
    throw new Error(`Expected ${e} bytes`);
  return t;
}
function normalizeScalar$1(n, e, t = !0) {
  if (!e)
    throw new TypeError("Specify max value");
  if (typeof n == "number" && Number.isSafeInteger(n) && (n = BigInt(n)), typeof n == "bigint" && n < e) {
    if (t) {
      if (_0n$2 < n)
        return n;
    } else if (_0n$2 <= n)
      return n;
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(n) {
  return n[0] &= 248, n[31] &= 127, n[31] |= 64, n;
}
function checkPrivateKey(n) {
  if (n = typeof n == "bigint" || typeof n == "number" ? numberTo32BytesBE(normalizeScalar$1(n, POW_2_256$1)) : ensureBytes$1(n), n.length !== 32)
    throw new Error("Expected 32 bytes");
  return n;
}
function getKeyFromHash(n) {
  const e = adjustBytes25519(n.slice(0, 32)), t = n.slice(32, 64), o = modlLE(e), c = Point$2.BASE.multiply(o), a = c.toRawBytes();
  return { head: e, prefix: t, scalar: o, point: c, pointBytes: a };
}
let _sha512Sync;
function sha512s(...n) {
  if (typeof _sha512Sync != "function")
    throw new Error("utils.sha512Sync must be set to use sync methods");
  return _sha512Sync(...n);
}
async function getExtendedPublicKey(n) {
  return getKeyFromHash(await utils$c.sha512(checkPrivateKey(n)));
}
function getExtendedPublicKeySync(n) {
  return getKeyFromHash(sha512s(checkPrivateKey(n)));
}
function getPublicKeySync(n) {
  return getExtendedPublicKeySync(n).pointBytes;
}
function signSync$1(n, e) {
  n = ensureBytes$1(n);
  const { prefix: t, scalar: o, pointBytes: c } = getExtendedPublicKeySync(e), a = modlLE(sha512s(t, n)), d = Point$2.BASE.multiply(a), p = modlLE(sha512s(d.toRawBytes(), c, n)), w = mod$1(a + p * o, CURVE$1.l);
  return new Signature$2(d, w).toRawBytes();
}
function prepareVerification(n, e, t) {
  e = ensureBytes$1(e), t instanceof Point$2 || (t = Point$2.fromHex(t, !1));
  const { r: o, s: c } = n instanceof Signature$2 ? n.assertValidity() : Signature$2.fromHex(n), a = ExtendedPoint.BASE.multiplyUnsafe(c);
  return { r: o, s: c, SB: a, pub: t, msg: e };
}
function finishVerification(n, e, t, o) {
  const c = modlLE(o), a = ExtendedPoint.fromAffine(n).multiplyUnsafe(c);
  return ExtendedPoint.fromAffine(e).add(a).subtract(t).multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO);
}
function verifySync(n, e, t) {
  const { r: o, SB: c, msg: a, pub: d } = prepareVerification(n, e, t), p = sha512s(o.toRawBytes(), d.toRawBytes(), a);
  return finishVerification(d, o, c, p);
}
const sync = {
  getExtendedPublicKey: getExtendedPublicKeySync,
  getPublicKey: getPublicKeySync,
  sign: signSync$1,
  verify: verifySync
};
Point$2.BASE._setWindowSize(8);
const crypto$3 = {
  node: nodeCrypto,
  web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
}, utils$c = {
  bytesToHex: bytesToHex$1,
  hexToBytes: hexToBytes$1,
  concatBytes: concatBytes$1,
  getExtendedPublicKey,
  mod: mod$1,
  invert: invert$1,
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  hashToPrivateScalar: (n) => {
    if (n = ensureBytes$1(n), n.length < 40 || n.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    return mod$1(bytesToNumberLE(n), CURVE$1.l - _1n$2) + _1n$2;
  },
  randomBytes: (n = 32) => {
    if (crypto$3.web)
      return crypto$3.web.getRandomValues(new Uint8Array(n));
    if (crypto$3.node) {
      const { randomBytes: e } = crypto$3.node;
      return new Uint8Array(e(n).buffer);
    } else
      throw new Error("The environment doesn't have randomBytes function");
  },
  randomPrivateKey: () => utils$c.randomBytes(32),
  sha512: async (...n) => {
    const e = concatBytes$1(...n);
    if (crypto$3.web) {
      const t = await crypto$3.web.subtle.digest("SHA-512", e.buffer);
      return new Uint8Array(t);
    } else {
      if (crypto$3.node)
        return Uint8Array.from(crypto$3.node.createHash("sha512").update(e).digest());
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(n = 8, e = Point$2.BASE) {
    const t = e.equals(Point$2.BASE) ? e : new Point$2(e.x, e.y);
    return t._setWindowSize(n), t.multiply(_2n$2), t;
  },
  sha512Sync: void 0
};
Object.defineProperties(utils$c, {
  sha512Sync: {
    configurable: !1,
    get() {
      return _sha512Sync;
    },
    set(n) {
      _sha512Sync || (_sha512Sync = n);
    }
  }
});
var bn$3 = { exports: {} };
(function(n) {
  (function(e, t) {
    function o(x, u) {
      if (!x)
        throw new Error(u || "Assertion failed");
    }
    function c(x, u) {
      x.super_ = u;
      var h = function() {
      };
      h.prototype = u.prototype, x.prototype = new h(), x.prototype.constructor = x;
    }
    function a(x, u, h) {
      if (a.isBN(x))
        return x;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, x !== null && ((u === "le" || u === "be") && (h = u, u = 10), this._init(x || 0, u || 10, h || "be"));
    }
    typeof e == "object" ? e.exports = a : t.BN = a, a.BN = a, a.wordSize = 26;
    var d;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? d = window.Buffer : d = require$$0$3.Buffer;
    } catch {
    }
    a.isBN = function(u) {
      return u instanceof a ? !0 : u !== null && typeof u == "object" && u.constructor.wordSize === a.wordSize && Array.isArray(u.words);
    }, a.max = function(u, h) {
      return u.cmp(h) > 0 ? u : h;
    }, a.min = function(u, h) {
      return u.cmp(h) < 0 ? u : h;
    }, a.prototype._init = function(u, h, g) {
      if (typeof u == "number")
        return this._initNumber(u, h, g);
      if (typeof u == "object")
        return this._initArray(u, h, g);
      h === "hex" && (h = 16), o(h === (h | 0) && h >= 2 && h <= 36), u = u.toString().replace(/\s+/g, "");
      var y = 0;
      u[0] === "-" && (y++, this.negative = 1), y < u.length && (h === 16 ? this._parseHex(u, y, g) : (this._parseBase(u, h, y), g === "le" && this._initArray(this.toArray(), h, g)));
    }, a.prototype._initNumber = function(u, h, g) {
      u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [
        u & 67108863,
        u / 67108864 & 67108863
      ], this.length = 2) : (o(u < 9007199254740992), this.words = [
        u & 67108863,
        u / 67108864 & 67108863,
        1
      ], this.length = 3), g === "le" && this._initArray(this.toArray(), h, g);
    }, a.prototype._initArray = function(u, h, g) {
      if (o(typeof u.length == "number"), u.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var m, _, R = 0;
      if (g === "be")
        for (y = u.length - 1, m = 0; y >= 0; y -= 3)
          _ = u[y] | u[y - 1] << 8 | u[y - 2] << 16, this.words[m] |= _ << R & 67108863, this.words[m + 1] = _ >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, m++);
      else if (g === "le")
        for (y = 0, m = 0; y < u.length; y += 3)
          _ = u[y] | u[y + 1] << 8 | u[y + 2] << 16, this.words[m] |= _ << R & 67108863, this.words[m + 1] = _ >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, m++);
      return this._strip();
    };
    function p(x, u) {
      var h = x.charCodeAt(u);
      if (h >= 48 && h <= 57)
        return h - 48;
      if (h >= 65 && h <= 70)
        return h - 55;
      if (h >= 97 && h <= 102)
        return h - 87;
      o(!1, "Invalid character in " + x);
    }
    function w(x, u, h) {
      var g = p(x, h);
      return h - 1 >= u && (g |= p(x, h - 1) << 4), g;
    }
    a.prototype._parseHex = function(u, h, g) {
      this.length = Math.ceil((u.length - h) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var m = 0, _ = 0, R;
      if (g === "be")
        for (y = u.length - 1; y >= h; y -= 2)
          R = w(u, h, y) << m, this.words[_] |= R & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= R >>> 26) : m += 8;
      else {
        var b = u.length - h;
        for (y = b % 2 === 0 ? h + 1 : h; y < u.length; y += 2)
          R = w(u, h, y) << m, this.words[_] |= R & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= R >>> 26) : m += 8;
      }
      this._strip();
    };
    function M(x, u, h, g) {
      for (var y = 0, m = 0, _ = Math.min(x.length, h), R = u; R < _; R++) {
        var b = x.charCodeAt(R) - 48;
        y *= g, b >= 49 ? m = b - 49 + 10 : b >= 17 ? m = b - 17 + 10 : m = b, o(b >= 0 && m < g, "Invalid character"), y += m;
      }
      return y;
    }
    a.prototype._parseBase = function(u, h, g) {
      this.words = [0], this.length = 1;
      for (var y = 0, m = 1; m <= 67108863; m *= h)
        y++;
      y--, m = m / h | 0;
      for (var _ = u.length - g, R = _ % y, b = Math.min(_, _ - R) + g, l = 0, v = g; v < b; v += y)
        l = M(u, v, v + y, h), this.imuln(m), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      if (R !== 0) {
        var X = 1;
        for (l = M(u, v, u.length, h), v = 0; v < R; v++)
          X *= h;
        this.imuln(X), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      }
      this._strip();
    }, a.prototype.copy = function(u) {
      u.words = new Array(this.length);
      for (var h = 0; h < this.length; h++)
        u.words[h] = this.words[h];
      u.length = this.length, u.negative = this.negative, u.red = this.red;
    };
    function I(x, u) {
      x.words = u.words, x.length = u.length, x.negative = u.negative, x.red = u.red;
    }
    if (a.prototype._move = function(u) {
      I(u, this);
    }, a.prototype.clone = function() {
      var u = new a(null);
      return this.copy(u), u;
    }, a.prototype._expand = function(u) {
      for (; this.length < u; )
        this.words[this.length++] = 0;
      return this;
    }, a.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, a.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        a.prototype[Symbol.for("nodejs.util.inspect.custom")] = B;
      } catch {
        a.prototype.inspect = B;
      }
    else
      a.prototype.inspect = B;
    function B() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var H = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], L = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], W = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    a.prototype.toString = function(u, h) {
      u = u || 10, h = h | 0 || 1;
      var g;
      if (u === 16 || u === "hex") {
        g = "";
        for (var y = 0, m = 0, _ = 0; _ < this.length; _++) {
          var R = this.words[_], b = ((R << y | m) & 16777215).toString(16);
          m = R >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, _--), m !== 0 || _ !== this.length - 1 ? g = H[6 - b.length] + b + g : g = b + g;
        }
        for (m !== 0 && (g = m.toString(16) + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      if (u === (u | 0) && u >= 2 && u <= 36) {
        var l = L[u], v = W[u];
        g = "";
        var X = this.clone();
        for (X.negative = 0; !X.isZero(); ) {
          var S = X.modrn(v).toString(u);
          X = X.idivn(v), X.isZero() ? g = S + g : g = H[l - S.length] + S + g;
        }
        for (this.isZero() && (g = "0" + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      o(!1, "Base should be between 2 and 36");
    }, a.prototype.toNumber = function() {
      var u = this.words[0];
      return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
    }, a.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, d && (a.prototype.toBuffer = function(u, h) {
      return this.toArrayLike(d, u, h);
    }), a.prototype.toArray = function(u, h) {
      return this.toArrayLike(Array, u, h);
    };
    var $ = function(u, h) {
      return u.allocUnsafe ? u.allocUnsafe(h) : new u(h);
    };
    a.prototype.toArrayLike = function(u, h, g) {
      this._strip();
      var y = this.byteLength(), m = g || Math.max(1, y);
      o(y <= m, "byte array longer than desired length"), o(m > 0, "Requested array length <= 0");
      var _ = $(u, m), R = h === "le" ? "LE" : "BE";
      return this["_toArrayLike" + R](_, y), _;
    }, a.prototype._toArrayLikeLE = function(u, h) {
      for (var g = 0, y = 0, m = 0, _ = 0; m < this.length; m++) {
        var R = this.words[m] << _ | y;
        u[g++] = R & 255, g < u.length && (u[g++] = R >> 8 & 255), g < u.length && (u[g++] = R >> 16 & 255), _ === 6 ? (g < u.length && (u[g++] = R >> 24 & 255), y = 0, _ = 0) : (y = R >>> 24, _ += 2);
      }
      if (g < u.length)
        for (u[g++] = y; g < u.length; )
          u[g++] = 0;
    }, a.prototype._toArrayLikeBE = function(u, h) {
      for (var g = u.length - 1, y = 0, m = 0, _ = 0; m < this.length; m++) {
        var R = this.words[m] << _ | y;
        u[g--] = R & 255, g >= 0 && (u[g--] = R >> 8 & 255), g >= 0 && (u[g--] = R >> 16 & 255), _ === 6 ? (g >= 0 && (u[g--] = R >> 24 & 255), y = 0, _ = 0) : (y = R >>> 24, _ += 2);
      }
      if (g >= 0)
        for (u[g--] = y; g >= 0; )
          u[g--] = 0;
    }, Math.clz32 ? a.prototype._countBits = function(u) {
      return 32 - Math.clz32(u);
    } : a.prototype._countBits = function(u) {
      var h = u, g = 0;
      return h >= 4096 && (g += 13, h >>>= 13), h >= 64 && (g += 7, h >>>= 7), h >= 8 && (g += 4, h >>>= 4), h >= 2 && (g += 2, h >>>= 2), g + h;
    }, a.prototype._zeroBits = function(u) {
      if (u === 0)
        return 26;
      var h = u, g = 0;
      return (h & 8191) === 0 && (g += 13, h >>>= 13), (h & 127) === 0 && (g += 7, h >>>= 7), (h & 15) === 0 && (g += 4, h >>>= 4), (h & 3) === 0 && (g += 2, h >>>= 2), (h & 1) === 0 && g++, g;
    }, a.prototype.bitLength = function() {
      var u = this.words[this.length - 1], h = this._countBits(u);
      return (this.length - 1) * 26 + h;
    };
    function P(x) {
      for (var u = new Array(x.bitLength()), h = 0; h < u.length; h++) {
        var g = h / 26 | 0, y = h % 26;
        u[h] = x.words[g] >>> y & 1;
      }
      return u;
    }
    a.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var u = 0, h = 0; h < this.length; h++) {
        var g = this._zeroBits(this.words[h]);
        if (u += g, g !== 26)
          break;
      }
      return u;
    }, a.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, a.prototype.toTwos = function(u) {
      return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
    }, a.prototype.fromTwos = function(u) {
      return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
    }, a.prototype.isNeg = function() {
      return this.negative !== 0;
    }, a.prototype.neg = function() {
      return this.clone().ineg();
    }, a.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, a.prototype.iuor = function(u) {
      for (; this.length < u.length; )
        this.words[this.length++] = 0;
      for (var h = 0; h < u.length; h++)
        this.words[h] = this.words[h] | u.words[h];
      return this._strip();
    }, a.prototype.ior = function(u) {
      return o((this.negative | u.negative) === 0), this.iuor(u);
    }, a.prototype.or = function(u) {
      return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
    }, a.prototype.uor = function(u) {
      return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
    }, a.prototype.iuand = function(u) {
      var h;
      this.length > u.length ? h = u : h = this;
      for (var g = 0; g < h.length; g++)
        this.words[g] = this.words[g] & u.words[g];
      return this.length = h.length, this._strip();
    }, a.prototype.iand = function(u) {
      return o((this.negative | u.negative) === 0), this.iuand(u);
    }, a.prototype.and = function(u) {
      return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
    }, a.prototype.uand = function(u) {
      return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
    }, a.prototype.iuxor = function(u) {
      var h, g;
      this.length > u.length ? (h = this, g = u) : (h = u, g = this);
      for (var y = 0; y < g.length; y++)
        this.words[y] = h.words[y] ^ g.words[y];
      if (this !== h)
        for (; y < h.length; y++)
          this.words[y] = h.words[y];
      return this.length = h.length, this._strip();
    }, a.prototype.ixor = function(u) {
      return o((this.negative | u.negative) === 0), this.iuxor(u);
    }, a.prototype.xor = function(u) {
      return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
    }, a.prototype.uxor = function(u) {
      return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
    }, a.prototype.inotn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = Math.ceil(u / 26) | 0, g = u % 26;
      this._expand(h), g > 0 && h--;
      for (var y = 0; y < h; y++)
        this.words[y] = ~this.words[y] & 67108863;
      return g > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - g), this._strip();
    }, a.prototype.notn = function(u) {
      return this.clone().inotn(u);
    }, a.prototype.setn = function(u, h) {
      o(typeof u == "number" && u >= 0);
      var g = u / 26 | 0, y = u % 26;
      return this._expand(g + 1), h ? this.words[g] = this.words[g] | 1 << y : this.words[g] = this.words[g] & ~(1 << y), this._strip();
    }, a.prototype.iadd = function(u) {
      var h;
      if (this.negative !== 0 && u.negative === 0)
        return this.negative = 0, h = this.isub(u), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && u.negative !== 0)
        return u.negative = 0, h = this.isub(u), u.negative = 1, h._normSign();
      var g, y;
      this.length > u.length ? (g = this, y = u) : (g = u, y = this);
      for (var m = 0, _ = 0; _ < y.length; _++)
        h = (g.words[_] | 0) + (y.words[_] | 0) + m, this.words[_] = h & 67108863, m = h >>> 26;
      for (; m !== 0 && _ < g.length; _++)
        h = (g.words[_] | 0) + m, this.words[_] = h & 67108863, m = h >>> 26;
      if (this.length = g.length, m !== 0)
        this.words[this.length] = m, this.length++;
      else if (g !== this)
        for (; _ < g.length; _++)
          this.words[_] = g.words[_];
      return this;
    }, a.prototype.add = function(u) {
      var h;
      return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, h = this.sub(u), u.negative ^= 1, h) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, h = u.sub(this), this.negative = 1, h) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
    }, a.prototype.isub = function(u) {
      if (u.negative !== 0) {
        u.negative = 0;
        var h = this.iadd(u);
        return u.negative = 1, h._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
      var g = this.cmp(u);
      if (g === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, m;
      g > 0 ? (y = this, m = u) : (y = u, m = this);
      for (var _ = 0, R = 0; R < m.length; R++)
        h = (y.words[R] | 0) - (m.words[R] | 0) + _, _ = h >> 26, this.words[R] = h & 67108863;
      for (; _ !== 0 && R < y.length; R++)
        h = (y.words[R] | 0) + _, _ = h >> 26, this.words[R] = h & 67108863;
      if (_ === 0 && R < y.length && y !== this)
        for (; R < y.length; R++)
          this.words[R] = y.words[R];
      return this.length = Math.max(this.length, R), y !== this && (this.negative = 1), this._strip();
    }, a.prototype.sub = function(u) {
      return this.clone().isub(u);
    };
    function U(x, u, h) {
      h.negative = u.negative ^ x.negative;
      var g = x.length + u.length | 0;
      h.length = g, g = g - 1 | 0;
      var y = x.words[0] | 0, m = u.words[0] | 0, _ = y * m, R = _ & 67108863, b = _ / 67108864 | 0;
      h.words[0] = R;
      for (var l = 1; l < g; l++) {
        for (var v = b >>> 26, X = b & 67108863, S = Math.min(l, u.length - 1), Y = Math.max(0, l - x.length + 1); Y <= S; Y++) {
          var fe = l - Y | 0;
          y = x.words[fe] | 0, m = u.words[Y] | 0, _ = y * m + X, v += _ / 67108864 | 0, X = _ & 67108863;
        }
        h.words[l] = X | 0, b = v | 0;
      }
      return b !== 0 ? h.words[l] = b | 0 : h.length--, h._strip();
    }
    var G = function(u, h, g) {
      var y = u.words, m = h.words, _ = g.words, R = 0, b, l, v, X = y[0] | 0, S = X & 8191, Y = X >>> 13, fe = y[1] | 0, oe = fe & 8191, de = fe >>> 13, Ie = y[2] | 0, ye = Ie & 8191, be = Ie >>> 13, rt = y[3] | 0, xe = rt & 8191, Ne = rt >>> 13, j = y[4] | 0, z = j & 8191, ee = j >>> 13, ve = y[5] | 0, me = ve & 8191, Ae = ve >>> 13, it = y[6] | 0, ke = it & 8191, qe = it >>> 13, or = y[7] | 0, Oe = or & 8191, T = or >>> 13, A = y[8] | 0, E = A & 8191, F = A >>> 13, ie = y[9] | 0, ne = ie & 8191, ce = ie >>> 13, nt = m[0] | 0, Be = nt & 8191, Ce = nt >>> 13, _t = m[1] | 0, Me = _t & 8191, pt = _t >>> 13, qr = m[2] | 0, Xe = qr & 8191, yt = qr >>> 13, Zr = m[3] | 0, He = Zr & 8191, dt = Zr >>> 13, Hr = m[4] | 0, Ze = Hr & 8191, mt = Hr >>> 13, zr = m[5] | 0, Qe = zr & 8191, tt = zr >>> 13, Wr = m[6] | 0, q = Wr & 8191, Q = Wr >>> 13, ae = m[7] | 0, k = ae & 8191, re = ae >>> 13, Ee = m[8] | 0, pe = Ee & 8191, _e = Ee >>> 13, bt = m[9] | 0, Te = bt & 8191, Re = bt >>> 13;
      g.negative = u.negative ^ h.negative, g.length = 19, b = Math.imul(S, Be), l = Math.imul(S, Ce), l = l + Math.imul(Y, Be) | 0, v = Math.imul(Y, Ce);
      var Dr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, b = Math.imul(oe, Be), l = Math.imul(oe, Ce), l = l + Math.imul(de, Be) | 0, v = Math.imul(de, Ce), b = b + Math.imul(S, Me) | 0, l = l + Math.imul(S, pt) | 0, l = l + Math.imul(Y, Me) | 0, v = v + Math.imul(Y, pt) | 0;
      var vt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, b = Math.imul(ye, Be), l = Math.imul(ye, Ce), l = l + Math.imul(be, Be) | 0, v = Math.imul(be, Ce), b = b + Math.imul(oe, Me) | 0, l = l + Math.imul(oe, pt) | 0, l = l + Math.imul(de, Me) | 0, v = v + Math.imul(de, pt) | 0, b = b + Math.imul(S, Xe) | 0, l = l + Math.imul(S, yt) | 0, l = l + Math.imul(Y, Xe) | 0, v = v + Math.imul(Y, yt) | 0;
      var pr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, b = Math.imul(xe, Be), l = Math.imul(xe, Ce), l = l + Math.imul(Ne, Be) | 0, v = Math.imul(Ne, Ce), b = b + Math.imul(ye, Me) | 0, l = l + Math.imul(ye, pt) | 0, l = l + Math.imul(be, Me) | 0, v = v + Math.imul(be, pt) | 0, b = b + Math.imul(oe, Xe) | 0, l = l + Math.imul(oe, yt) | 0, l = l + Math.imul(de, Xe) | 0, v = v + Math.imul(de, yt) | 0, b = b + Math.imul(S, He) | 0, l = l + Math.imul(S, dt) | 0, l = l + Math.imul(Y, He) | 0, v = v + Math.imul(Y, dt) | 0;
      var Pr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, b = Math.imul(z, Be), l = Math.imul(z, Ce), l = l + Math.imul(ee, Be) | 0, v = Math.imul(ee, Ce), b = b + Math.imul(xe, Me) | 0, l = l + Math.imul(xe, pt) | 0, l = l + Math.imul(Ne, Me) | 0, v = v + Math.imul(Ne, pt) | 0, b = b + Math.imul(ye, Xe) | 0, l = l + Math.imul(ye, yt) | 0, l = l + Math.imul(be, Xe) | 0, v = v + Math.imul(be, yt) | 0, b = b + Math.imul(oe, He) | 0, l = l + Math.imul(oe, dt) | 0, l = l + Math.imul(de, He) | 0, v = v + Math.imul(de, dt) | 0, b = b + Math.imul(S, Ze) | 0, l = l + Math.imul(S, mt) | 0, l = l + Math.imul(Y, Ze) | 0, v = v + Math.imul(Y, mt) | 0;
      var Lr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, b = Math.imul(me, Be), l = Math.imul(me, Ce), l = l + Math.imul(Ae, Be) | 0, v = Math.imul(Ae, Ce), b = b + Math.imul(z, Me) | 0, l = l + Math.imul(z, pt) | 0, l = l + Math.imul(ee, Me) | 0, v = v + Math.imul(ee, pt) | 0, b = b + Math.imul(xe, Xe) | 0, l = l + Math.imul(xe, yt) | 0, l = l + Math.imul(Ne, Xe) | 0, v = v + Math.imul(Ne, yt) | 0, b = b + Math.imul(ye, He) | 0, l = l + Math.imul(ye, dt) | 0, l = l + Math.imul(be, He) | 0, v = v + Math.imul(be, dt) | 0, b = b + Math.imul(oe, Ze) | 0, l = l + Math.imul(oe, mt) | 0, l = l + Math.imul(de, Ze) | 0, v = v + Math.imul(de, mt) | 0, b = b + Math.imul(S, Qe) | 0, l = l + Math.imul(S, tt) | 0, l = l + Math.imul(Y, Qe) | 0, v = v + Math.imul(Y, tt) | 0;
      var Kr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Kr >>> 26) | 0, Kr &= 67108863, b = Math.imul(ke, Be), l = Math.imul(ke, Ce), l = l + Math.imul(qe, Be) | 0, v = Math.imul(qe, Ce), b = b + Math.imul(me, Me) | 0, l = l + Math.imul(me, pt) | 0, l = l + Math.imul(Ae, Me) | 0, v = v + Math.imul(Ae, pt) | 0, b = b + Math.imul(z, Xe) | 0, l = l + Math.imul(z, yt) | 0, l = l + Math.imul(ee, Xe) | 0, v = v + Math.imul(ee, yt) | 0, b = b + Math.imul(xe, He) | 0, l = l + Math.imul(xe, dt) | 0, l = l + Math.imul(Ne, He) | 0, v = v + Math.imul(Ne, dt) | 0, b = b + Math.imul(ye, Ze) | 0, l = l + Math.imul(ye, mt) | 0, l = l + Math.imul(be, Ze) | 0, v = v + Math.imul(be, mt) | 0, b = b + Math.imul(oe, Qe) | 0, l = l + Math.imul(oe, tt) | 0, l = l + Math.imul(de, Qe) | 0, v = v + Math.imul(de, tt) | 0, b = b + Math.imul(S, q) | 0, l = l + Math.imul(S, Q) | 0, l = l + Math.imul(Y, q) | 0, v = v + Math.imul(Y, Q) | 0;
      var $r = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, b = Math.imul(Oe, Be), l = Math.imul(Oe, Ce), l = l + Math.imul(T, Be) | 0, v = Math.imul(T, Ce), b = b + Math.imul(ke, Me) | 0, l = l + Math.imul(ke, pt) | 0, l = l + Math.imul(qe, Me) | 0, v = v + Math.imul(qe, pt) | 0, b = b + Math.imul(me, Xe) | 0, l = l + Math.imul(me, yt) | 0, l = l + Math.imul(Ae, Xe) | 0, v = v + Math.imul(Ae, yt) | 0, b = b + Math.imul(z, He) | 0, l = l + Math.imul(z, dt) | 0, l = l + Math.imul(ee, He) | 0, v = v + Math.imul(ee, dt) | 0, b = b + Math.imul(xe, Ze) | 0, l = l + Math.imul(xe, mt) | 0, l = l + Math.imul(Ne, Ze) | 0, v = v + Math.imul(Ne, mt) | 0, b = b + Math.imul(ye, Qe) | 0, l = l + Math.imul(ye, tt) | 0, l = l + Math.imul(be, Qe) | 0, v = v + Math.imul(be, tt) | 0, b = b + Math.imul(oe, q) | 0, l = l + Math.imul(oe, Q) | 0, l = l + Math.imul(de, q) | 0, v = v + Math.imul(de, Q) | 0, b = b + Math.imul(S, k) | 0, l = l + Math.imul(S, re) | 0, l = l + Math.imul(Y, k) | 0, v = v + Math.imul(Y, re) | 0;
      var Fr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, b = Math.imul(E, Be), l = Math.imul(E, Ce), l = l + Math.imul(F, Be) | 0, v = Math.imul(F, Ce), b = b + Math.imul(Oe, Me) | 0, l = l + Math.imul(Oe, pt) | 0, l = l + Math.imul(T, Me) | 0, v = v + Math.imul(T, pt) | 0, b = b + Math.imul(ke, Xe) | 0, l = l + Math.imul(ke, yt) | 0, l = l + Math.imul(qe, Xe) | 0, v = v + Math.imul(qe, yt) | 0, b = b + Math.imul(me, He) | 0, l = l + Math.imul(me, dt) | 0, l = l + Math.imul(Ae, He) | 0, v = v + Math.imul(Ae, dt) | 0, b = b + Math.imul(z, Ze) | 0, l = l + Math.imul(z, mt) | 0, l = l + Math.imul(ee, Ze) | 0, v = v + Math.imul(ee, mt) | 0, b = b + Math.imul(xe, Qe) | 0, l = l + Math.imul(xe, tt) | 0, l = l + Math.imul(Ne, Qe) | 0, v = v + Math.imul(Ne, tt) | 0, b = b + Math.imul(ye, q) | 0, l = l + Math.imul(ye, Q) | 0, l = l + Math.imul(be, q) | 0, v = v + Math.imul(be, Q) | 0, b = b + Math.imul(oe, k) | 0, l = l + Math.imul(oe, re) | 0, l = l + Math.imul(de, k) | 0, v = v + Math.imul(de, re) | 0, b = b + Math.imul(S, pe) | 0, l = l + Math.imul(S, _e) | 0, l = l + Math.imul(Y, pe) | 0, v = v + Math.imul(Y, _e) | 0;
      var Ur = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, b = Math.imul(ne, Be), l = Math.imul(ne, Ce), l = l + Math.imul(ce, Be) | 0, v = Math.imul(ce, Ce), b = b + Math.imul(E, Me) | 0, l = l + Math.imul(E, pt) | 0, l = l + Math.imul(F, Me) | 0, v = v + Math.imul(F, pt) | 0, b = b + Math.imul(Oe, Xe) | 0, l = l + Math.imul(Oe, yt) | 0, l = l + Math.imul(T, Xe) | 0, v = v + Math.imul(T, yt) | 0, b = b + Math.imul(ke, He) | 0, l = l + Math.imul(ke, dt) | 0, l = l + Math.imul(qe, He) | 0, v = v + Math.imul(qe, dt) | 0, b = b + Math.imul(me, Ze) | 0, l = l + Math.imul(me, mt) | 0, l = l + Math.imul(Ae, Ze) | 0, v = v + Math.imul(Ae, mt) | 0, b = b + Math.imul(z, Qe) | 0, l = l + Math.imul(z, tt) | 0, l = l + Math.imul(ee, Qe) | 0, v = v + Math.imul(ee, tt) | 0, b = b + Math.imul(xe, q) | 0, l = l + Math.imul(xe, Q) | 0, l = l + Math.imul(Ne, q) | 0, v = v + Math.imul(Ne, Q) | 0, b = b + Math.imul(ye, k) | 0, l = l + Math.imul(ye, re) | 0, l = l + Math.imul(be, k) | 0, v = v + Math.imul(be, re) | 0, b = b + Math.imul(oe, pe) | 0, l = l + Math.imul(oe, _e) | 0, l = l + Math.imul(de, pe) | 0, v = v + Math.imul(de, _e) | 0, b = b + Math.imul(S, Te) | 0, l = l + Math.imul(S, Re) | 0, l = l + Math.imul(Y, Te) | 0, v = v + Math.imul(Y, Re) | 0;
      var ar = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, b = Math.imul(ne, Me), l = Math.imul(ne, pt), l = l + Math.imul(ce, Me) | 0, v = Math.imul(ce, pt), b = b + Math.imul(E, Xe) | 0, l = l + Math.imul(E, yt) | 0, l = l + Math.imul(F, Xe) | 0, v = v + Math.imul(F, yt) | 0, b = b + Math.imul(Oe, He) | 0, l = l + Math.imul(Oe, dt) | 0, l = l + Math.imul(T, He) | 0, v = v + Math.imul(T, dt) | 0, b = b + Math.imul(ke, Ze) | 0, l = l + Math.imul(ke, mt) | 0, l = l + Math.imul(qe, Ze) | 0, v = v + Math.imul(qe, mt) | 0, b = b + Math.imul(me, Qe) | 0, l = l + Math.imul(me, tt) | 0, l = l + Math.imul(Ae, Qe) | 0, v = v + Math.imul(Ae, tt) | 0, b = b + Math.imul(z, q) | 0, l = l + Math.imul(z, Q) | 0, l = l + Math.imul(ee, q) | 0, v = v + Math.imul(ee, Q) | 0, b = b + Math.imul(xe, k) | 0, l = l + Math.imul(xe, re) | 0, l = l + Math.imul(Ne, k) | 0, v = v + Math.imul(Ne, re) | 0, b = b + Math.imul(ye, pe) | 0, l = l + Math.imul(ye, _e) | 0, l = l + Math.imul(be, pe) | 0, v = v + Math.imul(be, _e) | 0, b = b + Math.imul(oe, Te) | 0, l = l + Math.imul(oe, Re) | 0, l = l + Math.imul(de, Te) | 0, v = v + Math.imul(de, Re) | 0;
      var gr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, b = Math.imul(ne, Xe), l = Math.imul(ne, yt), l = l + Math.imul(ce, Xe) | 0, v = Math.imul(ce, yt), b = b + Math.imul(E, He) | 0, l = l + Math.imul(E, dt) | 0, l = l + Math.imul(F, He) | 0, v = v + Math.imul(F, dt) | 0, b = b + Math.imul(Oe, Ze) | 0, l = l + Math.imul(Oe, mt) | 0, l = l + Math.imul(T, Ze) | 0, v = v + Math.imul(T, mt) | 0, b = b + Math.imul(ke, Qe) | 0, l = l + Math.imul(ke, tt) | 0, l = l + Math.imul(qe, Qe) | 0, v = v + Math.imul(qe, tt) | 0, b = b + Math.imul(me, q) | 0, l = l + Math.imul(me, Q) | 0, l = l + Math.imul(Ae, q) | 0, v = v + Math.imul(Ae, Q) | 0, b = b + Math.imul(z, k) | 0, l = l + Math.imul(z, re) | 0, l = l + Math.imul(ee, k) | 0, v = v + Math.imul(ee, re) | 0, b = b + Math.imul(xe, pe) | 0, l = l + Math.imul(xe, _e) | 0, l = l + Math.imul(Ne, pe) | 0, v = v + Math.imul(Ne, _e) | 0, b = b + Math.imul(ye, Te) | 0, l = l + Math.imul(ye, Re) | 0, l = l + Math.imul(be, Te) | 0, v = v + Math.imul(be, Re) | 0;
      var zt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, b = Math.imul(ne, He), l = Math.imul(ne, dt), l = l + Math.imul(ce, He) | 0, v = Math.imul(ce, dt), b = b + Math.imul(E, Ze) | 0, l = l + Math.imul(E, mt) | 0, l = l + Math.imul(F, Ze) | 0, v = v + Math.imul(F, mt) | 0, b = b + Math.imul(Oe, Qe) | 0, l = l + Math.imul(Oe, tt) | 0, l = l + Math.imul(T, Qe) | 0, v = v + Math.imul(T, tt) | 0, b = b + Math.imul(ke, q) | 0, l = l + Math.imul(ke, Q) | 0, l = l + Math.imul(qe, q) | 0, v = v + Math.imul(qe, Q) | 0, b = b + Math.imul(me, k) | 0, l = l + Math.imul(me, re) | 0, l = l + Math.imul(Ae, k) | 0, v = v + Math.imul(Ae, re) | 0, b = b + Math.imul(z, pe) | 0, l = l + Math.imul(z, _e) | 0, l = l + Math.imul(ee, pe) | 0, v = v + Math.imul(ee, _e) | 0, b = b + Math.imul(xe, Te) | 0, l = l + Math.imul(xe, Re) | 0, l = l + Math.imul(Ne, Te) | 0, v = v + Math.imul(Ne, Re) | 0;
      var lr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, b = Math.imul(ne, Ze), l = Math.imul(ne, mt), l = l + Math.imul(ce, Ze) | 0, v = Math.imul(ce, mt), b = b + Math.imul(E, Qe) | 0, l = l + Math.imul(E, tt) | 0, l = l + Math.imul(F, Qe) | 0, v = v + Math.imul(F, tt) | 0, b = b + Math.imul(Oe, q) | 0, l = l + Math.imul(Oe, Q) | 0, l = l + Math.imul(T, q) | 0, v = v + Math.imul(T, Q) | 0, b = b + Math.imul(ke, k) | 0, l = l + Math.imul(ke, re) | 0, l = l + Math.imul(qe, k) | 0, v = v + Math.imul(qe, re) | 0, b = b + Math.imul(me, pe) | 0, l = l + Math.imul(me, _e) | 0, l = l + Math.imul(Ae, pe) | 0, v = v + Math.imul(Ae, _e) | 0, b = b + Math.imul(z, Te) | 0, l = l + Math.imul(z, Re) | 0, l = l + Math.imul(ee, Te) | 0, v = v + Math.imul(ee, Re) | 0;
      var dr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, b = Math.imul(ne, Qe), l = Math.imul(ne, tt), l = l + Math.imul(ce, Qe) | 0, v = Math.imul(ce, tt), b = b + Math.imul(E, q) | 0, l = l + Math.imul(E, Q) | 0, l = l + Math.imul(F, q) | 0, v = v + Math.imul(F, Q) | 0, b = b + Math.imul(Oe, k) | 0, l = l + Math.imul(Oe, re) | 0, l = l + Math.imul(T, k) | 0, v = v + Math.imul(T, re) | 0, b = b + Math.imul(ke, pe) | 0, l = l + Math.imul(ke, _e) | 0, l = l + Math.imul(qe, pe) | 0, v = v + Math.imul(qe, _e) | 0, b = b + Math.imul(me, Te) | 0, l = l + Math.imul(me, Re) | 0, l = l + Math.imul(Ae, Te) | 0, v = v + Math.imul(Ae, Re) | 0;
      var wt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, b = Math.imul(ne, q), l = Math.imul(ne, Q), l = l + Math.imul(ce, q) | 0, v = Math.imul(ce, Q), b = b + Math.imul(E, k) | 0, l = l + Math.imul(E, re) | 0, l = l + Math.imul(F, k) | 0, v = v + Math.imul(F, re) | 0, b = b + Math.imul(Oe, pe) | 0, l = l + Math.imul(Oe, _e) | 0, l = l + Math.imul(T, pe) | 0, v = v + Math.imul(T, _e) | 0, b = b + Math.imul(ke, Te) | 0, l = l + Math.imul(ke, Re) | 0, l = l + Math.imul(qe, Te) | 0, v = v + Math.imul(qe, Re) | 0;
      var Le = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, b = Math.imul(ne, k), l = Math.imul(ne, re), l = l + Math.imul(ce, k) | 0, v = Math.imul(ce, re), b = b + Math.imul(E, pe) | 0, l = l + Math.imul(E, _e) | 0, l = l + Math.imul(F, pe) | 0, v = v + Math.imul(F, _e) | 0, b = b + Math.imul(Oe, Te) | 0, l = l + Math.imul(Oe, Re) | 0, l = l + Math.imul(T, Te) | 0, v = v + Math.imul(T, Re) | 0;
      var Fe = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, b = Math.imul(ne, pe), l = Math.imul(ne, _e), l = l + Math.imul(ce, pe) | 0, v = Math.imul(ce, _e), b = b + Math.imul(E, Te) | 0, l = l + Math.imul(E, Re) | 0, l = l + Math.imul(F, Te) | 0, v = v + Math.imul(F, Re) | 0;
      var gt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, b = Math.imul(ne, Te), l = Math.imul(ne, Re), l = l + Math.imul(ce, Te) | 0, v = Math.imul(ce, Re);
      var et = (R + b | 0) + ((l & 8191) << 13) | 0;
      return R = (v + (l >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, _[0] = Dr, _[1] = vt, _[2] = pr, _[3] = Pr, _[4] = Lr, _[5] = Kr, _[6] = $r, _[7] = Fr, _[8] = Ur, _[9] = ar, _[10] = gr, _[11] = zt, _[12] = lr, _[13] = dr, _[14] = wt, _[15] = Le, _[16] = Fe, _[17] = gt, _[18] = et, R !== 0 && (_[19] = R, g.length++), g;
    };
    Math.imul || (G = U);
    function D(x, u, h) {
      h.negative = u.negative ^ x.negative, h.length = x.length + u.length;
      for (var g = 0, y = 0, m = 0; m < h.length - 1; m++) {
        var _ = y;
        y = 0;
        for (var R = g & 67108863, b = Math.min(m, u.length - 1), l = Math.max(0, m - x.length + 1); l <= b; l++) {
          var v = m - l, X = x.words[v] | 0, S = u.words[l] | 0, Y = X * S, fe = Y & 67108863;
          _ = _ + (Y / 67108864 | 0) | 0, fe = fe + R | 0, R = fe & 67108863, _ = _ + (fe >>> 26) | 0, y += _ >>> 26, _ &= 67108863;
        }
        h.words[m] = R, g = _, _ = y;
      }
      return g !== 0 ? h.words[m] = g : h.length--, h._strip();
    }
    function Z(x, u, h) {
      return D(x, u, h);
    }
    a.prototype.mulTo = function(u, h) {
      var g, y = this.length + u.length;
      return this.length === 10 && u.length === 10 ? g = G(this, u, h) : y < 63 ? g = U(this, u, h) : y < 1024 ? g = D(this, u, h) : g = Z(this, u, h), g;
    }, a.prototype.mul = function(u) {
      var h = new a(null);
      return h.words = new Array(this.length + u.length), this.mulTo(u, h);
    }, a.prototype.mulf = function(u) {
      var h = new a(null);
      return h.words = new Array(this.length + u.length), Z(this, u, h);
    }, a.prototype.imul = function(u) {
      return this.clone().mulTo(u, this);
    }, a.prototype.imuln = function(u) {
      var h = u < 0;
      h && (u = -u), o(typeof u == "number"), o(u < 67108864);
      for (var g = 0, y = 0; y < this.length; y++) {
        var m = (this.words[y] | 0) * u, _ = (m & 67108863) + (g & 67108863);
        g >>= 26, g += m / 67108864 | 0, g += _ >>> 26, this.words[y] = _ & 67108863;
      }
      return g !== 0 && (this.words[y] = g, this.length++), h ? this.ineg() : this;
    }, a.prototype.muln = function(u) {
      return this.clone().imuln(u);
    }, a.prototype.sqr = function() {
      return this.mul(this);
    }, a.prototype.isqr = function() {
      return this.imul(this.clone());
    }, a.prototype.pow = function(u) {
      var h = P(u);
      if (h.length === 0)
        return new a(1);
      for (var g = this, y = 0; y < h.length && h[y] === 0; y++, g = g.sqr())
        ;
      if (++y < h.length)
        for (var m = g.sqr(); y < h.length; y++, m = m.sqr())
          h[y] !== 0 && (g = g.mul(m));
      return g;
    }, a.prototype.iushln = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26, y = 67108863 >>> 26 - h << 26 - h, m;
      if (h !== 0) {
        var _ = 0;
        for (m = 0; m < this.length; m++) {
          var R = this.words[m] & y, b = (this.words[m] | 0) - R << h;
          this.words[m] = b | _, _ = R >>> 26 - h;
        }
        _ && (this.words[m] = _, this.length++);
      }
      if (g !== 0) {
        for (m = this.length - 1; m >= 0; m--)
          this.words[m + g] = this.words[m];
        for (m = 0; m < g; m++)
          this.words[m] = 0;
        this.length += g;
      }
      return this._strip();
    }, a.prototype.ishln = function(u) {
      return o(this.negative === 0), this.iushln(u);
    }, a.prototype.iushrn = function(u, h, g) {
      o(typeof u == "number" && u >= 0);
      var y;
      h ? y = (h - h % 26) / 26 : y = 0;
      var m = u % 26, _ = Math.min((u - m) / 26, this.length), R = 67108863 ^ 67108863 >>> m << m, b = g;
      if (y -= _, y = Math.max(0, y), b) {
        for (var l = 0; l < _; l++)
          b.words[l] = this.words[l];
        b.length = _;
      }
      if (_ !== 0)
        if (this.length > _)
          for (this.length -= _, l = 0; l < this.length; l++)
            this.words[l] = this.words[l + _];
        else
          this.words[0] = 0, this.length = 1;
      var v = 0;
      for (l = this.length - 1; l >= 0 && (v !== 0 || l >= y); l--) {
        var X = this.words[l] | 0;
        this.words[l] = v << 26 - m | X >>> m, v = X & R;
      }
      return b && v !== 0 && (b.words[b.length++] = v), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, a.prototype.ishrn = function(u, h, g) {
      return o(this.negative === 0), this.iushrn(u, h, g);
    }, a.prototype.shln = function(u) {
      return this.clone().ishln(u);
    }, a.prototype.ushln = function(u) {
      return this.clone().iushln(u);
    }, a.prototype.shrn = function(u) {
      return this.clone().ishrn(u);
    }, a.prototype.ushrn = function(u) {
      return this.clone().iushrn(u);
    }, a.prototype.testn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26, y = 1 << h;
      if (this.length <= g)
        return !1;
      var m = this.words[g];
      return !!(m & y);
    }, a.prototype.imaskn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26;
      if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g)
        return this;
      if (h !== 0 && g++, this.length = Math.min(g, this.length), h !== 0) {
        var y = 67108863 ^ 67108863 >>> h << h;
        this.words[this.length - 1] &= y;
      }
      return this._strip();
    }, a.prototype.maskn = function(u) {
      return this.clone().imaskn(u);
    }, a.prototype.iaddn = function(u) {
      return o(typeof u == "number"), o(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
    }, a.prototype._iaddn = function(u) {
      this.words[0] += u;
      for (var h = 0; h < this.length && this.words[h] >= 67108864; h++)
        this.words[h] -= 67108864, h === this.length - 1 ? this.words[h + 1] = 1 : this.words[h + 1]++;
      return this.length = Math.max(this.length, h + 1), this;
    }, a.prototype.isubn = function(u) {
      if (o(typeof u == "number"), o(u < 67108864), u < 0)
        return this.iaddn(-u);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(u), this.negative = 1, this;
      if (this.words[0] -= u, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var h = 0; h < this.length && this.words[h] < 0; h++)
          this.words[h] += 67108864, this.words[h + 1] -= 1;
      return this._strip();
    }, a.prototype.addn = function(u) {
      return this.clone().iaddn(u);
    }, a.prototype.subn = function(u) {
      return this.clone().isubn(u);
    }, a.prototype.iabs = function() {
      return this.negative = 0, this;
    }, a.prototype.abs = function() {
      return this.clone().iabs();
    }, a.prototype._ishlnsubmul = function(u, h, g) {
      var y = u.length + g, m;
      this._expand(y);
      var _, R = 0;
      for (m = 0; m < u.length; m++) {
        _ = (this.words[m + g] | 0) + R;
        var b = (u.words[m] | 0) * h;
        _ -= b & 67108863, R = (_ >> 26) - (b / 67108864 | 0), this.words[m + g] = _ & 67108863;
      }
      for (; m < this.length - g; m++)
        _ = (this.words[m + g] | 0) + R, R = _ >> 26, this.words[m + g] = _ & 67108863;
      if (R === 0)
        return this._strip();
      for (o(R === -1), R = 0, m = 0; m < this.length; m++)
        _ = -(this.words[m] | 0) + R, R = _ >> 26, this.words[m] = _ & 67108863;
      return this.negative = 1, this._strip();
    }, a.prototype._wordDiv = function(u, h) {
      var g = this.length - u.length, y = this.clone(), m = u, _ = m.words[m.length - 1] | 0, R = this._countBits(_);
      g = 26 - R, g !== 0 && (m = m.ushln(g), y.iushln(g), _ = m.words[m.length - 1] | 0);
      var b = y.length - m.length, l;
      if (h !== "mod") {
        l = new a(null), l.length = b + 1, l.words = new Array(l.length);
        for (var v = 0; v < l.length; v++)
          l.words[v] = 0;
      }
      var X = y.clone()._ishlnsubmul(m, 1, b);
      X.negative === 0 && (y = X, l && (l.words[b] = 1));
      for (var S = b - 1; S >= 0; S--) {
        var Y = (y.words[m.length + S] | 0) * 67108864 + (y.words[m.length + S - 1] | 0);
        for (Y = Math.min(Y / _ | 0, 67108863), y._ishlnsubmul(m, Y, S); y.negative !== 0; )
          Y--, y.negative = 0, y._ishlnsubmul(m, 1, S), y.isZero() || (y.negative ^= 1);
        l && (l.words[S] = Y);
      }
      return l && l._strip(), y._strip(), h !== "div" && g !== 0 && y.iushrn(g), {
        div: l || null,
        mod: y
      };
    }, a.prototype.divmod = function(u, h, g) {
      if (o(!u.isZero()), this.isZero())
        return {
          div: new a(0),
          mod: new a(0)
        };
      var y, m, _;
      return this.negative !== 0 && u.negative === 0 ? (_ = this.neg().divmod(u, h), h !== "mod" && (y = _.div.neg()), h !== "div" && (m = _.mod.neg(), g && m.negative !== 0 && m.iadd(u)), {
        div: y,
        mod: m
      }) : this.negative === 0 && u.negative !== 0 ? (_ = this.divmod(u.neg(), h), h !== "mod" && (y = _.div.neg()), {
        div: y,
        mod: _.mod
      }) : (this.negative & u.negative) !== 0 ? (_ = this.neg().divmod(u.neg(), h), h !== "div" && (m = _.mod.neg(), g && m.negative !== 0 && m.isub(u)), {
        div: _.div,
        mod: m
      }) : u.length > this.length || this.cmp(u) < 0 ? {
        div: new a(0),
        mod: this
      } : u.length === 1 ? h === "div" ? {
        div: this.divn(u.words[0]),
        mod: null
      } : h === "mod" ? {
        div: null,
        mod: new a(this.modrn(u.words[0]))
      } : {
        div: this.divn(u.words[0]),
        mod: new a(this.modrn(u.words[0]))
      } : this._wordDiv(u, h);
    }, a.prototype.div = function(u) {
      return this.divmod(u, "div", !1).div;
    }, a.prototype.mod = function(u) {
      return this.divmod(u, "mod", !1).mod;
    }, a.prototype.umod = function(u) {
      return this.divmod(u, "mod", !0).mod;
    }, a.prototype.divRound = function(u) {
      var h = this.divmod(u);
      if (h.mod.isZero())
        return h.div;
      var g = h.div.negative !== 0 ? h.mod.isub(u) : h.mod, y = u.ushrn(1), m = u.andln(1), _ = g.cmp(y);
      return _ < 0 || m === 1 && _ === 0 ? h.div : h.div.negative !== 0 ? h.div.isubn(1) : h.div.iaddn(1);
    }, a.prototype.modrn = function(u) {
      var h = u < 0;
      h && (u = -u), o(u <= 67108863);
      for (var g = (1 << 26) % u, y = 0, m = this.length - 1; m >= 0; m--)
        y = (g * y + (this.words[m] | 0)) % u;
      return h ? -y : y;
    }, a.prototype.modn = function(u) {
      return this.modrn(u);
    }, a.prototype.idivn = function(u) {
      var h = u < 0;
      h && (u = -u), o(u <= 67108863);
      for (var g = 0, y = this.length - 1; y >= 0; y--) {
        var m = (this.words[y] | 0) + g * 67108864;
        this.words[y] = m / u | 0, g = m % u;
      }
      return this._strip(), h ? this.ineg() : this;
    }, a.prototype.divn = function(u) {
      return this.clone().idivn(u);
    }, a.prototype.egcd = function(u) {
      o(u.negative === 0), o(!u.isZero());
      var h = this, g = u.clone();
      h.negative !== 0 ? h = h.umod(u) : h = h.clone();
      for (var y = new a(1), m = new a(0), _ = new a(0), R = new a(1), b = 0; h.isEven() && g.isEven(); )
        h.iushrn(1), g.iushrn(1), ++b;
      for (var l = g.clone(), v = h.clone(); !h.isZero(); ) {
        for (var X = 0, S = 1; (h.words[0] & S) === 0 && X < 26; ++X, S <<= 1)
          ;
        if (X > 0)
          for (h.iushrn(X); X-- > 0; )
            (y.isOdd() || m.isOdd()) && (y.iadd(l), m.isub(v)), y.iushrn(1), m.iushrn(1);
        for (var Y = 0, fe = 1; (g.words[0] & fe) === 0 && Y < 26; ++Y, fe <<= 1)
          ;
        if (Y > 0)
          for (g.iushrn(Y); Y-- > 0; )
            (_.isOdd() || R.isOdd()) && (_.iadd(l), R.isub(v)), _.iushrn(1), R.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), y.isub(_), m.isub(R)) : (g.isub(h), _.isub(y), R.isub(m));
      }
      return {
        a: _,
        b: R,
        gcd: g.iushln(b)
      };
    }, a.prototype._invmp = function(u) {
      o(u.negative === 0), o(!u.isZero());
      var h = this, g = u.clone();
      h.negative !== 0 ? h = h.umod(u) : h = h.clone();
      for (var y = new a(1), m = new a(0), _ = g.clone(); h.cmpn(1) > 0 && g.cmpn(1) > 0; ) {
        for (var R = 0, b = 1; (h.words[0] & b) === 0 && R < 26; ++R, b <<= 1)
          ;
        if (R > 0)
          for (h.iushrn(R); R-- > 0; )
            y.isOdd() && y.iadd(_), y.iushrn(1);
        for (var l = 0, v = 1; (g.words[0] & v) === 0 && l < 26; ++l, v <<= 1)
          ;
        if (l > 0)
          for (g.iushrn(l); l-- > 0; )
            m.isOdd() && m.iadd(_), m.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), y.isub(m)) : (g.isub(h), m.isub(y));
      }
      var X;
      return h.cmpn(1) === 0 ? X = y : X = m, X.cmpn(0) < 0 && X.iadd(u), X;
    }, a.prototype.gcd = function(u) {
      if (this.isZero())
        return u.abs();
      if (u.isZero())
        return this.abs();
      var h = this.clone(), g = u.clone();
      h.negative = 0, g.negative = 0;
      for (var y = 0; h.isEven() && g.isEven(); y++)
        h.iushrn(1), g.iushrn(1);
      do {
        for (; h.isEven(); )
          h.iushrn(1);
        for (; g.isEven(); )
          g.iushrn(1);
        var m = h.cmp(g);
        if (m < 0) {
          var _ = h;
          h = g, g = _;
        } else if (m === 0 || g.cmpn(1) === 0)
          break;
        h.isub(g);
      } while (!0);
      return g.iushln(y);
    }, a.prototype.invm = function(u) {
      return this.egcd(u).a.umod(u);
    }, a.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, a.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, a.prototype.andln = function(u) {
      return this.words[0] & u;
    }, a.prototype.bincn = function(u) {
      o(typeof u == "number");
      var h = u % 26, g = (u - h) / 26, y = 1 << h;
      if (this.length <= g)
        return this._expand(g + 1), this.words[g] |= y, this;
      for (var m = y, _ = g; m !== 0 && _ < this.length; _++) {
        var R = this.words[_] | 0;
        R += m, m = R >>> 26, R &= 67108863, this.words[_] = R;
      }
      return m !== 0 && (this.words[_] = m, this.length++), this;
    }, a.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, a.prototype.cmpn = function(u) {
      var h = u < 0;
      if (this.negative !== 0 && !h)
        return -1;
      if (this.negative === 0 && h)
        return 1;
      this._strip();
      var g;
      if (this.length > 1)
        g = 1;
      else {
        h && (u = -u), o(u <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        g = y === u ? 0 : y < u ? -1 : 1;
      }
      return this.negative !== 0 ? -g | 0 : g;
    }, a.prototype.cmp = function(u) {
      if (this.negative !== 0 && u.negative === 0)
        return -1;
      if (this.negative === 0 && u.negative !== 0)
        return 1;
      var h = this.ucmp(u);
      return this.negative !== 0 ? -h | 0 : h;
    }, a.prototype.ucmp = function(u) {
      if (this.length > u.length)
        return 1;
      if (this.length < u.length)
        return -1;
      for (var h = 0, g = this.length - 1; g >= 0; g--) {
        var y = this.words[g] | 0, m = u.words[g] | 0;
        if (y !== m) {
          y < m ? h = -1 : y > m && (h = 1);
          break;
        }
      }
      return h;
    }, a.prototype.gtn = function(u) {
      return this.cmpn(u) === 1;
    }, a.prototype.gt = function(u) {
      return this.cmp(u) === 1;
    }, a.prototype.gten = function(u) {
      return this.cmpn(u) >= 0;
    }, a.prototype.gte = function(u) {
      return this.cmp(u) >= 0;
    }, a.prototype.ltn = function(u) {
      return this.cmpn(u) === -1;
    }, a.prototype.lt = function(u) {
      return this.cmp(u) === -1;
    }, a.prototype.lten = function(u) {
      return this.cmpn(u) <= 0;
    }, a.prototype.lte = function(u) {
      return this.cmp(u) <= 0;
    }, a.prototype.eqn = function(u) {
      return this.cmpn(u) === 0;
    }, a.prototype.eq = function(u) {
      return this.cmp(u) === 0;
    }, a.red = function(u) {
      return new O(u);
    }, a.prototype.toRed = function(u) {
      return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
    }, a.prototype.fromRed = function() {
      return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, a.prototype._forceRed = function(u) {
      return this.red = u, this;
    }, a.prototype.forceRed = function(u) {
      return o(!this.red, "Already a number in reduction context"), this._forceRed(u);
    }, a.prototype.redAdd = function(u) {
      return o(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
    }, a.prototype.redIAdd = function(u) {
      return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
    }, a.prototype.redSub = function(u) {
      return o(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
    }, a.prototype.redISub = function(u) {
      return o(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
    }, a.prototype.redShl = function(u) {
      return o(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
    }, a.prototype.redMul = function(u) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
    }, a.prototype.redIMul = function(u) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
    }, a.prototype.redSqr = function() {
      return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, a.prototype.redISqr = function() {
      return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, a.prototype.redSqrt = function() {
      return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, a.prototype.redInvm = function() {
      return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, a.prototype.redNeg = function() {
      return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, a.prototype.redPow = function(u) {
      return o(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
    };
    var J = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function te(x, u) {
      this.name = x, this.p = new a(u, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    te.prototype._tmp = function() {
      var u = new a(null);
      return u.words = new Array(Math.ceil(this.n / 13)), u;
    }, te.prototype.ireduce = function(u) {
      var h = u, g;
      do
        this.split(h, this.tmp), h = this.imulK(h), h = h.iadd(this.tmp), g = h.bitLength();
      while (g > this.n);
      var y = g < this.n ? -1 : h.ucmp(this.p);
      return y === 0 ? (h.words[0] = 0, h.length = 1) : y > 0 ? h.isub(this.p) : h.strip !== void 0 ? h.strip() : h._strip(), h;
    }, te.prototype.split = function(u, h) {
      u.iushrn(this.n, 0, h);
    }, te.prototype.imulK = function(u) {
      return u.imul(this.k);
    };
    function ue() {
      te.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    c(ue, te), ue.prototype.split = function(u, h) {
      for (var g = 4194303, y = Math.min(u.length, 9), m = 0; m < y; m++)
        h.words[m] = u.words[m];
      if (h.length = y, u.length <= 9) {
        u.words[0] = 0, u.length = 1;
        return;
      }
      var _ = u.words[9];
      for (h.words[h.length++] = _ & g, m = 10; m < u.length; m++) {
        var R = u.words[m] | 0;
        u.words[m - 10] = (R & g) << 4 | _ >>> 22, _ = R;
      }
      _ >>>= 22, u.words[m - 10] = _, _ === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
    }, ue.prototype.imulK = function(u) {
      u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
      for (var h = 0, g = 0; g < u.length; g++) {
        var y = u.words[g] | 0;
        h += y * 977, u.words[g] = h & 67108863, h = y * 64 + (h / 67108864 | 0);
      }
      return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
    };
    function he() {
      te.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    c(he, te);
    function Se() {
      te.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    c(Se, te);
    function C() {
      te.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    c(C, te), C.prototype.imulK = function(u) {
      for (var h = 0, g = 0; g < u.length; g++) {
        var y = (u.words[g] | 0) * 19 + h, m = y & 67108863;
        y >>>= 26, u.words[g] = m, h = y;
      }
      return h !== 0 && (u.words[u.length++] = h), u;
    }, a._prime = function(u) {
      if (J[u])
        return J[u];
      var h;
      if (u === "k256")
        h = new ue();
      else if (u === "p224")
        h = new he();
      else if (u === "p192")
        h = new Se();
      else if (u === "p25519")
        h = new C();
      else
        throw new Error("Unknown prime " + u);
      return J[u] = h, h;
    };
    function O(x) {
      if (typeof x == "string") {
        var u = a._prime(x);
        this.m = u.p, this.prime = u;
      } else
        o(x.gtn(1), "modulus must be greater than 1"), this.m = x, this.prime = null;
    }
    O.prototype._verify1 = function(u) {
      o(u.negative === 0, "red works only with positives"), o(u.red, "red works only with red numbers");
    }, O.prototype._verify2 = function(u, h) {
      o((u.negative | h.negative) === 0, "red works only with positives"), o(
        u.red && u.red === h.red,
        "red works only with red numbers"
      );
    }, O.prototype.imod = function(u) {
      return this.prime ? this.prime.ireduce(u)._forceRed(this) : (I(u, u.umod(this.m)._forceRed(this)), u);
    }, O.prototype.neg = function(u) {
      return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
    }, O.prototype.add = function(u, h) {
      this._verify2(u, h);
      var g = u.add(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
    }, O.prototype.iadd = function(u, h) {
      this._verify2(u, h);
      var g = u.iadd(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g;
    }, O.prototype.sub = function(u, h) {
      this._verify2(u, h);
      var g = u.sub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
    }, O.prototype.isub = function(u, h) {
      this._verify2(u, h);
      var g = u.isub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g;
    }, O.prototype.shl = function(u, h) {
      return this._verify1(u), this.imod(u.ushln(h));
    }, O.prototype.imul = function(u, h) {
      return this._verify2(u, h), this.imod(u.imul(h));
    }, O.prototype.mul = function(u, h) {
      return this._verify2(u, h), this.imod(u.mul(h));
    }, O.prototype.isqr = function(u) {
      return this.imul(u, u.clone());
    }, O.prototype.sqr = function(u) {
      return this.mul(u, u);
    }, O.prototype.sqrt = function(u) {
      if (u.isZero())
        return u.clone();
      var h = this.m.andln(3);
      if (o(h % 2 === 1), h === 3) {
        var g = this.m.add(new a(1)).iushrn(2);
        return this.pow(u, g);
      }
      for (var y = this.m.subn(1), m = 0; !y.isZero() && y.andln(1) === 0; )
        m++, y.iushrn(1);
      o(!y.isZero());
      var _ = new a(1).toRed(this), R = _.redNeg(), b = this.m.subn(1).iushrn(1), l = this.m.bitLength();
      for (l = new a(2 * l * l).toRed(this); this.pow(l, b).cmp(R) !== 0; )
        l.redIAdd(R);
      for (var v = this.pow(l, y), X = this.pow(u, y.addn(1).iushrn(1)), S = this.pow(u, y), Y = m; S.cmp(_) !== 0; ) {
        for (var fe = S, oe = 0; fe.cmp(_) !== 0; oe++)
          fe = fe.redSqr();
        o(oe < Y);
        var de = this.pow(v, new a(1).iushln(Y - oe - 1));
        X = X.redMul(de), v = de.redSqr(), S = S.redMul(v), Y = oe;
      }
      return X;
    }, O.prototype.invm = function(u) {
      var h = u._invmp(this.m);
      return h.negative !== 0 ? (h.negative = 0, this.imod(h).redNeg()) : this.imod(h);
    }, O.prototype.pow = function(u, h) {
      if (h.isZero())
        return new a(1).toRed(this);
      if (h.cmpn(1) === 0)
        return u.clone();
      var g = 4, y = new Array(1 << g);
      y[0] = new a(1).toRed(this), y[1] = u;
      for (var m = 2; m < y.length; m++)
        y[m] = this.mul(y[m - 1], u);
      var _ = y[0], R = 0, b = 0, l = h.bitLength() % 26;
      for (l === 0 && (l = 26), m = h.length - 1; m >= 0; m--) {
        for (var v = h.words[m], X = l - 1; X >= 0; X--) {
          var S = v >> X & 1;
          if (_ !== y[0] && (_ = this.sqr(_)), S === 0 && R === 0) {
            b = 0;
            continue;
          }
          R <<= 1, R |= S, b++, !(b !== g && (m !== 0 || X !== 0)) && (_ = this.mul(_, y[R]), b = 0, R = 0);
        }
        l = 26;
      }
      return _;
    }, O.prototype.convertTo = function(u) {
      var h = u.umod(this.m);
      return h === u ? h.clone() : h;
    }, O.prototype.convertFrom = function(u) {
      var h = u.clone();
      return h.red = null, h;
    }, a.mont = function(u) {
      return new V(u);
    };
    function V(x) {
      O.call(this, x), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    c(V, O), V.prototype.convertTo = function(u) {
      return this.imod(u.ushln(this.shift));
    }, V.prototype.convertFrom = function(u) {
      var h = this.imod(u.mul(this.rinv));
      return h.red = null, h;
    }, V.prototype.imul = function(u, h) {
      if (u.isZero() || h.isZero())
        return u.words[0] = 0, u.length = 1, u;
      var g = u.imul(h), y = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = g.isub(y).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, V.prototype.mul = function(u, h) {
      if (u.isZero() || h.isZero())
        return new a(0)._forceRed(this);
      var g = u.mul(h), y = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = g.isub(y).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, V.prototype.invm = function(u) {
      var h = this.imod(u._invmp(this.m).mul(this.r2));
      return h._forceRed(this);
    };
  })(n, commonjsGlobal);
})(bn$3);
const BN$2 = bn$3.exports, Chi = (n, e, t) => n & e ^ ~n & t, Maj = (n, e, t) => n & e ^ n & t ^ e & t, SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = new Uint32Array(64);
class SHA256$2 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: e, B: t, C: o, D: c, E: a, F: d, G: p, H: w } = this;
    return [e, t, o, c, a, d, p, w];
  }
  set(e, t, o, c, a, d, p, w) {
    this.A = e | 0, this.B = t | 0, this.C = o | 0, this.D = c | 0, this.E = a | 0, this.F = d | 0, this.G = p | 0, this.H = w | 0;
  }
  process(e, t) {
    for (let B = 0; B < 16; B++, t += 4)
      SHA256_W[B] = e.getUint32(t, !1);
    for (let B = 16; B < 64; B++) {
      const H = SHA256_W[B - 15], L = SHA256_W[B - 2], W = rotr(H, 7) ^ rotr(H, 18) ^ H >>> 3, $ = rotr(L, 17) ^ rotr(L, 19) ^ L >>> 10;
      SHA256_W[B] = $ + SHA256_W[B - 7] + W + SHA256_W[B - 16] | 0;
    }
    let { A: o, B: c, C: a, D: d, E: p, F: w, G: M, H: I } = this;
    for (let B = 0; B < 64; B++) {
      const H = rotr(p, 6) ^ rotr(p, 11) ^ rotr(p, 25), L = I + H + Chi(p, w, M) + SHA256_K[B] + SHA256_W[B] | 0, $ = (rotr(o, 2) ^ rotr(o, 13) ^ rotr(o, 22)) + Maj(o, c, a) | 0;
      I = M, M = w, w = p, p = d + L | 0, d = a, a = c, c = o, o = L + $ | 0;
    }
    o = o + this.A | 0, c = c + this.B | 0, a = a + this.C | 0, d = d + this.D | 0, p = p + this.E | 0, w = w + this.F | 0, M = M + this.G | 0, I = I + this.H | 0, this.set(o, c, a, d, p, w, M, I);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const sha256$2 = wrapConstructor(() => new SHA256$2());
var Layout$1 = {};
Object.defineProperty(Layout$1, "__esModule", { value: !0 });
Layout$1.s16 = Layout$1.s8 = Layout$1.nu64be = Layout$1.u48be = Layout$1.u40be = Layout$1.u32be = Layout$1.u24be = Layout$1.u16be = nu64 = Layout$1.nu64 = Layout$1.u48 = Layout$1.u40 = u32 = Layout$1.u32 = Layout$1.u24 = u16 = Layout$1.u16 = u8 = Layout$1.u8 = offset = Layout$1.offset = Layout$1.greedy = Layout$1.Constant = Layout$1.UTF8 = Layout$1.CString = Layout$1.Blob = Layout$1.Boolean = Layout$1.BitField = Layout$1.BitStructure = Layout$1.VariantLayout = Layout$1.Union = Layout$1.UnionLayoutDiscriminator = Layout$1.UnionDiscriminator = Layout$1.Structure = Layout$1.Sequence = Layout$1.DoubleBE = Layout$1.Double = Layout$1.FloatBE = Layout$1.Float = Layout$1.NearInt64BE = Layout$1.NearInt64 = Layout$1.NearUInt64BE = Layout$1.NearUInt64 = Layout$1.IntBE = Layout$1.Int = Layout$1.UIntBE = Layout$1.UInt = Layout$1.OffsetLayout = Layout$1.GreedyCount = Layout$1.ExternalLayout = Layout$1.bindConstructorLayout = Layout$1.nameWithProperty = Layout$1.Layout = Layout$1.uint8ArrayToBuffer = Layout$1.checkUint8Array = void 0;
Layout$1.constant = Layout$1.utf8 = Layout$1.cstr = blob = Layout$1.blob = Layout$1.unionLayoutDiscriminator = Layout$1.union = seq = Layout$1.seq = Layout$1.bits = struct = Layout$1.struct = Layout$1.f64be = Layout$1.f64 = Layout$1.f32be = Layout$1.f32 = Layout$1.ns64be = Layout$1.s48be = Layout$1.s40be = Layout$1.s32be = Layout$1.s24be = Layout$1.s16be = ns64 = Layout$1.ns64 = Layout$1.s48 = Layout$1.s40 = Layout$1.s32 = Layout$1.s24 = void 0;
const buffer_1 = buffer$1;
function checkUint8Array(n) {
  if (!(n instanceof Uint8Array))
    throw new TypeError("b must be a Uint8Array");
}
Layout$1.checkUint8Array = checkUint8Array;
function uint8ArrayToBuffer(n) {
  return checkUint8Array(n), buffer_1.Buffer.from(n.buffer, n.byteOffset, n.length);
}
Layout$1.uint8ArrayToBuffer = uint8ArrayToBuffer;
class Layout {
  constructor(e, t) {
    if (!Number.isInteger(e))
      throw new TypeError("span must be an integer");
    this.span = e, this.property = t;
  }
  makeDestinationObject() {
    return {};
  }
  getSpan(e, t) {
    if (0 > this.span)
      throw new RangeError("indeterminate span");
    return this.span;
  }
  replicate(e) {
    const t = Object.create(this.constructor.prototype);
    return Object.assign(t, this), t.property = e, t;
  }
  fromArray(e) {
  }
}
Layout$1.Layout = Layout;
function nameWithProperty(n, e) {
  return e.property ? n + "[" + e.property + "]" : n;
}
Layout$1.nameWithProperty = nameWithProperty;
function bindConstructorLayout(n, e) {
  if (typeof n != "function")
    throw new TypeError("Class must be constructor");
  if (Object.prototype.hasOwnProperty.call(n, "layout_"))
    throw new Error("Class is already bound to a layout");
  if (!(e && e instanceof Layout))
    throw new TypeError("layout must be a Layout");
  if (Object.prototype.hasOwnProperty.call(e, "boundConstructor_"))
    throw new Error("layout is already bound to a constructor");
  n.layout_ = e, e.boundConstructor_ = n, e.makeDestinationObject = () => new n(), Object.defineProperty(n.prototype, "encode", {
    value(t, o) {
      return e.encode(this, t, o);
    },
    writable: !0
  }), Object.defineProperty(n, "decode", {
    value(t, o) {
      return e.decode(t, o);
    },
    writable: !0
  });
}
Layout$1.bindConstructorLayout = bindConstructorLayout;
class ExternalLayout extends Layout {
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
}
Layout$1.ExternalLayout = ExternalLayout;
class GreedyCount extends ExternalLayout {
  constructor(e = 1, t) {
    if (!Number.isInteger(e) || 0 >= e)
      throw new TypeError("elementSpan must be a (positive) integer");
    super(-1, t), this.elementSpan = e;
  }
  isCount() {
    return !0;
  }
  decode(e, t = 0) {
    checkUint8Array(e);
    const o = e.length - t;
    return Math.floor(o / this.elementSpan);
  }
  encode(e, t, o) {
    return 0;
  }
}
Layout$1.GreedyCount = GreedyCount;
class OffsetLayout extends ExternalLayout {
  constructor(e, t = 0, o) {
    if (!(e instanceof Layout))
      throw new TypeError("layout must be a Layout");
    if (!Number.isInteger(t))
      throw new TypeError("offset must be integer or undefined");
    super(e.span, o || e.property), this.layout = e, this.offset = t;
  }
  isCount() {
    return this.layout instanceof UInt || this.layout instanceof UIntBE;
  }
  decode(e, t = 0) {
    return this.layout.decode(e, t + this.offset);
  }
  encode(e, t, o = 0) {
    return this.layout.encode(e, t, o + this.offset);
  }
}
Layout$1.OffsetLayout = OffsetLayout;
class UInt extends Layout {
  constructor(e, t) {
    if (super(e, t), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(e, t = 0) {
    return uint8ArrayToBuffer(e).readUIntLE(t, this.span);
  }
  encode(e, t, o = 0) {
    return uint8ArrayToBuffer(t).writeUIntLE(e, o, this.span), this.span;
  }
}
Layout$1.UInt = UInt;
class UIntBE extends Layout {
  constructor(e, t) {
    if (super(e, t), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(e, t = 0) {
    return uint8ArrayToBuffer(e).readUIntBE(t, this.span);
  }
  encode(e, t, o = 0) {
    return uint8ArrayToBuffer(t).writeUIntBE(e, o, this.span), this.span;
  }
}
Layout$1.UIntBE = UIntBE;
class Int extends Layout {
  constructor(e, t) {
    if (super(e, t), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(e, t = 0) {
    return uint8ArrayToBuffer(e).readIntLE(t, this.span);
  }
  encode(e, t, o = 0) {
    return uint8ArrayToBuffer(t).writeIntLE(e, o, this.span), this.span;
  }
}
Layout$1.Int = Int;
class IntBE extends Layout {
  constructor(e, t) {
    if (super(e, t), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(e, t = 0) {
    return uint8ArrayToBuffer(e).readIntBE(t, this.span);
  }
  encode(e, t, o = 0) {
    return uint8ArrayToBuffer(t).writeIntBE(e, o, this.span), this.span;
  }
}
Layout$1.IntBE = IntBE;
const V2E32 = Math.pow(2, 32);
function divmodInt64(n) {
  const e = Math.floor(n / V2E32), t = n - e * V2E32;
  return { hi32: e, lo32: t };
}
function roundedInt64(n, e) {
  return n * V2E32 + e;
}
class NearUInt64 extends Layout {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    const o = uint8ArrayToBuffer(e), c = o.readUInt32LE(t), a = o.readUInt32LE(t + 4);
    return roundedInt64(a, c);
  }
  encode(e, t, o = 0) {
    const c = divmodInt64(e), a = uint8ArrayToBuffer(t);
    return a.writeUInt32LE(c.lo32, o), a.writeUInt32LE(c.hi32, o + 4), 8;
  }
}
Layout$1.NearUInt64 = NearUInt64;
class NearUInt64BE extends Layout {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    const o = uint8ArrayToBuffer(e), c = o.readUInt32BE(t), a = o.readUInt32BE(t + 4);
    return roundedInt64(c, a);
  }
  encode(e, t, o = 0) {
    const c = divmodInt64(e), a = uint8ArrayToBuffer(t);
    return a.writeUInt32BE(c.hi32, o), a.writeUInt32BE(c.lo32, o + 4), 8;
  }
}
Layout$1.NearUInt64BE = NearUInt64BE;
class NearInt64 extends Layout {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    const o = uint8ArrayToBuffer(e), c = o.readUInt32LE(t), a = o.readInt32LE(t + 4);
    return roundedInt64(a, c);
  }
  encode(e, t, o = 0) {
    const c = divmodInt64(e), a = uint8ArrayToBuffer(t);
    return a.writeUInt32LE(c.lo32, o), a.writeInt32LE(c.hi32, o + 4), 8;
  }
}
Layout$1.NearInt64 = NearInt64;
class NearInt64BE extends Layout {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    const o = uint8ArrayToBuffer(e), c = o.readInt32BE(t), a = o.readUInt32BE(t + 4);
    return roundedInt64(c, a);
  }
  encode(e, t, o = 0) {
    const c = divmodInt64(e), a = uint8ArrayToBuffer(t);
    return a.writeInt32BE(c.hi32, o), a.writeUInt32BE(c.lo32, o + 4), 8;
  }
}
Layout$1.NearInt64BE = NearInt64BE;
class Float extends Layout {
  constructor(e) {
    super(4, e);
  }
  decode(e, t = 0) {
    return uint8ArrayToBuffer(e).readFloatLE(t);
  }
  encode(e, t, o = 0) {
    return uint8ArrayToBuffer(t).writeFloatLE(e, o), 4;
  }
}
Layout$1.Float = Float;
class FloatBE extends Layout {
  constructor(e) {
    super(4, e);
  }
  decode(e, t = 0) {
    return uint8ArrayToBuffer(e).readFloatBE(t);
  }
  encode(e, t, o = 0) {
    return uint8ArrayToBuffer(t).writeFloatBE(e, o), 4;
  }
}
Layout$1.FloatBE = FloatBE;
class Double extends Layout {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    return uint8ArrayToBuffer(e).readDoubleLE(t);
  }
  encode(e, t, o = 0) {
    return uint8ArrayToBuffer(t).writeDoubleLE(e, o), 8;
  }
}
Layout$1.Double = Double;
class DoubleBE extends Layout {
  constructor(e) {
    super(8, e);
  }
  decode(e, t = 0) {
    return uint8ArrayToBuffer(e).readDoubleBE(t);
  }
  encode(e, t, o = 0) {
    return uint8ArrayToBuffer(t).writeDoubleBE(e, o), 8;
  }
}
Layout$1.DoubleBE = DoubleBE;
class Sequence extends Layout {
  constructor(e, t, o) {
    if (!(e instanceof Layout))
      throw new TypeError("elementLayout must be a Layout");
    if (!(t instanceof ExternalLayout && t.isCount() || Number.isInteger(t) && 0 <= t))
      throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
    let c = -1;
    !(t instanceof ExternalLayout) && 0 < e.span && (c = t * e.span), super(c, o), this.elementLayout = e, this.count = t;
  }
  getSpan(e, t = 0) {
    if (0 <= this.span)
      return this.span;
    let o = 0, c = this.count;
    if (c instanceof ExternalLayout && (c = c.decode(e, t)), 0 < this.elementLayout.span)
      o = c * this.elementLayout.span;
    else {
      let a = 0;
      for (; a < c; )
        o += this.elementLayout.getSpan(e, t + o), ++a;
    }
    return o;
  }
  decode(e, t = 0) {
    const o = [];
    let c = 0, a = this.count;
    for (a instanceof ExternalLayout && (a = a.decode(e, t)); c < a; )
      o.push(this.elementLayout.decode(e, t)), t += this.elementLayout.getSpan(e, t), c += 1;
    return o;
  }
  encode(e, t, o = 0) {
    const c = this.elementLayout, a = e.reduce((d, p) => d + c.encode(p, t, o + d), 0);
    return this.count instanceof ExternalLayout && this.count.encode(e.length, t, o), a;
  }
}
Layout$1.Sequence = Sequence;
class Structure extends Layout {
  constructor(e, t, o) {
    if (!(Array.isArray(e) && e.reduce((a, d) => a && d instanceof Layout, !0)))
      throw new TypeError("fields must be array of Layout instances");
    typeof t == "boolean" && o === void 0 && (o = t, t = void 0);
    for (const a of e)
      if (0 > a.span && a.property === void 0)
        throw new Error("fields cannot contain unnamed variable-length layout");
    let c = -1;
    try {
      c = e.reduce((a, d) => a + d.getSpan(), 0);
    } catch {
    }
    super(c, t), this.fields = e, this.decodePrefixes = !!o;
  }
  getSpan(e, t = 0) {
    if (0 <= this.span)
      return this.span;
    let o = 0;
    try {
      o = this.fields.reduce((c, a) => {
        const d = a.getSpan(e, t);
        return t += d, c + d;
      }, 0);
    } catch {
      throw new RangeError("indeterminate span");
    }
    return o;
  }
  decode(e, t = 0) {
    checkUint8Array(e);
    const o = this.makeDestinationObject();
    for (const c of this.fields)
      if (c.property !== void 0 && (o[c.property] = c.decode(e, t)), t += c.getSpan(e, t), this.decodePrefixes && e.length === t)
        break;
    return o;
  }
  encode(e, t, o = 0) {
    const c = o;
    let a = 0, d = 0;
    for (const p of this.fields) {
      let w = p.span;
      if (d = 0 < w ? w : 0, p.property !== void 0) {
        const M = e[p.property];
        M !== void 0 && (d = p.encode(M, t, o), 0 > w && (w = p.getSpan(t, o)));
      }
      a = o, o += w;
    }
    return a + d - c;
  }
  fromArray(e) {
    const t = this.makeDestinationObject();
    for (const o of this.fields)
      o.property !== void 0 && 0 < e.length && (t[o.property] = e.shift());
    return t;
  }
  layoutFor(e) {
    if (typeof e != "string")
      throw new TypeError("property must be string");
    for (const t of this.fields)
      if (t.property === e)
        return t;
  }
  offsetOf(e) {
    if (typeof e != "string")
      throw new TypeError("property must be string");
    let t = 0;
    for (const o of this.fields) {
      if (o.property === e)
        return t;
      0 > o.span ? t = -1 : 0 <= t && (t += o.span);
    }
  }
}
Layout$1.Structure = Structure;
class UnionDiscriminator {
  constructor(e) {
    this.property = e;
  }
  decode(e, t) {
    throw new Error("UnionDiscriminator is abstract");
  }
  encode(e, t, o) {
    throw new Error("UnionDiscriminator is abstract");
  }
}
Layout$1.UnionDiscriminator = UnionDiscriminator;
class UnionLayoutDiscriminator extends UnionDiscriminator {
  constructor(e, t) {
    if (!(e instanceof ExternalLayout && e.isCount()))
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    super(t || e.property || "variant"), this.layout = e;
  }
  decode(e, t) {
    return this.layout.decode(e, t);
  }
  encode(e, t, o) {
    return this.layout.encode(e, t, o);
  }
}
Layout$1.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
class Union extends Layout {
  constructor(e, t, o) {
    let c;
    if (e instanceof UInt || e instanceof UIntBE)
      c = new UnionLayoutDiscriminator(new OffsetLayout(e));
    else if (e instanceof ExternalLayout && e.isCount())
      c = new UnionLayoutDiscriminator(e);
    else if (e instanceof UnionDiscriminator)
      c = e;
    else
      throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
    if (t === void 0 && (t = null), !(t === null || t instanceof Layout))
      throw new TypeError("defaultLayout must be null or a Layout");
    if (t !== null) {
      if (0 > t.span)
        throw new Error("defaultLayout must have constant span");
      t.property === void 0 && (t = t.replicate("content"));
    }
    let a = -1;
    t && (a = t.span, 0 <= a && (e instanceof UInt || e instanceof UIntBE) && (a += c.layout.span)), super(a, o), this.discriminator = c, this.usesPrefixDiscriminator = e instanceof UInt || e instanceof UIntBE, this.defaultLayout = t, this.registry = {};
    let d = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(p) {
      return d(p);
    }, this.configGetSourceVariant = function(p) {
      d = p.bind(this);
    };
  }
  getSpan(e, t = 0) {
    if (0 <= this.span)
      return this.span;
    const o = this.getVariant(e, t);
    if (!o)
      throw new Error("unable to determine span for unrecognized variant");
    return o.getSpan(e, t);
  }
  defaultGetSourceVariant(e) {
    if (Object.prototype.hasOwnProperty.call(e, this.discriminator.property)) {
      if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(e, this.defaultLayout.property))
        return;
      const t = this.registry[e[this.discriminator.property]];
      if (t && (!t.layout || t.property && Object.prototype.hasOwnProperty.call(e, t.property)))
        return t;
    } else
      for (const t in this.registry) {
        const o = this.registry[t];
        if (o.property && Object.prototype.hasOwnProperty.call(e, o.property))
          return o;
      }
    throw new Error("unable to infer src variant");
  }
  decode(e, t = 0) {
    let o;
    const c = this.discriminator, a = c.decode(e, t), d = this.registry[a];
    if (d === void 0) {
      const p = this.defaultLayout;
      let w = 0;
      this.usesPrefixDiscriminator && (w = c.layout.span), o = this.makeDestinationObject(), o[c.property] = a, o[p.property] = p.decode(e, t + w);
    } else
      o = d.decode(e, t);
    return o;
  }
  encode(e, t, o = 0) {
    const c = this.getSourceVariant(e);
    if (c === void 0) {
      const a = this.discriminator, d = this.defaultLayout;
      let p = 0;
      return this.usesPrefixDiscriminator && (p = a.layout.span), a.encode(e[a.property], t, o), p + d.encode(e[d.property], t, o + p);
    }
    return c.encode(e, t, o);
  }
  addVariant(e, t, o) {
    const c = new VariantLayout(this, e, t, o);
    return this.registry[e] = c, c;
  }
  getVariant(e, t = 0) {
    let o;
    return e instanceof Uint8Array ? o = this.discriminator.decode(e, t) : o = e, this.registry[o];
  }
}
Layout$1.Union = Union;
class VariantLayout extends Layout {
  constructor(e, t, o, c) {
    if (!(e instanceof Union))
      throw new TypeError("union must be a Union");
    if (!Number.isInteger(t) || 0 > t)
      throw new TypeError("variant must be a (non-negative) integer");
    if (typeof o == "string" && c === void 0 && (c = o, o = null), o) {
      if (!(o instanceof Layout))
        throw new TypeError("layout must be a Layout");
      if (e.defaultLayout !== null && 0 <= o.span && o.span > e.defaultLayout.span)
        throw new Error("variant span exceeds span of containing union");
      if (typeof c != "string")
        throw new TypeError("variant must have a String property");
    }
    let a = e.span;
    0 > e.span && (a = o ? o.span : 0, 0 <= a && e.usesPrefixDiscriminator && (a += e.discriminator.layout.span)), super(a, c), this.union = e, this.variant = t, this.layout = o || null;
  }
  getSpan(e, t = 0) {
    if (0 <= this.span)
      return this.span;
    let o = 0;
    this.union.usesPrefixDiscriminator && (o = this.union.discriminator.layout.span);
    let c = 0;
    return this.layout && (c = this.layout.getSpan(e, t + o)), o + c;
  }
  decode(e, t = 0) {
    const o = this.makeDestinationObject();
    if (this !== this.union.getVariant(e, t))
      throw new Error("variant mismatch");
    let c = 0;
    return this.union.usesPrefixDiscriminator && (c = this.union.discriminator.layout.span), this.layout ? o[this.property] = this.layout.decode(e, t + c) : this.property ? o[this.property] = !0 : this.union.usesPrefixDiscriminator && (o[this.union.discriminator.property] = this.variant), o;
  }
  encode(e, t, o = 0) {
    let c = 0;
    if (this.union.usesPrefixDiscriminator && (c = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(e, this.property))
      throw new TypeError("variant lacks property " + this.property);
    this.union.discriminator.encode(this.variant, t, o);
    let a = c;
    if (this.layout && (this.layout.encode(e[this.property], t, o + c), a += this.layout.getSpan(t, o + c), 0 <= this.union.span && a > this.union.span))
      throw new Error("encoded variant overruns containing union");
    return a;
  }
  fromArray(e) {
    if (this.layout)
      return this.layout.fromArray(e);
  }
}
Layout$1.VariantLayout = VariantLayout;
function fixBitwiseResult(n) {
  return 0 > n && (n += 4294967296), n;
}
class BitStructure extends Layout {
  constructor(e, t, o) {
    if (!(e instanceof UInt || e instanceof UIntBE))
      throw new TypeError("word must be a UInt or UIntBE layout");
    if (typeof t == "string" && o === void 0 && (o = t, t = !1), 4 < e.span)
      throw new RangeError("word cannot exceed 32 bits");
    super(e.span, o), this.word = e, this.msb = !!t, this.fields = [];
    let c = 0;
    this._packedSetValue = function(a) {
      return c = fixBitwiseResult(a), this;
    }, this._packedGetValue = function() {
      return c;
    };
  }
  decode(e, t = 0) {
    const o = this.makeDestinationObject(), c = this.word.decode(e, t);
    this._packedSetValue(c);
    for (const a of this.fields)
      a.property !== void 0 && (o[a.property] = a.decode(e));
    return o;
  }
  encode(e, t, o = 0) {
    const c = this.word.decode(t, o);
    this._packedSetValue(c);
    for (const a of this.fields)
      if (a.property !== void 0) {
        const d = e[a.property];
        d !== void 0 && a.encode(d);
      }
    return this.word.encode(this._packedGetValue(), t, o);
  }
  addField(e, t) {
    const o = new BitField(this, e, t);
    return this.fields.push(o), o;
  }
  addBoolean(e) {
    const t = new Boolean$1(this, e);
    return this.fields.push(t), t;
  }
  fieldFor(e) {
    if (typeof e != "string")
      throw new TypeError("property must be string");
    for (const t of this.fields)
      if (t.property === e)
        return t;
  }
}
Layout$1.BitStructure = BitStructure;
class BitField {
  constructor(e, t, o) {
    if (!(e instanceof BitStructure))
      throw new TypeError("container must be a BitStructure");
    if (!Number.isInteger(t) || 0 >= t)
      throw new TypeError("bits must be positive integer");
    const c = 8 * e.span, a = e.fields.reduce((d, p) => d + p.bits, 0);
    if (t + a > c)
      throw new Error("bits too long for span remainder (" + (c - a) + " of " + c + " remain)");
    this.container = e, this.bits = t, this.valueMask = (1 << t) - 1, t === 32 && (this.valueMask = 4294967295), this.start = a, this.container.msb && (this.start = c - a - t), this.wordMask = fixBitwiseResult(this.valueMask << this.start), this.property = o;
  }
  decode(e, t) {
    const o = this.container._packedGetValue();
    return fixBitwiseResult(o & this.wordMask) >>> this.start;
  }
  encode(e) {
    if (typeof e != "number" || !Number.isInteger(e) || e !== fixBitwiseResult(e & this.valueMask))
      throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
    const t = this.container._packedGetValue(), o = fixBitwiseResult(e << this.start);
    this.container._packedSetValue(fixBitwiseResult(t & ~this.wordMask) | o);
  }
}
Layout$1.BitField = BitField;
class Boolean$1 extends BitField {
  constructor(e, t) {
    super(e, 1, t);
  }
  decode(e, t) {
    return !!super.decode(e, t);
  }
  encode(e) {
    typeof e == "boolean" && (e = +e), super.encode(e);
  }
}
Layout$1.Boolean = Boolean$1;
class Blob extends Layout {
  constructor(e, t) {
    if (!(e instanceof ExternalLayout && e.isCount() || Number.isInteger(e) && 0 <= e))
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    let o = -1;
    e instanceof ExternalLayout || (o = e), super(o, t), this.length = e;
  }
  getSpan(e, t) {
    let o = this.span;
    return 0 > o && (o = this.length.decode(e, t)), o;
  }
  decode(e, t = 0) {
    let o = this.span;
    return 0 > o && (o = this.length.decode(e, t)), uint8ArrayToBuffer(e).slice(t, t + o);
  }
  encode(e, t, o) {
    let c = this.length;
    if (this.length instanceof ExternalLayout && (c = e.length), !(e instanceof Uint8Array && c === e.length))
      throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + c + ") Uint8Array as src");
    if (o + c > t.length)
      throw new RangeError("encoding overruns Uint8Array");
    const a = uint8ArrayToBuffer(e);
    return uint8ArrayToBuffer(t).write(a.toString("hex"), o, c, "hex"), this.length instanceof ExternalLayout && this.length.encode(c, t, o), c;
  }
}
Layout$1.Blob = Blob;
class CString extends Layout {
  constructor(e) {
    super(-1, e);
  }
  getSpan(e, t = 0) {
    checkUint8Array(e);
    let o = t;
    for (; o < e.length && e[o] !== 0; )
      o += 1;
    return 1 + o - t;
  }
  decode(e, t = 0) {
    const o = this.getSpan(e, t);
    return uint8ArrayToBuffer(e).slice(t, t + o - 1).toString("utf-8");
  }
  encode(e, t, o = 0) {
    typeof e != "string" && (e = String(e));
    const c = buffer_1.Buffer.from(e, "utf8"), a = c.length;
    if (o + a > t.length)
      throw new RangeError("encoding overruns Buffer");
    const d = uint8ArrayToBuffer(t);
    return c.copy(d, o), d[o + a] = 0, a + 1;
  }
}
Layout$1.CString = CString;
class UTF8 extends Layout {
  constructor(e, t) {
    if (typeof e == "string" && t === void 0 && (t = e, e = void 0), e === void 0)
      e = -1;
    else if (!Number.isInteger(e))
      throw new TypeError("maxSpan must be an integer");
    super(-1, t), this.maxSpan = e;
  }
  getSpan(e, t = 0) {
    return checkUint8Array(e), e.length - t;
  }
  decode(e, t = 0) {
    const o = this.getSpan(e, t);
    if (0 <= this.maxSpan && this.maxSpan < o)
      throw new RangeError("text length exceeds maxSpan");
    return uint8ArrayToBuffer(e).slice(t, t + o).toString("utf-8");
  }
  encode(e, t, o = 0) {
    typeof e != "string" && (e = String(e));
    const c = buffer_1.Buffer.from(e, "utf8"), a = c.length;
    if (0 <= this.maxSpan && this.maxSpan < a)
      throw new RangeError("text length exceeds maxSpan");
    if (o + a > t.length)
      throw new RangeError("encoding overruns Buffer");
    return c.copy(uint8ArrayToBuffer(t), o), a;
  }
}
Layout$1.UTF8 = UTF8;
class Constant extends Layout {
  constructor(e, t) {
    super(0, t), this.value = e;
  }
  decode(e, t) {
    return this.value;
  }
  encode(e, t, o) {
    return 0;
  }
}
Layout$1.Constant = Constant;
Layout$1.greedy = (n, e) => new GreedyCount(n, e);
var offset = Layout$1.offset = (n, e, t) => new OffsetLayout(n, e, t), u8 = Layout$1.u8 = (n) => new UInt(1, n), u16 = Layout$1.u16 = (n) => new UInt(2, n);
Layout$1.u24 = (n) => new UInt(3, n);
var u32 = Layout$1.u32 = (n) => new UInt(4, n);
Layout$1.u40 = (n) => new UInt(5, n);
Layout$1.u48 = (n) => new UInt(6, n);
var nu64 = Layout$1.nu64 = (n) => new NearUInt64(n);
Layout$1.u16be = (n) => new UIntBE(2, n);
Layout$1.u24be = (n) => new UIntBE(3, n);
Layout$1.u32be = (n) => new UIntBE(4, n);
Layout$1.u40be = (n) => new UIntBE(5, n);
Layout$1.u48be = (n) => new UIntBE(6, n);
Layout$1.nu64be = (n) => new NearUInt64BE(n);
Layout$1.s8 = (n) => new Int(1, n);
Layout$1.s16 = (n) => new Int(2, n);
Layout$1.s24 = (n) => new Int(3, n);
Layout$1.s32 = (n) => new Int(4, n);
Layout$1.s40 = (n) => new Int(5, n);
Layout$1.s48 = (n) => new Int(6, n);
var ns64 = Layout$1.ns64 = (n) => new NearInt64(n);
Layout$1.s16be = (n) => new IntBE(2, n);
Layout$1.s24be = (n) => new IntBE(3, n);
Layout$1.s32be = (n) => new IntBE(4, n);
Layout$1.s40be = (n) => new IntBE(5, n);
Layout$1.s48be = (n) => new IntBE(6, n);
Layout$1.ns64be = (n) => new NearInt64BE(n);
Layout$1.f32 = (n) => new Float(n);
Layout$1.f32be = (n) => new FloatBE(n);
Layout$1.f64 = (n) => new Double(n);
Layout$1.f64be = (n) => new DoubleBE(n);
var struct = Layout$1.struct = (n, e, t) => new Structure(n, e, t);
Layout$1.bits = (n, e, t) => new BitStructure(n, e, t);
var seq = Layout$1.seq = (n, e, t) => new Sequence(n, e, t);
Layout$1.union = (n, e, t) => new Union(n, e, t);
Layout$1.unionLayoutDiscriminator = (n, e) => new UnionLayoutDiscriminator(n, e);
var blob = Layout$1.blob = (n, e) => new Blob(n, e);
Layout$1.cstr = (n) => new CString(n);
Layout$1.utf8 = (n, e) => new UTF8(n, e);
Layout$1.constant = (n, e) => new Constant(n, e);
var browser$1 = {};
Object.defineProperty(browser$1, "__esModule", { value: !0 });
function toBigIntLE(n) {
  {
    const e = Buffer.from(n);
    e.reverse();
    const t = e.toString("hex");
    return t.length === 0 ? BigInt(0) : BigInt(`0x${t}`);
  }
}
var toBigIntLE_1 = browser$1.toBigIntLE = toBigIntLE;
function toBigIntBE(n) {
  {
    const e = n.toString("hex");
    return e.length === 0 ? BigInt(0) : BigInt(`0x${e}`);
  }
}
browser$1.toBigIntBE = toBigIntBE;
function toBufferLE(n, e) {
  {
    const t = n.toString(16), o = Buffer.from(t.padStart(e * 2, "0").slice(0, e * 2), "hex");
    return o.reverse(), o;
  }
}
var toBufferLE_1 = browser$1.toBufferLE = toBufferLE;
function toBufferBE(n, e) {
  {
    const t = n.toString(16);
    return Buffer.from(t.padStart(e * 2, "0").slice(0, e * 2), "hex");
  }
}
browser$1.toBufferBE = toBufferBE;
class StructError extends TypeError {
  constructor(e, t) {
    let o;
    const {
      message: c,
      ...a
    } = e, {
      path: d
    } = e, p = d.length === 0 ? c : "At path: " + d.join(".") + " -- " + c;
    super(p), Object.assign(this, a), this.name = this.constructor.name, this.failures = () => {
      var w;
      return (w = o) != null ? w : o = [e, ...t()];
    };
  }
}
function isIterable(n) {
  return isObject(n) && typeof n[Symbol.iterator] == "function";
}
function isObject(n) {
  return typeof n == "object" && n != null;
}
function print(n) {
  return typeof n == "string" ? JSON.stringify(n) : "" + n;
}
function shiftIterator(n) {
  const {
    done: e,
    value: t
  } = n.next();
  return e ? void 0 : t;
}
function toFailure(n, e, t, o) {
  if (n === !0)
    return;
  n === !1 ? n = {} : typeof n == "string" && (n = {
    message: n
  });
  const {
    path: c,
    branch: a
  } = e, {
    type: d
  } = t, {
    refinement: p,
    message: w = "Expected a value of type `" + d + "`" + (p ? " with refinement `" + p + "`" : "") + ", but received: `" + print(o) + "`"
  } = n;
  return {
    value: o,
    type: d,
    refinement: p,
    key: c[c.length - 1],
    path: c,
    branch: a,
    ...n,
    message: w
  };
}
function* toFailures(n, e, t, o) {
  isIterable(n) || (n = [n]);
  for (const c of n) {
    const a = toFailure(c, e, t, o);
    a && (yield a);
  }
}
function* run(n, e, t = {}) {
  const {
    path: o = [],
    branch: c = [n],
    coerce: a = !1,
    mask: d = !1
  } = t, p = {
    path: o,
    branch: c
  };
  if (a && (n = e.coercer(n, p), d && e.type !== "type" && isObject(e.schema) && isObject(n) && !Array.isArray(n)))
    for (const M in n)
      e.schema[M] === void 0 && delete n[M];
  let w = !0;
  for (const M of e.validator(n, p))
    w = !1, yield [M, void 0];
  for (let [M, I, B] of e.entries(n, p)) {
    const H = run(I, B, {
      path: M === void 0 ? o : [...o, M],
      branch: M === void 0 ? c : [...c, I],
      coerce: a,
      mask: d
    });
    for (const L of H)
      L[0] ? (w = !1, yield [L[0], void 0]) : a && (I = L[1], M === void 0 ? n = I : n instanceof Map ? n.set(M, I) : n instanceof Set ? n.add(I) : isObject(n) && (n[M] = I));
  }
  if (w)
    for (const M of e.refiner(n, p))
      w = !1, yield [M, void 0];
  w && (yield [void 0, n]);
}
class Struct$1 {
  constructor(e) {
    const {
      type: t,
      schema: o,
      validator: c,
      refiner: a,
      coercer: d = (w) => w,
      entries: p = function* () {
      }
    } = e;
    this.type = t, this.schema = o, this.entries = p, this.coercer = d, c ? this.validator = (w, M) => {
      const I = c(w, M);
      return toFailures(I, M, this, w);
    } : this.validator = () => [], a ? this.refiner = (w, M) => {
      const I = a(w, M);
      return toFailures(I, M, this, w);
    } : this.refiner = () => [];
  }
  assert(e) {
    return assert$d(e, this);
  }
  create(e) {
    return create(e, this);
  }
  is(e) {
    return is(e, this);
  }
  mask(e) {
    return mask(e, this);
  }
  validate(e, t = {}) {
    return validate$1(e, this, t);
  }
}
function assert$d(n, e) {
  const t = validate$1(n, e);
  if (t[0])
    throw t[0];
}
function create(n, e) {
  const t = validate$1(n, e, {
    coerce: !0
  });
  if (t[0])
    throw t[0];
  return t[1];
}
function mask(n, e) {
  const t = validate$1(n, e, {
    coerce: !0,
    mask: !0
  });
  if (t[0])
    throw t[0];
  return t[1];
}
function is(n, e) {
  return !validate$1(n, e)[0];
}
function validate$1(n, e, t = {}) {
  const o = run(n, e, t), c = shiftIterator(o);
  if (c[0])
    return [new StructError(c[0], function* () {
      for (const d of o)
        d[0] && (yield d[0]);
    }), void 0];
  {
    const a = c[1];
    return [void 0, a];
  }
}
function define(n, e) {
  return new Struct$1({
    type: n,
    schema: null,
    validator: e
  });
}
function any() {
  return define("any", () => !0);
}
function array(n) {
  return new Struct$1({
    type: "array",
    schema: n,
    *entries(e) {
      if (n && Array.isArray(e))
        for (const [t, o] of e.entries())
          yield [t, o, n];
    },
    coercer(e) {
      return Array.isArray(e) ? e.slice() : e;
    },
    validator(e) {
      return Array.isArray(e) || "Expected an array value, but received: " + print(e);
    }
  });
}
function boolean() {
  return define("boolean", (n) => typeof n == "boolean");
}
function instance(n) {
  return define("instance", (e) => e instanceof n || "Expected a `" + n.name + "` instance, but received: " + print(e));
}
function literal(n) {
  const e = print(n), t = typeof n;
  return new Struct$1({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? n : null,
    validator(o) {
      return o === n || "Expected the literal `" + e + "`, but received: " + print(o);
    }
  });
}
function never() {
  return define("never", () => !1);
}
function nullable(n) {
  return new Struct$1({
    ...n,
    validator: (e, t) => e === null || n.validator(e, t),
    refiner: (e, t) => e === null || n.refiner(e, t)
  });
}
function number() {
  return define("number", (n) => typeof n == "number" && !isNaN(n) || "Expected a number, but received: " + print(n));
}
function optional(n) {
  return new Struct$1({
    ...n,
    validator: (e, t) => e === void 0 || n.validator(e, t),
    refiner: (e, t) => e === void 0 || n.refiner(e, t)
  });
}
function record(n, e) {
  return new Struct$1({
    type: "record",
    schema: null,
    *entries(t) {
      if (isObject(t))
        for (const o in t) {
          const c = t[o];
          yield [o, o, n], yield [o, c, e];
        }
    },
    validator(t) {
      return isObject(t) || "Expected an object, but received: " + print(t);
    }
  });
}
function string() {
  return define("string", (n) => typeof n == "string" || "Expected a string, but received: " + print(n));
}
function tuple(n) {
  const e = never();
  return new Struct$1({
    type: "tuple",
    schema: null,
    *entries(t) {
      if (Array.isArray(t)) {
        const o = Math.max(n.length, t.length);
        for (let c = 0; c < o; c++)
          yield [c, t[c], n[c] || e];
      }
    },
    validator(t) {
      return Array.isArray(t) || "Expected an array, but received: " + print(t);
    }
  });
}
function type(n) {
  const e = Object.keys(n);
  return new Struct$1({
    type: "type",
    schema: n,
    *entries(t) {
      if (isObject(t))
        for (const o of e)
          yield [o, t[o], n[o]];
    },
    validator(t) {
      return isObject(t) || "Expected an object, but received: " + print(t);
    }
  });
}
function union(n) {
  const e = n.map((t) => t.type).join(" | ");
  return new Struct$1({
    type: "union",
    schema: null,
    validator(t, o) {
      const c = [];
      for (const a of n) {
        const [...d] = run(t, a, o), [p] = d;
        if (p[0])
          for (const [w] of d)
            w && c.push(w);
        else
          return [];
      }
      return ["Expected the value to satisfy a union of `" + e + "`, but received: " + print(t), ...c];
    }
  });
}
function unknown() {
  return define("unknown", () => !0);
}
function coerce(n, e, t) {
  return new Struct$1({
    ...n,
    coercer: (o, c) => is(o, e) ? n.coercer(t(o, c), c) : n.coercer(o, c)
  });
}
var index_browser = {}, interopRequireDefault = { exports: {} };
(function(n) {
  function e(t) {
    return t && t.__esModule ? t : {
      default: t
    };
  }
  n.exports = e, n.exports.__esModule = !0, n.exports.default = n.exports;
})(interopRequireDefault);
var createClass = { exports: {} }, toPropertyKey = { exports: {} }, _typeof = { exports: {} }, hasRequired_typeof;
function require_typeof() {
  return hasRequired_typeof || (hasRequired_typeof = 1, function(n) {
    function e(t) {
      return n.exports = e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
        return typeof o;
      } : function(o) {
        return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
      }, n.exports.__esModule = !0, n.exports.default = n.exports, e(t);
    }
    n.exports = e, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(_typeof)), _typeof.exports;
}
var toPrimitive = { exports: {} }, hasRequiredToPrimitive;
function requireToPrimitive() {
  return hasRequiredToPrimitive || (hasRequiredToPrimitive = 1, function(n) {
    var e = require_typeof().default;
    function t(o, c) {
      if (e(o) !== "object" || o === null)
        return o;
      var a = o[Symbol.toPrimitive];
      if (a !== void 0) {
        var d = a.call(o, c || "default");
        if (e(d) !== "object")
          return d;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (c === "string" ? String : Number)(o);
    }
    n.exports = t, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(toPrimitive)), toPrimitive.exports;
}
var hasRequiredToPropertyKey;
function requireToPropertyKey() {
  return hasRequiredToPropertyKey || (hasRequiredToPropertyKey = 1, function(n) {
    var e = require_typeof().default, t = requireToPrimitive();
    function o(c) {
      var a = t(c, "string");
      return e(a) === "symbol" ? a : String(a);
    }
    n.exports = o, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(toPropertyKey)), toPropertyKey.exports;
}
var hasRequiredCreateClass;
function requireCreateClass() {
  return hasRequiredCreateClass || (hasRequiredCreateClass = 1, function(n) {
    var e = requireToPropertyKey();
    function t(c, a) {
      for (var d = 0; d < a.length; d++) {
        var p = a[d];
        p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(c, e(p.key), p);
      }
    }
    function o(c, a, d) {
      return a && t(c.prototype, a), d && t(c, d), Object.defineProperty(c, "prototype", {
        writable: !1
      }), c;
    }
    n.exports = o, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(createClass)), createClass.exports;
}
var classCallCheck = { exports: {} }, hasRequiredClassCallCheck;
function requireClassCallCheck() {
  return hasRequiredClassCallCheck || (hasRequiredClassCallCheck = 1, function(n) {
    function e(t, o) {
      if (!(t instanceof o))
        throw new TypeError("Cannot call a class as a function");
    }
    n.exports = e, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(classCallCheck)), classCallCheck.exports;
}
var inherits$1 = { exports: {} }, setPrototypeOf = { exports: {} }, hasRequiredSetPrototypeOf;
function requireSetPrototypeOf() {
  return hasRequiredSetPrototypeOf || (hasRequiredSetPrototypeOf = 1, function(n) {
    function e(t, o) {
      return n.exports = e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, d) {
        return a.__proto__ = d, a;
      }, n.exports.__esModule = !0, n.exports.default = n.exports, e(t, o);
    }
    n.exports = e, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(setPrototypeOf)), setPrototypeOf.exports;
}
var hasRequiredInherits;
function requireInherits() {
  return hasRequiredInherits || (hasRequiredInherits = 1, function(n) {
    var e = requireSetPrototypeOf();
    function t(o, c) {
      if (typeof c != "function" && c !== null)
        throw new TypeError("Super expression must either be null or a function");
      o.prototype = Object.create(c && c.prototype, {
        constructor: {
          value: o,
          writable: !0,
          configurable: !0
        }
      }), Object.defineProperty(o, "prototype", {
        writable: !1
      }), c && e(o, c);
    }
    n.exports = t, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(inherits$1)), inherits$1.exports;
}
var possibleConstructorReturn = { exports: {} }, assertThisInitialized = { exports: {} }, hasRequiredAssertThisInitialized;
function requireAssertThisInitialized() {
  return hasRequiredAssertThisInitialized || (hasRequiredAssertThisInitialized = 1, function(n) {
    function e(t) {
      if (t === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t;
    }
    n.exports = e, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(assertThisInitialized)), assertThisInitialized.exports;
}
var hasRequiredPossibleConstructorReturn;
function requirePossibleConstructorReturn() {
  return hasRequiredPossibleConstructorReturn || (hasRequiredPossibleConstructorReturn = 1, function(n) {
    var e = require_typeof().default, t = requireAssertThisInitialized();
    function o(c, a) {
      if (a && (e(a) === "object" || typeof a == "function"))
        return a;
      if (a !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
      return t(c);
    }
    n.exports = o, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(possibleConstructorReturn)), possibleConstructorReturn.exports;
}
var getPrototypeOf = { exports: {} }, hasRequiredGetPrototypeOf;
function requireGetPrototypeOf() {
  return hasRequiredGetPrototypeOf || (hasRequiredGetPrototypeOf = 1, function(n) {
    function e(t) {
      return n.exports = e = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(c) {
        return c.__proto__ || Object.getPrototypeOf(c);
      }, n.exports.__esModule = !0, n.exports.default = n.exports, e(t);
    }
    n.exports = e, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(getPrototypeOf)), getPrototypeOf.exports;
}
var websocket_browser = {}, eventemitter3 = { exports: {} }, hasRequiredEventemitter3;
function requireEventemitter3() {
  return hasRequiredEventemitter3 || (hasRequiredEventemitter3 = 1, function(n) {
    var e = Object.prototype.hasOwnProperty, t = "~";
    function o() {
    }
    Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (t = !1));
    function c(w, M, I) {
      this.fn = w, this.context = M, this.once = I || !1;
    }
    function a(w, M, I, B, H) {
      if (typeof I != "function")
        throw new TypeError("The listener must be a function");
      var L = new c(I, B || w, H), W = t ? t + M : M;
      return w._events[W] ? w._events[W].fn ? w._events[W] = [w._events[W], L] : w._events[W].push(L) : (w._events[W] = L, w._eventsCount++), w;
    }
    function d(w, M) {
      --w._eventsCount === 0 ? w._events = new o() : delete w._events[M];
    }
    function p() {
      this._events = new o(), this._eventsCount = 0;
    }
    p.prototype.eventNames = function() {
      var M = [], I, B;
      if (this._eventsCount === 0)
        return M;
      for (B in I = this._events)
        e.call(I, B) && M.push(t ? B.slice(1) : B);
      return Object.getOwnPropertySymbols ? M.concat(Object.getOwnPropertySymbols(I)) : M;
    }, p.prototype.listeners = function(M) {
      var I = t ? t + M : M, B = this._events[I];
      if (!B)
        return [];
      if (B.fn)
        return [B.fn];
      for (var H = 0, L = B.length, W = new Array(L); H < L; H++)
        W[H] = B[H].fn;
      return W;
    }, p.prototype.listenerCount = function(M) {
      var I = t ? t + M : M, B = this._events[I];
      return B ? B.fn ? 1 : B.length : 0;
    }, p.prototype.emit = function(M, I, B, H, L, W) {
      var $ = t ? t + M : M;
      if (!this._events[$])
        return !1;
      var P = this._events[$], U = arguments.length, G, D;
      if (P.fn) {
        switch (P.once && this.removeListener(M, P.fn, void 0, !0), U) {
          case 1:
            return P.fn.call(P.context), !0;
          case 2:
            return P.fn.call(P.context, I), !0;
          case 3:
            return P.fn.call(P.context, I, B), !0;
          case 4:
            return P.fn.call(P.context, I, B, H), !0;
          case 5:
            return P.fn.call(P.context, I, B, H, L), !0;
          case 6:
            return P.fn.call(P.context, I, B, H, L, W), !0;
        }
        for (D = 1, G = new Array(U - 1); D < U; D++)
          G[D - 1] = arguments[D];
        P.fn.apply(P.context, G);
      } else {
        var Z = P.length, J;
        for (D = 0; D < Z; D++)
          switch (P[D].once && this.removeListener(M, P[D].fn, void 0, !0), U) {
            case 1:
              P[D].fn.call(P[D].context);
              break;
            case 2:
              P[D].fn.call(P[D].context, I);
              break;
            case 3:
              P[D].fn.call(P[D].context, I, B);
              break;
            case 4:
              P[D].fn.call(P[D].context, I, B, H);
              break;
            default:
              if (!G)
                for (J = 1, G = new Array(U - 1); J < U; J++)
                  G[J - 1] = arguments[J];
              P[D].fn.apply(P[D].context, G);
          }
      }
      return !0;
    }, p.prototype.on = function(M, I, B) {
      return a(this, M, I, B, !1);
    }, p.prototype.once = function(M, I, B) {
      return a(this, M, I, B, !0);
    }, p.prototype.removeListener = function(M, I, B, H) {
      var L = t ? t + M : M;
      if (!this._events[L])
        return this;
      if (!I)
        return d(this, L), this;
      var W = this._events[L];
      if (W.fn)
        W.fn === I && (!H || W.once) && (!B || W.context === B) && d(this, L);
      else {
        for (var $ = 0, P = [], U = W.length; $ < U; $++)
          (W[$].fn !== I || H && !W[$].once || B && W[$].context !== B) && P.push(W[$]);
        P.length ? this._events[L] = P.length === 1 ? P[0] : P : d(this, L);
      }
      return this;
    }, p.prototype.removeAllListeners = function(M) {
      var I;
      return M ? (I = t ? t + M : M, this._events[I] && d(this, I)) : (this._events = new o(), this._eventsCount = 0), this;
    }, p.prototype.off = p.prototype.removeListener, p.prototype.addListener = p.prototype.on, p.prefixed = t, p.EventEmitter = p, n.exports = p;
  }(eventemitter3)), eventemitter3.exports;
}
var hasRequiredWebsocket_browser;
function requireWebsocket_browser() {
  return hasRequiredWebsocket_browser || (hasRequiredWebsocket_browser = 1, function(n) {
    var e = interopRequireDefault.exports;
    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.default = B;
    var t = e(requireClassCallCheck()), o = e(requireCreateClass()), c = e(requireInherits()), a = e(requirePossibleConstructorReturn()), d = e(requireGetPrototypeOf()), p = requireEventemitter3();
    function w(H) {
      var L = M();
      return function() {
        var $ = (0, d.default)(H), P;
        if (L) {
          var U = (0, d.default)(this).constructor;
          P = Reflect.construct($, arguments, U);
        } else
          P = $.apply(this, arguments);
        return (0, a.default)(this, P);
      };
    }
    function M() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var I = /* @__PURE__ */ function(H) {
      (0, c.default)(W, H);
      var L = w(W);
      function W($, P, U) {
        var G;
        return (0, t.default)(this, W), G = L.call(this), G.socket = new window.WebSocket($, U), G.socket.onopen = function() {
          return G.emit("open");
        }, G.socket.onmessage = function(D) {
          return G.emit("message", D.data);
        }, G.socket.onerror = function(D) {
          return G.emit("error", D);
        }, G.socket.onclose = function(D) {
          G.emit("close", D.code, D.reason);
        }, G;
      }
      return (0, o.default)(W, [{
        key: "send",
        value: function(P, U, G) {
          var D = G || U;
          try {
            this.socket.send(P), D();
          } catch (Z) {
            D(Z);
          }
        }
      }, {
        key: "close",
        value: function(P, U) {
          this.socket.close(P, U);
        }
      }, {
        key: "addEventListener",
        value: function(P, U, G) {
          this.socket.addEventListener(P, U, G);
        }
      }]), W;
    }(p.EventEmitter);
    function B(H, L) {
      return new I(H, L);
    }
  }(websocket_browser)), websocket_browser;
}
var client = {}, regeneratorRuntime$1 = { exports: {} }, hasRequiredRegeneratorRuntime;
function requireRegeneratorRuntime() {
  return hasRequiredRegeneratorRuntime || (hasRequiredRegeneratorRuntime = 1, function(n) {
    var e = require_typeof().default;
    function t() {
      n.exports = t = function() {
        return o;
      }, n.exports.__esModule = !0, n.exports.default = n.exports;
      var o = {}, c = Object.prototype, a = c.hasOwnProperty, d = Object.defineProperty || function(h, g, y) {
        h[g] = y.value;
      }, p = typeof Symbol == "function" ? Symbol : {}, w = p.iterator || "@@iterator", M = p.asyncIterator || "@@asyncIterator", I = p.toStringTag || "@@toStringTag";
      function B(h, g, y) {
        return Object.defineProperty(h, g, {
          value: y,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), h[g];
      }
      try {
        B({}, "");
      } catch {
        B = function(y, m, _) {
          return y[m] = _;
        };
      }
      function H(h, g, y, m) {
        var _ = g && g.prototype instanceof $ ? g : $, R = Object.create(_.prototype), b = new V(m || []);
        return d(R, "_invoke", {
          value: he(h, y, b)
        }), R;
      }
      function L(h, g, y) {
        try {
          return {
            type: "normal",
            arg: h.call(g, y)
          };
        } catch (m) {
          return {
            type: "throw",
            arg: m
          };
        }
      }
      o.wrap = H;
      var W = {};
      function $() {
      }
      function P() {
      }
      function U() {
      }
      var G = {};
      B(G, w, function() {
        return this;
      });
      var D = Object.getPrototypeOf, Z = D && D(D(x([])));
      Z && Z !== c && a.call(Z, w) && (G = Z);
      var J = U.prototype = $.prototype = Object.create(G);
      function te(h) {
        ["next", "throw", "return"].forEach(function(g) {
          B(h, g, function(y) {
            return this._invoke(g, y);
          });
        });
      }
      function ue(h, g) {
        function y(_, R, b, l) {
          var v = L(h[_], h, R);
          if (v.type !== "throw") {
            var X = v.arg, S = X.value;
            return S && e(S) == "object" && a.call(S, "__await") ? g.resolve(S.__await).then(function(Y) {
              y("next", Y, b, l);
            }, function(Y) {
              y("throw", Y, b, l);
            }) : g.resolve(S).then(function(Y) {
              X.value = Y, b(X);
            }, function(Y) {
              return y("throw", Y, b, l);
            });
          }
          l(v.arg);
        }
        var m;
        d(this, "_invoke", {
          value: function(R, b) {
            function l() {
              return new g(function(v, X) {
                y(R, b, v, X);
              });
            }
            return m = m ? m.then(l, l) : l();
          }
        });
      }
      function he(h, g, y) {
        var m = "suspendedStart";
        return function(_, R) {
          if (m === "executing")
            throw new Error("Generator is already running");
          if (m === "completed") {
            if (_ === "throw")
              throw R;
            return u();
          }
          for (y.method = _, y.arg = R; ; ) {
            var b = y.delegate;
            if (b) {
              var l = Se(b, y);
              if (l) {
                if (l === W)
                  continue;
                return l;
              }
            }
            if (y.method === "next")
              y.sent = y._sent = y.arg;
            else if (y.method === "throw") {
              if (m === "suspendedStart")
                throw m = "completed", y.arg;
              y.dispatchException(y.arg);
            } else
              y.method === "return" && y.abrupt("return", y.arg);
            m = "executing";
            var v = L(h, g, y);
            if (v.type === "normal") {
              if (m = y.done ? "completed" : "suspendedYield", v.arg === W)
                continue;
              return {
                value: v.arg,
                done: y.done
              };
            }
            v.type === "throw" && (m = "completed", y.method = "throw", y.arg = v.arg);
          }
        };
      }
      function Se(h, g) {
        var y = g.method, m = h.iterator[y];
        if (m === void 0)
          return g.delegate = null, y === "throw" && h.iterator.return && (g.method = "return", g.arg = void 0, Se(h, g), g.method === "throw") || y !== "return" && (g.method = "throw", g.arg = new TypeError("The iterator does not provide a '" + y + "' method")), W;
        var _ = L(m, h.iterator, g.arg);
        if (_.type === "throw")
          return g.method = "throw", g.arg = _.arg, g.delegate = null, W;
        var R = _.arg;
        return R ? R.done ? (g[h.resultName] = R.value, g.next = h.nextLoc, g.method !== "return" && (g.method = "next", g.arg = void 0), g.delegate = null, W) : R : (g.method = "throw", g.arg = new TypeError("iterator result is not an object"), g.delegate = null, W);
      }
      function C(h) {
        var g = {
          tryLoc: h[0]
        };
        1 in h && (g.catchLoc = h[1]), 2 in h && (g.finallyLoc = h[2], g.afterLoc = h[3]), this.tryEntries.push(g);
      }
      function O(h) {
        var g = h.completion || {};
        g.type = "normal", delete g.arg, h.completion = g;
      }
      function V(h) {
        this.tryEntries = [{
          tryLoc: "root"
        }], h.forEach(C, this), this.reset(!0);
      }
      function x(h) {
        if (h) {
          var g = h[w];
          if (g)
            return g.call(h);
          if (typeof h.next == "function")
            return h;
          if (!isNaN(h.length)) {
            var y = -1, m = function _() {
              for (; ++y < h.length; )
                if (a.call(h, y))
                  return _.value = h[y], _.done = !1, _;
              return _.value = void 0, _.done = !0, _;
            };
            return m.next = m;
          }
        }
        return {
          next: u
        };
      }
      function u() {
        return {
          value: void 0,
          done: !0
        };
      }
      return P.prototype = U, d(J, "constructor", {
        value: U,
        configurable: !0
      }), d(U, "constructor", {
        value: P,
        configurable: !0
      }), P.displayName = B(U, I, "GeneratorFunction"), o.isGeneratorFunction = function(h) {
        var g = typeof h == "function" && h.constructor;
        return !!g && (g === P || (g.displayName || g.name) === "GeneratorFunction");
      }, o.mark = function(h) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(h, U) : (h.__proto__ = U, B(h, I, "GeneratorFunction")), h.prototype = Object.create(J), h;
      }, o.awrap = function(h) {
        return {
          __await: h
        };
      }, te(ue.prototype), B(ue.prototype, M, function() {
        return this;
      }), o.AsyncIterator = ue, o.async = function(h, g, y, m, _) {
        _ === void 0 && (_ = Promise);
        var R = new ue(H(h, g, y, m), _);
        return o.isGeneratorFunction(g) ? R : R.next().then(function(b) {
          return b.done ? b.value : R.next();
        });
      }, te(J), B(J, I, "Generator"), B(J, w, function() {
        return this;
      }), B(J, "toString", function() {
        return "[object Generator]";
      }), o.keys = function(h) {
        var g = Object(h), y = [];
        for (var m in g)
          y.push(m);
        return y.reverse(), function _() {
          for (; y.length; ) {
            var R = y.pop();
            if (R in g)
              return _.value = R, _.done = !1, _;
          }
          return _.done = !0, _;
        };
      }, o.values = x, V.prototype = {
        constructor: V,
        reset: function(g) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(O), !g)
            for (var y in this)
              y.charAt(0) === "t" && a.call(this, y) && !isNaN(+y.slice(1)) && (this[y] = void 0);
        },
        stop: function() {
          this.done = !0;
          var g = this.tryEntries[0].completion;
          if (g.type === "throw")
            throw g.arg;
          return this.rval;
        },
        dispatchException: function(g) {
          if (this.done)
            throw g;
          var y = this;
          function m(X, S) {
            return b.type = "throw", b.arg = g, y.next = X, S && (y.method = "next", y.arg = void 0), !!S;
          }
          for (var _ = this.tryEntries.length - 1; _ >= 0; --_) {
            var R = this.tryEntries[_], b = R.completion;
            if (R.tryLoc === "root")
              return m("end");
            if (R.tryLoc <= this.prev) {
              var l = a.call(R, "catchLoc"), v = a.call(R, "finallyLoc");
              if (l && v) {
                if (this.prev < R.catchLoc)
                  return m(R.catchLoc, !0);
                if (this.prev < R.finallyLoc)
                  return m(R.finallyLoc);
              } else if (l) {
                if (this.prev < R.catchLoc)
                  return m(R.catchLoc, !0);
              } else {
                if (!v)
                  throw new Error("try statement without catch or finally");
                if (this.prev < R.finallyLoc)
                  return m(R.finallyLoc);
              }
            }
          }
        },
        abrupt: function(g, y) {
          for (var m = this.tryEntries.length - 1; m >= 0; --m) {
            var _ = this.tryEntries[m];
            if (_.tryLoc <= this.prev && a.call(_, "finallyLoc") && this.prev < _.finallyLoc) {
              var R = _;
              break;
            }
          }
          R && (g === "break" || g === "continue") && R.tryLoc <= y && y <= R.finallyLoc && (R = null);
          var b = R ? R.completion : {};
          return b.type = g, b.arg = y, R ? (this.method = "next", this.next = R.finallyLoc, W) : this.complete(b);
        },
        complete: function(g, y) {
          if (g.type === "throw")
            throw g.arg;
          return g.type === "break" || g.type === "continue" ? this.next = g.arg : g.type === "return" ? (this.rval = this.arg = g.arg, this.method = "return", this.next = "end") : g.type === "normal" && y && (this.next = y), W;
        },
        finish: function(g) {
          for (var y = this.tryEntries.length - 1; y >= 0; --y) {
            var m = this.tryEntries[y];
            if (m.finallyLoc === g)
              return this.complete(m.completion, m.afterLoc), O(m), W;
          }
        },
        catch: function(g) {
          for (var y = this.tryEntries.length - 1; y >= 0; --y) {
            var m = this.tryEntries[y];
            if (m.tryLoc === g) {
              var _ = m.completion;
              if (_.type === "throw") {
                var R = _.arg;
                O(m);
              }
              return R;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(g, y, m) {
          return this.delegate = {
            iterator: x(g),
            resultName: y,
            nextLoc: m
          }, this.method === "next" && (this.arg = void 0), W;
        }
      }, o;
    }
    n.exports = t, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(regeneratorRuntime$1)), regeneratorRuntime$1.exports;
}
var regenerator, hasRequiredRegenerator;
function requireRegenerator() {
  if (hasRequiredRegenerator)
    return regenerator;
  hasRequiredRegenerator = 1;
  var n = requireRegeneratorRuntime()();
  regenerator = n;
  try {
    regeneratorRuntime = n;
  } catch {
    typeof globalThis == "object" ? globalThis.regeneratorRuntime = n : Function("r", "regeneratorRuntime = r")(n);
  }
  return regenerator;
}
var asyncToGenerator = { exports: {} }, hasRequiredAsyncToGenerator;
function requireAsyncToGenerator() {
  return hasRequiredAsyncToGenerator || (hasRequiredAsyncToGenerator = 1, function(n) {
    function e(o, c, a, d, p, w, M) {
      try {
        var I = o[w](M), B = I.value;
      } catch (H) {
        a(H);
        return;
      }
      I.done ? c(B) : Promise.resolve(B).then(d, p);
    }
    function t(o) {
      return function() {
        var c = this, a = arguments;
        return new Promise(function(d, p) {
          var w = o.apply(c, a);
          function M(B) {
            e(w, d, p, M, I, "next", B);
          }
          function I(B) {
            e(w, d, p, M, I, "throw", B);
          }
          M(void 0);
        });
      };
    }
    n.exports = t, n.exports.__esModule = !0, n.exports.default = n.exports;
  }(asyncToGenerator)), asyncToGenerator.exports;
}
var hasRequiredClient;
function requireClient() {
  return hasRequiredClient || (hasRequiredClient = 1, function(n) {
    var e = interopRequireDefault.exports;
    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.default = void 0;
    var t = e(requireRegenerator()), o = e(requireAsyncToGenerator()), c = e(require_typeof()), a = e(requireClassCallCheck()), d = e(requireCreateClass()), p = e(requireInherits()), w = e(requirePossibleConstructorReturn()), M = e(requireGetPrototypeOf()), I = requireEventemitter3();
    function B($) {
      var P = H();
      return function() {
        var G = (0, M.default)($), D;
        if (P) {
          var Z = (0, M.default)(this).constructor;
          D = Reflect.construct(G, arguments, Z);
        } else
          D = G.apply(this, arguments);
        return (0, w.default)(this, D);
      };
    }
    function H() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var L = function($, P) {
      var U = {};
      for (var G in $)
        Object.prototype.hasOwnProperty.call($, G) && P.indexOf(G) < 0 && (U[G] = $[G]);
      if ($ != null && typeof Object.getOwnPropertySymbols == "function")
        for (var D = 0, G = Object.getOwnPropertySymbols($); D < G.length; D++)
          P.indexOf(G[D]) < 0 && Object.prototype.propertyIsEnumerable.call($, G[D]) && (U[G[D]] = $[G[D]]);
      return U;
    }, W = /* @__PURE__ */ function($) {
      (0, p.default)(U, $);
      var P = B(U);
      function U(G) {
        var D, Z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080", J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, te = arguments.length > 3 ? arguments[3] : void 0;
        (0, a.default)(this, U);
        var ue = J.autoconnect, he = ue === void 0 ? !0 : ue, Se = J.reconnect, C = Se === void 0 ? !0 : Se, O = J.reconnect_interval, V = O === void 0 ? 1e3 : O, x = J.max_reconnects, u = x === void 0 ? 5 : x, h = L(J, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
        return D = P.call(this), D.webSocketFactory = G, D.queue = {}, D.rpc_id = 0, D.address = Z, D.autoconnect = he, D.ready = !1, D.reconnect = C, D.reconnect_interval = V, D.max_reconnects = u, D.rest_options = h, D.current_reconnects = 0, D.generate_request_id = te || function() {
          return ++D.rpc_id;
        }, D.autoconnect && D._connect(D.address, Object.assign({
          autoconnect: D.autoconnect,
          reconnect: D.reconnect,
          reconnect_interval: D.reconnect_interval,
          max_reconnects: D.max_reconnects
        }, D.rest_options)), D;
      }
      return (0, d.default)(U, [{
        key: "connect",
        value: function() {
          this.socket || this._connect(this.address, Object.assign({
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects
          }, this.rest_options));
        }
      }, {
        key: "call",
        value: function(D, Z, J, te) {
          var ue = this;
          return !te && (0, c.default)(J) === "object" && (te = J, J = null), new Promise(function(he, Se) {
            if (!ue.ready)
              return Se(new Error("socket not ready"));
            var C = ue.generate_request_id(D, Z), O = {
              jsonrpc: "2.0",
              method: D,
              params: Z || null,
              id: C
            };
            ue.socket.send(JSON.stringify(O), te, function(V) {
              if (V)
                return Se(V);
              ue.queue[C] = {
                promise: [he, Se]
              }, J && (ue.queue[C].timeout = setTimeout(function() {
                delete ue.queue[C], Se(new Error("reply timeout"));
              }, J));
            });
          });
        }
      }, {
        key: "login",
        value: function() {
          var G = (0, o.default)(/* @__PURE__ */ t.default.mark(function Z(J) {
            var te;
            return t.default.wrap(function(he) {
              for (; ; )
                switch (he.prev = he.next) {
                  case 0:
                    return he.next = 2, this.call("rpc.login", J);
                  case 2:
                    if (te = he.sent, te) {
                      he.next = 5;
                      break;
                    }
                    throw new Error("authentication failed");
                  case 5:
                    return he.abrupt("return", te);
                  case 6:
                  case "end":
                    return he.stop();
                }
            }, Z, this);
          }));
          function D(Z) {
            return G.apply(this, arguments);
          }
          return D;
        }()
      }, {
        key: "listMethods",
        value: function() {
          var G = (0, o.default)(/* @__PURE__ */ t.default.mark(function Z() {
            return t.default.wrap(function(te) {
              for (; ; )
                switch (te.prev = te.next) {
                  case 0:
                    return te.next = 2, this.call("__listMethods");
                  case 2:
                    return te.abrupt("return", te.sent);
                  case 3:
                  case "end":
                    return te.stop();
                }
            }, Z, this);
          }));
          function D() {
            return G.apply(this, arguments);
          }
          return D;
        }()
      }, {
        key: "notify",
        value: function(D, Z) {
          var J = this;
          return new Promise(function(te, ue) {
            if (!J.ready)
              return ue(new Error("socket not ready"));
            var he = {
              jsonrpc: "2.0",
              method: D,
              params: Z || null
            };
            J.socket.send(JSON.stringify(he), function(Se) {
              if (Se)
                return ue(Se);
              te();
            });
          });
        }
      }, {
        key: "subscribe",
        value: function() {
          var G = (0, o.default)(/* @__PURE__ */ t.default.mark(function Z(J) {
            var te;
            return t.default.wrap(function(he) {
              for (; ; )
                switch (he.prev = he.next) {
                  case 0:
                    return typeof J == "string" && (J = [J]), he.next = 3, this.call("rpc.on", J);
                  case 3:
                    if (te = he.sent, !(typeof J == "string" && te[J] !== "ok")) {
                      he.next = 6;
                      break;
                    }
                    throw new Error("Failed subscribing to an event '" + J + "' with: " + te[J]);
                  case 6:
                    return he.abrupt("return", te);
                  case 7:
                  case "end":
                    return he.stop();
                }
            }, Z, this);
          }));
          function D(Z) {
            return G.apply(this, arguments);
          }
          return D;
        }()
      }, {
        key: "unsubscribe",
        value: function() {
          var G = (0, o.default)(/* @__PURE__ */ t.default.mark(function Z(J) {
            var te;
            return t.default.wrap(function(he) {
              for (; ; )
                switch (he.prev = he.next) {
                  case 0:
                    return typeof J == "string" && (J = [J]), he.next = 3, this.call("rpc.off", J);
                  case 3:
                    if (te = he.sent, !(typeof J == "string" && te[J] !== "ok")) {
                      he.next = 6;
                      break;
                    }
                    throw new Error("Failed unsubscribing from an event with: " + te);
                  case 6:
                    return he.abrupt("return", te);
                  case 7:
                  case "end":
                    return he.stop();
                }
            }, Z, this);
          }));
          function D(Z) {
            return G.apply(this, arguments);
          }
          return D;
        }()
      }, {
        key: "close",
        value: function(D, Z) {
          this.socket.close(D || 1e3, Z);
        }
      }, {
        key: "_connect",
        value: function(D, Z) {
          var J = this;
          this.socket = this.webSocketFactory(D, Z), this.socket.addEventListener("open", function() {
            J.ready = !0, J.emit("open"), J.current_reconnects = 0;
          }), this.socket.addEventListener("message", function(te) {
            var ue = te.data;
            ue instanceof ArrayBuffer && (ue = Buffer.from(ue).toString());
            try {
              ue = JSON.parse(ue);
            } catch {
              return;
            }
            if (ue.notification && J.listeners(ue.notification).length) {
              if (!Object.keys(ue.params).length)
                return J.emit(ue.notification);
              var he = [ue.notification];
              if (ue.params.constructor === Object)
                he.push(ue.params);
              else
                for (var Se = 0; Se < ue.params.length; Se++)
                  he.push(ue.params[Se]);
              return Promise.resolve().then(function() {
                J.emit.apply(J, he);
              });
            }
            if (!J.queue[ue.id])
              return ue.method && ue.params ? Promise.resolve().then(function() {
                J.emit(ue.method, ue.params);
              }) : void 0;
            "error" in ue == "result" in ue && J.queue[ue.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), J.queue[ue.id].timeout && clearTimeout(J.queue[ue.id].timeout), ue.error ? J.queue[ue.id].promise[1](ue.error) : J.queue[ue.id].promise[0](ue.result), delete J.queue[ue.id];
          }), this.socket.addEventListener("error", function(te) {
            return J.emit("error", te);
          }), this.socket.addEventListener("close", function(te) {
            var ue = te.code, he = te.reason;
            J.ready && setTimeout(function() {
              return J.emit("close", ue, he);
            }, 0), J.ready = !1, J.socket = void 0, ue !== 1e3 && (J.current_reconnects++, J.reconnect && (J.max_reconnects > J.current_reconnects || J.max_reconnects === 0) && setTimeout(function() {
              return J._connect(D, Z);
            }, J.reconnect_interval));
          });
        }
      }]), U;
    }(I.EventEmitter);
    n.default = W;
  }(client)), client;
}
var _interopRequireDefault = interopRequireDefault.exports;
Object.defineProperty(index_browser, "__esModule", {
  value: !0
});
var Client_1 = index_browser.Client = void 0, _createClass2 = _interopRequireDefault(requireCreateClass()), _classCallCheck2 = _interopRequireDefault(requireClassCallCheck()), _inherits2 = _interopRequireDefault(requireInherits()), _possibleConstructorReturn2 = _interopRequireDefault(requirePossibleConstructorReturn()), _getPrototypeOf2 = _interopRequireDefault(requireGetPrototypeOf()), _websocket = _interopRequireDefault(requireWebsocket_browser()), _client = _interopRequireDefault(requireClient());
function _createSuper(n) {
  var e = _isNativeReflectConstruct();
  return function() {
    var o = (0, _getPrototypeOf2.default)(n), c;
    if (e) {
      var a = (0, _getPrototypeOf2.default)(this).constructor;
      c = Reflect.construct(o, arguments, a);
    } else
      c = o.apply(this, arguments);
    return (0, _possibleConstructorReturn2.default)(this, c);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var Client = /* @__PURE__ */ function(n) {
  (0, _inherits2.default)(t, n);
  var e = _createSuper(t);
  function t() {
    var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ws://localhost:8080", c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = c.autoconnect, d = a === void 0 ? !0 : a, p = c.reconnect, w = p === void 0 ? !0 : p, M = c.reconnect_interval, I = M === void 0 ? 1e3 : M, B = c.max_reconnects, H = B === void 0 ? 5 : B, L = arguments.length > 2 ? arguments[2] : void 0;
    return (0, _classCallCheck2.default)(this, t), e.call(this, _websocket.default, o, {
      autoconnect: d,
      reconnect: w,
      reconnect_interval: I,
      max_reconnects: H
    }, L);
  }
  return (0, _createClass2.default)(t);
}(_client.default);
Client_1 = index_browser.Client = Client;
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(n) {
  return typeof n == "string" && REGEX.test(n);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i)
  byteToHex.push((i + 256).toString(16).substr(1));
function stringify$1(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = (byteToHex[n[e + 0]] + byteToHex[n[e + 1]] + byteToHex[n[e + 2]] + byteToHex[n[e + 3]] + "-" + byteToHex[n[e + 4]] + byteToHex[n[e + 5]] + "-" + byteToHex[n[e + 6]] + byteToHex[n[e + 7]] + "-" + byteToHex[n[e + 8]] + byteToHex[n[e + 9]] + "-" + byteToHex[n[e + 10]] + byteToHex[n[e + 11]] + byteToHex[n[e + 12]] + byteToHex[n[e + 13]] + byteToHex[n[e + 14]] + byteToHex[n[e + 15]]).toLowerCase();
  if (!validate(t))
    throw TypeError("Stringified UUID is invalid");
  return t;
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
function v1(n, e, t) {
  var o = e && t || 0, c = e || new Array(16);
  n = n || {};
  var a = n.node || _nodeId, d = n.clockseq !== void 0 ? n.clockseq : _clockseq;
  if (a == null || d == null) {
    var p = n.random || (n.rng || rng)();
    a == null && (a = _nodeId = [p[0] | 1, p[1], p[2], p[3], p[4], p[5]]), d == null && (d = _clockseq = (p[6] << 8 | p[7]) & 16383);
  }
  var w = n.msecs !== void 0 ? n.msecs : Date.now(), M = n.nsecs !== void 0 ? n.nsecs : _lastNSecs + 1, I = w - _lastMSecs + (M - _lastNSecs) / 1e4;
  if (I < 0 && n.clockseq === void 0 && (d = d + 1 & 16383), (I < 0 || w > _lastMSecs) && n.nsecs === void 0 && (M = 0), M >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = w, _lastNSecs = M, _clockseq = d, w += 122192928e5;
  var B = ((w & 268435455) * 1e4 + M) % 4294967296;
  c[o++] = B >>> 24 & 255, c[o++] = B >>> 16 & 255, c[o++] = B >>> 8 & 255, c[o++] = B & 255;
  var H = w / 4294967296 * 1e4 & 268435455;
  c[o++] = H >>> 8 & 255, c[o++] = H & 255, c[o++] = H >>> 24 & 15 | 16, c[o++] = H >>> 16 & 255, c[o++] = d >>> 8 | 128, c[o++] = d & 255;
  for (var L = 0; L < 6; ++L)
    c[o + L] = a[L];
  return e || stringify$1(c);
}
function parse$1(n) {
  if (!validate(n))
    throw TypeError("Invalid UUID");
  var e, t = new Uint8Array(16);
  return t[0] = (e = parseInt(n.slice(0, 8), 16)) >>> 24, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, t[3] = e & 255, t[4] = (e = parseInt(n.slice(9, 13), 16)) >>> 8, t[5] = e & 255, t[6] = (e = parseInt(n.slice(14, 18), 16)) >>> 8, t[7] = e & 255, t[8] = (e = parseInt(n.slice(19, 23), 16)) >>> 8, t[9] = e & 255, t[10] = (e = parseInt(n.slice(24, 36), 16)) / 1099511627776 & 255, t[11] = e / 4294967296 & 255, t[12] = e >>> 24 & 255, t[13] = e >>> 16 & 255, t[14] = e >>> 8 & 255, t[15] = e & 255, t;
}
function stringToBytes(n) {
  n = unescape(encodeURIComponent(n));
  for (var e = [], t = 0; t < n.length; ++t)
    e.push(n.charCodeAt(t));
  return e;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(n, e, t) {
  function o(c, a, d, p) {
    if (typeof c == "string" && (c = stringToBytes(c)), typeof a == "string" && (a = parse$1(a)), a.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var w = new Uint8Array(16 + c.length);
    if (w.set(a), w.set(c, a.length), w = t(w), w[6] = w[6] & 15 | e, w[8] = w[8] & 63 | 128, d) {
      p = p || 0;
      for (var M = 0; M < 16; ++M)
        d[p + M] = w[M];
      return d;
    }
    return stringify$1(w);
  }
  try {
    o.name = n;
  } catch {
  }
  return o.DNS = DNS, o.URL = URL$1, o;
}
function md5(n) {
  if (typeof n == "string") {
    var e = unescape(encodeURIComponent(n));
    n = new Uint8Array(e.length);
    for (var t = 0; t < e.length; ++t)
      n[t] = e.charCodeAt(t);
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(n), n.length * 8));
}
function md5ToHexEncodedArray(n) {
  for (var e = [], t = n.length * 32, o = "0123456789abcdef", c = 0; c < t; c += 8) {
    var a = n[c >> 5] >>> c % 32 & 255, d = parseInt(o.charAt(a >>> 4 & 15) + o.charAt(a & 15), 16);
    e.push(d);
  }
  return e;
}
function getOutputLength(n) {
  return (n + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(n, e) {
  n[e >> 5] |= 128 << e % 32, n[getOutputLength(e) - 1] = e;
  for (var t = 1732584193, o = -271733879, c = -1732584194, a = 271733878, d = 0; d < n.length; d += 16) {
    var p = t, w = o, M = c, I = a;
    t = md5ff(t, o, c, a, n[d], 7, -680876936), a = md5ff(a, t, o, c, n[d + 1], 12, -389564586), c = md5ff(c, a, t, o, n[d + 2], 17, 606105819), o = md5ff(o, c, a, t, n[d + 3], 22, -1044525330), t = md5ff(t, o, c, a, n[d + 4], 7, -176418897), a = md5ff(a, t, o, c, n[d + 5], 12, 1200080426), c = md5ff(c, a, t, o, n[d + 6], 17, -1473231341), o = md5ff(o, c, a, t, n[d + 7], 22, -45705983), t = md5ff(t, o, c, a, n[d + 8], 7, 1770035416), a = md5ff(a, t, o, c, n[d + 9], 12, -1958414417), c = md5ff(c, a, t, o, n[d + 10], 17, -42063), o = md5ff(o, c, a, t, n[d + 11], 22, -1990404162), t = md5ff(t, o, c, a, n[d + 12], 7, 1804603682), a = md5ff(a, t, o, c, n[d + 13], 12, -40341101), c = md5ff(c, a, t, o, n[d + 14], 17, -1502002290), o = md5ff(o, c, a, t, n[d + 15], 22, 1236535329), t = md5gg(t, o, c, a, n[d + 1], 5, -165796510), a = md5gg(a, t, o, c, n[d + 6], 9, -1069501632), c = md5gg(c, a, t, o, n[d + 11], 14, 643717713), o = md5gg(o, c, a, t, n[d], 20, -373897302), t = md5gg(t, o, c, a, n[d + 5], 5, -701558691), a = md5gg(a, t, o, c, n[d + 10], 9, 38016083), c = md5gg(c, a, t, o, n[d + 15], 14, -660478335), o = md5gg(o, c, a, t, n[d + 4], 20, -405537848), t = md5gg(t, o, c, a, n[d + 9], 5, 568446438), a = md5gg(a, t, o, c, n[d + 14], 9, -1019803690), c = md5gg(c, a, t, o, n[d + 3], 14, -187363961), o = md5gg(o, c, a, t, n[d + 8], 20, 1163531501), t = md5gg(t, o, c, a, n[d + 13], 5, -1444681467), a = md5gg(a, t, o, c, n[d + 2], 9, -51403784), c = md5gg(c, a, t, o, n[d + 7], 14, 1735328473), o = md5gg(o, c, a, t, n[d + 12], 20, -1926607734), t = md5hh(t, o, c, a, n[d + 5], 4, -378558), a = md5hh(a, t, o, c, n[d + 8], 11, -2022574463), c = md5hh(c, a, t, o, n[d + 11], 16, 1839030562), o = md5hh(o, c, a, t, n[d + 14], 23, -35309556), t = md5hh(t, o, c, a, n[d + 1], 4, -1530992060), a = md5hh(a, t, o, c, n[d + 4], 11, 1272893353), c = md5hh(c, a, t, o, n[d + 7], 16, -155497632), o = md5hh(o, c, a, t, n[d + 10], 23, -1094730640), t = md5hh(t, o, c, a, n[d + 13], 4, 681279174), a = md5hh(a, t, o, c, n[d], 11, -358537222), c = md5hh(c, a, t, o, n[d + 3], 16, -722521979), o = md5hh(o, c, a, t, n[d + 6], 23, 76029189), t = md5hh(t, o, c, a, n[d + 9], 4, -640364487), a = md5hh(a, t, o, c, n[d + 12], 11, -421815835), c = md5hh(c, a, t, o, n[d + 15], 16, 530742520), o = md5hh(o, c, a, t, n[d + 2], 23, -995338651), t = md5ii(t, o, c, a, n[d], 6, -198630844), a = md5ii(a, t, o, c, n[d + 7], 10, 1126891415), c = md5ii(c, a, t, o, n[d + 14], 15, -1416354905), o = md5ii(o, c, a, t, n[d + 5], 21, -57434055), t = md5ii(t, o, c, a, n[d + 12], 6, 1700485571), a = md5ii(a, t, o, c, n[d + 3], 10, -1894986606), c = md5ii(c, a, t, o, n[d + 10], 15, -1051523), o = md5ii(o, c, a, t, n[d + 1], 21, -2054922799), t = md5ii(t, o, c, a, n[d + 8], 6, 1873313359), a = md5ii(a, t, o, c, n[d + 15], 10, -30611744), c = md5ii(c, a, t, o, n[d + 6], 15, -1560198380), o = md5ii(o, c, a, t, n[d + 13], 21, 1309151649), t = md5ii(t, o, c, a, n[d + 4], 6, -145523070), a = md5ii(a, t, o, c, n[d + 11], 10, -1120210379), c = md5ii(c, a, t, o, n[d + 2], 15, 718787259), o = md5ii(o, c, a, t, n[d + 9], 21, -343485551), t = safeAdd(t, p), o = safeAdd(o, w), c = safeAdd(c, M), a = safeAdd(a, I);
  }
  return [t, o, c, a];
}
function bytesToWords(n) {
  if (n.length === 0)
    return [];
  for (var e = n.length * 8, t = new Uint32Array(getOutputLength(e)), o = 0; o < e; o += 8)
    t[o >> 5] |= (n[o / 8] & 255) << o % 32;
  return t;
}
function safeAdd(n, e) {
  var t = (n & 65535) + (e & 65535), o = (n >> 16) + (e >> 16) + (t >> 16);
  return o << 16 | t & 65535;
}
function bitRotateLeft(n, e) {
  return n << e | n >>> 32 - e;
}
function md5cmn(n, e, t, o, c, a) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(e, n), safeAdd(o, a)), c), t);
}
function md5ff(n, e, t, o, c, a, d) {
  return md5cmn(e & t | ~e & o, n, e, c, a, d);
}
function md5gg(n, e, t, o, c, a, d) {
  return md5cmn(e & o | t & ~o, n, e, c, a, d);
}
function md5hh(n, e, t, o, c, a, d) {
  return md5cmn(e ^ t ^ o, n, e, c, a, d);
}
function md5ii(n, e, t, o, c, a, d) {
  return md5cmn(t ^ (e | ~o), n, e, c, a, d);
}
var v3 = v35("v3", 48, md5);
const v3$1 = v3;
function v4(n, e, t) {
  n = n || {};
  var o = n.random || (n.rng || rng)();
  if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, e) {
    t = t || 0;
    for (var c = 0; c < 16; ++c)
      e[t + c] = o[c];
    return e;
  }
  return stringify$1(o);
}
function f$1(n, e, t, o) {
  switch (n) {
    case 0:
      return e & t ^ ~e & o;
    case 1:
      return e ^ t ^ o;
    case 2:
      return e & t ^ e & o ^ t & o;
    case 3:
      return e ^ t ^ o;
  }
}
function ROTL(n, e) {
  return n << e | n >>> 32 - e;
}
function sha1(n) {
  var e = [1518500249, 1859775393, 2400959708, 3395469782], t = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof n == "string") {
    var o = unescape(encodeURIComponent(n));
    n = [];
    for (var c = 0; c < o.length; ++c)
      n.push(o.charCodeAt(c));
  } else
    Array.isArray(n) || (n = Array.prototype.slice.call(n));
  n.push(128);
  for (var a = n.length / 4 + 2, d = Math.ceil(a / 16), p = new Array(d), w = 0; w < d; ++w) {
    for (var M = new Uint32Array(16), I = 0; I < 16; ++I)
      M[I] = n[w * 64 + I * 4] << 24 | n[w * 64 + I * 4 + 1] << 16 | n[w * 64 + I * 4 + 2] << 8 | n[w * 64 + I * 4 + 3];
    p[w] = M;
  }
  p[d - 1][14] = (n.length - 1) * 8 / Math.pow(2, 32), p[d - 1][14] = Math.floor(p[d - 1][14]), p[d - 1][15] = (n.length - 1) * 8 & 4294967295;
  for (var B = 0; B < d; ++B) {
    for (var H = new Uint32Array(80), L = 0; L < 16; ++L)
      H[L] = p[B][L];
    for (var W = 16; W < 80; ++W)
      H[W] = ROTL(H[W - 3] ^ H[W - 8] ^ H[W - 14] ^ H[W - 16], 1);
    for (var $ = t[0], P = t[1], U = t[2], G = t[3], D = t[4], Z = 0; Z < 80; ++Z) {
      var J = Math.floor(Z / 20), te = ROTL($, 5) + f$1(J, P, U, G) + D + e[J] + H[Z] >>> 0;
      D = G, G = U, U = ROTL(P, 30) >>> 0, P = $, $ = te;
    }
    t[0] = t[0] + $ >>> 0, t[1] = t[1] + P >>> 0, t[2] = t[2] + U >>> 0, t[3] = t[3] + G >>> 0, t[4] = t[4] + D >>> 0;
  }
  return [t[0] >> 24 & 255, t[0] >> 16 & 255, t[0] >> 8 & 255, t[0] & 255, t[1] >> 24 & 255, t[1] >> 16 & 255, t[1] >> 8 & 255, t[1] & 255, t[2] >> 24 & 255, t[2] >> 16 & 255, t[2] >> 8 & 255, t[2] & 255, t[3] >> 24 & 255, t[3] >> 16 & 255, t[3] >> 8 & 255, t[3] & 255, t[4] >> 24 & 255, t[4] >> 16 & 255, t[4] >> 8 & 255, t[4] & 255];
}
var v5 = v35("v5", 80, sha1);
const v5$1 = v5, nil = "00000000-0000-0000-0000-000000000000";
function version$m(n) {
  if (!validate(n))
    throw TypeError("Invalid UUID");
  return parseInt(n.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  NIL: nil,
  version: version$m,
  validate,
  stringify: stringify$1,
  parse: parse$1
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser), uuid$1 = require$$0$1.v4, generateRequest$1 = function(n, e, t, o) {
  if (typeof n != "string")
    throw new TypeError(n + " must be a string");
  o = o || {};
  const c = typeof o.version == "number" ? o.version : 2;
  if (c !== 1 && c !== 2)
    throw new TypeError(c + " must be 1 or 2");
  const a = {
    method: n
  };
  if (c === 2 && (a.jsonrpc = "2.0"), e) {
    if (typeof e != "object" && !Array.isArray(e))
      throw new TypeError(e + " must be an object, array or omitted");
    a.params = e;
  }
  if (typeof t > "u") {
    const d = typeof o.generator == "function" ? o.generator : function() {
      return uuid$1();
    };
    a.id = d(a, o);
  } else
    c === 2 && t === null ? o.notificationIdNull && (a.id = null) : a.id = t;
  return a;
};
var generateRequest_1 = generateRequest$1;
const uuid = require$$0$1.v4, generateRequest = generateRequest_1, ClientBrowser = function(n, e) {
  if (!(this instanceof ClientBrowser))
    return new ClientBrowser(n, e);
  e || (e = {}), this.options = {
    reviver: typeof e.reviver < "u" ? e.reviver : null,
    replacer: typeof e.replacer < "u" ? e.replacer : null,
    generator: typeof e.generator < "u" ? e.generator : function() {
      return uuid();
    },
    version: typeof e.version < "u" ? e.version : 2,
    notificationIdNull: typeof e.notificationIdNull == "boolean" ? e.notificationIdNull : !1
  }, this.callServer = n;
};
var browser = ClientBrowser;
ClientBrowser.prototype.request = function(n, e, t, o) {
  const c = this;
  let a = null;
  const d = Array.isArray(n) && typeof e == "function";
  if (this.options.version === 1 && d)
    throw new TypeError("JSON-RPC 1.0 does not support batching");
  if (d || !d && n && typeof n == "object" && typeof e == "function")
    o = e, a = n;
  else {
    typeof t == "function" && (o = t, t = void 0);
    const M = typeof o == "function";
    try {
      a = generateRequest(n, e, t, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull
      });
    } catch (I) {
      if (M)
        return o(I);
      throw I;
    }
    if (!M)
      return a;
  }
  let w;
  try {
    w = JSON.stringify(a, this.options.replacer);
  } catch (M) {
    return o(M);
  }
  return this.callServer(w, function(M, I) {
    c._parseResponse(M, I, o);
  }), a;
};
ClientBrowser.prototype._parseResponse = function(n, e, t) {
  if (n) {
    t(n);
    return;
  }
  if (!e)
    return t();
  let o;
  try {
    o = JSON.parse(e, this.options.reviver);
  } catch (c) {
    return t(c);
  }
  if (t.length === 3)
    if (Array.isArray(o)) {
      const c = function(d) {
        return typeof d.error < "u";
      }, a = function(d) {
        return !c(d);
      };
      return t(null, o.filter(c), o.filter(a));
    } else
      return t(null, o.error, o.result);
  t(null, o);
};
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []], _0n$1 = BigInt(0), _1n$1 = BigInt(1), _2n$1 = BigInt(2), _7n = BigInt(7), _256n = BigInt(256), _0x71n = BigInt(113);
for (let n = 0, e = _1n$1, t = 1, o = 0; n < 24; n++) {
  [t, o] = [o, (2 * t + 3 * o) % 5], SHA3_PI.push(2 * (5 * o + t)), SHA3_ROTL.push((n + 1) * (n + 2) / 2 % 64);
  let c = _0n$1;
  for (let a = 0; a < 7; a++)
    e = (e << _1n$1 ^ (e >> _7n) * _0x71n) % _256n, e & _2n$1 && (c ^= _1n$1 << (_1n$1 << BigInt(a)) - _1n$1);
  _SHA3_IOTA.push(c);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = u64$1.split(_SHA3_IOTA, !0), rotlH = (n, e, t) => t > 32 ? u64$1.rotlBH(n, e, t) : u64$1.rotlSH(n, e, t), rotlL = (n, e, t) => t > 32 ? u64$1.rotlBL(n, e, t) : u64$1.rotlSL(n, e, t);
function keccakP(n, e = 24) {
  const t = new Uint32Array(10);
  for (let o = 24 - e; o < 24; o++) {
    for (let d = 0; d < 10; d++)
      t[d] = n[d] ^ n[d + 10] ^ n[d + 20] ^ n[d + 30] ^ n[d + 40];
    for (let d = 0; d < 10; d += 2) {
      const p = (d + 8) % 10, w = (d + 2) % 10, M = t[w], I = t[w + 1], B = rotlH(M, I, 1) ^ t[p], H = rotlL(M, I, 1) ^ t[p + 1];
      for (let L = 0; L < 50; L += 10)
        n[d + L] ^= B, n[d + L + 1] ^= H;
    }
    let c = n[2], a = n[3];
    for (let d = 0; d < 24; d++) {
      const p = SHA3_ROTL[d], w = rotlH(c, a, p), M = rotlL(c, a, p), I = SHA3_PI[d];
      c = n[I], a = n[I + 1], n[I] = w, n[I + 1] = M;
    }
    for (let d = 0; d < 50; d += 10) {
      for (let p = 0; p < 10; p++)
        t[p] = n[d + p];
      for (let p = 0; p < 10; p++)
        n[d + p] ^= ~t[(p + 2) % 10] & t[(p + 4) % 10];
    }
    n[0] ^= SHA3_IOTA_H[o], n[1] ^= SHA3_IOTA_L[o];
  }
  t.fill(0);
}
class Keccak extends Hash {
  constructor(e, t, o, c = !1, a = 24) {
    if (super(), this.blockLen = e, this.suffix = t, this.outputLen = o, this.enableXOF = c, this.rounds = a, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, assert$e.number(o), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = u32$1(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    assert$e.exists(this);
    const { blockLen: t, state: o } = this;
    e = toBytes(e);
    const c = e.length;
    for (let a = 0; a < c; ) {
      const d = Math.min(t - this.pos, c - a);
      for (let p = 0; p < d; p++)
        o[this.pos++] ^= e[a++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: t, pos: o, blockLen: c } = this;
    e[o] ^= t, (t & 128) !== 0 && o === c - 1 && this.keccak(), e[c - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    assert$e.exists(this, !1), assert$e.bytes(e), this.finish();
    const t = this.state, { blockLen: o } = this;
    for (let c = 0, a = e.length; c < a; ) {
      this.posOut >= o && this.keccak();
      const d = Math.min(o - this.posOut, a - c);
      e.set(t.subarray(this.posOut, this.posOut + d), c), this.posOut += d, c += d;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return assert$e.number(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (assert$e.output(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: o, outputLen: c, rounds: a, enableXOF: d } = this;
    return e || (e = new Keccak(t, o, c, d, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = o, e.outputLen = c, e.enableXOF = d, e.destroyed = this.destroyed, e;
  }
}
const gen = (n, e, t) => wrapConstructor(() => new Keccak(e, n, t));
gen(6, 144, 224 / 8);
gen(6, 136, 256 / 8);
gen(6, 104, 384 / 8);
gen(6, 72, 512 / 8);
gen(1, 144, 224 / 8);
const keccak_256 = gen(1, 136, 256 / 8);
gen(1, 104, 384 / 8);
gen(1, 72, 512 / 8);
const genShake = (n, e, t) => wrapConstructorWithOpts((o = {}) => new Keccak(e, n, o.dkLen === void 0 ? t : o.dkLen, !0));
genShake(31, 168, 128 / 8);
genShake(31, 136, 256 / 8);
class HMAC extends Hash {
  constructor(e, t) {
    super(), this.finished = !1, this.destroyed = !1, assert$e.hash(e);
    const o = toBytes(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const c = this.blockLen, a = new Uint8Array(c);
    a.set(o.length > c ? e.create().update(o).digest() : o);
    for (let d = 0; d < a.length; d++)
      a[d] ^= 54;
    this.iHash.update(a), this.oHash = e.create();
    for (let d = 0; d < a.length; d++)
      a[d] ^= 106;
    this.oHash.update(a), a.fill(0);
  }
  update(e) {
    return assert$e.exists(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    assert$e.exists(this), assert$e.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: o, finished: c, destroyed: a, blockLen: d, outputLen: p } = this;
    return e = e, e.finished = c, e.destroyed = a, e.blockLen = d, e.outputLen = p, e.oHash = t._cloneInto(e.oHash), e.iHash = o._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac$1 = (n, e, t) => new HMAC(n, e).update(t).digest();
hmac$1.create = (n, e) => new HMAC(n, e);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _8n = BigInt(8), CURVE = Object.freeze({
  a: _0n,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
function weistrass(n) {
  const { a: e, b: t } = CURVE, o = mod(n * n), c = mod(o * n);
  return mod(c + e * n + t);
}
const USE_ENDOMORPHISM = CURVE.a === _0n;
class ShaError extends Error {
  constructor(e) {
    super(e);
  }
}
class JacobianPoint {
  constructor(e, t, o) {
    this.x = e, this.y = t, this.z = o;
  }
  static fromAffine(e) {
    if (!(e instanceof Point$1))
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    return new JacobianPoint(e.x, e.y, _1n);
  }
  static toAffineBatch(e) {
    const t = invertBatch(e.map((o) => o.z));
    return e.map((o, c) => o.toAffine(t[c]));
  }
  static normalizeZ(e) {
    return JacobianPoint.toAffineBatch(e).map(JacobianPoint.fromAffine);
  }
  equals(e) {
    if (!(e instanceof JacobianPoint))
      throw new TypeError("JacobianPoint expected");
    const { x: t, y: o, z: c } = this, { x: a, y: d, z: p } = e, w = mod(c * c), M = mod(p * p), I = mod(t * M), B = mod(a * w), H = mod(mod(o * p) * M), L = mod(mod(d * c) * w);
    return I === B && H === L;
  }
  negate() {
    return new JacobianPoint(this.x, mod(-this.y), this.z);
  }
  double() {
    const { x: e, y: t, z: o } = this, c = mod(e * e), a = mod(t * t), d = mod(a * a), p = e + a, w = mod(_2n * (mod(p * p) - c - d)), M = mod(_3n * c), I = mod(M * M), B = mod(I - _2n * w), H = mod(M * (w - B) - _8n * d), L = mod(_2n * t * o);
    return new JacobianPoint(B, H, L);
  }
  add(e) {
    if (!(e instanceof JacobianPoint))
      throw new TypeError("JacobianPoint expected");
    const { x: t, y: o, z: c } = this, { x: a, y: d, z: p } = e;
    if (a === _0n || d === _0n)
      return this;
    if (t === _0n || o === _0n)
      return e;
    const w = mod(c * c), M = mod(p * p), I = mod(t * M), B = mod(a * w), H = mod(mod(o * p) * M), L = mod(mod(d * c) * w), W = mod(B - I), $ = mod(L - H);
    if (W === _0n)
      return $ === _0n ? this.double() : JacobianPoint.ZERO;
    const P = mod(W * W), U = mod(W * P), G = mod(I * P), D = mod($ * $ - U - _2n * G), Z = mod($ * (G - D) - H * U), J = mod(c * p * W);
    return new JacobianPoint(D, Z, J);
  }
  subtract(e) {
    return this.add(e.negate());
  }
  multiplyUnsafe(e) {
    const t = JacobianPoint.ZERO;
    if (typeof e == "bigint" && e === _0n)
      return t;
    let o = normalizeScalar(e);
    if (o === _1n)
      return this;
    if (!USE_ENDOMORPHISM) {
      let B = t, H = this;
      for (; o > _0n; )
        o & _1n && (B = B.add(H)), H = H.double(), o >>= _1n;
      return B;
    }
    let { k1neg: c, k1: a, k2neg: d, k2: p } = splitScalarEndo(o), w = t, M = t, I = this;
    for (; a > _0n || p > _0n; )
      a & _1n && (w = w.add(I)), p & _1n && (M = M.add(I)), I = I.double(), a >>= _1n, p >>= _1n;
    return c && (w = w.negate()), d && (M = M.negate()), M = new JacobianPoint(mod(M.x * CURVE.beta), M.y, M.z), w.add(M);
  }
  precomputeWindow(e) {
    const t = USE_ENDOMORPHISM ? 128 / e + 1 : 256 / e + 1, o = [];
    let c = this, a = c;
    for (let d = 0; d < t; d++) {
      a = c, o.push(a);
      for (let p = 1; p < 2 ** (e - 1); p++)
        a = a.add(c), o.push(a);
      c = a.double();
    }
    return o;
  }
  wNAF(e, t) {
    !t && this.equals(JacobianPoint.BASE) && (t = Point$1.BASE);
    const o = t && t._WINDOW_SIZE || 1;
    if (256 % o)
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    let c = t && pointPrecomputes.get(t);
    c || (c = this.precomputeWindow(o), t && o !== 1 && (c = JacobianPoint.normalizeZ(c), pointPrecomputes.set(t, c)));
    let a = JacobianPoint.ZERO, d = JacobianPoint.ZERO;
    const p = 1 + (USE_ENDOMORPHISM ? 128 / o : 256 / o), w = 2 ** (o - 1), M = BigInt(2 ** o - 1), I = 2 ** o, B = BigInt(o);
    for (let H = 0; H < p; H++) {
      const L = H * w;
      let W = Number(e & M);
      if (e >>= B, W > w && (W -= I, e += _1n), W === 0) {
        let $ = c[L];
        H % 2 && ($ = $.negate()), d = d.add($);
      } else {
        let $ = c[L + Math.abs(W) - 1];
        W < 0 && ($ = $.negate()), a = a.add($);
      }
    }
    return { p: a, f: d };
  }
  multiply(e, t) {
    let o = normalizeScalar(e), c, a;
    if (USE_ENDOMORPHISM) {
      const { k1neg: d, k1: p, k2neg: w, k2: M } = splitScalarEndo(o);
      let { p: I, f: B } = this.wNAF(p, t), { p: H, f: L } = this.wNAF(M, t);
      d && (I = I.negate()), w && (H = H.negate()), H = new JacobianPoint(mod(H.x * CURVE.beta), H.y, H.z), c = I.add(H), a = B.add(L);
    } else {
      const { p: d, f: p } = this.wNAF(o, t);
      c = d, a = p;
    }
    return JacobianPoint.normalizeZ([c, a])[0];
  }
  toAffine(e = invert(this.z)) {
    const { x: t, y: o, z: c } = this, a = e, d = mod(a * a), p = mod(d * a), w = mod(t * d), M = mod(o * p);
    if (mod(c * a) !== _1n)
      throw new Error("invZ was invalid");
    return new Point$1(w, M);
  }
}
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
const pointPrecomputes = /* @__PURE__ */ new WeakMap();
class Point$1 {
  constructor(e, t) {
    this.x = e, this.y = t;
  }
  _setWindowSize(e) {
    this._WINDOW_SIZE = e, pointPrecomputes.delete(this);
  }
  hasEvenY() {
    return this.y % _2n === _0n;
  }
  static fromCompressedHex(e) {
    const t = e.length === 32, o = bytesToNumber(t ? e : e.subarray(1));
    if (!isValidFieldElement(o))
      throw new Error("Point is not on curve");
    const c = weistrass(o);
    let a = sqrtMod(c);
    const d = (a & _1n) === _1n;
    t ? d && (a = mod(-a)) : (e[0] & 1) === 1 !== d && (a = mod(-a));
    const p = new Point$1(o, a);
    return p.assertValidity(), p;
  }
  static fromUncompressedHex(e) {
    const t = bytesToNumber(e.subarray(1, 33)), o = bytesToNumber(e.subarray(33, 65)), c = new Point$1(t, o);
    return c.assertValidity(), c;
  }
  static fromHex(e) {
    const t = ensureBytes(e), o = t.length, c = t[0];
    if (o === 32 || o === 33 && (c === 2 || c === 3))
      return this.fromCompressedHex(t);
    if (o === 65 && c === 4)
      return this.fromUncompressedHex(t);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${o}`);
  }
  static fromPrivateKey(e) {
    return Point$1.BASE.multiply(normalizePrivateKey(e));
  }
  static fromSignature(e, t, o) {
    e = ensureBytes(e);
    const c = truncateHash(e), { r: a, s: d } = normalizeSignature(t);
    if (o !== 0 && o !== 1)
      throw new Error("Cannot recover signature: invalid recovery bit");
    const p = o & 1 ? "03" : "02", w = Point$1.fromHex(p + numTo32bStr(a)), { n: M } = CURVE, I = invert(a, M), B = mod(-c * I, M), H = mod(d * I, M), L = Point$1.BASE.multiplyAndAddUnsafe(w, B, H);
    if (!L)
      throw new Error("Cannot recover signature: point at infinify");
    return L.assertValidity(), L;
  }
  toRawBytes(e = !1) {
    return hexToBytes(this.toHex(e));
  }
  toHex(e = !1) {
    const t = numTo32bStr(this.x);
    return e ? `${this.hasEvenY() ? "02" : "03"}${t}` : `04${t}${numTo32bStr(this.y)}`;
  }
  toHexX() {
    return this.toHex(!0).slice(2);
  }
  toRawX() {
    return this.toRawBytes(!0).slice(1);
  }
  assertValidity() {
    const e = "Point is not on elliptic curve", { x: t, y: o } = this;
    if (!isValidFieldElement(t) || !isValidFieldElement(o))
      throw new Error(e);
    const c = mod(o * o), a = weistrass(t);
    if (mod(c - a) !== _0n)
      throw new Error(e);
  }
  equals(e) {
    return this.x === e.x && this.y === e.y;
  }
  negate() {
    return new Point$1(this.x, mod(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(e) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(e)).toAffine();
  }
  subtract(e) {
    return this.add(e.negate());
  }
  multiply(e) {
    return JacobianPoint.fromAffine(this).multiply(e, this).toAffine();
  }
  multiplyAndAddUnsafe(e, t, o) {
    const c = JacobianPoint.fromAffine(this), a = t === _0n || t === _1n || this !== Point$1.BASE ? c.multiplyUnsafe(t) : c.multiply(t), d = JacobianPoint.fromAffine(e).multiplyUnsafe(o), p = a.add(d);
    return p.equals(JacobianPoint.ZERO) ? void 0 : p.toAffine();
  }
}
Point$1.BASE = new Point$1(CURVE.Gx, CURVE.Gy);
Point$1.ZERO = new Point$1(_0n, _0n);
function sliceDER(n) {
  return Number.parseInt(n[0], 16) >= 8 ? "00" + n : n;
}
function parseDERInt(n) {
  if (n.length < 2 || n[0] !== 2)
    throw new Error(`Invalid signature integer tag: ${bytesToHex(n)}`);
  const e = n[1], t = n.subarray(2, e + 2);
  if (!e || t.length !== e)
    throw new Error("Invalid signature integer: wrong length");
  if (t[0] === 0 && t[1] <= 127)
    throw new Error("Invalid signature integer: trailing length");
  return { data: bytesToNumber(t), left: n.subarray(e + 2) };
}
function parseDERSignature(n) {
  if (n.length < 2 || n[0] != 48)
    throw new Error(`Invalid signature tag: ${bytesToHex(n)}`);
  if (n[1] !== n.length - 2)
    throw new Error("Invalid signature: incorrect length");
  const { data: e, left: t } = parseDERInt(n.subarray(2)), { data: o, left: c } = parseDERInt(t);
  if (c.length)
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(c)}`);
  return { r: e, s: o };
}
class Signature$1 {
  constructor(e, t) {
    this.r = e, this.s = t, this.assertValidity();
  }
  static fromCompact(e) {
    const t = e instanceof Uint8Array, o = "Signature.fromCompact";
    if (typeof e != "string" && !t)
      throw new TypeError(`${o}: Expected string or Uint8Array`);
    const c = t ? bytesToHex(e) : e;
    if (c.length !== 128)
      throw new Error(`${o}: Expected 64-byte hex`);
    return new Signature$1(hexToNumber(c.slice(0, 64)), hexToNumber(c.slice(64, 128)));
  }
  static fromDER(e) {
    const t = e instanceof Uint8Array;
    if (typeof e != "string" && !t)
      throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
    const { r: o, s: c } = parseDERSignature(t ? e : hexToBytes(e));
    return new Signature$1(o, c);
  }
  static fromHex(e) {
    return this.fromDER(e);
  }
  assertValidity() {
    const { r: e, s: t } = this;
    if (!isWithinCurveOrder(e))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(t))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const e = CURVE.n >> _1n;
    return this.s > e;
  }
  normalizeS() {
    return this.hasHighS() ? new Signature$1(this.r, CURVE.n - this.s) : this;
  }
  toDERRawBytes(e = !1) {
    return hexToBytes(this.toDERHex(e));
  }
  toDERHex(e = !1) {
    const t = sliceDER(numberToHexUnpadded(this.s));
    if (e)
      return t;
    const o = sliceDER(numberToHexUnpadded(this.r)), c = numberToHexUnpadded(o.length / 2), a = numberToHexUnpadded(t.length / 2);
    return `30${numberToHexUnpadded(o.length / 2 + t.length / 2 + 4)}02${c}${o}02${a}${t}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
}
function concatBytes(...n) {
  if (!n.every((o) => o instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (n.length === 1)
    return n[0];
  const e = n.reduce((o, c) => o + c.length, 0), t = new Uint8Array(e);
  for (let o = 0, c = 0; o < n.length; o++) {
    const a = n[o];
    t.set(a, c), c += a.length;
  }
  return t;
}
const hexes = Array.from({ length: 256 }, (n, e) => e.toString(16).padStart(2, "0"));
function bytesToHex(n) {
  if (!(n instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let e = "";
  for (let t = 0; t < n.length; t++)
    e += hexes[n[t]];
  return e;
}
const POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(n) {
  if (typeof n != "bigint")
    throw new Error("Expected bigint");
  if (!(_0n <= n && n < POW_2_256))
    throw new Error("Expected number < 2^256");
  return n.toString(16).padStart(64, "0");
}
function numTo32b(n) {
  const e = hexToBytes(numTo32bStr(n));
  if (e.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return e;
}
function numberToHexUnpadded(n) {
  const e = n.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function hexToNumber(n) {
  if (typeof n != "string")
    throw new TypeError("hexToNumber: expected string, got " + typeof n);
  return BigInt(`0x${n}`);
}
function hexToBytes(n) {
  if (typeof n != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof n);
  if (n.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + n.length);
  const e = new Uint8Array(n.length / 2);
  for (let t = 0; t < e.length; t++) {
    const o = t * 2, c = n.slice(o, o + 2), a = Number.parseInt(c, 16);
    if (Number.isNaN(a) || a < 0)
      throw new Error("Invalid byte sequence");
    e[t] = a;
  }
  return e;
}
function bytesToNumber(n) {
  return hexToNumber(bytesToHex(n));
}
function ensureBytes(n) {
  return n instanceof Uint8Array ? Uint8Array.from(n) : hexToBytes(n);
}
function normalizeScalar(n) {
  if (typeof n == "number" && Number.isSafeInteger(n) && n > 0)
    return BigInt(n);
  if (typeof n == "bigint" && isWithinCurveOrder(n))
    return n;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod(n, e = CURVE.P) {
  const t = n % e;
  return t >= _0n ? t : e + t;
}
function pow2(n, e) {
  const { P: t } = CURVE;
  let o = n;
  for (; e-- > _0n; )
    o *= o, o %= t;
  return o;
}
function sqrtMod(n) {
  const { P: e } = CURVE, t = BigInt(6), o = BigInt(11), c = BigInt(22), a = BigInt(23), d = BigInt(44), p = BigInt(88), w = n * n * n % e, M = w * w * n % e, I = pow2(M, _3n) * M % e, B = pow2(I, _3n) * M % e, H = pow2(B, _2n) * w % e, L = pow2(H, o) * H % e, W = pow2(L, c) * L % e, $ = pow2(W, d) * W % e, P = pow2($, p) * $ % e, U = pow2(P, d) * W % e, G = pow2(U, _3n) * M % e, D = pow2(G, a) * L % e, Z = pow2(D, t) * w % e;
  return pow2(Z, _2n);
}
function invert(n, e = CURVE.P) {
  if (n === _0n || e <= _0n)
    throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);
  let t = mod(n, e), o = e, c = _0n, a = _1n;
  for (; t !== _0n; ) {
    const p = o / t, w = o % t, M = c - a * p;
    o = t, t = w, c = a, a = M;
  }
  if (o !== _1n)
    throw new Error("invert: does not exist");
  return mod(c, e);
}
function invertBatch(n, e = CURVE.P) {
  const t = new Array(n.length), o = n.reduce((a, d, p) => d === _0n ? a : (t[p] = a, mod(a * d, e)), _1n), c = invert(o, e);
  return n.reduceRight((a, d, p) => d === _0n ? a : (t[p] = mod(a * t[p], e), mod(a * d, e)), c), t;
}
const divNearest = (n, e) => (n + e / _2n) / e, ENDO = {
  a1: BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
  b1: -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
  a2: BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
  b2: BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
  POW_2_128: BigInt("0x100000000000000000000000000000000")
};
function splitScalarEndo(n) {
  const { n: e } = CURVE, { a1: t, b1: o, a2: c, b2: a, POW_2_128: d } = ENDO, p = divNearest(a * n, e), w = divNearest(-o * n, e);
  let M = mod(n - p * t - w * c, e), I = mod(-p * o - w * a, e);
  const B = M > d, H = I > d;
  if (B && (M = e - M), H && (I = e - I), M > d || I > d)
    throw new Error("splitScalarEndo: Endomorphism failed, k=" + n);
  return { k1neg: B, k1: M, k2neg: H, k2: I };
}
function truncateHash(n) {
  const { n: e } = CURVE, o = n.length * 8 - 256;
  let c = bytesToNumber(n);
  return o > 0 && (c = c >> BigInt(o)), c >= e && (c -= e), c;
}
let _sha256Sync, _hmacSha256Sync;
class HmacDrbg {
  constructor() {
    this.v = new Uint8Array(32).fill(1), this.k = new Uint8Array(32).fill(0), this.counter = 0;
  }
  hmac(...e) {
    return utils$b.hmacSha256(this.k, ...e);
  }
  hmacSync(...e) {
    return _hmacSha256Sync(this.k, ...e);
  }
  checkSync() {
    if (typeof _hmacSha256Sync != "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(e = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), e), this.v = await this.hmac(this.v), e.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), e), this.v = await this.hmac(this.v));
  }
  reseedSync(e = new Uint8Array()) {
    this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), e), this.v = this.hmacSync(this.v), e.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), e), this.v = this.hmacSync(this.v));
  }
  async generate() {
    return this.incr(), this.v = await this.hmac(this.v), this.v;
  }
  generateSync() {
    return this.checkSync(), this.incr(), this.v = this.hmacSync(this.v), this.v;
  }
}
function isWithinCurveOrder(n) {
  return _0n < n && n < CURVE.n;
}
function isValidFieldElement(n) {
  return _0n < n && n < CURVE.P;
}
function kmdToSig(n, e, t) {
  const o = bytesToNumber(n);
  if (!isWithinCurveOrder(o))
    return;
  const { n: c } = CURVE, a = Point$1.BASE.multiply(o), d = mod(a.x, c);
  if (d === _0n)
    return;
  const p = mod(invert(o, c) * mod(e + t * d, c), c);
  if (p === _0n)
    return;
  const w = new Signature$1(d, p), M = (a.x === w.r ? 0 : 2) | Number(a.y & _1n);
  return { sig: w, recovery: M };
}
function normalizePrivateKey(n) {
  let e;
  if (typeof n == "bigint")
    e = n;
  else if (typeof n == "number" && Number.isSafeInteger(n) && n > 0)
    e = BigInt(n);
  else if (typeof n == "string") {
    if (n.length !== 64)
      throw new Error("Expected 32 bytes of private key");
    e = hexToNumber(n);
  } else if (n instanceof Uint8Array) {
    if (n.length !== 32)
      throw new Error("Expected 32 bytes of private key");
    e = bytesToNumber(n);
  } else
    throw new TypeError("Expected valid private key");
  if (!isWithinCurveOrder(e))
    throw new Error("Expected private key: 0 < key < n");
  return e;
}
function normalizeSignature(n) {
  if (n instanceof Signature$1)
    return n.assertValidity(), n;
  try {
    return Signature$1.fromDER(n);
  } catch {
    return Signature$1.fromCompact(n);
  }
}
function getPublicKey$1(n, e = !1) {
  return Point$1.fromPrivateKey(n).toRawBytes(e);
}
function bits2int(n) {
  const e = n.length > 32 ? n.slice(0, 32) : n;
  return bytesToNumber(e);
}
function bits2octets(n) {
  const e = bits2int(n), t = mod(e, CURVE.n);
  return int2octets(t < _0n ? e : t);
}
function int2octets(n) {
  return numTo32b(n);
}
function initSigArgs(n, e, t) {
  if (n == null)
    throw new Error(`sign: expected valid message hash, not "${n}"`);
  const o = ensureBytes(n), c = normalizePrivateKey(e), a = [int2octets(c), bits2octets(o)];
  if (t != null) {
    t === !0 && (t = utils$b.randomBytes(32));
    const w = ensureBytes(t);
    if (w.length !== 32)
      throw new Error("sign: Expected 32 bytes of extra data");
    a.push(w);
  }
  const d = concatBytes(...a), p = bits2int(o);
  return { seed: d, m: p, d: c };
}
function finalizeSig(n, e) {
  let { sig: t, recovery: o } = n;
  const { canonical: c, der: a, recovered: d } = Object.assign({ canonical: !0, der: !0 }, e);
  c && t.hasHighS() && (t = t.normalizeS(), o ^= 1);
  const p = a ? t.toDERRawBytes() : t.toCompactRawBytes();
  return d ? [p, o] : p;
}
function signSync(n, e, t = {}) {
  const { seed: o, m: c, d: a } = initSigArgs(n, e, t.extraEntropy);
  let d;
  const p = new HmacDrbg();
  for (p.reseedSync(o); !(d = kmdToSig(p.generateSync(), c, a)); )
    p.reseedSync();
  return finalizeSig(d, t);
}
Point$1.BASE._setWindowSize(8);
const crypto$2 = {
  node: nodeCrypto,
  web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
}, TAGGED_HASH_PREFIXES = {}, utils$b = {
  bytesToHex,
  hexToBytes,
  concatBytes,
  mod,
  invert,
  isValidPrivateKey(n) {
    try {
      return normalizePrivateKey(n), !0;
    } catch {
      return !1;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (n) => {
    if (n = ensureBytes(n), n.length < 40 || n.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    const e = mod(bytesToNumber(n), CURVE.n - _1n) + _1n;
    return numTo32b(e);
  },
  randomBytes: (n = 32) => {
    if (crypto$2.web)
      return crypto$2.web.getRandomValues(new Uint8Array(n));
    if (crypto$2.node) {
      const { randomBytes: e } = crypto$2.node;
      return Uint8Array.from(e(n));
    } else
      throw new Error("The environment doesn't have randomBytes function");
  },
  randomPrivateKey: () => utils$b.hashToPrivateKey(utils$b.randomBytes(40)),
  sha256: async (...n) => {
    if (crypto$2.web) {
      const e = await crypto$2.web.subtle.digest("SHA-256", concatBytes(...n));
      return new Uint8Array(e);
    } else if (crypto$2.node) {
      const { createHash: e } = crypto$2.node, t = e("sha256");
      return n.forEach((o) => t.update(o)), Uint8Array.from(t.digest());
    } else
      throw new Error("The environment doesn't have sha256 function");
  },
  hmacSha256: async (n, ...e) => {
    if (crypto$2.web) {
      const t = await crypto$2.web.subtle.importKey("raw", n, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), o = concatBytes(...e), c = await crypto$2.web.subtle.sign("HMAC", t, o);
      return new Uint8Array(c);
    } else if (crypto$2.node) {
      const { createHmac: t } = crypto$2.node, o = t("sha256", n);
      return e.forEach((c) => o.update(c)), Uint8Array.from(o.digest());
    } else
      throw new Error("The environment doesn't have hmac-sha256 function");
  },
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: async (n, ...e) => {
    let t = TAGGED_HASH_PREFIXES[n];
    if (t === void 0) {
      const o = await utils$b.sha256(Uint8Array.from(n, (c) => c.charCodeAt(0)));
      t = concatBytes(o, o), TAGGED_HASH_PREFIXES[n] = t;
    }
    return utils$b.sha256(t, ...e);
  },
  taggedHashSync: (n, ...e) => {
    if (typeof _sha256Sync != "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let t = TAGGED_HASH_PREFIXES[n];
    if (t === void 0) {
      const o = _sha256Sync(Uint8Array.from(n, (c) => c.charCodeAt(0)));
      t = concatBytes(o, o), TAGGED_HASH_PREFIXES[n] = t;
    }
    return _sha256Sync(t, ...e);
  },
  precompute(n = 8, e = Point$1.BASE) {
    const t = e === Point$1.BASE ? e : new Point$1(e.x, e.y);
    return t._setWindowSize(n), t.multiply(_3n), t;
  }
};
Object.defineProperties(utils$b, {
  sha256Sync: {
    configurable: !1,
    get() {
      return _sha256Sync;
    },
    set(n) {
      _sha256Sync || (_sha256Sync = n);
    }
  },
  hmacSha256Sync: {
    configurable: !1,
    get() {
      return _hmacSha256Sync;
    },
    set(n) {
      _hmacSha256Sync || (_hmacSha256Sync = n);
    }
  }
});
utils$c.sha512Sync = (...n) => sha512$1(utils$c.concatBytes(...n));
const generatePrivateKey = utils$c.randomPrivateKey, generateKeypair = () => {
  const n = utils$c.randomPrivateKey(), e = getPublicKey(n), t = new Uint8Array(64);
  return t.set(n), t.set(e, 32), {
    publicKey: e,
    secretKey: t
  };
}, getPublicKey = sync.getPublicKey;
function isOnCurve(n) {
  try {
    return Point$2.fromHex(
      n,
      !0
    ), !0;
  } catch {
    return !1;
  }
}
const sign = (n, e) => sync.sign(n, e.slice(0, 32)), verify = sync.verify, toBuffer = (n) => buffer.Buffer.isBuffer(n) ? n : n instanceof Uint8Array ? buffer.Buffer.from(n.buffer, n.byteOffset, n.byteLength) : buffer.Buffer.from(n);
class Struct {
  constructor(e) {
    Object.assign(this, e);
  }
  encode() {
    return buffer.Buffer.from(serialize_1(SOLANA_SCHEMA, this));
  }
  static decode(e) {
    return deserialize_1(SOLANA_SCHEMA, this, e);
  }
  static decodeUnchecked(e) {
    return deserializeUnchecked_1(SOLANA_SCHEMA, this, e);
  }
}
class Enum extends Struct {
  constructor(e) {
    if (super(e), this.enum = "", Object.keys(e).length !== 1)
      throw new Error("Enum can only take single value");
    Object.keys(e).map((t) => {
      this.enum = t;
    });
  }
}
const SOLANA_SCHEMA = /* @__PURE__ */ new Map();
let _Symbol$toStringTag;
const MAX_SEED_LENGTH = 32, PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(n) {
  return n._bn !== void 0;
}
let uniquePublicKeyCounter = 1;
_Symbol$toStringTag = Symbol.toStringTag;
class PublicKey extends Struct {
  constructor(e) {
    if (super({}), this._bn = void 0, isPublicKeyData(e))
      this._bn = e._bn;
    else {
      if (typeof e == "string") {
        const t = bs58.decode(e);
        if (t.length != PUBLIC_KEY_LENGTH)
          throw new Error("Invalid public key input");
        this._bn = new BN$2(t);
      } else
        this._bn = new BN$2(e);
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH)
        throw new Error("Invalid public key input");
    }
  }
  static unique() {
    const e = new PublicKey(uniquePublicKeyCounter);
    return uniquePublicKeyCounter += 1, new PublicKey(e.toBuffer());
  }
  equals(e) {
    return this._bn.eq(e._bn);
  }
  toBase58() {
    return bs58.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    return this.toBuffer();
  }
  toBuffer() {
    const e = this._bn.toArrayLike(buffer.Buffer);
    if (e.length === PUBLIC_KEY_LENGTH)
      return e;
    const t = buffer.Buffer.alloc(32);
    return e.copy(t, 32 - e.length), t;
  }
  get [_Symbol$toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(e, t, o) {
    const c = buffer.Buffer.concat([e.toBuffer(), buffer.Buffer.from(t), o.toBuffer()]), a = sha256$2(c);
    return new PublicKey(a);
  }
  static createProgramAddressSync(e, t) {
    let o = buffer.Buffer.alloc(0);
    e.forEach(function(a) {
      if (a.length > MAX_SEED_LENGTH)
        throw new TypeError("Max seed length exceeded");
      o = buffer.Buffer.concat([o, toBuffer(a)]);
    }), o = buffer.Buffer.concat([o, t.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
    const c = sha256$2(o);
    if (isOnCurve(c))
      throw new Error("Invalid seeds, address must fall off the curve");
    return new PublicKey(c);
  }
  static async createProgramAddress(e, t) {
    return this.createProgramAddressSync(e, t);
  }
  static findProgramAddressSync(e, t) {
    let o = 255, c;
    for (; o != 0; ) {
      try {
        const a = e.concat(buffer.Buffer.from([o]));
        c = this.createProgramAddressSync(a, t);
      } catch (a) {
        if (a instanceof TypeError)
          throw a;
        o--;
        continue;
      }
      return [c, o];
    }
    throw new Error("Unable to find a viable program address nonce");
  }
  static async findProgramAddress(e, t) {
    return this.findProgramAddressSync(e, t);
  }
  static isOnCurve(e) {
    const t = new PublicKey(e);
    return isOnCurve(t.toBytes());
  }
}
PublicKey.default = new PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
class Account {
  constructor(e) {
    if (this._publicKey = void 0, this._secretKey = void 0, e) {
      const t = toBuffer(e);
      if (e.length !== 64)
        throw new Error("bad secret key size");
      this._publicKey = t.slice(32, 64), this._secretKey = t.slice(0, 32);
    } else
      this._secretKey = toBuffer(generatePrivateKey()), this._publicKey = toBuffer(getPublicKey(this._secretKey));
  }
  get publicKey() {
    return new PublicKey(this._publicKey);
  }
  get secretKey() {
    return buffer.Buffer.concat([this._secretKey, this._publicKey], 64);
  }
}
const BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111"), PACKET_DATA_SIZE = 1280 - 40 - 8, VERSION_PREFIX_MASK = 127, SIGNATURE_LENGTH_IN_BYTES = 64;
class TransactionExpiredBlockheightExceededError extends Error {
  constructor(e) {
    super(`Signature ${e} has expired: block height exceeded.`), this.signature = void 0, this.signature = e;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
class TransactionExpiredTimeoutError extends Error {
  constructor(e, t) {
    super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`), this.signature = void 0, this.signature = e;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
class TransactionExpiredNonceInvalidError extends Error {
  constructor(e) {
    super(`Signature ${e} has expired: the nonce is no longer valid.`), this.signature = void 0, this.signature = e;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
class MessageAccountKeys {
  constructor(e, t) {
    this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = e, this.accountKeysFromLookups = t;
  }
  keySegments() {
    const e = [this.staticAccountKeys];
    return this.accountKeysFromLookups && (e.push(this.accountKeysFromLookups.writable), e.push(this.accountKeysFromLookups.readonly)), e;
  }
  get(e) {
    for (const t of this.keySegments()) {
      if (e < t.length)
        return t[e];
      e -= t.length;
    }
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(e) {
    if (this.length > 255 + 1)
      throw new Error("Account index overflow encountered during compilation");
    const o = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((a, d) => {
      o.set(a.toBase58(), d);
    });
    const c = (a) => {
      const d = o.get(a.toBase58());
      if (d === void 0)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return d;
    };
    return e.map((a) => ({
      programIdIndex: c(a.programId),
      accountKeyIndexes: a.keys.map((d) => c(d.pubkey)),
      data: a.data
    }));
  }
}
const publicKey = (n = "publicKey") => blob(32, n), signature$1 = (n = "signature") => blob(64, n), rustString = (n = "string") => {
  const e = struct([u32("length"), u32("lengthPadding"), blob(offset(u32(), -8), "chars")], n), t = e.decode.bind(e), o = e.encode.bind(e), c = e;
  return c.decode = (a, d) => t(a, d).chars.toString(), c.encode = (a, d, p) => {
    const w = {
      chars: buffer.Buffer.from(a, "utf8")
    };
    return o(w, d, p);
  }, c.alloc = (a) => u32().span + u32().span + buffer.Buffer.from(a, "utf8").length, c;
}, authorized = (n = "authorized") => struct([publicKey("staker"), publicKey("withdrawer")], n), lockup = (n = "lockup") => struct([ns64("unixTimestamp"), ns64("epoch"), publicKey("custodian")], n), voteInit = (n = "voteInit") => struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), u8("commission")], n), voteAuthorizeWithSeedArgs = (n = "voteAuthorizeWithSeedArgs") => struct([u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], n);
function getAlloc(n, e) {
  const t = (c) => {
    if (c.span >= 0)
      return c.span;
    if (typeof c.alloc == "function")
      return c.alloc(e[c.property]);
    if ("count" in c && "elementLayout" in c) {
      const a = e[c.property];
      if (Array.isArray(a))
        return a.length * t(c.elementLayout);
    } else if ("fields" in c)
      return getAlloc({
        layout: c
      }, e[c.property]);
    return 0;
  };
  let o = 0;
  return n.layout.fields.forEach((c) => {
    o += t(c);
  }), o;
}
function decodeLength(n) {
  let e = 0, t = 0;
  for (; ; ) {
    let o = n.shift();
    if (e |= (o & 127) << t * 7, t += 1, (o & 128) === 0)
      break;
  }
  return e;
}
function encodeLength(n, e) {
  let t = e;
  for (; ; ) {
    let o = t & 127;
    if (t >>= 7, t == 0) {
      n.push(o);
      break;
    } else
      o |= 128, n.push(o);
  }
}
function assert$c(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
class CompiledKeys {
  constructor(e, t) {
    this.payer = void 0, this.keyMetaMap = void 0, this.payer = e, this.keyMetaMap = t;
  }
  static compile(e, t) {
    const o = /* @__PURE__ */ new Map(), c = (d) => {
      const p = d.toBase58();
      let w = o.get(p);
      return w === void 0 && (w = {
        isSigner: !1,
        isWritable: !1,
        isInvoked: !1
      }, o.set(p, w)), w;
    }, a = c(t);
    a.isSigner = !0, a.isWritable = !0;
    for (const d of e) {
      c(d.programId).isInvoked = !0;
      for (const p of d.keys) {
        const w = c(p.pubkey);
        w.isSigner || (w.isSigner = p.isSigner), w.isWritable || (w.isWritable = p.isWritable);
      }
    }
    return new CompiledKeys(t, o);
  }
  getMessageComponents() {
    const e = [...this.keyMetaMap.entries()];
    assert$c(e.length <= 256, "Max static account keys length exceeded");
    const t = e.filter(([, w]) => w.isSigner && w.isWritable), o = e.filter(([, w]) => w.isSigner && !w.isWritable), c = e.filter(([, w]) => !w.isSigner && w.isWritable), a = e.filter(([, w]) => !w.isSigner && !w.isWritable), d = {
      numRequiredSignatures: t.length + o.length,
      numReadonlySignedAccounts: o.length,
      numReadonlyUnsignedAccounts: a.length
    };
    {
      assert$c(t.length > 0, "Expected at least one writable signer key");
      const [w] = t[0];
      assert$c(w === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const p = [...t.map(([w]) => new PublicKey(w)), ...o.map(([w]) => new PublicKey(w)), ...c.map(([w]) => new PublicKey(w)), ...a.map(([w]) => new PublicKey(w))];
    return [d, p];
  }
  extractTableLookup(e) {
    const [t, o] = this.drainKeysFoundInLookupTable(e.state.addresses, (d) => !d.isSigner && !d.isInvoked && d.isWritable), [c, a] = this.drainKeysFoundInLookupTable(e.state.addresses, (d) => !d.isSigner && !d.isInvoked && !d.isWritable);
    if (!(t.length === 0 && c.length === 0))
      return [{
        accountKey: e.key,
        writableIndexes: t,
        readonlyIndexes: c
      }, {
        writable: o,
        readonly: a
      }];
  }
  drainKeysFoundInLookupTable(e, t) {
    const o = new Array(), c = new Array();
    for (const [a, d] of this.keyMetaMap.entries())
      if (t(d)) {
        const p = new PublicKey(a), w = e.findIndex((M) => M.equals(p));
        w >= 0 && (assert$c(w < 256, "Max lookup table index exceeded"), o.push(w), c.push(p), this.keyMetaMap.delete(a));
      }
    return [o, c];
  }
}
class Message {
  constructor(e) {
    this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = /* @__PURE__ */ new Map(), this.header = e.header, this.accountKeys = e.accountKeys.map((t) => new PublicKey(t)), this.recentBlockhash = e.recentBlockhash, this.instructions = e.instructions, this.instructions.forEach((t) => this.indexToProgramIds.set(t.programIdIndex, this.accountKeys[t.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((e) => ({
      programIdIndex: e.programIdIndex,
      accountKeyIndexes: e.accounts,
      data: bs58.decode(e.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(e) {
    const t = CompiledKeys.compile(e.instructions, e.payerKey), [o, c] = t.getMessageComponents(), d = new MessageAccountKeys(c).compileInstructions(e.instructions).map((p) => ({
      programIdIndex: p.programIdIndex,
      accounts: p.accountKeyIndexes,
      data: bs58.encode(p.data)
    }));
    return new Message({
      header: o,
      accountKeys: c,
      recentBlockhash: e.recentBlockhash,
      instructions: d
    });
  }
  isAccountSigner(e) {
    return e < this.header.numRequiredSignatures;
  }
  isAccountWritable(e) {
    const t = this.header.numRequiredSignatures;
    if (e >= this.header.numRequiredSignatures) {
      const o = e - t, a = this.accountKeys.length - t - this.header.numReadonlyUnsignedAccounts;
      return o < a;
    } else {
      const o = t - this.header.numReadonlySignedAccounts;
      return e < o;
    }
  }
  isProgramId(e) {
    return this.indexToProgramIds.has(e);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((e, t) => !this.isProgramId(t));
  }
  serialize() {
    const e = this.accountKeys.length;
    let t = [];
    encodeLength(t, e);
    const o = this.instructions.map((B) => {
      const {
        accounts: H,
        programIdIndex: L
      } = B, W = Array.from(bs58.decode(B.data));
      let $ = [];
      encodeLength($, H.length);
      let P = [];
      return encodeLength(P, W.length), {
        programIdIndex: L,
        keyIndicesCount: buffer.Buffer.from($),
        keyIndices: H,
        dataLength: buffer.Buffer.from(P),
        data: W
      };
    });
    let c = [];
    encodeLength(c, o.length);
    let a = buffer.Buffer.alloc(PACKET_DATA_SIZE);
    buffer.Buffer.from(c).copy(a);
    let d = c.length;
    o.forEach((B) => {
      d += struct([u8("programIdIndex"), blob(B.keyIndicesCount.length, "keyIndicesCount"), seq(u8("keyIndex"), B.keyIndices.length, "keyIndices"), blob(B.dataLength.length, "dataLength"), seq(u8("userdatum"), B.data.length, "data")]).encode(B, a, d);
    }), a = a.slice(0, d);
    const p = struct([blob(1, "numRequiredSignatures"), blob(1, "numReadonlySignedAccounts"), blob(1, "numReadonlyUnsignedAccounts"), blob(t.length, "keyCount"), seq(publicKey("key"), e, "keys"), publicKey("recentBlockhash")]), w = {
      numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: buffer.Buffer.from(t),
      keys: this.accountKeys.map((B) => toBuffer(B.toBytes())),
      recentBlockhash: bs58.decode(this.recentBlockhash)
    };
    let M = buffer.Buffer.alloc(2048);
    const I = p.encode(w, M);
    return a.copy(M, I), M.slice(0, I + a.length);
  }
  static from(e) {
    let t = [...e];
    const o = t.shift();
    if (o !== (o & VERSION_PREFIX_MASK))
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    const c = t.shift(), a = t.shift(), d = decodeLength(t);
    let p = [];
    for (let H = 0; H < d; H++) {
      const L = t.slice(0, PUBLIC_KEY_LENGTH);
      t = t.slice(PUBLIC_KEY_LENGTH), p.push(new PublicKey(buffer.Buffer.from(L)));
    }
    const w = t.slice(0, PUBLIC_KEY_LENGTH);
    t = t.slice(PUBLIC_KEY_LENGTH);
    const M = decodeLength(t);
    let I = [];
    for (let H = 0; H < M; H++) {
      const L = t.shift(), W = decodeLength(t), $ = t.slice(0, W);
      t = t.slice(W);
      const P = decodeLength(t), U = t.slice(0, P), G = bs58.encode(buffer.Buffer.from(U));
      t = t.slice(P), I.push({
        programIdIndex: L,
        accounts: $,
        data: G
      });
    }
    const B = {
      header: {
        numRequiredSignatures: o,
        numReadonlySignedAccounts: c,
        numReadonlyUnsignedAccounts: a
      },
      recentBlockhash: bs58.encode(buffer.Buffer.from(w)),
      accountKeys: p,
      instructions: I
    };
    return new Message(B);
  }
}
class MessageV0 {
  constructor(e) {
    this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = e.header, this.staticAccountKeys = e.staticAccountKeys, this.recentBlockhash = e.recentBlockhash, this.compiledInstructions = e.compiledInstructions, this.addressTableLookups = e.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let e = 0;
    for (const t of this.addressTableLookups)
      e += t.readonlyIndexes.length + t.writableIndexes.length;
    return e;
  }
  getAccountKeys(e) {
    let t;
    if (e && "accountKeysFromLookups" in e && e.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length)
        throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
      t = e.accountKeysFromLookups;
    } else if (e && "addressLookupTableAccounts" in e && e.addressLookupTableAccounts)
      t = this.resolveAddressTableLookups(e.addressLookupTableAccounts);
    else if (this.addressTableLookups.length > 0)
      throw new Error("Failed to get account keys because address table lookups were not resolved");
    return new MessageAccountKeys(this.staticAccountKeys, t);
  }
  isAccountSigner(e) {
    return e < this.header.numRequiredSignatures;
  }
  isAccountWritable(e) {
    const t = this.header.numRequiredSignatures, o = this.staticAccountKeys.length;
    if (e >= o) {
      const c = e - o, a = this.addressTableLookups.reduce((d, p) => d + p.writableIndexes.length, 0);
      return c < a;
    } else if (e >= this.header.numRequiredSignatures) {
      const c = e - t, d = o - t - this.header.numReadonlyUnsignedAccounts;
      return c < d;
    } else {
      const c = t - this.header.numReadonlySignedAccounts;
      return e < c;
    }
  }
  resolveAddressTableLookups(e) {
    const t = {
      writable: [],
      readonly: []
    };
    for (const o of this.addressTableLookups) {
      const c = e.find((a) => a.key.equals(o.accountKey));
      if (!c)
        throw new Error(`Failed to find address lookup table account for table key ${o.accountKey.toBase58()}`);
      for (const a of o.writableIndexes)
        if (a < c.state.addresses.length)
          t.writable.push(c.state.addresses[a]);
        else
          throw new Error(`Failed to find address for index ${a} in address lookup table ${o.accountKey.toBase58()}`);
      for (const a of o.readonlyIndexes)
        if (a < c.state.addresses.length)
          t.readonly.push(c.state.addresses[a]);
        else
          throw new Error(`Failed to find address for index ${a} in address lookup table ${o.accountKey.toBase58()}`);
    }
    return t;
  }
  static compile(e) {
    const t = CompiledKeys.compile(e.instructions, e.payerKey), o = new Array(), c = {
      writable: new Array(),
      readonly: new Array()
    }, a = e.addressLookupTableAccounts || [];
    for (const I of a) {
      const B = t.extractTableLookup(I);
      if (B !== void 0) {
        const [H, {
          writable: L,
          readonly: W
        }] = B;
        o.push(H), c.writable.push(...L), c.readonly.push(...W);
      }
    }
    const [d, p] = t.getMessageComponents(), M = new MessageAccountKeys(p, c).compileInstructions(e.instructions);
    return new MessageV0({
      header: d,
      staticAccountKeys: p,
      recentBlockhash: e.recentBlockhash,
      compiledInstructions: M,
      addressTableLookups: o
    });
  }
  serialize() {
    const e = Array();
    encodeLength(e, this.staticAccountKeys.length);
    const t = this.serializeInstructions(), o = Array();
    encodeLength(o, this.compiledInstructions.length);
    const c = this.serializeAddressTableLookups(), a = Array();
    encodeLength(a, this.addressTableLookups.length);
    const d = struct([u8("prefix"), struct([u8("numRequiredSignatures"), u8("numReadonlySignedAccounts"), u8("numReadonlyUnsignedAccounts")], "header"), blob(e.length, "staticAccountKeysLength"), seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), blob(o.length, "instructionsLength"), blob(t.length, "serializedInstructions"), blob(a.length, "addressTableLookupsLength"), blob(c.length, "serializedAddressTableLookups")]), p = new Uint8Array(PACKET_DATA_SIZE), w = 1 << 7, M = d.encode({
      prefix: w,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(e),
      staticAccountKeys: this.staticAccountKeys.map((I) => I.toBytes()),
      recentBlockhash: bs58.decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(o),
      serializedInstructions: t,
      addressTableLookupsLength: new Uint8Array(a),
      serializedAddressTableLookups: c
    }, p);
    return p.slice(0, M);
  }
  serializeInstructions() {
    let e = 0;
    const t = new Uint8Array(PACKET_DATA_SIZE);
    for (const o of this.compiledInstructions) {
      const c = Array();
      encodeLength(c, o.accountKeyIndexes.length);
      const a = Array();
      encodeLength(a, o.data.length), e += struct([u8("programIdIndex"), blob(c.length, "encodedAccountKeyIndexesLength"), seq(u8(), o.accountKeyIndexes.length, "accountKeyIndexes"), blob(a.length, "encodedDataLength"), blob(o.data.length, "data")]).encode({
        programIdIndex: o.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(c),
        accountKeyIndexes: o.accountKeyIndexes,
        encodedDataLength: new Uint8Array(a),
        data: o.data
      }, t, e);
    }
    return t.slice(0, e);
  }
  serializeAddressTableLookups() {
    let e = 0;
    const t = new Uint8Array(PACKET_DATA_SIZE);
    for (const o of this.addressTableLookups) {
      const c = Array();
      encodeLength(c, o.writableIndexes.length);
      const a = Array();
      encodeLength(a, o.readonlyIndexes.length), e += struct([publicKey("accountKey"), blob(c.length, "encodedWritableIndexesLength"), seq(u8(), o.writableIndexes.length, "writableIndexes"), blob(a.length, "encodedReadonlyIndexesLength"), seq(u8(), o.readonlyIndexes.length, "readonlyIndexes")]).encode({
        accountKey: o.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(c),
        writableIndexes: o.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(a),
        readonlyIndexes: o.readonlyIndexes
      }, t, e);
    }
    return t.slice(0, e);
  }
  static deserialize(e) {
    let t = [...e];
    const o = t.shift(), c = o & VERSION_PREFIX_MASK;
    assert$c(o !== c, "Expected versioned message but received legacy message");
    const a = c;
    assert$c(a === 0, `Expected versioned message with version 0 but found version ${a}`);
    const d = {
      numRequiredSignatures: t.shift(),
      numReadonlySignedAccounts: t.shift(),
      numReadonlyUnsignedAccounts: t.shift()
    }, p = [], w = decodeLength(t);
    for (let W = 0; W < w; W++)
      p.push(new PublicKey(t.splice(0, PUBLIC_KEY_LENGTH)));
    const M = bs58.encode(t.splice(0, PUBLIC_KEY_LENGTH)), I = decodeLength(t), B = [];
    for (let W = 0; W < I; W++) {
      const $ = t.shift(), P = decodeLength(t), U = t.splice(0, P), G = decodeLength(t), D = new Uint8Array(t.splice(0, G));
      B.push({
        programIdIndex: $,
        accountKeyIndexes: U,
        data: D
      });
    }
    const H = decodeLength(t), L = [];
    for (let W = 0; W < H; W++) {
      const $ = new PublicKey(t.splice(0, PUBLIC_KEY_LENGTH)), P = decodeLength(t), U = t.splice(0, P), G = decodeLength(t), D = t.splice(0, G);
      L.push({
        accountKey: $,
        writableIndexes: U,
        readonlyIndexes: D
      });
    }
    return new MessageV0({
      header: d,
      staticAccountKeys: p,
      recentBlockhash: M,
      compiledInstructions: B,
      addressTableLookups: L
    });
  }
}
const VersionedMessage = {
  deserializeMessageVersion(n) {
    const e = n[0], t = e & VERSION_PREFIX_MASK;
    return t === e ? "legacy" : t;
  },
  deserialize: (n) => {
    const e = VersionedMessage.deserializeMessageVersion(n);
    if (e === "legacy")
      return Message.from(n);
    if (e === 0)
      return MessageV0.deserialize(n);
    throw new Error(`Transaction message version ${e} deserialization is not supported`);
  }
};
let TransactionStatus;
(function(n) {
  n[n.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED", n[n.PROCESSED = 1] = "PROCESSED", n[n.TIMED_OUT = 2] = "TIMED_OUT", n[n.NONCE_INVALID = 3] = "NONCE_INVALID";
})(TransactionStatus || (TransactionStatus = {}));
const DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
class TransactionInstruction {
  constructor(e) {
    this.keys = void 0, this.programId = void 0, this.data = buffer.Buffer.alloc(0), this.programId = e.programId, this.keys = e.keys, e.data && (this.data = e.data);
  }
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey: e,
        isSigner: t,
        isWritable: o
      }) => ({
        pubkey: e.toJSON(),
        isSigner: t,
        isWritable: o
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}
class Transaction {
  get signature() {
    return this.signatures.length > 0 ? this.signatures[0].signature : null;
  }
  constructor(e) {
    if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, !!e)
      if (e.feePayer && (this.feePayer = e.feePayer), e.signatures && (this.signatures = e.signatures), Object.prototype.hasOwnProperty.call(e, "nonceInfo")) {
        const {
          minContextSlot: t,
          nonceInfo: o
        } = e;
        this.minNonceContextSlot = t, this.nonceInfo = o;
      } else if (Object.prototype.hasOwnProperty.call(e, "lastValidBlockHeight")) {
        const {
          blockhash: t,
          lastValidBlockHeight: o
        } = e;
        this.recentBlockhash = t, this.lastValidBlockHeight = o;
      } else {
        const {
          recentBlockhash: t,
          nonceInfo: o
        } = e;
        o && (this.nonceInfo = o), this.recentBlockhash = t;
      }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((e) => e.toJSON()),
      signers: this.signatures.map(({
        publicKey: e
      }) => e.toJSON())
    };
  }
  add(...e) {
    if (e.length === 0)
      throw new Error("No instructions");
    return e.forEach((t) => {
      "instructions" in t ? this.instructions = this.instructions.concat(t.instructions) : "data" in t && "programId" in t && "keys" in t ? this.instructions.push(t) : this.instructions.push(new TransactionInstruction(t));
    }), this;
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
      return this._message;
    let e, t;
    if (this.nonceInfo ? (e = this.nonceInfo.nonce, this.instructions[0] != this.nonceInfo.nonceInstruction ? t = [this.nonceInfo.nonceInstruction, ...this.instructions] : t = this.instructions) : (e = this.recentBlockhash, t = this.instructions), !e)
      throw new Error("Transaction recentBlockhash required");
    t.length < 1 && console.warn("No instructions provided");
    let o;
    if (this.feePayer)
      o = this.feePayer;
    else if (this.signatures.length > 0 && this.signatures[0].publicKey)
      o = this.signatures[0].publicKey;
    else
      throw new Error("Transaction fee payer required");
    for (let $ = 0; $ < t.length; $++)
      if (t[$].programId === void 0)
        throw new Error(`Transaction instruction index ${$} has undefined program id`);
    const c = [], a = [];
    t.forEach(($) => {
      $.keys.forEach((U) => {
        a.push({
          ...U
        });
      });
      const P = $.programId.toString();
      c.includes(P) || c.push(P);
    }), c.forEach(($) => {
      a.push({
        pubkey: new PublicKey($),
        isSigner: !1,
        isWritable: !1
      });
    });
    const d = [];
    a.forEach(($) => {
      const P = $.pubkey.toString(), U = d.findIndex((G) => G.pubkey.toString() === P);
      U > -1 ? (d[U].isWritable = d[U].isWritable || $.isWritable, d[U].isSigner = d[U].isSigner || $.isSigner) : d.push($);
    }), d.sort(function($, P) {
      return $.isSigner !== P.isSigner ? $.isSigner ? -1 : 1 : $.isWritable !== P.isWritable ? $.isWritable ? -1 : 1 : $.pubkey.toBase58().localeCompare(P.pubkey.toBase58());
    });
    const p = d.findIndex(($) => $.pubkey.equals(o));
    if (p > -1) {
      const [$] = d.splice(p, 1);
      $.isSigner = !0, $.isWritable = !0, d.unshift($);
    } else
      d.unshift({
        pubkey: o,
        isSigner: !0,
        isWritable: !0
      });
    for (const $ of this.signatures) {
      const P = d.findIndex((U) => U.pubkey.equals($.publicKey));
      if (P > -1)
        d[P].isSigner || (d[P].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
      else
        throw new Error(`unknown signer: ${$.publicKey.toString()}`);
    }
    let w = 0, M = 0, I = 0;
    const B = [], H = [];
    d.forEach(({
      pubkey: $,
      isSigner: P,
      isWritable: U
    }) => {
      P ? (B.push($.toString()), w += 1, U || (M += 1)) : (H.push($.toString()), U || (I += 1));
    });
    const L = B.concat(H), W = t.map(($) => {
      const {
        data: P,
        programId: U
      } = $;
      return {
        programIdIndex: L.indexOf(U.toString()),
        accounts: $.keys.map((G) => L.indexOf(G.pubkey.toString())),
        data: bs58.encode(P)
      };
    });
    return W.forEach(($) => {
      assert$c($.programIdIndex >= 0), $.accounts.forEach((P) => assert$c(P >= 0));
    }), new Message({
      header: {
        numRequiredSignatures: w,
        numReadonlySignedAccounts: M,
        numReadonlyUnsignedAccounts: I
      },
      accountKeys: L,
      recentBlockhash: e,
      instructions: W
    });
  }
  _compile() {
    const e = this.compileMessage(), t = e.accountKeys.slice(0, e.header.numRequiredSignatures);
    return this.signatures.length === t.length && this.signatures.every((c, a) => t[a].equals(c.publicKey)) || (this.signatures = t.map((o) => ({
      signature: null,
      publicKey: o
    }))), e;
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(e) {
    return (await e.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...e) {
    if (e.length === 0)
      throw new Error("No signers");
    const t = /* @__PURE__ */ new Set();
    this.signatures = e.filter((o) => {
      const c = o.toString();
      return t.has(c) ? !1 : (t.add(c), !0);
    }).map((o) => ({
      signature: null,
      publicKey: o
    }));
  }
  sign(...e) {
    if (e.length === 0)
      throw new Error("No signers");
    const t = /* @__PURE__ */ new Set(), o = [];
    for (const a of e) {
      const d = a.publicKey.toString();
      t.has(d) || (t.add(d), o.push(a));
    }
    this.signatures = o.map((a) => ({
      signature: null,
      publicKey: a.publicKey
    }));
    const c = this._compile();
    this._partialSign(c, ...o);
  }
  partialSign(...e) {
    if (e.length === 0)
      throw new Error("No signers");
    const t = /* @__PURE__ */ new Set(), o = [];
    for (const a of e) {
      const d = a.publicKey.toString();
      t.has(d) || (t.add(d), o.push(a));
    }
    const c = this._compile();
    this._partialSign(c, ...o);
  }
  _partialSign(e, ...t) {
    const o = e.serialize();
    t.forEach((c) => {
      const a = sign(o, c.secretKey);
      this._addSignature(c.publicKey, toBuffer(a));
    });
  }
  addSignature(e, t) {
    this._compile(), this._addSignature(e, t);
  }
  _addSignature(e, t) {
    assert$c(t.length === 64);
    const o = this.signatures.findIndex((c) => e.equals(c.publicKey));
    if (o < 0)
      throw new Error(`unknown signer: ${e.toString()}`);
    this.signatures[o].signature = buffer.Buffer.from(t);
  }
  verifySignatures() {
    return this._verifySignatures(this.serializeMessage(), !0);
  }
  _verifySignatures(e, t) {
    for (const {
      signature: o,
      publicKey: c
    } of this.signatures)
      if (o === null) {
        if (t)
          return !1;
      } else if (!verify(o, e, c.toBytes()))
        return !1;
    return !0;
  }
  serialize(e) {
    const {
      requireAllSignatures: t,
      verifySignatures: o
    } = Object.assign({
      requireAllSignatures: !0,
      verifySignatures: !0
    }, e), c = this.serializeMessage();
    if (o && !this._verifySignatures(c, t))
      throw new Error("Signature verification failed");
    return this._serialize(c);
  }
  _serialize(e) {
    const {
      signatures: t
    } = this, o = [];
    encodeLength(o, t.length);
    const c = o.length + t.length * 64 + e.length, a = buffer.Buffer.alloc(c);
    return assert$c(t.length < 256), buffer.Buffer.from(o).copy(a, 0), t.forEach(({
      signature: d
    }, p) => {
      d !== null && (assert$c(d.length === 64, "signature has invalid length"), buffer.Buffer.from(d).copy(a, o.length + p * 64));
    }), e.copy(a, o.length + t.length * 64), assert$c(a.length <= PACKET_DATA_SIZE, `Transaction too large: ${a.length} > ${PACKET_DATA_SIZE}`), a;
  }
  get keys() {
    return assert$c(this.instructions.length === 1), this.instructions[0].keys.map((e) => e.pubkey);
  }
  get programId() {
    return assert$c(this.instructions.length === 1), this.instructions[0].programId;
  }
  get data() {
    return assert$c(this.instructions.length === 1), this.instructions[0].data;
  }
  static from(e) {
    let t = [...e];
    const o = decodeLength(t);
    let c = [];
    for (let a = 0; a < o; a++) {
      const d = t.slice(0, SIGNATURE_LENGTH_IN_BYTES);
      t = t.slice(SIGNATURE_LENGTH_IN_BYTES), c.push(bs58.encode(buffer.Buffer.from(d)));
    }
    return Transaction.populate(Message.from(t), c);
  }
  static populate(e, t = []) {
    const o = new Transaction();
    return o.recentBlockhash = e.recentBlockhash, e.header.numRequiredSignatures > 0 && (o.feePayer = e.accountKeys[0]), t.forEach((c, a) => {
      const d = {
        signature: c == bs58.encode(DEFAULT_SIGNATURE) ? null : bs58.decode(c),
        publicKey: e.accountKeys[a]
      };
      o.signatures.push(d);
    }), e.instructions.forEach((c) => {
      const a = c.accounts.map((d) => {
        const p = e.accountKeys[d];
        return {
          pubkey: p,
          isSigner: o.signatures.some((w) => w.publicKey.toString() === p.toString()) || e.isAccountSigner(d),
          isWritable: e.isAccountWritable(d)
        };
      });
      o.instructions.push(new TransactionInstruction({
        keys: a,
        programId: e.accountKeys[c.programIdIndex],
        data: bs58.decode(c.data)
      }));
    }), o._message = e, o._json = o.toJSON(), o;
  }
}
class TransactionMessage {
  constructor(e) {
    this.payerKey = void 0, this.instructions = void 0, this.recentBlockhash = void 0, this.payerKey = e.payerKey, this.instructions = e.instructions, this.recentBlockhash = e.recentBlockhash;
  }
  static decompile(e, t) {
    const {
      header: o,
      compiledInstructions: c,
      recentBlockhash: a
    } = e, {
      numRequiredSignatures: d,
      numReadonlySignedAccounts: p,
      numReadonlyUnsignedAccounts: w
    } = o, M = d - p;
    assert$c(M > 0, "Message header is invalid");
    const I = e.staticAccountKeys.length - d - w;
    assert$c(I >= 0, "Message header is invalid");
    const B = e.getAccountKeys(t), H = B.get(0);
    if (H === void 0)
      throw new Error("Failed to decompile message because no account keys were found");
    const L = [];
    for (const W of c) {
      const $ = [];
      for (const U of W.accountKeyIndexes) {
        const G = B.get(U);
        if (G === void 0)
          throw new Error(`Failed to find key for account key index ${U}`);
        const D = U < d;
        let Z;
        D ? Z = U < M : U < B.staticAccountKeys.length ? Z = U - d < I : Z = U - B.staticAccountKeys.length < B.accountKeysFromLookups.writable.length, $.push({
          pubkey: G,
          isSigner: U < o.numRequiredSignatures,
          isWritable: Z
        });
      }
      const P = B.get(W.programIdIndex);
      if (P === void 0)
        throw new Error(`Failed to find program id for program id index ${W.programIdIndex}`);
      L.push(new TransactionInstruction({
        programId: P,
        data: toBuffer(W.data),
        keys: $
      }));
    }
    return new TransactionMessage({
      payerKey: H,
      instructions: L,
      recentBlockhash: a
    });
  }
  compileToLegacyMessage() {
    return Message.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions
    });
  }
  compileToV0Message(e) {
    return MessageV0.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
      addressLookupTableAccounts: e
    });
  }
}
class VersionedTransaction {
  get version() {
    return this.message.version;
  }
  constructor(e, t) {
    if (this.signatures = void 0, this.message = void 0, t !== void 0)
      assert$c(t.length === e.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = t;
    else {
      const o = [];
      for (let c = 0; c < e.header.numRequiredSignatures; c++)
        o.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      this.signatures = o;
    }
    this.message = e;
  }
  serialize() {
    const e = this.message.serialize(), t = Array();
    encodeLength(t, this.signatures.length);
    const o = struct([blob(t.length, "encodedSignaturesLength"), seq(signature$1(), this.signatures.length, "signatures"), blob(e.length, "serializedMessage")]), c = new Uint8Array(2048), a = o.encode({
      encodedSignaturesLength: new Uint8Array(t),
      signatures: this.signatures,
      serializedMessage: e
    }, c);
    return c.slice(0, a);
  }
  static deserialize(e) {
    let t = [...e];
    const o = [], c = decodeLength(t);
    for (let d = 0; d < c; d++)
      o.push(new Uint8Array(t.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
    const a = VersionedMessage.deserialize(new Uint8Array(t));
    return new VersionedTransaction(a, o);
  }
  sign(e) {
    const t = this.message.serialize(), o = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const c of e) {
      const a = o.findIndex((d) => d.equals(c.publicKey));
      assert$c(a >= 0, `Cannot sign with non signer key ${c.publicKey.toBase58()}`), this.signatures[a] = sign(t, c.secretKey);
    }
  }
  addSignature(e, t) {
    assert$c(t.byteLength === 64, "Signature must be 64 bytes long");
    const c = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex((a) => a.equals(e));
    assert$c(c >= 0, `Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`), this.signatures[c] = t;
  }
}
const SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111"), SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111"), SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111"), SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111"), SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111"), SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111"), SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111"), SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111"), SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
async function sendAndConfirmTransaction(n, e, t, o) {
  const c = o && {
    skipPreflight: o.skipPreflight,
    preflightCommitment: o.preflightCommitment || o.commitment,
    maxRetries: o.maxRetries,
    minContextSlot: o.minContextSlot
  }, a = await n.sendTransaction(e, t, c);
  let d;
  if (e.recentBlockhash != null && e.lastValidBlockHeight != null)
    d = (await n.confirmTransaction({
      abortSignal: o == null ? void 0 : o.abortSignal,
      signature: a,
      blockhash: e.recentBlockhash,
      lastValidBlockHeight: e.lastValidBlockHeight
    }, o && o.commitment)).value;
  else if (e.minNonceContextSlot != null && e.nonceInfo != null) {
    const {
      nonceInstruction: p
    } = e.nonceInfo, w = p.keys[0].pubkey;
    d = (await n.confirmTransaction({
      abortSignal: o == null ? void 0 : o.abortSignal,
      minContextSlot: e.minNonceContextSlot,
      nonceAccountPubkey: w,
      nonceValue: e.nonceInfo.nonce,
      signature: a
    }, o && o.commitment)).value;
  } else
    (o == null ? void 0 : o.abortSignal) != null && console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."), d = (await n.confirmTransaction(a, o && o.commitment)).value;
  if (d.err)
    throw new Error(`Transaction ${a} failed (${JSON.stringify(d)})`);
  return a;
}
function sleep(n) {
  return new Promise((e) => setTimeout(e, n));
}
function encodeData(n, e) {
  const t = n.layout.span >= 0 ? n.layout.span : getAlloc(n, e), o = buffer.Buffer.alloc(t), c = Object.assign({
    instruction: n.index
  }, e);
  return n.layout.encode(c, o), o;
}
function decodeData$1(n, e) {
  let t;
  try {
    t = n.layout.decode(e);
  } catch (o) {
    throw new Error("invalid instruction; " + o);
  }
  if (t.instruction !== n.index)
    throw new Error(`invalid instruction; instruction index mismatch ${t.instruction} != ${n.index}`);
  return t;
}
const FeeCalculatorLayout = nu64("lamportsPerSignature"), NonceAccountLayout = struct([u32("version"), u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), struct([FeeCalculatorLayout], "feeCalculator")]), NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
class NonceAccount {
  constructor(e) {
    this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = e.authorizedPubkey, this.nonce = e.nonce, this.feeCalculator = e.feeCalculator;
  }
  static fromAccountData(e) {
    const t = NonceAccountLayout.decode(toBuffer(e), 0);
    return new NonceAccount({
      authorizedPubkey: new PublicKey(t.authorizedPubkey),
      nonce: new PublicKey(t.nonce).toString(),
      feeCalculator: t.feeCalculator
    });
  }
}
const encodeDecode = (n) => {
  const e = n.decode.bind(n), t = n.encode.bind(n);
  return {
    decode: e,
    encode: t
  };
}, bigInt = (n) => (e) => {
  const t = blob(n, e), {
    encode: o,
    decode: c
  } = encodeDecode(t), a = t;
  return a.decode = (d, p) => {
    const w = c(d, p);
    return toBigIntLE_1(buffer.Buffer.from(w));
  }, a.encode = (d, p, w) => {
    const M = toBufferLE_1(d, n);
    return o(M, p, w);
  }, a;
}, u64 = bigInt(8);
class SystemInstruction {
  constructor() {
  }
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const o = u32("instruction").decode(e.data);
    let c;
    for (const [a, d] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS))
      if (d.index == o) {
        c = a;
        break;
      }
    if (!c)
      throw new Error("Instruction type incorrect; not a SystemInstruction");
    return c;
  }
  static decodeCreateAccount(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const {
      lamports: t,
      space: o,
      programId: c
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, e.data);
    return {
      fromPubkey: e.keys[0].pubkey,
      newAccountPubkey: e.keys[1].pubkey,
      lamports: t,
      space: o,
      programId: new PublicKey(c)
    };
  }
  static decodeTransfer(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const {
      lamports: t
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, e.data);
    return {
      fromPubkey: e.keys[0].pubkey,
      toPubkey: e.keys[1].pubkey,
      lamports: t
    };
  }
  static decodeTransferWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const {
      lamports: t,
      seed: o,
      programId: c
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, e.data);
    return {
      fromPubkey: e.keys[0].pubkey,
      basePubkey: e.keys[1].pubkey,
      toPubkey: e.keys[2].pubkey,
      lamports: t,
      seed: o,
      programId: new PublicKey(c)
    };
  }
  static decodeAllocate(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const {
      space: t
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, e.data);
    return {
      accountPubkey: e.keys[0].pubkey,
      space: t
    };
  }
  static decodeAllocateWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const {
      base: t,
      seed: o,
      space: c,
      programId: a
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, e.data);
    return {
      accountPubkey: e.keys[0].pubkey,
      basePubkey: new PublicKey(t),
      seed: o,
      space: c,
      programId: new PublicKey(a)
    };
  }
  static decodeAssign(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const {
      programId: t
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, e.data);
    return {
      accountPubkey: e.keys[0].pubkey,
      programId: new PublicKey(t)
    };
  }
  static decodeAssignWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
    const {
      base: t,
      seed: o,
      programId: c
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, e.data);
    return {
      accountPubkey: e.keys[0].pubkey,
      basePubkey: new PublicKey(t),
      seed: o,
      programId: new PublicKey(c)
    };
  }
  static decodeCreateWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const {
      base: t,
      seed: o,
      lamports: c,
      space: a,
      programId: d
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, e.data);
    return {
      fromPubkey: e.keys[0].pubkey,
      newAccountPubkey: e.keys[1].pubkey,
      basePubkey: new PublicKey(t),
      seed: o,
      lamports: c,
      space: a,
      programId: new PublicKey(d)
    };
  }
  static decodeNonceInitialize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const {
      authorized: t
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, e.data);
    return {
      noncePubkey: e.keys[0].pubkey,
      authorizedPubkey: new PublicKey(t)
    };
  }
  static decodeNonceAdvance(e) {
    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, e.data), {
      noncePubkey: e.keys[0].pubkey,
      authorizedPubkey: e.keys[2].pubkey
    };
  }
  static decodeNonceWithdraw(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
    const {
      lamports: t
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, e.data);
    return {
      noncePubkey: e.keys[0].pubkey,
      toPubkey: e.keys[1].pubkey,
      authorizedPubkey: e.keys[4].pubkey,
      lamports: t
    };
  }
  static decodeNonceAuthorize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const {
      authorized: t
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, e.data);
    return {
      noncePubkey: e.keys[0].pubkey,
      authorizedPubkey: e.keys[1].pubkey,
      newAuthorizedPubkey: new PublicKey(t)
    };
  }
  static checkProgramId(e) {
    if (!e.equals(SystemProgram.programId))
      throw new Error("invalid instruction; programId is not SystemProgram");
  }
  static checkKeyLength(e, t) {
    if (e.length < t)
      throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
  }
}
const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: struct([u32("instruction"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: struct([u32("instruction"), u64("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: struct([u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: struct([u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: struct([u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: struct([u32("instruction"), ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: struct([u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: struct([u32("instruction")])
  }
});
class SystemProgram {
  constructor() {
  }
  static createAccount(e) {
    const t = SYSTEM_INSTRUCTION_LAYOUTS.Create, o = encodeData(t, {
      lamports: e.lamports,
      space: e.space,
      programId: toBuffer(e.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: e.fromPubkey,
        isSigner: !0,
        isWritable: !0
      }, {
        pubkey: e.newAccountPubkey,
        isSigner: !0,
        isWritable: !0
      }],
      programId: this.programId,
      data: o
    });
  }
  static transfer(e) {
    let t, o;
    if ("basePubkey" in e) {
      const c = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      t = encodeData(c, {
        lamports: BigInt(e.lamports),
        seed: e.seed,
        programId: toBuffer(e.programId.toBuffer())
      }), o = [{
        pubkey: e.fromPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: e.basePubkey,
        isSigner: !0,
        isWritable: !1
      }, {
        pubkey: e.toPubkey,
        isSigner: !1,
        isWritable: !0
      }];
    } else {
      const c = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      t = encodeData(c, {
        lamports: BigInt(e.lamports)
      }), o = [{
        pubkey: e.fromPubkey,
        isSigner: !0,
        isWritable: !0
      }, {
        pubkey: e.toPubkey,
        isSigner: !1,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: o,
      programId: this.programId,
      data: t
    });
  }
  static assign(e) {
    let t, o;
    if ("basePubkey" in e) {
      const c = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      t = encodeData(c, {
        base: toBuffer(e.basePubkey.toBuffer()),
        seed: e.seed,
        programId: toBuffer(e.programId.toBuffer())
      }), o = [{
        pubkey: e.accountPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: e.basePubkey,
        isSigner: !0,
        isWritable: !1
      }];
    } else {
      const c = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      t = encodeData(c, {
        programId: toBuffer(e.programId.toBuffer())
      }), o = [{
        pubkey: e.accountPubkey,
        isSigner: !0,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: o,
      programId: this.programId,
      data: t
    });
  }
  static createAccountWithSeed(e) {
    const t = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, o = encodeData(t, {
      base: toBuffer(e.basePubkey.toBuffer()),
      seed: e.seed,
      lamports: e.lamports,
      space: e.space,
      programId: toBuffer(e.programId.toBuffer())
    });
    let c = [{
      pubkey: e.fromPubkey,
      isSigner: !0,
      isWritable: !0
    }, {
      pubkey: e.newAccountPubkey,
      isSigner: !1,
      isWritable: !0
    }];
    return e.basePubkey != e.fromPubkey && c.push({
      pubkey: e.basePubkey,
      isSigner: !0,
      isWritable: !1
    }), new TransactionInstruction({
      keys: c,
      programId: this.programId,
      data: o
    });
  }
  static createNonceAccount(e) {
    const t = new Transaction();
    "basePubkey" in e && "seed" in e ? t.add(SystemProgram.createAccountWithSeed({
      fromPubkey: e.fromPubkey,
      newAccountPubkey: e.noncePubkey,
      basePubkey: e.basePubkey,
      seed: e.seed,
      lamports: e.lamports,
      space: NONCE_ACCOUNT_LENGTH,
      programId: this.programId
    })) : t.add(SystemProgram.createAccount({
      fromPubkey: e.fromPubkey,
      newAccountPubkey: e.noncePubkey,
      lamports: e.lamports,
      space: NONCE_ACCOUNT_LENGTH,
      programId: this.programId
    }));
    const o = {
      noncePubkey: e.noncePubkey,
      authorizedPubkey: e.authorizedPubkey
    };
    return t.add(this.nonceInitialize(o)), t;
  }
  static nonceInitialize(e) {
    const t = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, o = encodeData(t, {
      authorized: toBuffer(e.authorizedPubkey.toBuffer())
    }), c = {
      keys: [{
        pubkey: e.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }],
      programId: this.programId,
      data: o
    };
    return new TransactionInstruction(c);
  }
  static nonceAdvance(e) {
    const t = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, o = encodeData(t), c = {
      keys: [{
        pubkey: e.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: e.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: o
    };
    return new TransactionInstruction(c);
  }
  static nonceWithdraw(e) {
    const t = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, o = encodeData(t, {
      lamports: e.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: e.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: e.toPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: e.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: o
    });
  }
  static nonceAuthorize(e) {
    const t = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, o = encodeData(t, {
      authorized: toBuffer(e.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: e.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: e.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: o
    });
  }
  static allocate(e) {
    let t, o;
    if ("basePubkey" in e) {
      const c = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      t = encodeData(c, {
        base: toBuffer(e.basePubkey.toBuffer()),
        seed: e.seed,
        space: e.space,
        programId: toBuffer(e.programId.toBuffer())
      }), o = [{
        pubkey: e.accountPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: e.basePubkey,
        isSigner: !0,
        isWritable: !1
      }];
    } else {
      const c = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      t = encodeData(c, {
        space: e.space
      }), o = [{
        pubkey: e.accountPubkey,
        isSigner: !0,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: o,
      programId: this.programId,
      data: t
    });
  }
}
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
const CHUNK_SIZE = PACKET_DATA_SIZE - 300;
class Loader {
  constructor() {
  }
  static getMinNumSignatures(e) {
    return 2 * (Math.ceil(e / Loader.chunkSize) + 1 + 1);
  }
  static async load(e, t, o, c, a) {
    {
      const B = await e.getMinimumBalanceForRentExemption(a.length), H = await e.getAccountInfo(o.publicKey, "confirmed");
      let L = null;
      if (H !== null) {
        if (H.executable)
          return console.error("Program load failed, account is already executable"), !1;
        H.data.length !== a.length && (L = L || new Transaction(), L.add(SystemProgram.allocate({
          accountPubkey: o.publicKey,
          space: a.length
        }))), H.owner.equals(c) || (L = L || new Transaction(), L.add(SystemProgram.assign({
          accountPubkey: o.publicKey,
          programId: c
        }))), H.lamports < B && (L = L || new Transaction(), L.add(SystemProgram.transfer({
          fromPubkey: t.publicKey,
          toPubkey: o.publicKey,
          lamports: B - H.lamports
        })));
      } else
        L = new Transaction().add(SystemProgram.createAccount({
          fromPubkey: t.publicKey,
          newAccountPubkey: o.publicKey,
          lamports: B > 0 ? B : 1,
          space: a.length,
          programId: c
        }));
      L !== null && await sendAndConfirmTransaction(e, L, [t, o], {
        commitment: "confirmed"
      });
    }
    const d = struct([u32("instruction"), u32("offset"), u32("bytesLength"), u32("bytesLengthPadding"), seq(u8("byte"), offset(u32(), -8), "bytes")]), p = Loader.chunkSize;
    let w = 0, M = a, I = [];
    for (; M.length > 0; ) {
      const B = M.slice(0, p), H = buffer.Buffer.alloc(p + 16);
      d.encode({
        instruction: 0,
        offset: w,
        bytes: B,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, H);
      const L = new Transaction().add({
        keys: [{
          pubkey: o.publicKey,
          isSigner: !0,
          isWritable: !0
        }],
        programId: c,
        data: H
      });
      I.push(sendAndConfirmTransaction(e, L, [t, o], {
        commitment: "confirmed"
      })), e._rpcEndpoint.includes("solana.com") && await sleep(1e3 / 4), w += p, M = M.slice(p);
    }
    await Promise.all(I);
    {
      const B = struct([u32("instruction")]), H = buffer.Buffer.alloc(B.span);
      B.encode({
        instruction: 1
      }, H);
      const L = new Transaction().add({
        keys: [{
          pubkey: o.publicKey,
          isSigner: !0,
          isWritable: !0
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: !1,
          isWritable: !1
        }],
        programId: c,
        data: H
      });
      await sendAndConfirmTransaction(e, L, [t, o], {
        commitment: "confirmed"
      });
    }
    return !0;
  }
}
Loader.chunkSize = CHUNK_SIZE;
const BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
class BpfLoader {
  static getMinNumSignatures(e) {
    return Loader.getMinNumSignatures(e);
  }
  static load(e, t, o, c, a) {
    return Loader.load(e, t, o, a, c);
  }
}
var objToString = Object.prototype.toString, objKeys = Object.keys || function(n) {
  var e = [];
  for (var t in n)
    e.push(t);
  return e;
};
function stringify(n, e) {
  var t, o, c, a, d, p, w;
  if (n === !0)
    return "true";
  if (n === !1)
    return "false";
  switch (typeof n) {
    case "object":
      if (n === null)
        return null;
      if (n.toJSON && typeof n.toJSON == "function")
        return stringify(n.toJSON(), e);
      if (w = objToString.call(n), w === "[object Array]") {
        for (c = "[", o = n.length - 1, t = 0; t < o; t++)
          c += stringify(n[t], !0) + ",";
        return o > -1 && (c += stringify(n[t], !0)), c + "]";
      } else if (w === "[object Object]") {
        for (a = objKeys(n).sort(), o = a.length, c = "", t = 0; t < o; )
          d = a[t], p = stringify(n[d], !1), p !== void 0 && (c && (c += ","), c += JSON.stringify(d) + ":" + p), t++;
        return "{" + c + "}";
      } else
        return JSON.stringify(n);
    case "function":
    case "undefined":
      return e ? null : void 0;
    case "string":
      return JSON.stringify(n);
    default:
      return isFinite(n) ? n : null;
  }
}
var fastStableStringify = function(n) {
  var e = stringify(n, !1);
  if (e !== void 0)
    return "" + e;
}, fastStableStringify$1 = fastStableStringify;
const MINIMUM_SLOT_PER_EPOCH = 32;
function trailingZeros(n) {
  let e = 0;
  for (; n > 1; )
    n /= 2, e++;
  return e;
}
function nextPowerOfTwo(n) {
  return n === 0 ? 1 : (n--, n |= n >> 1, n |= n >> 2, n |= n >> 4, n |= n >> 8, n |= n >> 16, n |= n >> 32, n + 1);
}
class EpochSchedule {
  constructor(e, t, o, c, a) {
    this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = e, this.leaderScheduleSlotOffset = t, this.warmup = o, this.firstNormalEpoch = c, this.firstNormalSlot = a;
  }
  getEpoch(e) {
    return this.getEpochAndSlotIndex(e)[0];
  }
  getEpochAndSlotIndex(e) {
    if (e < this.firstNormalSlot) {
      const t = trailingZeros(nextPowerOfTwo(e + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1, o = this.getSlotsInEpoch(t), c = e - (o - MINIMUM_SLOT_PER_EPOCH);
      return [t, c];
    } else {
      const t = e - this.firstNormalSlot, o = Math.floor(t / this.slotsPerEpoch), c = this.firstNormalEpoch + o, a = t % this.slotsPerEpoch;
      return [c, a];
    }
  }
  getFirstSlotInEpoch(e) {
    return e <= this.firstNormalEpoch ? (Math.pow(2, e) - 1) * MINIMUM_SLOT_PER_EPOCH : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
  }
  getLastSlotInEpoch(e) {
    return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1;
  }
  getSlotsInEpoch(e) {
    return e < this.firstNormalEpoch ? Math.pow(2, e + trailingZeros(MINIMUM_SLOT_PER_EPOCH)) : this.slotsPerEpoch;
  }
}
class SendTransactionError extends Error {
  constructor(e, t) {
    super(e), this.logs = void 0, this.logs = t;
  }
}
const SolanaJSONRPCErrorCode = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
class SolanaJSONRPCError extends Error {
  constructor({
    code: e,
    message: t,
    data: o
  }, c) {
    super(c != null ? `${c}: ${t}` : t), this.code = void 0, this.data = void 0, this.code = e, this.data = o, this.name = "SolanaJSONRPCError";
  }
}
var fetchImpl = globalThis.fetch;
const NUM_TICKS_PER_SECOND = 160, DEFAULT_TICKS_PER_SLOT = 64, NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT, MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
function decodeData(n, e) {
  let t;
  try {
    t = n.layout.decode(e);
  } catch (o) {
    throw new Error("invalid instruction; " + o);
  }
  if (t.typeIndex !== n.index)
    throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${n.index}`);
  return t;
}
const LOOKUP_TABLE_META_SIZE = 56;
class AddressLookupTableAccount {
  constructor(e) {
    this.key = void 0, this.state = void 0, this.key = e.key, this.state = e.state;
  }
  isActive() {
    const e = BigInt("0xffffffffffffffff");
    return this.state.deactivationSlot === e;
  }
  static deserialize(e) {
    const t = decodeData(LookupTableMetaLayout, e), o = e.length - LOOKUP_TABLE_META_SIZE;
    assert$c(o >= 0, "lookup table is invalid"), assert$c(o % 32 === 0, "lookup table is invalid");
    const c = o / 32, {
      addresses: a
    } = struct([seq(publicKey(), c, "addresses")]).decode(e.slice(LOOKUP_TABLE_META_SIZE));
    return {
      deactivationSlot: t.deactivationSlot,
      lastExtendedSlot: t.lastExtendedSlot,
      lastExtendedSlotStartIndex: t.lastExtendedStartIndex,
      authority: t.authority.length !== 0 ? new PublicKey(t.authority[0]) : void 0,
      addresses: a.map((d) => new PublicKey(d))
    };
  }
}
const LookupTableMetaLayout = {
  index: 1,
  layout: struct([
    u32("typeIndex"),
    u64("deactivationSlot"),
    nu64("lastExtendedSlot"),
    u8("lastExtendedStartIndex"),
    u8(),
    seq(publicKey(), offset(u8(), -1), "authority")
  ])
}, URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(n) {
  const e = n.match(URL_RE);
  if (e == null)
    throw TypeError(`Failed to validate endpoint URL \`${n}\``);
  const [
    t,
    o,
    c,
    a
  ] = e, d = n.startsWith("https:") ? "wss:" : "ws:", p = c == null ? null : parseInt(c.slice(1), 10), w = p == null ? "" : `:${p + 1}`;
  return `${d}//${o}${w}${a}`;
}
var _process$env$npm_pack;
const PublicKeyFromString = coerce(instance(PublicKey), string(), (n) => new PublicKey(n)), RawAccountDataResult = tuple([string(), literal("base64")]), BufferFromRawAccountData = coerce(instance(buffer.Buffer), RawAccountDataResult, (n) => buffer.Buffer.from(n[0], "base64")), BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
function assertEndpointUrl(n) {
  if (/^https?:/.test(n) === !1)
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  return n;
}
function extractCommitmentFromConfig(n) {
  let e, t;
  if (typeof n == "string")
    e = n;
  else if (n) {
    const {
      commitment: o,
      ...c
    } = n;
    e = o, t = c;
  }
  return {
    commitment: e,
    config: t
  };
}
function createRpcResult(n) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result: n
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
const UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(n) {
  return coerce(createRpcResult(n), UnknownRpcResult, (e) => "error" in e ? e : {
    ...e,
    result: create(e.result, n)
  });
}
function jsonRpcResultAndContext(n) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value: n
  }));
}
function notificationResultAndContext(n) {
  return type({
    context: type({
      slot: number()
    }),
    value: n
  });
}
function versionedMessageFromResponse(n, e) {
  return n === 0 ? new MessageV0({
    header: e.header,
    staticAccountKeys: e.accountKeys.map((t) => new PublicKey(t)),
    recentBlockhash: e.recentBlockhash,
    compiledInstructions: e.instructions.map((t) => ({
      programIdIndex: t.programIdIndex,
      accountKeyIndexes: t.accounts,
      data: bs58.decode(t.data)
    })),
    addressTableLookups: e.addressTableLookups
  }) : new Message(e);
}
const GetInflationGovernorResult = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
}), GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number()
})))), GetEpochInfoResult = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
}), GetEpochScheduleResult = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
}), GetLeaderScheduleResult = record(string(), array(number())), TransactionErrorResult = nullable(union([type({}), string()])), SignatureStatusResult = type({
  err: TransactionErrorResult
}), SignatureReceivedResult = literal("receivedSignature"), VersionResult = type({
  "solana-core": string(),
  "feature-set": optional(number())
}), SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  })))
})), BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));
function createRpcClient(n, e, t, o, c, a) {
  const d = t || fetchImpl;
  a != null && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
  let p;
  return o && (p = async (M, I) => {
    const B = await new Promise((H, L) => {
      try {
        o(M, I, (W, $) => H([W, $]));
      } catch (W) {
        L(W);
      }
    });
    return await d(...B);
  }), new browser(async (M, I) => {
    const H = {
      method: "POST",
      body: M,
      agent: void 0,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, e || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let L = 5, W, $ = 500;
      for (; p ? W = await p(n, H) : W = await d(n, H), !(W.status !== 429 || c === !0 || (L -= 1, L === 0)); )
        console.log(`Server responded with ${W.status} ${W.statusText}.  Retrying after ${$}ms delay...`), await sleep($), $ *= 2;
      const P = await W.text();
      W.ok ? I(null, P) : I(new Error(`${W.status} ${W.statusText}: ${P}`));
    } catch (L) {
      L instanceof Error && I(L);
    } finally {
    }
  }, {});
}
function createRpcRequest(n) {
  return (e, t) => new Promise((o, c) => {
    n.request(e, t, (a, d) => {
      if (a) {
        c(a);
        return;
      }
      o(d);
    });
  });
}
function createRpcBatchRequest(n) {
  return (e) => new Promise((t, o) => {
    e.length === 0 && t([]);
    const c = e.map((a) => n.request(a.methodName, a.args));
    n.request(c, (a, d) => {
      if (a) {
        o(a);
        return;
      }
      t(d);
    });
  });
}
const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult), GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult), GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult), GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult), SlotRpcResult = jsonRpcResult(number()), GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString)
})), TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
}), GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
}))), GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  })
}))), ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number()
}), GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedAccountDataResult,
    rentEpoch: number()
  })
}))), GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number(),
  address: PublicKeyFromString
}))), AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: BufferFromRawAccountData,
  rentEpoch: number()
}), KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
}), ParsedOrRawAccountData = coerce(union([instance(buffer.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (n) => Array.isArray(n) ? create(n, BufferFromRawAccountData) : n), ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: ParsedOrRawAccountData,
  rentEpoch: number()
}), KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
}), StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
}), GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
}))), GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
}))), AccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(AccountInfoResult)
}), ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
}), ProgramAccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
}), SlotInfoResult = type({
  parent: number(),
  slot: number(),
  root: number()
}), SlotNotificationResult = type({
  subscription: number(),
  result: SlotInfoResult
}), SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]), SlotUpdateNotificationResult = type({
  subscription: number(),
  result: SlotUpdateResult
}), SignatureNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
}), RootNotificationResult = type({
  subscription: number(),
  result: number()
}), ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
}), VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
}), GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
})), ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]), SignatureStatusResponse = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
}), GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse))), GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number()), AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
}), ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
}), AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
}), ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
}), ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
}), RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
}), InstructionResult = union([RawInstructionResult, ParsedInstructionResult]), UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]), ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (n) => "accounts" in n ? create(n, RawInstructionResult) : create(n, ParsedInstructionResult)), ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
}), TokenBalanceResult = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  uiTokenAmount: TokenAmountResult
}), LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
}), ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
}), ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
}), TransactionVersionStruct = union([literal(0), literal("legacy")]), RewardsResult = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string())
}), GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number())
}))), GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
}))), GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  meta: ConfirmedTransactionMetaResult,
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
}))), GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct)
}))), GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})), GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number()
})), PerfSampleResult = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
}), GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult)), GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
}))), RequestAirdropRpcResult = jsonRpcResult(string()), SendTransactionRpcResult = jsonRpcResult(string()), LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
}), LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number()
}), COMMON_HTTP_HEADERS = {
  "solana-client": `js/${(_process$env$npm_pack = "0.0.0-development") !== null && _process$env$npm_pack !== void 0 ? _process$env$npm_pack : "UNKNOWN"}`
};
class Connection {
  constructor(e, t) {
    this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionHashByClientSubscriptionId = {}, this._subscriptionStateChangeCallbacksByHash = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
    let o, c, a, d, p, w;
    t && typeof t == "string" ? this._commitment = t : t && (this._commitment = t.commitment, this._confirmTransactionInitialTimeout = t.confirmTransactionInitialTimeout, o = t.wsEndpoint, c = t.httpHeaders, a = t.fetch, d = t.fetchMiddleware, p = t.disableRetryOnRateLimit, w = t.httpAgent), this._rpcEndpoint = assertEndpointUrl(e), this._rpcWsEndpoint = o || makeWebsocketUrl(e), this._rpcClient = createRpcClient(e, c, a, d, p, w), this._rpcRequest = createRpcRequest(this._rpcClient), this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient), this._rpcWebSocket = new Client_1(this._rpcWsEndpoint, {
      autoconnect: !1,
      max_reconnects: 1 / 0
    }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
  }
  get commitment() {
    return this._commitment;
  }
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  async getBalanceAndContext(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = this._buildArgs(
      [e.toBase58()],
      o,
      void 0,
      c
    ), d = await this._rpcRequest("getBalance", a), p = create(d, jsonRpcResultAndContext(number()));
    if ("error" in p)
      throw new SolanaJSONRPCError(p.error, `failed to get balance for ${e.toBase58()}`);
    return p.result;
  }
  async getBalance(e, t) {
    return await this.getBalanceAndContext(e, t).then((o) => o.value).catch((o) => {
      throw new Error("failed to get balance of account " + e.toBase58() + ": " + o);
    });
  }
  async getBlockTime(e) {
    const t = await this._rpcRequest("getBlockTime", [e]), o = create(t, jsonRpcResult(nullable(number())));
    if ("error" in o)
      throw new SolanaJSONRPCError(o.error, `failed to get block time for slot ${e}`);
    return o.result;
  }
  async getMinimumLedgerSlot() {
    const e = await this._rpcRequest("minimumLedgerSlot", []), t = create(e, jsonRpcResult(number()));
    if ("error" in t)
      throw new SolanaJSONRPCError(t.error, "failed to get minimum ledger slot");
    return t.result;
  }
  async getFirstAvailableBlock() {
    const e = await this._rpcRequest("getFirstAvailableBlock", []), t = create(e, SlotRpcResult);
    if ("error" in t)
      throw new SolanaJSONRPCError(t.error, "failed to get first available block");
    return t.result;
  }
  async getSupply(e) {
    let t = {};
    typeof e == "string" ? t = {
      commitment: e
    } : e ? t = {
      ...e,
      commitment: e && e.commitment || this.commitment
    } : t = {
      commitment: this.commitment
    };
    const o = await this._rpcRequest("getSupply", [t]), c = create(o, GetSupplyRpcResult);
    if ("error" in c)
      throw new SolanaJSONRPCError(c.error, "failed to get supply");
    return c.result;
  }
  async getTokenSupply(e, t) {
    const o = this._buildArgs([e.toBase58()], t), c = await this._rpcRequest("getTokenSupply", o), a = create(c, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get token supply");
    return a.result;
  }
  async getTokenAccountBalance(e, t) {
    const o = this._buildArgs([e.toBase58()], t), c = await this._rpcRequest("getTokenAccountBalance", o), a = create(c, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get token account balance");
    return a.result;
  }
  async getTokenAccountsByOwner(e, t, o) {
    const {
      commitment: c,
      config: a
    } = extractCommitmentFromConfig(o);
    let d = [e.toBase58()];
    "mint" in t ? d.push({
      mint: t.mint.toBase58()
    }) : d.push({
      programId: t.programId.toBase58()
    });
    const p = this._buildArgs(d, c, "base64", a), w = await this._rpcRequest("getTokenAccountsByOwner", p), M = create(w, GetTokenAccountsByOwner);
    if ("error" in M)
      throw new SolanaJSONRPCError(M.error, `failed to get token accounts owned by account ${e.toBase58()}`);
    return M.result;
  }
  async getParsedTokenAccountsByOwner(e, t, o) {
    let c = [e.toBase58()];
    "mint" in t ? c.push({
      mint: t.mint.toBase58()
    }) : c.push({
      programId: t.programId.toBase58()
    });
    const a = this._buildArgs(c, o, "jsonParsed"), d = await this._rpcRequest("getTokenAccountsByOwner", a), p = create(d, GetParsedTokenAccountsByOwner);
    if ("error" in p)
      throw new SolanaJSONRPCError(p.error, `failed to get token accounts owned by account ${e.toBase58()}`);
    return p.result;
  }
  async getLargestAccounts(e) {
    const t = {
      ...e,
      commitment: e && e.commitment || this.commitment
    }, o = t.filter || t.commitment ? [t] : [], c = await this._rpcRequest("getLargestAccounts", o), a = create(c, GetLargestAccountsRpcResult);
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get largest accounts");
    return a.result;
  }
  async getTokenLargestAccounts(e, t) {
    const o = this._buildArgs([e.toBase58()], t), c = await this._rpcRequest("getTokenLargestAccounts", o), a = create(c, GetTokenLargestAccountsResult);
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get token largest accounts");
    return a.result;
  }
  async getAccountInfoAndContext(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = this._buildArgs([e.toBase58()], o, "base64", c), d = await this._rpcRequest("getAccountInfo", a), p = create(d, jsonRpcResultAndContext(nullable(AccountInfoResult)));
    if ("error" in p)
      throw new SolanaJSONRPCError(p.error, `failed to get info about account ${e.toBase58()}`);
    return p.result;
  }
  async getParsedAccountInfo(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = this._buildArgs([e.toBase58()], o, "jsonParsed", c), d = await this._rpcRequest("getAccountInfo", a), p = create(d, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
    if ("error" in p)
      throw new SolanaJSONRPCError(p.error, `failed to get info about account ${e.toBase58()}`);
    return p.result;
  }
  async getAccountInfo(e, t) {
    try {
      return (await this.getAccountInfoAndContext(e, t)).value;
    } catch (o) {
      throw new Error("failed to get info about account " + e.toBase58() + ": " + o);
    }
  }
  async getMultipleParsedAccounts(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = e.map((M) => M.toBase58()), d = this._buildArgs([a], o, "jsonParsed", c), p = await this._rpcRequest("getMultipleAccounts", d), w = create(p, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
    if ("error" in w)
      throw new SolanaJSONRPCError(w.error, `failed to get info for accounts ${a}`);
    return w.result;
  }
  async getMultipleAccountsInfoAndContext(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = e.map((M) => M.toBase58()), d = this._buildArgs([a], o, "base64", c), p = await this._rpcRequest("getMultipleAccounts", d), w = create(p, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
    if ("error" in w)
      throw new SolanaJSONRPCError(w.error, `failed to get info for accounts ${a}`);
    return w.result;
  }
  async getMultipleAccountsInfo(e, t) {
    return (await this.getMultipleAccountsInfoAndContext(e, t)).value;
  }
  async getStakeActivation(e, t, o) {
    const {
      commitment: c,
      config: a
    } = extractCommitmentFromConfig(t), d = this._buildArgs(
      [e.toBase58()],
      c,
      void 0,
      {
        ...a,
        epoch: o != null ? o : a == null ? void 0 : a.epoch
      }
    ), p = await this._rpcRequest("getStakeActivation", d), w = create(p, jsonRpcResult(StakeActivationResult));
    if ("error" in w)
      throw new SolanaJSONRPCError(w.error, `failed to get Stake Activation ${e.toBase58()}`);
    return w.result;
  }
  async getProgramAccounts(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), {
      encoding: a,
      ...d
    } = c || {}, p = this._buildArgs([e.toBase58()], o, a || "base64", d), w = await this._rpcRequest("getProgramAccounts", p), M = create(w, jsonRpcResult(array(KeyedAccountInfoResult)));
    if ("error" in M)
      throw new SolanaJSONRPCError(M.error, `failed to get accounts owned by program ${e.toBase58()}`);
    return M.result;
  }
  async getParsedProgramAccounts(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = this._buildArgs([e.toBase58()], o, "jsonParsed", c), d = await this._rpcRequest("getProgramAccounts", a), p = create(d, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
    if ("error" in p)
      throw new SolanaJSONRPCError(p.error, `failed to get accounts owned by program ${e.toBase58()}`);
    return p.result;
  }
  async confirmTransaction(e, t) {
    let o;
    if (typeof e == "string")
      o = e;
    else {
      var c;
      const d = e;
      if ((c = d.abortSignal) !== null && c !== void 0 && c.aborted)
        return Promise.reject(d.abortSignal.reason);
      o = d.signature;
    }
    let a;
    try {
      a = bs58.decode(o);
    } catch {
      throw new Error("signature must be base58 encoded: " + o);
    }
    return assert$c(a.length === 64, "signature has invalid length"), typeof e == "string" ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
      commitment: t || this.commitment,
      signature: o
    }) : "lastValidBlockHeight" in e ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
      commitment: t || this.commitment,
      strategy: e
    }) : await this.confirmTransactionUsingDurableNonceStrategy({
      commitment: t || this.commitment,
      strategy: e
    });
  }
  getCancellationPromise(e) {
    return new Promise((t, o) => {
      e != null && (e.aborted ? o(e.reason) : e.addEventListener("abort", () => {
        o(e.reason);
      }));
    });
  }
  getTransactionConfirmationPromise({
    commitment: e,
    signature: t
  }) {
    let o, c, a = !1;
    const d = new Promise((w, M) => {
      try {
        o = this.onSignature(t, (B, H) => {
          o = void 0;
          const L = {
            context: H,
            value: B
          };
          w({
            __type: TransactionStatus.PROCESSED,
            response: L
          });
        }, e);
        const I = new Promise((B) => {
          o == null ? B() : c = this._onSubscriptionStateChange(o, (H) => {
            H === "subscribed" && B();
          });
        });
        (async () => {
          if (await I, a)
            return;
          const B = await this.getSignatureStatus(t);
          if (a || B == null)
            return;
          const {
            context: H,
            value: L
          } = B;
          if (L != null)
            if (L != null && L.err)
              M(L.err);
            else {
              switch (e) {
                case "confirmed":
                case "single":
                case "singleGossip": {
                  if (L.confirmationStatus === "processed")
                    return;
                  break;
                }
                case "finalized":
                case "max":
                case "root": {
                  if (L.confirmationStatus === "processed" || L.confirmationStatus === "confirmed")
                    return;
                  break;
                }
                case "processed":
                case "recent":
              }
              a = !0, w({
                __type: TransactionStatus.PROCESSED,
                response: {
                  context: H,
                  value: L
                }
              });
            }
        })();
      } catch (I) {
        M(I);
      }
    });
    return {
      abortConfirmation: () => {
        c && (c(), c = void 0), o != null && (this.removeSignatureListener(o), o = void 0);
      },
      confirmationPromise: d
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment: e,
    strategy: {
      abortSignal: t,
      lastValidBlockHeight: o,
      signature: c
    }
  }) {
    let a = !1;
    const d = new Promise((B) => {
      const H = async () => {
        try {
          return await this.getBlockHeight(e);
        } catch {
          return -1;
        }
      };
      (async () => {
        let L = await H();
        if (!a) {
          for (; L <= o; )
            if (await sleep(1e3), a || (L = await H(), a))
              return;
          B({
            __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
          });
        }
      })();
    }), {
      abortConfirmation: p,
      confirmationPromise: w
    } = this.getTransactionConfirmationPromise({
      commitment: e,
      signature: c
    }), M = this.getCancellationPromise(t);
    let I;
    try {
      const B = await Promise.race([M, w, d]);
      if (B.__type === TransactionStatus.PROCESSED)
        I = B.response;
      else
        throw new TransactionExpiredBlockheightExceededError(c);
    } finally {
      a = !0, p();
    }
    return I;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment: e,
    strategy: {
      abortSignal: t,
      minContextSlot: o,
      nonceAccountPubkey: c,
      nonceValue: a,
      signature: d
    }
  }) {
    let p = !1;
    const w = new Promise(($) => {
      let P = a, U = null;
      const G = async () => {
        try {
          const {
            context: D,
            value: Z
          } = await this.getNonceAndContext(c, {
            commitment: e,
            minContextSlot: o
          });
          return U = D.slot, Z == null ? void 0 : Z.nonce;
        } catch {
          return P;
        }
      };
      (async () => {
        if (P = await G(), !p)
          for (; ; ) {
            if (a !== P) {
              $({
                __type: TransactionStatus.NONCE_INVALID,
                slotInWhichNonceDidAdvance: U
              });
              return;
            }
            if (await sleep(2e3), p || (P = await G(), p))
              return;
          }
      })();
    }), {
      abortConfirmation: M,
      confirmationPromise: I
    } = this.getTransactionConfirmationPromise({
      commitment: e,
      signature: d
    }), B = this.getCancellationPromise(t);
    let H;
    try {
      const $ = await Promise.race([B, I, w]);
      if ($.__type === TransactionStatus.PROCESSED)
        H = $.response;
      else {
        var L;
        let P;
        for (; ; ) {
          var W;
          const U = await this.getSignatureStatus(d);
          if (U == null)
            break;
          if (U.context.slot < ((W = $.slotInWhichNonceDidAdvance) !== null && W !== void 0 ? W : o)) {
            await sleep(400);
            continue;
          }
          P = U;
          break;
        }
        if ((L = P) !== null && L !== void 0 && L.value) {
          const U = e || "finalized", {
            confirmationStatus: G
          } = P.value;
          switch (U) {
            case "processed":
            case "recent":
              if (G !== "processed" && G !== "confirmed" && G !== "finalized")
                throw new TransactionExpiredNonceInvalidError(d);
              break;
            case "confirmed":
            case "single":
            case "singleGossip":
              if (G !== "confirmed" && G !== "finalized")
                throw new TransactionExpiredNonceInvalidError(d);
              break;
            case "finalized":
            case "max":
            case "root":
              if (G !== "finalized")
                throw new TransactionExpiredNonceInvalidError(d);
              break;
            default:
              ((D) => {
              })(U);
          }
          H = {
            context: P.context,
            value: {
              err: P.value.err
            }
          };
        } else
          throw new TransactionExpiredNonceInvalidError(d);
      }
    } finally {
      p = !0, M();
    }
    return H;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment: e,
    signature: t
  }) {
    let o;
    const c = new Promise((w) => {
      let M = this._confirmTransactionInitialTimeout || 6e4;
      switch (e) {
        case "processed":
        case "recent":
        case "single":
        case "confirmed":
        case "singleGossip": {
          M = this._confirmTransactionInitialTimeout || 3e4;
          break;
        }
      }
      o = setTimeout(() => w({
        __type: TransactionStatus.TIMED_OUT,
        timeoutMs: M
      }), M);
    }), {
      abortConfirmation: a,
      confirmationPromise: d
    } = this.getTransactionConfirmationPromise({
      commitment: e,
      signature: t
    });
    let p;
    try {
      const w = await Promise.race([d, c]);
      if (w.__type === TransactionStatus.PROCESSED)
        p = w.response;
      else
        throw new TransactionExpiredTimeoutError(t, w.timeoutMs / 1e3);
    } finally {
      clearTimeout(o), a();
    }
    return p;
  }
  async getClusterNodes() {
    const e = await this._rpcRequest("getClusterNodes", []), t = create(e, jsonRpcResult(array(ContactInfoResult)));
    if ("error" in t)
      throw new SolanaJSONRPCError(t.error, "failed to get cluster nodes");
    return t.result;
  }
  async getVoteAccounts(e) {
    const t = this._buildArgs([], e), o = await this._rpcRequest("getVoteAccounts", t), c = create(o, GetVoteAccounts);
    if ("error" in c)
      throw new SolanaJSONRPCError(c.error, "failed to get vote accounts");
    return c.result;
  }
  async getSlot(e) {
    const {
      commitment: t,
      config: o
    } = extractCommitmentFromConfig(e), c = this._buildArgs(
      [],
      t,
      void 0,
      o
    ), a = await this._rpcRequest("getSlot", c), d = create(a, jsonRpcResult(number()));
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get slot");
    return d.result;
  }
  async getSlotLeader(e) {
    const {
      commitment: t,
      config: o
    } = extractCommitmentFromConfig(e), c = this._buildArgs(
      [],
      t,
      void 0,
      o
    ), a = await this._rpcRequest("getSlotLeader", c), d = create(a, jsonRpcResult(string()));
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get slot leader");
    return d.result;
  }
  async getSlotLeaders(e, t) {
    const o = [e, t], c = await this._rpcRequest("getSlotLeaders", o), a = create(c, jsonRpcResult(array(PublicKeyFromString)));
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get slot leaders");
    return a.result;
  }
  async getSignatureStatus(e, t) {
    const {
      context: o,
      value: c
    } = await this.getSignatureStatuses([e], t);
    assert$c(c.length === 1);
    const a = c[0];
    return {
      context: o,
      value: a
    };
  }
  async getSignatureStatuses(e, t) {
    const o = [e];
    t && o.push(t);
    const c = await this._rpcRequest("getSignatureStatuses", o), a = create(c, GetSignatureStatusesRpcResult);
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get signature status");
    return a.result;
  }
  async getTransactionCount(e) {
    const {
      commitment: t,
      config: o
    } = extractCommitmentFromConfig(e), c = this._buildArgs(
      [],
      t,
      void 0,
      o
    ), a = await this._rpcRequest("getTransactionCount", c), d = create(a, jsonRpcResult(number()));
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get transaction count");
    return d.result;
  }
  async getTotalSupply(e) {
    return (await this.getSupply({
      commitment: e,
      excludeNonCirculatingAccountsList: !0
    })).value.total;
  }
  async getInflationGovernor(e) {
    const t = this._buildArgs([], e), o = await this._rpcRequest("getInflationGovernor", t), c = create(o, GetInflationGovernorRpcResult);
    if ("error" in c)
      throw new SolanaJSONRPCError(c.error, "failed to get inflation");
    return c.result;
  }
  async getInflationReward(e, t, o) {
    const {
      commitment: c,
      config: a
    } = extractCommitmentFromConfig(o), d = this._buildArgs(
      [e.map((M) => M.toBase58())],
      c,
      void 0,
      {
        ...a,
        epoch: t != null ? t : a == null ? void 0 : a.epoch
      }
    ), p = await this._rpcRequest("getInflationReward", d), w = create(p, GetInflationRewardResult);
    if ("error" in w)
      throw new SolanaJSONRPCError(w.error, "failed to get inflation reward");
    return w.result;
  }
  async getEpochInfo(e) {
    const {
      commitment: t,
      config: o
    } = extractCommitmentFromConfig(e), c = this._buildArgs(
      [],
      t,
      void 0,
      o
    ), a = await this._rpcRequest("getEpochInfo", c), d = create(a, GetEpochInfoRpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get epoch info");
    return d.result;
  }
  async getEpochSchedule() {
    const e = await this._rpcRequest("getEpochSchedule", []), t = create(e, GetEpochScheduleRpcResult);
    if ("error" in t)
      throw new SolanaJSONRPCError(t.error, "failed to get epoch schedule");
    const o = t.result;
    return new EpochSchedule(o.slotsPerEpoch, o.leaderScheduleSlotOffset, o.warmup, o.firstNormalEpoch, o.firstNormalSlot);
  }
  async getLeaderSchedule() {
    const e = await this._rpcRequest("getLeaderSchedule", []), t = create(e, GetLeaderScheduleRpcResult);
    if ("error" in t)
      throw new SolanaJSONRPCError(t.error, "failed to get leader schedule");
    return t.result;
  }
  async getMinimumBalanceForRentExemption(e, t) {
    const o = this._buildArgs([e], t), c = await this._rpcRequest("getMinimumBalanceForRentExemption", o), a = create(c, GetMinimumBalanceForRentExemptionRpcResult);
    return "error" in a ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : a.result;
  }
  async getRecentBlockhashAndContext(e) {
    const t = this._buildArgs([], e), o = await this._rpcRequest("getRecentBlockhash", t), c = create(o, GetRecentBlockhashAndContextRpcResult);
    if ("error" in c)
      throw new SolanaJSONRPCError(c.error, "failed to get recent blockhash");
    return c.result;
  }
  async getRecentPerformanceSamples(e) {
    const t = await this._rpcRequest("getRecentPerformanceSamples", e ? [e] : []), o = create(t, GetRecentPerformanceSamplesRpcResult);
    if ("error" in o)
      throw new SolanaJSONRPCError(o.error, "failed to get recent performance samples");
    return o.result;
  }
  async getFeeCalculatorForBlockhash(e, t) {
    const o = this._buildArgs([e], t), c = await this._rpcRequest("getFeeCalculatorForBlockhash", o), a = create(c, GetFeeCalculatorRpcResult);
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get fee calculator");
    const {
      context: d,
      value: p
    } = a.result;
    return {
      context: d,
      value: p !== null ? p.feeCalculator : null
    };
  }
  async getFeeForMessage(e, t) {
    const o = toBuffer(e.serialize()).toString("base64"), c = this._buildArgs([o], t), a = await this._rpcRequest("getFeeForMessage", c), d = create(a, jsonRpcResultAndContext(nullable(number())));
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get fee for message");
    if (d.result === null)
      throw new Error("invalid blockhash");
    return d.result;
  }
  async getRecentBlockhash(e) {
    try {
      return (await this.getRecentBlockhashAndContext(e)).value;
    } catch (t) {
      throw new Error("failed to get recent blockhash: " + t);
    }
  }
  async getLatestBlockhash(e) {
    try {
      return (await this.getLatestBlockhashAndContext(e)).value;
    } catch (t) {
      throw new Error("failed to get recent blockhash: " + t);
    }
  }
  async getLatestBlockhashAndContext(e) {
    const {
      commitment: t,
      config: o
    } = extractCommitmentFromConfig(e), c = this._buildArgs(
      [],
      t,
      void 0,
      o
    ), a = await this._rpcRequest("getLatestBlockhash", c), d = create(a, GetLatestBlockhashRpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get latest blockhash");
    return d.result;
  }
  async getVersion() {
    const e = await this._rpcRequest("getVersion", []), t = create(e, jsonRpcResult(VersionResult));
    if ("error" in t)
      throw new SolanaJSONRPCError(t.error, "failed to get version");
    return t.result;
  }
  async getGenesisHash() {
    const e = await this._rpcRequest("getGenesisHash", []), t = create(e, jsonRpcResult(string()));
    if ("error" in t)
      throw new SolanaJSONRPCError(t.error, "failed to get genesis hash");
    return t.result;
  }
  async getBlock(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = this._buildArgsAtLeastConfirmed(
      [e],
      o,
      void 0,
      c
    ), d = await this._rpcRequest("getBlock", a);
    try {
      switch (c == null ? void 0 : c.transactionDetails) {
        case "accounts": {
          const p = create(d, GetAccountsModeBlockRpcResult);
          if ("error" in p)
            throw p.error;
          return p.result;
        }
        case "none": {
          const p = create(d, GetNoneModeBlockRpcResult);
          if ("error" in p)
            throw p.error;
          return p.result;
        }
        default: {
          const p = create(d, GetBlockRpcResult);
          if ("error" in p)
            throw p.error;
          const {
            result: w
          } = p;
          return w ? {
            ...w,
            transactions: w.transactions.map(({
              transaction: M,
              meta: I,
              version: B
            }) => ({
              meta: I,
              transaction: {
                ...M,
                message: versionedMessageFromResponse(B, M.message)
              },
              version: B
            }))
          } : null;
        }
      }
    } catch (p) {
      throw new SolanaJSONRPCError(p, "failed to get confirmed block");
    }
  }
  async getParsedBlock(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = this._buildArgsAtLeastConfirmed([e], o, "jsonParsed", c), d = await this._rpcRequest("getBlock", a);
    try {
      switch (c == null ? void 0 : c.transactionDetails) {
        case "accounts": {
          const p = create(d, GetParsedAccountsModeBlockRpcResult);
          if ("error" in p)
            throw p.error;
          return p.result;
        }
        case "none": {
          const p = create(d, GetParsedNoneModeBlockRpcResult);
          if ("error" in p)
            throw p.error;
          return p.result;
        }
        default: {
          const p = create(d, GetParsedBlockRpcResult);
          if ("error" in p)
            throw p.error;
          return p.result;
        }
      }
    } catch (p) {
      throw new SolanaJSONRPCError(p, "failed to get block");
    }
  }
  async getBlockHeight(e) {
    const {
      commitment: t,
      config: o
    } = extractCommitmentFromConfig(e), c = this._buildArgs(
      [],
      t,
      void 0,
      o
    ), a = await this._rpcRequest("getBlockHeight", c), d = create(a, jsonRpcResult(number()));
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get block height information");
    return d.result;
  }
  async getBlockProduction(e) {
    let t, o;
    if (typeof e == "string")
      o = e;
    else if (e) {
      const {
        commitment: p,
        ...w
      } = e;
      o = p, t = w;
    }
    const c = this._buildArgs([], o, "base64", t), a = await this._rpcRequest("getBlockProduction", c), d = create(a, BlockProductionResponseStruct);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get block production information");
    return d.result;
  }
  async getTransaction(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = this._buildArgsAtLeastConfirmed(
      [e],
      o,
      void 0,
      c
    ), d = await this._rpcRequest("getTransaction", a), p = create(d, GetTransactionRpcResult);
    if ("error" in p)
      throw new SolanaJSONRPCError(p.error, "failed to get transaction");
    const w = p.result;
    return w && {
      ...w,
      transaction: {
        ...w.transaction,
        message: versionedMessageFromResponse(w.version, w.transaction.message)
      }
    };
  }
  async getParsedTransaction(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = this._buildArgsAtLeastConfirmed([e], o, "jsonParsed", c), d = await this._rpcRequest("getTransaction", a), p = create(d, GetParsedTransactionRpcResult);
    if ("error" in p)
      throw new SolanaJSONRPCError(p.error, "failed to get transaction");
    return p.result;
  }
  async getParsedTransactions(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = e.map((w) => {
      const M = this._buildArgsAtLeastConfirmed([w], o, "jsonParsed", c);
      return {
        methodName: "getTransaction",
        args: M
      };
    });
    return (await this._rpcBatchRequest(a)).map((w) => {
      const M = create(w, GetParsedTransactionRpcResult);
      if ("error" in M)
        throw new SolanaJSONRPCError(M.error, "failed to get transactions");
      return M.result;
    });
  }
  async getTransactions(e, t) {
    const {
      commitment: o,
      config: c
    } = extractCommitmentFromConfig(t), a = e.map((w) => {
      const M = this._buildArgsAtLeastConfirmed(
        [w],
        o,
        void 0,
        c
      );
      return {
        methodName: "getTransaction",
        args: M
      };
    });
    return (await this._rpcBatchRequest(a)).map((w) => {
      const M = create(w, GetTransactionRpcResult);
      if ("error" in M)
        throw new SolanaJSONRPCError(M.error, "failed to get transactions");
      const I = M.result;
      return I && {
        ...I,
        transaction: {
          ...I.transaction,
          message: versionedMessageFromResponse(I.version, I.transaction.message)
        }
      };
    });
  }
  async getConfirmedBlock(e, t) {
    const o = this._buildArgsAtLeastConfirmed([e], t), c = await this._rpcRequest("getConfirmedBlock", o), a = create(c, GetConfirmedBlockRpcResult);
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get confirmed block");
    const d = a.result;
    if (!d)
      throw new Error("Confirmed block " + e + " not found");
    const p = {
      ...d,
      transactions: d.transactions.map(({
        transaction: w,
        meta: M
      }) => {
        const I = new Message(w.message);
        return {
          meta: M,
          transaction: {
            ...w,
            message: I
          }
        };
      })
    };
    return {
      ...p,
      transactions: p.transactions.map(({
        transaction: w,
        meta: M
      }) => ({
        meta: M,
        transaction: Transaction.populate(w.message, w.signatures)
      }))
    };
  }
  async getBlocks(e, t, o) {
    const c = this._buildArgsAtLeastConfirmed(t !== void 0 ? [e, t] : [e], o), a = await this._rpcRequest("getBlocks", c), d = create(a, jsonRpcResult(array(number())));
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get blocks");
    return d.result;
  }
  async getBlockSignatures(e, t) {
    const o = this._buildArgsAtLeastConfirmed([e], t, void 0, {
      transactionDetails: "signatures",
      rewards: !1
    }), c = await this._rpcRequest("getBlock", o), a = create(c, GetBlockSignaturesRpcResult);
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get block");
    const d = a.result;
    if (!d)
      throw new Error("Block " + e + " not found");
    return d;
  }
  async getConfirmedBlockSignatures(e, t) {
    const o = this._buildArgsAtLeastConfirmed([e], t, void 0, {
      transactionDetails: "signatures",
      rewards: !1
    }), c = await this._rpcRequest("getConfirmedBlock", o), a = create(c, GetBlockSignaturesRpcResult);
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get confirmed block");
    const d = a.result;
    if (!d)
      throw new Error("Confirmed block " + e + " not found");
    return d;
  }
  async getConfirmedTransaction(e, t) {
    const o = this._buildArgsAtLeastConfirmed([e], t), c = await this._rpcRequest("getConfirmedTransaction", o), a = create(c, GetTransactionRpcResult);
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get transaction");
    const d = a.result;
    if (!d)
      return d;
    const p = new Message(d.transaction.message), w = d.transaction.signatures;
    return {
      ...d,
      transaction: Transaction.populate(p, w)
    };
  }
  async getParsedConfirmedTransaction(e, t) {
    const o = this._buildArgsAtLeastConfirmed([e], t, "jsonParsed"), c = await this._rpcRequest("getConfirmedTransaction", o), a = create(c, GetParsedTransactionRpcResult);
    if ("error" in a)
      throw new SolanaJSONRPCError(a.error, "failed to get confirmed transaction");
    return a.result;
  }
  async getParsedConfirmedTransactions(e, t) {
    const o = e.map((d) => {
      const p = this._buildArgsAtLeastConfirmed([d], t, "jsonParsed");
      return {
        methodName: "getConfirmedTransaction",
        args: p
      };
    });
    return (await this._rpcBatchRequest(o)).map((d) => {
      const p = create(d, GetParsedTransactionRpcResult);
      if ("error" in p)
        throw new SolanaJSONRPCError(p.error, "failed to get confirmed transactions");
      return p.result;
    });
  }
  async getConfirmedSignaturesForAddress(e, t, o) {
    let c = {}, a = await this.getFirstAvailableBlock();
    for (; !("until" in c) && (t--, !(t <= 0 || t < a)); )
      try {
        const w = await this.getConfirmedBlockSignatures(t, "finalized");
        w.signatures.length > 0 && (c.until = w.signatures[w.signatures.length - 1].toString());
      } catch (w) {
        if (w instanceof Error && w.message.includes("skipped"))
          continue;
        throw w;
      }
    let d = await this.getSlot("finalized");
    for (; !("before" in c) && (o++, !(o > d)); )
      try {
        const w = await this.getConfirmedBlockSignatures(o);
        w.signatures.length > 0 && (c.before = w.signatures[w.signatures.length - 1].toString());
      } catch (w) {
        if (w instanceof Error && w.message.includes("skipped"))
          continue;
        throw w;
      }
    return (await this.getConfirmedSignaturesForAddress2(e, c)).map((w) => w.signature);
  }
  async getConfirmedSignaturesForAddress2(e, t, o) {
    const c = this._buildArgsAtLeastConfirmed([e.toBase58()], o, void 0, t), a = await this._rpcRequest("getConfirmedSignaturesForAddress2", c), d = create(a, GetConfirmedSignaturesForAddress2RpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get confirmed signatures for address");
    return d.result;
  }
  async getSignaturesForAddress(e, t, o) {
    const c = this._buildArgsAtLeastConfirmed([e.toBase58()], o, void 0, t), a = await this._rpcRequest("getSignaturesForAddress", c), d = create(a, GetSignaturesForAddressRpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get signatures for address");
    return d.result;
  }
  async getAddressLookupTable(e, t) {
    const {
      context: o,
      value: c
    } = await this.getAccountInfoAndContext(e, t);
    let a = null;
    return c !== null && (a = new AddressLookupTableAccount({
      key: e,
      state: AddressLookupTableAccount.deserialize(c.data)
    })), {
      context: o,
      value: a
    };
  }
  async getNonceAndContext(e, t) {
    const {
      context: o,
      value: c
    } = await this.getAccountInfoAndContext(e, t);
    let a = null;
    return c !== null && (a = NonceAccount.fromAccountData(c.data)), {
      context: o,
      value: a
    };
  }
  async getNonce(e, t) {
    return await this.getNonceAndContext(e, t).then((o) => o.value).catch((o) => {
      throw new Error("failed to get nonce for account " + e.toBase58() + ": " + o);
    });
  }
  async requestAirdrop(e, t) {
    const o = await this._rpcRequest("requestAirdrop", [e.toBase58(), t]), c = create(o, RequestAirdropRpcResult);
    if ("error" in c)
      throw new SolanaJSONRPCError(c.error, `airdrop to ${e.toBase58()} failed`);
    return c.result;
  }
  async _blockhashWithExpiryBlockHeight(e) {
    if (!e) {
      for (; this._pollingBlockhash; )
        await sleep(100);
      const o = Date.now() - this._blockhashInfo.lastFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
      if (this._blockhashInfo.latestBlockhash !== null && !o)
        return this._blockhashInfo.latestBlockhash;
    }
    return await this._pollNewBlockhash();
  }
  async _pollNewBlockhash() {
    this._pollingBlockhash = !0;
    try {
      const e = Date.now(), t = this._blockhashInfo.latestBlockhash, o = t ? t.blockhash : null;
      for (let c = 0; c < 50; c++) {
        const a = await this.getLatestBlockhash("finalized");
        if (o !== a.blockhash)
          return this._blockhashInfo = {
            latestBlockhash: a,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          }, a;
        await sleep(MS_PER_SLOT / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - e}ms`);
    } finally {
      this._pollingBlockhash = !1;
    }
  }
  async getStakeMinimumDelegation(e) {
    const {
      commitment: t,
      config: o
    } = extractCommitmentFromConfig(e), c = this._buildArgs([], t, "base64", o), a = await this._rpcRequest("getStakeMinimumDelegation", c), d = create(a, jsonRpcResultAndContext(number()));
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get stake minimum delegation");
    return d.result;
  }
  async simulateTransaction(e, t, o) {
    if ("message" in e) {
      const $ = e.serialize(), P = buffer.Buffer.from($).toString("base64");
      if (Array.isArray(t) || o !== void 0)
        throw new Error("Invalid arguments");
      const U = t || {};
      U.encoding = "base64", "commitment" in U || (U.commitment = this.commitment);
      const G = [P, U], D = await this._rpcRequest("simulateTransaction", G), Z = create(D, SimulatedTransactionResponseStruct);
      if ("error" in Z)
        throw new Error("failed to simulate transaction: " + Z.error.message);
      return Z.result;
    }
    let c;
    if (e instanceof Transaction) {
      let W = e;
      c = new Transaction(), c.feePayer = W.feePayer, c.instructions = e.instructions, c.nonceInfo = W.nonceInfo, c.signatures = W.signatures;
    } else
      c = Transaction.populate(e), c._message = c._json = void 0;
    if (t !== void 0 && !Array.isArray(t))
      throw new Error("Invalid arguments");
    const a = t;
    if (c.nonceInfo && a)
      c.sign(...a);
    else {
      let W = this._disableBlockhashCaching;
      for (; ; ) {
        const $ = await this._blockhashWithExpiryBlockHeight(W);
        if (c.lastValidBlockHeight = $.lastValidBlockHeight, c.recentBlockhash = $.blockhash, !a)
          break;
        if (c.sign(...a), !c.signature)
          throw new Error("!signature");
        const P = c.signature.toString("base64");
        if (!this._blockhashInfo.simulatedSignatures.includes(P) && !this._blockhashInfo.transactionSignatures.includes(P)) {
          this._blockhashInfo.simulatedSignatures.push(P);
          break;
        } else
          W = !0;
      }
    }
    const d = c._compile(), p = d.serialize(), M = c._serialize(p).toString("base64"), I = {
      encoding: "base64",
      commitment: this.commitment
    };
    if (o) {
      const W = (Array.isArray(o) ? o : d.nonProgramIds()).map(($) => $.toBase58());
      I.accounts = {
        encoding: "base64",
        addresses: W
      };
    }
    a && (I.sigVerify = !0);
    const B = [M, I], H = await this._rpcRequest("simulateTransaction", B), L = create(H, SimulatedTransactionResponseStruct);
    if ("error" in L) {
      let W;
      if ("data" in L.error && (W = L.error.data.logs, W && Array.isArray(W))) {
        const $ = `
    `, P = $ + W.join($);
        console.error(L.error.message, P);
      }
      throw new SendTransactionError("failed to simulate transaction: " + L.error.message, W);
    }
    return L.result;
  }
  async sendTransaction(e, t, o) {
    if ("version" in e) {
      if (t && Array.isArray(t))
        throw new Error("Invalid arguments");
      const d = e.serialize();
      return await this.sendRawTransaction(d, o);
    }
    if (t === void 0 || !Array.isArray(t))
      throw new Error("Invalid arguments");
    const c = t;
    if (e.nonceInfo)
      e.sign(...c);
    else {
      let d = this._disableBlockhashCaching;
      for (; ; ) {
        const p = await this._blockhashWithExpiryBlockHeight(d);
        if (e.lastValidBlockHeight = p.lastValidBlockHeight, e.recentBlockhash = p.blockhash, e.sign(...c), !e.signature)
          throw new Error("!signature");
        const w = e.signature.toString("base64");
        if (this._blockhashInfo.transactionSignatures.includes(w))
          d = !0;
        else {
          this._blockhashInfo.transactionSignatures.push(w);
          break;
        }
      }
    }
    const a = e.serialize();
    return await this.sendRawTransaction(a, o);
  }
  async sendRawTransaction(e, t) {
    const o = toBuffer(e).toString("base64");
    return await this.sendEncodedTransaction(o, t);
  }
  async sendEncodedTransaction(e, t) {
    const o = {
      encoding: "base64"
    }, c = t && t.skipPreflight, a = t && t.preflightCommitment || this.commitment;
    t && t.maxRetries != null && (o.maxRetries = t.maxRetries), t && t.minContextSlot != null && (o.minContextSlot = t.minContextSlot), c && (o.skipPreflight = c), a && (o.preflightCommitment = a);
    const d = [e, o], p = await this._rpcRequest("sendTransaction", d), w = create(p, SendTransactionRpcResult);
    if ("error" in w) {
      let M;
      throw "data" in w.error && (M = w.error.data.logs), new SendTransactionError("failed to send transaction: " + w.error.message, M);
    }
    return w.result;
  }
  _wsOnOpen() {
    this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval(() => {
      this._rpcWebSocket.notify("ping").catch(() => {
      });
    }, 5e3), this._updateSubscriptions();
  }
  _wsOnError(e) {
    this._rpcWebSocketConnected = !1, console.error("ws error:", e.message);
  }
  _wsOnClose(e) {
    if (this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER, this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null), this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), e === 1e3) {
      this._updateSubscriptions();
      return;
    }
    this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach(([t, o]) => {
      this._setSubscription(t, {
        ...o,
        state: "pending"
      });
    });
  }
  _setSubscription(e, t) {
    var o;
    const c = (o = this._subscriptionsByHash[e]) === null || o === void 0 ? void 0 : o.state;
    if (this._subscriptionsByHash[e] = t, c !== t.state) {
      const a = this._subscriptionStateChangeCallbacksByHash[e];
      a && a.forEach((d) => {
        try {
          d(t.state);
        } catch {
        }
      });
    }
  }
  _onSubscriptionStateChange(e, t) {
    var o;
    const c = this._subscriptionHashByClientSubscriptionId[e];
    if (c == null)
      return () => {
      };
    const a = (o = this._subscriptionStateChangeCallbacksByHash)[c] || (o[c] = /* @__PURE__ */ new Set());
    return a.add(t), () => {
      a.delete(t), a.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[c];
    };
  }
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1, this._rpcWebSocketIdleTimeout = setTimeout(() => {
        this._rpcWebSocketIdleTimeout = null;
        try {
          this._rpcWebSocket.close();
        } catch (o) {
          o instanceof Error && console.log(`Error when closing socket connection: ${o.message}`);
        }
      }, 500));
      return;
    }
    if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketConnected = !0), !this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();
      return;
    }
    const e = this._rpcWebSocketGeneration, t = () => e === this._rpcWebSocketGeneration;
    await Promise.all(
      Object.keys(this._subscriptionsByHash).map(async (o) => {
        const c = this._subscriptionsByHash[o];
        if (c !== void 0)
          switch (c.state) {
            case "pending":
            case "unsubscribed":
              if (c.callbacks.size === 0) {
                delete this._subscriptionsByHash[o], c.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[c.serverSubscriptionId], await this._updateSubscriptions();
                return;
              }
              await (async () => {
                const {
                  args: a,
                  method: d
                } = c;
                try {
                  this._setSubscription(o, {
                    ...c,
                    state: "subscribing"
                  });
                  const p = await this._rpcWebSocket.call(d, a);
                  this._setSubscription(o, {
                    ...c,
                    serverSubscriptionId: p,
                    state: "subscribed"
                  }), this._subscriptionCallbacksByServerSubscriptionId[p] = c.callbacks, await this._updateSubscriptions();
                } catch (p) {
                  if (p instanceof Error && console.error(`${d} error for argument`, a, p.message), !t())
                    return;
                  this._setSubscription(o, {
                    ...c,
                    state: "pending"
                  }), await this._updateSubscriptions();
                }
              })();
              break;
            case "subscribed":
              c.callbacks.size === 0 && await (async () => {
                const {
                  serverSubscriptionId: a,
                  unsubscribeMethod: d
                } = c;
                if (this._subscriptionsAutoDisposedByRpc.has(a))
                  this._subscriptionsAutoDisposedByRpc.delete(a);
                else {
                  this._setSubscription(o, {
                    ...c,
                    state: "unsubscribing"
                  }), this._setSubscription(o, {
                    ...c,
                    state: "unsubscribing"
                  });
                  try {
                    await this._rpcWebSocket.call(d, [a]);
                  } catch (p) {
                    if (p instanceof Error && console.error(`${d} error:`, p.message), !t())
                      return;
                    this._setSubscription(o, {
                      ...c,
                      state: "subscribed"
                    }), await this._updateSubscriptions();
                    return;
                  }
                }
                this._setSubscription(o, {
                  ...c,
                  state: "unsubscribed"
                }), await this._updateSubscriptions();
              })();
              break;
          }
      })
    );
  }
  _handleServerNotification(e, t) {
    const o = this._subscriptionCallbacksByServerSubscriptionId[e];
    o !== void 0 && o.forEach((c) => {
      try {
        c(
          ...t
        );
      } catch (a) {
        console.error(a);
      }
    });
  }
  _wsOnAccountNotification(e) {
    const {
      result: t,
      subscription: o
    } = create(e, AccountNotificationResult);
    this._handleServerNotification(o, [t.value, t.context]);
  }
  _makeSubscription(e, t) {
    const o = this._nextClientSubscriptionId++, c = fastStableStringify$1([e.method, t]), a = this._subscriptionsByHash[c];
    return a === void 0 ? this._subscriptionsByHash[c] = {
      ...e,
      args: t,
      callbacks: /* @__PURE__ */ new Set([e.callback]),
      state: "pending"
    } : a.callbacks.add(e.callback), this._subscriptionHashByClientSubscriptionId[o] = c, this._subscriptionDisposeFunctionsByClientSubscriptionId[o] = async () => {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[o], delete this._subscriptionHashByClientSubscriptionId[o];
      const d = this._subscriptionsByHash[c];
      assert$c(d !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${o}`), d.callbacks.delete(e.callback), await this._updateSubscriptions();
    }, this._updateSubscriptions(), o;
  }
  onAccountChange(e, t, o) {
    const c = this._buildArgs(
      [e.toBase58()],
      o || this._commitment || "finalized",
      "base64"
    );
    return this._makeSubscription({
      callback: t,
      method: "accountSubscribe",
      unsubscribeMethod: "accountUnsubscribe"
    }, c);
  }
  async removeAccountChangeListener(e) {
    await this._unsubscribeClientSubscription(e, "account change");
  }
  _wsOnProgramAccountNotification(e) {
    const {
      result: t,
      subscription: o
    } = create(e, ProgramAccountNotificationResult);
    this._handleServerNotification(o, [{
      accountId: t.value.pubkey,
      accountInfo: t.value.account
    }, t.context]);
  }
  onProgramAccountChange(e, t, o, c) {
    const a = this._buildArgs(
      [e.toBase58()],
      o || this._commitment || "finalized",
      "base64",
      c ? {
        filters: c
      } : void 0
    );
    return this._makeSubscription({
      callback: t,
      method: "programSubscribe",
      unsubscribeMethod: "programUnsubscribe"
    }, a);
  }
  async removeProgramAccountChangeListener(e) {
    await this._unsubscribeClientSubscription(e, "program account change");
  }
  onLogs(e, t, o) {
    const c = this._buildArgs(
      [typeof e == "object" ? {
        mentions: [e.toString()]
      } : e],
      o || this._commitment || "finalized"
    );
    return this._makeSubscription({
      callback: t,
      method: "logsSubscribe",
      unsubscribeMethod: "logsUnsubscribe"
    }, c);
  }
  async removeOnLogsListener(e) {
    await this._unsubscribeClientSubscription(e, "logs");
  }
  _wsOnLogsNotification(e) {
    const {
      result: t,
      subscription: o
    } = create(e, LogsNotificationResult);
    this._handleServerNotification(o, [t.value, t.context]);
  }
  _wsOnSlotNotification(e) {
    const {
      result: t,
      subscription: o
    } = create(e, SlotNotificationResult);
    this._handleServerNotification(o, [t]);
  }
  onSlotChange(e) {
    return this._makeSubscription(
      {
        callback: e,
        method: "slotSubscribe",
        unsubscribeMethod: "slotUnsubscribe"
      },
      []
    );
  }
  async removeSlotChangeListener(e) {
    await this._unsubscribeClientSubscription(e, "slot change");
  }
  _wsOnSlotUpdatesNotification(e) {
    const {
      result: t,
      subscription: o
    } = create(e, SlotUpdateNotificationResult);
    this._handleServerNotification(o, [t]);
  }
  onSlotUpdate(e) {
    return this._makeSubscription(
      {
        callback: e,
        method: "slotsUpdatesSubscribe",
        unsubscribeMethod: "slotsUpdatesUnsubscribe"
      },
      []
    );
  }
  async removeSlotUpdateListener(e) {
    await this._unsubscribeClientSubscription(e, "slot update");
  }
  async _unsubscribeClientSubscription(e, t) {
    const o = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
    o ? await o() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`);
  }
  _buildArgs(e, t, o, c) {
    const a = t || this._commitment;
    if (a || o || c) {
      let d = {};
      o && (d.encoding = o), a && (d.commitment = a), c && (d = Object.assign(d, c)), e.push(d);
    }
    return e;
  }
  _buildArgsAtLeastConfirmed(e, t, o, c) {
    const a = t || this._commitment;
    if (a && !["confirmed", "finalized"].includes(a))
      throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
    return this._buildArgs(e, t, o, c);
  }
  _wsOnSignatureNotification(e) {
    const {
      result: t,
      subscription: o
    } = create(e, SignatureNotificationResult);
    t.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add(o), this._handleServerNotification(o, t.value === "receivedSignature" ? [{
      type: "received"
    }, t.context] : [{
      type: "status",
      result: t.value
    }, t.context]);
  }
  onSignature(e, t, o) {
    const c = this._buildArgs(
      [e],
      o || this._commitment || "finalized"
    ), a = this._makeSubscription({
      callback: (d, p) => {
        if (d.type === "status") {
          t(d.result, p);
          try {
            this.removeSignatureListener(a);
          } catch {
          }
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, c);
    return a;
  }
  onSignatureWithOptions(e, t, o) {
    const {
      commitment: c,
      ...a
    } = {
      ...o,
      commitment: o && o.commitment || this._commitment || "finalized"
    }, d = this._buildArgs(
      [e],
      c,
      void 0,
      a
    ), p = this._makeSubscription({
      callback: (w, M) => {
        t(w, M);
        try {
          this.removeSignatureListener(p);
        } catch {
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, d);
    return p;
  }
  async removeSignatureListener(e) {
    await this._unsubscribeClientSubscription(e, "signature result");
  }
  _wsOnRootNotification(e) {
    const {
      result: t,
      subscription: o
    } = create(e, RootNotificationResult);
    this._handleServerNotification(o, [t]);
  }
  onRootChange(e) {
    return this._makeSubscription(
      {
        callback: e,
        method: "rootSubscribe",
        unsubscribeMethod: "rootUnsubscribe"
      },
      []
    );
  }
  async removeRootChangeListener(e) {
    await this._unsubscribeClientSubscription(e, "root change");
  }
}
class Keypair {
  constructor(e) {
    this._keypair = void 0, this._keypair = e != null ? e : generateKeypair();
  }
  static generate() {
    return new Keypair(generateKeypair());
  }
  static fromSecretKey(e, t) {
    if (e.byteLength !== 64)
      throw new Error("bad secret key size");
    const o = e.slice(32, 64);
    if (!t || !t.skipValidation) {
      const c = e.slice(0, 32), a = getPublicKey(c);
      for (let d = 0; d < 32; d++)
        if (o[d] !== a[d])
          throw new Error("provided secretKey is invalid");
    }
    return new Keypair({
      publicKey: o,
      secretKey: e
    });
  }
  static fromSeed(e) {
    const t = getPublicKey(e), o = new Uint8Array(64);
    return o.set(e), o.set(t, 32), new Keypair({
      publicKey: t,
      secretKey: o
    });
  }
  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: struct([u32("instruction"), u64("recentSlot"), u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: struct([u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: struct([u32("instruction"), u64(), seq(publicKey(), offset(u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: struct([u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: struct([u32("instruction")])
  }
});
class AddressLookupTableInstruction {
  constructor() {
  }
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const o = u32("instruction").decode(e.data);
    let c;
    for (const [a, d] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS))
      if (d.index == o) {
        c = a;
        break;
      }
    if (!c)
      throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
    return c;
  }
  static decodeCreateLookupTable(e) {
    this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 4);
    const {
      recentSlot: t
    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, e.data);
    return {
      authority: e.keys[1].pubkey,
      payer: e.keys[2].pubkey,
      recentSlot: Number(t)
    };
  }
  static decodeExtendLookupTable(e) {
    if (this.checkProgramId(e.programId), e.keys.length < 2)
      throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);
    const {
      addresses: t
    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, e.data);
    return {
      lookupTable: e.keys[0].pubkey,
      authority: e.keys[1].pubkey,
      payer: e.keys.length > 2 ? e.keys[2].pubkey : void 0,
      addresses: t.map((o) => new PublicKey(o))
    };
  }
  static decodeCloseLookupTable(e) {
    return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 3), {
      lookupTable: e.keys[0].pubkey,
      authority: e.keys[1].pubkey,
      recipient: e.keys[2].pubkey
    };
  }
  static decodeFreezeLookupTable(e) {
    return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 2), {
      lookupTable: e.keys[0].pubkey,
      authority: e.keys[1].pubkey
    };
  }
  static decodeDeactivateLookupTable(e) {
    return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 2), {
      lookupTable: e.keys[0].pubkey,
      authority: e.keys[1].pubkey
    };
  }
  static checkProgramId(e) {
    if (!e.equals(AddressLookupTableProgram.programId))
      throw new Error("invalid instruction; programId is not AddressLookupTable Program");
  }
  static checkKeysLength(e, t) {
    if (e.length < t)
      throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
  }
}
class AddressLookupTableProgram {
  constructor() {
  }
  static createLookupTable(e) {
    const [t, o] = PublicKey.findProgramAddressSync([e.authority.toBuffer(), toBufferLE_1(BigInt(e.recentSlot), 8)], this.programId), c = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, a = encodeData(c, {
      recentSlot: BigInt(e.recentSlot),
      bumpSeed: o
    }), d = [{
      pubkey: t,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: e.authority,
      isSigner: !0,
      isWritable: !1
    }, {
      pubkey: e.payer,
      isSigner: !0,
      isWritable: !0
    }, {
      pubkey: SystemProgram.programId,
      isSigner: !1,
      isWritable: !1
    }];
    return [new TransactionInstruction({
      programId: this.programId,
      keys: d,
      data: a
    }), t];
  }
  static freezeLookupTable(e) {
    const t = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable, o = encodeData(t), c = [{
      pubkey: e.lookupTable,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: e.authority,
      isSigner: !0,
      isWritable: !1
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: c,
      data: o
    });
  }
  static extendLookupTable(e) {
    const t = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, o = encodeData(t, {
      addresses: e.addresses.map((a) => a.toBytes())
    }), c = [{
      pubkey: e.lookupTable,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: e.authority,
      isSigner: !0,
      isWritable: !1
    }];
    return e.payer && c.push({
      pubkey: e.payer,
      isSigner: !0,
      isWritable: !0
    }, {
      pubkey: SystemProgram.programId,
      isSigner: !1,
      isWritable: !1
    }), new TransactionInstruction({
      programId: this.programId,
      keys: c,
      data: o
    });
  }
  static deactivateLookupTable(e) {
    const t = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable, o = encodeData(t), c = [{
      pubkey: e.lookupTable,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: e.authority,
      isSigner: !0,
      isWritable: !1
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: c,
      data: o
    });
  }
  static closeLookupTable(e) {
    const t = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable, o = encodeData(t), c = [{
      pubkey: e.lookupTable,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: e.authority,
      isSigner: !0,
      isWritable: !1
    }, {
      pubkey: e.recipient,
      isSigner: !1,
      isWritable: !0
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: c,
      data: o
    });
  }
}
AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
class ComputeBudgetInstruction {
  constructor() {
  }
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const o = u8("instruction").decode(e.data);
    let c;
    for (const [a, d] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS))
      if (d.index == o) {
        c = a;
        break;
      }
    if (!c)
      throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
    return c;
  }
  static decodeRequestUnits(e) {
    this.checkProgramId(e.programId);
    const {
      units: t,
      additionalFee: o
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, e.data);
    return {
      units: t,
      additionalFee: o
    };
  }
  static decodeRequestHeapFrame(e) {
    this.checkProgramId(e.programId);
    const {
      bytes: t
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, e.data);
    return {
      bytes: t
    };
  }
  static decodeSetComputeUnitLimit(e) {
    this.checkProgramId(e.programId);
    const {
      units: t
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, e.data);
    return {
      units: t
    };
  }
  static decodeSetComputeUnitPrice(e) {
    this.checkProgramId(e.programId);
    const {
      microLamports: t
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, e.data);
    return {
      microLamports: t
    };
  }
  static checkProgramId(e) {
    if (!e.equals(ComputeBudgetProgram.programId))
      throw new Error("invalid instruction; programId is not ComputeBudgetProgram");
  }
}
const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: struct([u8("instruction"), u32("units"), u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: struct([u8("instruction"), u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: struct([u8("instruction"), u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: struct([u8("instruction"), u64("microLamports")])
  }
});
class ComputeBudgetProgram {
  constructor() {
  }
  static requestUnits(e) {
    const t = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, o = encodeData(t, e);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: o
    });
  }
  static requestHeapFrame(e) {
    const t = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, o = encodeData(t, e);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: o
    });
  }
  static setComputeUnitLimit(e) {
    const t = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, o = encodeData(t, e);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: o
    });
  }
  static setComputeUnitPrice(e) {
    const t = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, o = encodeData(t, {
      microLamports: BigInt(e.microLamports)
    });
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: o
    });
  }
}
ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
const PRIVATE_KEY_BYTES$1 = 64, PUBLIC_KEY_BYTES$1 = 32, SIGNATURE_BYTES = 64, ED25519_INSTRUCTION_LAYOUT = struct([u8("numSignatures"), u8("padding"), u16("signatureOffset"), u16("signatureInstructionIndex"), u16("publicKeyOffset"), u16("publicKeyInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u16("messageInstructionIndex")]);
class Ed25519Program {
  constructor() {
  }
  static createInstructionWithPublicKey(e) {
    const {
      publicKey: t,
      message: o,
      signature: c,
      instructionIndex: a
    } = e;
    assert$c(t.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${t.length} bytes`), assert$c(c.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${c.length} bytes`);
    const d = ED25519_INSTRUCTION_LAYOUT.span, p = d + t.length, w = p + c.length, M = 1, I = buffer.Buffer.alloc(w + o.length), B = a == null ? 65535 : a;
    return ED25519_INSTRUCTION_LAYOUT.encode({
      numSignatures: M,
      padding: 0,
      signatureOffset: p,
      signatureInstructionIndex: B,
      publicKeyOffset: d,
      publicKeyInstructionIndex: B,
      messageDataOffset: w,
      messageDataSize: o.length,
      messageInstructionIndex: B
    }, I), I.fill(t, d), I.fill(c, p), I.fill(o, w), new TransactionInstruction({
      keys: [],
      programId: Ed25519Program.programId,
      data: I
    });
  }
  static createInstructionWithPrivateKey(e) {
    const {
      privateKey: t,
      message: o,
      instructionIndex: c
    } = e;
    assert$c(t.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${t.length} bytes`);
    try {
      const a = Keypair.fromSecretKey(t), d = a.publicKey.toBytes(), p = sign(o, a.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: d,
        message: o,
        signature: p,
        instructionIndex: c
      });
    } catch (a) {
      throw new Error(`Error creating instruction; ${a}`);
    }
  }
}
Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
utils$b.hmacSha256Sync = (n, ...e) => {
  const t = hmac$1.create(sha256$2, n);
  return e.forEach((o) => t.update(o)), t.digest();
};
const ecdsaSign = (n, e) => signSync(n, e, {
  der: !1,
  recovered: !0
});
utils$b.isValidPrivateKey;
const publicKeyCreate = getPublicKey$1, PRIVATE_KEY_BYTES = 32, ETHEREUM_ADDRESS_BYTES = 20, PUBLIC_KEY_BYTES = 64, SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11, SECP256K1_INSTRUCTION_LAYOUT = struct([u8("numSignatures"), u16("signatureOffset"), u8("signatureInstructionIndex"), u16("ethAddressOffset"), u8("ethAddressInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u8("messageInstructionIndex"), blob(20, "ethAddress"), blob(64, "signature"), u8("recoveryId")]);
class Secp256k1Program {
  constructor() {
  }
  static publicKeyToEthAddress(e) {
    assert$c(e.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${e.length} bytes`);
    try {
      return buffer.Buffer.from(keccak_256(toBuffer(e))).slice(-ETHEREUM_ADDRESS_BYTES);
    } catch (t) {
      throw new Error(`Error constructing Ethereum address: ${t}`);
    }
  }
  static createInstructionWithPublicKey(e) {
    const {
      publicKey: t,
      message: o,
      signature: c,
      recoveryId: a,
      instructionIndex: d
    } = e;
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program.publicKeyToEthAddress(t),
      message: o,
      signature: c,
      recoveryId: a,
      instructionIndex: d
    });
  }
  static createInstructionWithEthAddress(e) {
    const {
      ethAddress: t,
      message: o,
      signature: c,
      recoveryId: a,
      instructionIndex: d = 0
    } = e;
    let p;
    typeof t == "string" ? t.startsWith("0x") ? p = buffer.Buffer.from(t.substr(2), "hex") : p = buffer.Buffer.from(t, "hex") : p = t, assert$c(p.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${p.length} bytes`);
    const w = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE, M = w, I = w + p.length, B = I + c.length + 1, H = 1, L = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + o.length);
    return SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures: H,
      signatureOffset: I,
      signatureInstructionIndex: d,
      ethAddressOffset: M,
      ethAddressInstructionIndex: d,
      messageDataOffset: B,
      messageDataSize: o.length,
      messageInstructionIndex: d,
      signature: toBuffer(c),
      ethAddress: toBuffer(p),
      recoveryId: a
    }, L), L.fill(toBuffer(o), SECP256K1_INSTRUCTION_LAYOUT.span), new TransactionInstruction({
      keys: [],
      programId: Secp256k1Program.programId,
      data: L
    });
  }
  static createInstructionWithPrivateKey(e) {
    const {
      privateKey: t,
      message: o,
      instructionIndex: c
    } = e;
    assert$c(t.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${t.length} bytes`);
    try {
      const a = toBuffer(t), d = publicKeyCreate(
        a,
        !1
      ).slice(1), p = buffer.Buffer.from(keccak_256(toBuffer(o))), [w, M] = ecdsaSign(p, a);
      return this.createInstructionWithPublicKey({
        publicKey: d,
        message: o,
        signature: w,
        recoveryId: M,
        instructionIndex: c
      });
    } catch (a) {
      throw new Error(`Error creating instruction; ${a}`);
    }
  }
}
Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
const STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
class Authorized {
  constructor(e, t) {
    this.staker = void 0, this.withdrawer = void 0, this.staker = e, this.withdrawer = t;
  }
}
class Lockup {
  constructor(e, t, o) {
    this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = e, this.epoch = t, this.custodian = o;
  }
}
Lockup.default = new Lockup(0, 0, PublicKey.default);
class StakeInstruction {
  constructor() {
  }
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const o = u32("instruction").decode(e.data);
    let c;
    for (const [a, d] of Object.entries(STAKE_INSTRUCTION_LAYOUTS))
      if (d.index == o) {
        c = a;
        break;
      }
    if (!c)
      throw new Error("Instruction type incorrect; not a StakeInstruction");
    return c;
  }
  static decodeInitialize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const {
      authorized: t,
      lockup: o
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, e.data);
    return {
      stakePubkey: e.keys[0].pubkey,
      authorized: new Authorized(new PublicKey(t.staker), new PublicKey(t.withdrawer)),
      lockup: new Lockup(o.unixTimestamp, o.epoch, new PublicKey(o.custodian))
    };
  }
  static decodeDelegate(e) {
    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 6), decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, e.data), {
      stakePubkey: e.keys[0].pubkey,
      votePubkey: e.keys[1].pubkey,
      authorizedPubkey: e.keys[5].pubkey
    };
  }
  static decodeAuthorize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const {
      newAuthorized: t,
      stakeAuthorizationType: o
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, e.data), c = {
      stakePubkey: e.keys[0].pubkey,
      authorizedPubkey: e.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(t),
      stakeAuthorizationType: {
        index: o
      }
    };
    return e.keys.length > 3 && (c.custodianPubkey = e.keys[3].pubkey), c;
  }
  static decodeAuthorizeWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
    const {
      newAuthorized: t,
      stakeAuthorizationType: o,
      authoritySeed: c,
      authorityOwner: a
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, e.data), d = {
      stakePubkey: e.keys[0].pubkey,
      authorityBase: e.keys[1].pubkey,
      authoritySeed: c,
      authorityOwner: new PublicKey(a),
      newAuthorizedPubkey: new PublicKey(t),
      stakeAuthorizationType: {
        index: o
      }
    };
    return e.keys.length > 3 && (d.custodianPubkey = e.keys[3].pubkey), d;
  }
  static decodeSplit(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const {
      lamports: t
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, e.data);
    return {
      stakePubkey: e.keys[0].pubkey,
      splitStakePubkey: e.keys[1].pubkey,
      authorizedPubkey: e.keys[2].pubkey,
      lamports: t
    };
  }
  static decodeMerge(e) {
    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, e.data), {
      stakePubkey: e.keys[0].pubkey,
      sourceStakePubKey: e.keys[1].pubkey,
      authorizedPubkey: e.keys[4].pubkey
    };
  }
  static decodeWithdraw(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
    const {
      lamports: t
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, e.data), o = {
      stakePubkey: e.keys[0].pubkey,
      toPubkey: e.keys[1].pubkey,
      authorizedPubkey: e.keys[4].pubkey,
      lamports: t
    };
    return e.keys.length > 5 && (o.custodianPubkey = e.keys[5].pubkey), o;
  }
  static decodeDeactivate(e) {
    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, e.data), {
      stakePubkey: e.keys[0].pubkey,
      authorizedPubkey: e.keys[2].pubkey
    };
  }
  static checkProgramId(e) {
    if (!e.equals(StakeProgram.programId))
      throw new Error("invalid instruction; programId is not StakeProgram");
  }
  static checkKeyLength(e, t) {
    if (e.length < t)
      throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
  }
}
const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: struct([u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: struct([u32("instruction")])
  },
  Split: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: struct([u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: struct([u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
}), StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
class StakeProgram {
  constructor() {
  }
  static initialize(e) {
    const {
      stakePubkey: t,
      authorized: o,
      lockup: c
    } = e, a = c || Lockup.default, d = STAKE_INSTRUCTION_LAYOUTS.Initialize, p = encodeData(d, {
      authorized: {
        staker: toBuffer(o.staker.toBuffer()),
        withdrawer: toBuffer(o.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: a.unixTimestamp,
        epoch: a.epoch,
        custodian: toBuffer(a.custodian.toBuffer())
      }
    }), w = {
      keys: [{
        pubkey: t,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }],
      programId: this.programId,
      data: p
    };
    return new TransactionInstruction(w);
  }
  static createAccountWithSeed(e) {
    const t = new Transaction();
    t.add(SystemProgram.createAccountWithSeed({
      fromPubkey: e.fromPubkey,
      newAccountPubkey: e.stakePubkey,
      basePubkey: e.basePubkey,
      seed: e.seed,
      lamports: e.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey: o,
      authorized: c,
      lockup: a
    } = e;
    return t.add(this.initialize({
      stakePubkey: o,
      authorized: c,
      lockup: a
    }));
  }
  static createAccount(e) {
    const t = new Transaction();
    t.add(SystemProgram.createAccount({
      fromPubkey: e.fromPubkey,
      newAccountPubkey: e.stakePubkey,
      lamports: e.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey: o,
      authorized: c,
      lockup: a
    } = e;
    return t.add(this.initialize({
      stakePubkey: o,
      authorized: c,
      lockup: a
    }));
  }
  static delegate(e) {
    const {
      stakePubkey: t,
      authorizedPubkey: o,
      votePubkey: c
    } = e, a = STAKE_INSTRUCTION_LAYOUTS.Delegate, d = encodeData(a);
    return new Transaction().add({
      keys: [{
        pubkey: t,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: c,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: o,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: d
    });
  }
  static authorize(e) {
    const {
      stakePubkey: t,
      authorizedPubkey: o,
      newAuthorizedPubkey: c,
      stakeAuthorizationType: a,
      custodianPubkey: d
    } = e, p = STAKE_INSTRUCTION_LAYOUTS.Authorize, w = encodeData(p, {
      newAuthorized: toBuffer(c.toBuffer()),
      stakeAuthorizationType: a.index
    }), M = [{
      pubkey: t,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: o,
      isSigner: !0,
      isWritable: !1
    }];
    return d && M.push({
      pubkey: d,
      isSigner: !1,
      isWritable: !1
    }), new Transaction().add({
      keys: M,
      programId: this.programId,
      data: w
    });
  }
  static authorizeWithSeed(e) {
    const {
      stakePubkey: t,
      authorityBase: o,
      authoritySeed: c,
      authorityOwner: a,
      newAuthorizedPubkey: d,
      stakeAuthorizationType: p,
      custodianPubkey: w
    } = e, M = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, I = encodeData(M, {
      newAuthorized: toBuffer(d.toBuffer()),
      stakeAuthorizationType: p.index,
      authoritySeed: c,
      authorityOwner: toBuffer(a.toBuffer())
    }), B = [{
      pubkey: t,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: o,
      isSigner: !0,
      isWritable: !1
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: !1,
      isWritable: !1
    }];
    return w && B.push({
      pubkey: w,
      isSigner: !1,
      isWritable: !1
    }), new Transaction().add({
      keys: B,
      programId: this.programId,
      data: I
    });
  }
  static splitInstruction(e) {
    const {
      stakePubkey: t,
      authorizedPubkey: o,
      splitStakePubkey: c,
      lamports: a
    } = e, d = STAKE_INSTRUCTION_LAYOUTS.Split, p = encodeData(d, {
      lamports: a
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: t,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: c,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: o,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: p
    });
  }
  static split(e) {
    const t = new Transaction();
    return t.add(SystemProgram.createAccount({
      fromPubkey: e.authorizedPubkey,
      newAccountPubkey: e.splitStakePubkey,
      lamports: 0,
      space: this.space,
      programId: this.programId
    })), t.add(this.splitInstruction(e));
  }
  static splitWithSeed(e) {
    const {
      stakePubkey: t,
      authorizedPubkey: o,
      splitStakePubkey: c,
      basePubkey: a,
      seed: d,
      lamports: p
    } = e, w = new Transaction();
    return w.add(SystemProgram.allocate({
      accountPubkey: c,
      basePubkey: a,
      seed: d,
      space: this.space,
      programId: this.programId
    })), w.add(this.splitInstruction({
      stakePubkey: t,
      authorizedPubkey: o,
      splitStakePubkey: c,
      lamports: p
    }));
  }
  static merge(e) {
    const {
      stakePubkey: t,
      sourceStakePubKey: o,
      authorizedPubkey: c
    } = e, a = STAKE_INSTRUCTION_LAYOUTS.Merge, d = encodeData(a);
    return new Transaction().add({
      keys: [{
        pubkey: t,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: o,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: c,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: d
    });
  }
  static withdraw(e) {
    const {
      stakePubkey: t,
      authorizedPubkey: o,
      toPubkey: c,
      lamports: a,
      custodianPubkey: d
    } = e, p = STAKE_INSTRUCTION_LAYOUTS.Withdraw, w = encodeData(p, {
      lamports: a
    }), M = [{
      pubkey: t,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: c,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: !1,
      isWritable: !1
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: !1,
      isWritable: !1
    }, {
      pubkey: o,
      isSigner: !0,
      isWritable: !1
    }];
    return d && M.push({
      pubkey: d,
      isSigner: !1,
      isWritable: !1
    }), new Transaction().add({
      keys: M,
      programId: this.programId,
      data: w
    });
  }
  static deactivate(e) {
    const {
      stakePubkey: t,
      authorizedPubkey: o
    } = e, c = STAKE_INSTRUCTION_LAYOUTS.Deactivate, a = encodeData(c);
    return new Transaction().add({
      keys: [{
        pubkey: t,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: o,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: a
    });
  }
}
StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
StakeProgram.space = 200;
class VoteInit {
  constructor(e, t, o, c) {
    this.nodePubkey = void 0, this.authorizedVoter = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.nodePubkey = e, this.authorizedVoter = t, this.authorizedWithdrawer = o, this.commission = c;
  }
}
class VoteInstruction {
  constructor() {
  }
  static decodeInstructionType(e) {
    this.checkProgramId(e.programId);
    const o = u32("instruction").decode(e.data);
    let c;
    for (const [a, d] of Object.entries(VOTE_INSTRUCTION_LAYOUTS))
      if (d.index == o) {
        c = a;
        break;
      }
    if (!c)
      throw new Error("Instruction type incorrect; not a VoteInstruction");
    return c;
  }
  static decodeInitializeAccount(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 4);
    const {
      voteInit: t
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, e.data);
    return {
      votePubkey: e.keys[0].pubkey,
      nodePubkey: e.keys[3].pubkey,
      voteInit: new VoteInit(new PublicKey(t.nodePubkey), new PublicKey(t.authorizedVoter), new PublicKey(t.authorizedWithdrawer), t.commission)
    };
  }
  static decodeAuthorize(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const {
      newAuthorized: t,
      voteAuthorizationType: o
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, e.data);
    return {
      votePubkey: e.keys[0].pubkey,
      authorizedPubkey: e.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(t),
      voteAuthorizationType: {
        index: o
      }
    };
  }
  static decodeAuthorizeWithSeed(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: t,
        currentAuthorityDerivedKeySeed: o,
        newAuthorized: c,
        voteAuthorizationType: a
      }
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, e.data);
    return {
      currentAuthorityDerivedKeyBasePubkey: e.keys[2].pubkey,
      currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(t),
      currentAuthorityDerivedKeySeed: o,
      newAuthorizedPubkey: new PublicKey(c),
      voteAuthorizationType: {
        index: a
      },
      votePubkey: e.keys[0].pubkey
    };
  }
  static decodeWithdraw(e) {
    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
    const {
      lamports: t
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, e.data);
    return {
      votePubkey: e.keys[0].pubkey,
      authorizedWithdrawerPubkey: e.keys[2].pubkey,
      lamports: t,
      toPubkey: e.keys[1].pubkey
    };
  }
  static checkProgramId(e) {
    if (!e.equals(VoteProgram.programId))
      throw new Error("invalid instruction; programId is not VoteProgram");
  }
  static checkKeyLength(e, t) {
    if (e.length < t)
      throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`);
  }
}
const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: struct([u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
}), VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
class VoteProgram {
  constructor() {
  }
  static initializeAccount(e) {
    const {
      votePubkey: t,
      nodePubkey: o,
      voteInit: c
    } = e, a = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, d = encodeData(a, {
      voteInit: {
        nodePubkey: toBuffer(c.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer(c.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer(c.authorizedWithdrawer.toBuffer()),
        commission: c.commission
      }
    }), p = {
      keys: [{
        pubkey: t,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: o,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: d
    };
    return new TransactionInstruction(p);
  }
  static createAccount(e) {
    const t = new Transaction();
    return t.add(SystemProgram.createAccount({
      fromPubkey: e.fromPubkey,
      newAccountPubkey: e.votePubkey,
      lamports: e.lamports,
      space: this.space,
      programId: this.programId
    })), t.add(this.initializeAccount({
      votePubkey: e.votePubkey,
      nodePubkey: e.voteInit.nodePubkey,
      voteInit: e.voteInit
    }));
  }
  static authorize(e) {
    const {
      votePubkey: t,
      authorizedPubkey: o,
      newAuthorizedPubkey: c,
      voteAuthorizationType: a
    } = e, d = VOTE_INSTRUCTION_LAYOUTS.Authorize, p = encodeData(d, {
      newAuthorized: toBuffer(c.toBuffer()),
      voteAuthorizationType: a.index
    }), w = [{
      pubkey: t,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: !1,
      isWritable: !1
    }, {
      pubkey: o,
      isSigner: !0,
      isWritable: !1
    }];
    return new Transaction().add({
      keys: w,
      programId: this.programId,
      data: p
    });
  }
  static authorizeWithSeed(e) {
    const {
      currentAuthorityDerivedKeyBasePubkey: t,
      currentAuthorityDerivedKeyOwnerPubkey: o,
      currentAuthorityDerivedKeySeed: c,
      newAuthorizedPubkey: a,
      voteAuthorizationType: d,
      votePubkey: p
    } = e, w = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, M = encodeData(w, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(o.toBuffer()),
        currentAuthorityDerivedKeySeed: c,
        newAuthorized: toBuffer(a.toBuffer()),
        voteAuthorizationType: d.index
      }
    }), I = [{
      pubkey: p,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: !1,
      isWritable: !1
    }, {
      pubkey: t,
      isSigner: !0,
      isWritable: !1
    }];
    return new Transaction().add({
      keys: I,
      programId: this.programId,
      data: M
    });
  }
  static withdraw(e) {
    const {
      votePubkey: t,
      authorizedWithdrawerPubkey: o,
      lamports: c,
      toPubkey: a
    } = e, d = VOTE_INSTRUCTION_LAYOUTS.Withdraw, p = encodeData(d, {
      lamports: c
    }), w = [{
      pubkey: t,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: a,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: o,
      isSigner: !0,
      isWritable: !1
    }];
    return new Transaction().add({
      keys: w,
      programId: this.programId,
      data: p
    });
  }
  static safeWithdraw(e, t, o) {
    if (e.lamports > t - o)
      throw new Error("Withdraw will leave vote account with insuffcient funds.");
    return VoteProgram.withdraw(e);
  }
}
VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
VoteProgram.space = 3731;
const VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111"), InfoString = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  keybaseUsername: optional(string())
});
class ValidatorInfo {
  constructor(e, t) {
    this.key = void 0, this.info = void 0, this.key = e, this.info = t;
  }
  static fromConfigData(e) {
    let t = [...e];
    if (decodeLength(t) !== 2)
      return null;
    const c = [];
    for (let a = 0; a < 2; a++) {
      const d = new PublicKey(t.slice(0, PUBLIC_KEY_LENGTH));
      t = t.slice(PUBLIC_KEY_LENGTH);
      const p = t.slice(0, 1)[0] === 1;
      t = t.slice(1), c.push({
        publicKey: d,
        isSigner: p
      });
    }
    if (c[0].publicKey.equals(VALIDATOR_INFO_KEY) && c[1].isSigner) {
      const a = rustString().decode(buffer.Buffer.from(t)), d = JSON.parse(a);
      return assert$d(d, InfoString), new ValidatorInfo(c[1].publicKey, d);
    }
    return null;
  }
}
const VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111"), VoteAccountLayout = struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  u8("commission"),
  nu64(),
  seq(struct([nu64("slot"), u32("confirmationCount")]), offset(u32(), -8), "votes"),
  u8("rootSlotValid"),
  nu64("rootSlot"),
  nu64(),
  seq(struct([nu64("epoch"), publicKey("authorizedVoter")]), offset(u32(), -8), "authorizedVoters"),
  struct([seq(struct([publicKey("authorizedPubkey"), nu64("epochOfLastAuthorizedSwitch"), nu64("targetEpoch")]), 32, "buf"), nu64("idx"), u8("isEmpty")], "priorVoters"),
  nu64(),
  seq(struct([nu64("epoch"), nu64("credits"), nu64("prevCredits")]), offset(u32(), -8), "epochCredits"),
  struct([nu64("slot"), nu64("timestamp")], "lastTimestamp")
]);
class VoteAccount {
  constructor(e) {
    this.nodePubkey = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.rootSlot = void 0, this.votes = void 0, this.authorizedVoters = void 0, this.priorVoters = void 0, this.epochCredits = void 0, this.lastTimestamp = void 0, this.nodePubkey = e.nodePubkey, this.authorizedWithdrawer = e.authorizedWithdrawer, this.commission = e.commission, this.rootSlot = e.rootSlot, this.votes = e.votes, this.authorizedVoters = e.authorizedVoters, this.priorVoters = e.priorVoters, this.epochCredits = e.epochCredits, this.lastTimestamp = e.lastTimestamp;
  }
  static fromAccountData(e) {
    const o = VoteAccountLayout.decode(toBuffer(e), 4);
    let c = o.rootSlot;
    return o.rootSlotValid || (c = null), new VoteAccount({
      nodePubkey: new PublicKey(o.nodePubkey),
      authorizedWithdrawer: new PublicKey(o.authorizedWithdrawer),
      commission: o.commission,
      votes: o.votes,
      rootSlot: c,
      authorizedVoters: o.authorizedVoters.map(parseAuthorizedVoter),
      priorVoters: getPriorVoters(o.priorVoters),
      epochCredits: o.epochCredits,
      lastTimestamp: o.lastTimestamp
    });
  }
}
function parseAuthorizedVoter({
  authorizedVoter: n,
  epoch: e
}) {
  return {
    epoch: e,
    authorizedVoter: new PublicKey(n)
  };
}
function parsePriorVoters({
  authorizedPubkey: n,
  epochOfLastAuthorizedSwitch: e,
  targetEpoch: t
}) {
  return {
    authorizedPubkey: new PublicKey(n),
    epochOfLastAuthorizedSwitch: e,
    targetEpoch: t
  };
}
function getPriorVoters({
  buf: n,
  idx: e,
  isEmpty: t
}) {
  return t ? [] : [...n.slice(e + 1).map(parsePriorVoters), ...n.slice(0, e).map(parsePriorVoters)];
}
const endpoint = {
  http: {
    devnet: "http://api.devnet.solana.com",
    testnet: "http://api.testnet.solana.com",
    "mainnet-beta": "http://api.mainnet-beta.solana.com/"
  },
  https: {
    devnet: "https://api.devnet.solana.com",
    testnet: "https://api.testnet.solana.com",
    "mainnet-beta": "https://api.mainnet-beta.solana.com/"
  }
};
function clusterApiUrl(n, e) {
  const t = e === !1 ? "http" : "https";
  if (!n)
    return endpoint[t].devnet;
  const o = endpoint[t][n];
  if (!o)
    throw new Error(`Unknown ${t} cluster: ${n}`);
  return o;
}
async function sendAndConfirmRawTransaction(n, e, t, o) {
  let c, a;
  t && Object.prototype.hasOwnProperty.call(t, "lastValidBlockHeight") || t && Object.prototype.hasOwnProperty.call(t, "nonceValue") ? (c = t, a = o) : a = t;
  const d = a && {
    skipPreflight: a.skipPreflight,
    preflightCommitment: a.preflightCommitment || a.commitment,
    minContextSlot: a.minContextSlot
  }, p = await n.sendRawTransaction(e, d), w = a && a.commitment, I = (await (c ? n.confirmTransaction(c, w) : n.confirmTransaction(p, w))).value;
  if (I.err)
    throw new Error(`Raw transaction ${p} failed (${JSON.stringify(I)})`);
  return p;
}
const LAMPORTS_PER_SOL = 1e9, index_browser_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Account,
  AddressLookupTableAccount,
  AddressLookupTableInstruction,
  AddressLookupTableProgram,
  Authorized,
  BLOCKHASH_CACHE_TIMEOUT_MS,
  BPF_LOADER_DEPRECATED_PROGRAM_ID,
  BPF_LOADER_PROGRAM_ID,
  BpfLoader,
  COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,
  ComputeBudgetInstruction,
  ComputeBudgetProgram,
  Connection,
  Ed25519Program,
  Enum,
  EpochSchedule,
  FeeCalculatorLayout,
  Keypair,
  LAMPORTS_PER_SOL,
  LOOKUP_TABLE_INSTRUCTION_LAYOUTS,
  Loader,
  Lockup,
  MAX_SEED_LENGTH,
  Message,
  MessageAccountKeys,
  MessageV0,
  NONCE_ACCOUNT_LENGTH,
  NonceAccount,
  PACKET_DATA_SIZE,
  PUBLIC_KEY_LENGTH,
  PublicKey,
  SIGNATURE_LENGTH_IN_BYTES,
  SOLANA_SCHEMA,
  STAKE_CONFIG_ID,
  STAKE_INSTRUCTION_LAYOUTS,
  SYSTEM_INSTRUCTION_LAYOUTS,
  SYSVAR_CLOCK_PUBKEY,
  SYSVAR_EPOCH_SCHEDULE_PUBKEY,
  SYSVAR_INSTRUCTIONS_PUBKEY,
  SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
  SYSVAR_RENT_PUBKEY,
  SYSVAR_REWARDS_PUBKEY,
  SYSVAR_SLOT_HASHES_PUBKEY,
  SYSVAR_SLOT_HISTORY_PUBKEY,
  SYSVAR_STAKE_HISTORY_PUBKEY,
  Secp256k1Program,
  SendTransactionError,
  SolanaJSONRPCError,
  SolanaJSONRPCErrorCode,
  StakeAuthorizationLayout,
  StakeInstruction,
  StakeProgram,
  Struct,
  SystemInstruction,
  SystemProgram,
  Transaction,
  TransactionExpiredBlockheightExceededError,
  TransactionExpiredNonceInvalidError,
  TransactionExpiredTimeoutError,
  TransactionInstruction,
  TransactionMessage,
  get TransactionStatus() {
    return TransactionStatus;
  },
  VALIDATOR_INFO_KEY,
  VERSION_PREFIX_MASK,
  VOTE_PROGRAM_ID,
  ValidatorInfo,
  VersionedMessage,
  VersionedTransaction,
  VoteAccount,
  VoteAuthorizationLayout,
  VoteInit,
  VoteInstruction,
  VoteProgram,
  clusterApiUrl,
  sendAndConfirmRawTransaction,
  sendAndConfirmTransaction
}, Symbol.toStringTag, { value: "Module" })), require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(index_browser_esm);
var utils$a = {}, bn$2 = { exports: {} };
(function(n) {
  (function(e, t) {
    function o(x, u) {
      if (!x)
        throw new Error(u || "Assertion failed");
    }
    function c(x, u) {
      x.super_ = u;
      var h = function() {
      };
      h.prototype = u.prototype, x.prototype = new h(), x.prototype.constructor = x;
    }
    function a(x, u, h) {
      if (a.isBN(x))
        return x;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, x !== null && ((u === "le" || u === "be") && (h = u, u = 10), this._init(x || 0, u || 10, h || "be"));
    }
    typeof e == "object" ? e.exports = a : t.BN = a, a.BN = a, a.wordSize = 26;
    var d;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? d = window.Buffer : d = require$$0$3.Buffer;
    } catch {
    }
    a.isBN = function(u) {
      return u instanceof a ? !0 : u !== null && typeof u == "object" && u.constructor.wordSize === a.wordSize && Array.isArray(u.words);
    }, a.max = function(u, h) {
      return u.cmp(h) > 0 ? u : h;
    }, a.min = function(u, h) {
      return u.cmp(h) < 0 ? u : h;
    }, a.prototype._init = function(u, h, g) {
      if (typeof u == "number")
        return this._initNumber(u, h, g);
      if (typeof u == "object")
        return this._initArray(u, h, g);
      h === "hex" && (h = 16), o(h === (h | 0) && h >= 2 && h <= 36), u = u.toString().replace(/\s+/g, "");
      var y = 0;
      u[0] === "-" && (y++, this.negative = 1), y < u.length && (h === 16 ? this._parseHex(u, y, g) : (this._parseBase(u, h, y), g === "le" && this._initArray(this.toArray(), h, g)));
    }, a.prototype._initNumber = function(u, h, g) {
      u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [
        u & 67108863,
        u / 67108864 & 67108863
      ], this.length = 2) : (o(u < 9007199254740992), this.words = [
        u & 67108863,
        u / 67108864 & 67108863,
        1
      ], this.length = 3), g === "le" && this._initArray(this.toArray(), h, g);
    }, a.prototype._initArray = function(u, h, g) {
      if (o(typeof u.length == "number"), u.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var m, _, R = 0;
      if (g === "be")
        for (y = u.length - 1, m = 0; y >= 0; y -= 3)
          _ = u[y] | u[y - 1] << 8 | u[y - 2] << 16, this.words[m] |= _ << R & 67108863, this.words[m + 1] = _ >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, m++);
      else if (g === "le")
        for (y = 0, m = 0; y < u.length; y += 3)
          _ = u[y] | u[y + 1] << 8 | u[y + 2] << 16, this.words[m] |= _ << R & 67108863, this.words[m + 1] = _ >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, m++);
      return this._strip();
    };
    function p(x, u) {
      var h = x.charCodeAt(u);
      if (h >= 48 && h <= 57)
        return h - 48;
      if (h >= 65 && h <= 70)
        return h - 55;
      if (h >= 97 && h <= 102)
        return h - 87;
      o(!1, "Invalid character in " + x);
    }
    function w(x, u, h) {
      var g = p(x, h);
      return h - 1 >= u && (g |= p(x, h - 1) << 4), g;
    }
    a.prototype._parseHex = function(u, h, g) {
      this.length = Math.ceil((u.length - h) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var m = 0, _ = 0, R;
      if (g === "be")
        for (y = u.length - 1; y >= h; y -= 2)
          R = w(u, h, y) << m, this.words[_] |= R & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= R >>> 26) : m += 8;
      else {
        var b = u.length - h;
        for (y = b % 2 === 0 ? h + 1 : h; y < u.length; y += 2)
          R = w(u, h, y) << m, this.words[_] |= R & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= R >>> 26) : m += 8;
      }
      this._strip();
    };
    function M(x, u, h, g) {
      for (var y = 0, m = 0, _ = Math.min(x.length, h), R = u; R < _; R++) {
        var b = x.charCodeAt(R) - 48;
        y *= g, b >= 49 ? m = b - 49 + 10 : b >= 17 ? m = b - 17 + 10 : m = b, o(b >= 0 && m < g, "Invalid character"), y += m;
      }
      return y;
    }
    a.prototype._parseBase = function(u, h, g) {
      this.words = [0], this.length = 1;
      for (var y = 0, m = 1; m <= 67108863; m *= h)
        y++;
      y--, m = m / h | 0;
      for (var _ = u.length - g, R = _ % y, b = Math.min(_, _ - R) + g, l = 0, v = g; v < b; v += y)
        l = M(u, v, v + y, h), this.imuln(m), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      if (R !== 0) {
        var X = 1;
        for (l = M(u, v, u.length, h), v = 0; v < R; v++)
          X *= h;
        this.imuln(X), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      }
      this._strip();
    }, a.prototype.copy = function(u) {
      u.words = new Array(this.length);
      for (var h = 0; h < this.length; h++)
        u.words[h] = this.words[h];
      u.length = this.length, u.negative = this.negative, u.red = this.red;
    };
    function I(x, u) {
      x.words = u.words, x.length = u.length, x.negative = u.negative, x.red = u.red;
    }
    if (a.prototype._move = function(u) {
      I(u, this);
    }, a.prototype.clone = function() {
      var u = new a(null);
      return this.copy(u), u;
    }, a.prototype._expand = function(u) {
      for (; this.length < u; )
        this.words[this.length++] = 0;
      return this;
    }, a.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, a.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        a.prototype[Symbol.for("nodejs.util.inspect.custom")] = B;
      } catch {
        a.prototype.inspect = B;
      }
    else
      a.prototype.inspect = B;
    function B() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var H = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], L = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], W = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    a.prototype.toString = function(u, h) {
      u = u || 10, h = h | 0 || 1;
      var g;
      if (u === 16 || u === "hex") {
        g = "";
        for (var y = 0, m = 0, _ = 0; _ < this.length; _++) {
          var R = this.words[_], b = ((R << y | m) & 16777215).toString(16);
          m = R >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, _--), m !== 0 || _ !== this.length - 1 ? g = H[6 - b.length] + b + g : g = b + g;
        }
        for (m !== 0 && (g = m.toString(16) + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      if (u === (u | 0) && u >= 2 && u <= 36) {
        var l = L[u], v = W[u];
        g = "";
        var X = this.clone();
        for (X.negative = 0; !X.isZero(); ) {
          var S = X.modrn(v).toString(u);
          X = X.idivn(v), X.isZero() ? g = S + g : g = H[l - S.length] + S + g;
        }
        for (this.isZero() && (g = "0" + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      o(!1, "Base should be between 2 and 36");
    }, a.prototype.toNumber = function() {
      var u = this.words[0];
      return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
    }, a.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, d && (a.prototype.toBuffer = function(u, h) {
      return this.toArrayLike(d, u, h);
    }), a.prototype.toArray = function(u, h) {
      return this.toArrayLike(Array, u, h);
    };
    var $ = function(u, h) {
      return u.allocUnsafe ? u.allocUnsafe(h) : new u(h);
    };
    a.prototype.toArrayLike = function(u, h, g) {
      this._strip();
      var y = this.byteLength(), m = g || Math.max(1, y);
      o(y <= m, "byte array longer than desired length"), o(m > 0, "Requested array length <= 0");
      var _ = $(u, m), R = h === "le" ? "LE" : "BE";
      return this["_toArrayLike" + R](_, y), _;
    }, a.prototype._toArrayLikeLE = function(u, h) {
      for (var g = 0, y = 0, m = 0, _ = 0; m < this.length; m++) {
        var R = this.words[m] << _ | y;
        u[g++] = R & 255, g < u.length && (u[g++] = R >> 8 & 255), g < u.length && (u[g++] = R >> 16 & 255), _ === 6 ? (g < u.length && (u[g++] = R >> 24 & 255), y = 0, _ = 0) : (y = R >>> 24, _ += 2);
      }
      if (g < u.length)
        for (u[g++] = y; g < u.length; )
          u[g++] = 0;
    }, a.prototype._toArrayLikeBE = function(u, h) {
      for (var g = u.length - 1, y = 0, m = 0, _ = 0; m < this.length; m++) {
        var R = this.words[m] << _ | y;
        u[g--] = R & 255, g >= 0 && (u[g--] = R >> 8 & 255), g >= 0 && (u[g--] = R >> 16 & 255), _ === 6 ? (g >= 0 && (u[g--] = R >> 24 & 255), y = 0, _ = 0) : (y = R >>> 24, _ += 2);
      }
      if (g >= 0)
        for (u[g--] = y; g >= 0; )
          u[g--] = 0;
    }, Math.clz32 ? a.prototype._countBits = function(u) {
      return 32 - Math.clz32(u);
    } : a.prototype._countBits = function(u) {
      var h = u, g = 0;
      return h >= 4096 && (g += 13, h >>>= 13), h >= 64 && (g += 7, h >>>= 7), h >= 8 && (g += 4, h >>>= 4), h >= 2 && (g += 2, h >>>= 2), g + h;
    }, a.prototype._zeroBits = function(u) {
      if (u === 0)
        return 26;
      var h = u, g = 0;
      return (h & 8191) === 0 && (g += 13, h >>>= 13), (h & 127) === 0 && (g += 7, h >>>= 7), (h & 15) === 0 && (g += 4, h >>>= 4), (h & 3) === 0 && (g += 2, h >>>= 2), (h & 1) === 0 && g++, g;
    }, a.prototype.bitLength = function() {
      var u = this.words[this.length - 1], h = this._countBits(u);
      return (this.length - 1) * 26 + h;
    };
    function P(x) {
      for (var u = new Array(x.bitLength()), h = 0; h < u.length; h++) {
        var g = h / 26 | 0, y = h % 26;
        u[h] = x.words[g] >>> y & 1;
      }
      return u;
    }
    a.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var u = 0, h = 0; h < this.length; h++) {
        var g = this._zeroBits(this.words[h]);
        if (u += g, g !== 26)
          break;
      }
      return u;
    }, a.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, a.prototype.toTwos = function(u) {
      return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
    }, a.prototype.fromTwos = function(u) {
      return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
    }, a.prototype.isNeg = function() {
      return this.negative !== 0;
    }, a.prototype.neg = function() {
      return this.clone().ineg();
    }, a.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, a.prototype.iuor = function(u) {
      for (; this.length < u.length; )
        this.words[this.length++] = 0;
      for (var h = 0; h < u.length; h++)
        this.words[h] = this.words[h] | u.words[h];
      return this._strip();
    }, a.prototype.ior = function(u) {
      return o((this.negative | u.negative) === 0), this.iuor(u);
    }, a.prototype.or = function(u) {
      return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
    }, a.prototype.uor = function(u) {
      return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
    }, a.prototype.iuand = function(u) {
      var h;
      this.length > u.length ? h = u : h = this;
      for (var g = 0; g < h.length; g++)
        this.words[g] = this.words[g] & u.words[g];
      return this.length = h.length, this._strip();
    }, a.prototype.iand = function(u) {
      return o((this.negative | u.negative) === 0), this.iuand(u);
    }, a.prototype.and = function(u) {
      return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
    }, a.prototype.uand = function(u) {
      return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
    }, a.prototype.iuxor = function(u) {
      var h, g;
      this.length > u.length ? (h = this, g = u) : (h = u, g = this);
      for (var y = 0; y < g.length; y++)
        this.words[y] = h.words[y] ^ g.words[y];
      if (this !== h)
        for (; y < h.length; y++)
          this.words[y] = h.words[y];
      return this.length = h.length, this._strip();
    }, a.prototype.ixor = function(u) {
      return o((this.negative | u.negative) === 0), this.iuxor(u);
    }, a.prototype.xor = function(u) {
      return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
    }, a.prototype.uxor = function(u) {
      return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
    }, a.prototype.inotn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = Math.ceil(u / 26) | 0, g = u % 26;
      this._expand(h), g > 0 && h--;
      for (var y = 0; y < h; y++)
        this.words[y] = ~this.words[y] & 67108863;
      return g > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - g), this._strip();
    }, a.prototype.notn = function(u) {
      return this.clone().inotn(u);
    }, a.prototype.setn = function(u, h) {
      o(typeof u == "number" && u >= 0);
      var g = u / 26 | 0, y = u % 26;
      return this._expand(g + 1), h ? this.words[g] = this.words[g] | 1 << y : this.words[g] = this.words[g] & ~(1 << y), this._strip();
    }, a.prototype.iadd = function(u) {
      var h;
      if (this.negative !== 0 && u.negative === 0)
        return this.negative = 0, h = this.isub(u), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && u.negative !== 0)
        return u.negative = 0, h = this.isub(u), u.negative = 1, h._normSign();
      var g, y;
      this.length > u.length ? (g = this, y = u) : (g = u, y = this);
      for (var m = 0, _ = 0; _ < y.length; _++)
        h = (g.words[_] | 0) + (y.words[_] | 0) + m, this.words[_] = h & 67108863, m = h >>> 26;
      for (; m !== 0 && _ < g.length; _++)
        h = (g.words[_] | 0) + m, this.words[_] = h & 67108863, m = h >>> 26;
      if (this.length = g.length, m !== 0)
        this.words[this.length] = m, this.length++;
      else if (g !== this)
        for (; _ < g.length; _++)
          this.words[_] = g.words[_];
      return this;
    }, a.prototype.add = function(u) {
      var h;
      return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, h = this.sub(u), u.negative ^= 1, h) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, h = u.sub(this), this.negative = 1, h) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
    }, a.prototype.isub = function(u) {
      if (u.negative !== 0) {
        u.negative = 0;
        var h = this.iadd(u);
        return u.negative = 1, h._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
      var g = this.cmp(u);
      if (g === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, m;
      g > 0 ? (y = this, m = u) : (y = u, m = this);
      for (var _ = 0, R = 0; R < m.length; R++)
        h = (y.words[R] | 0) - (m.words[R] | 0) + _, _ = h >> 26, this.words[R] = h & 67108863;
      for (; _ !== 0 && R < y.length; R++)
        h = (y.words[R] | 0) + _, _ = h >> 26, this.words[R] = h & 67108863;
      if (_ === 0 && R < y.length && y !== this)
        for (; R < y.length; R++)
          this.words[R] = y.words[R];
      return this.length = Math.max(this.length, R), y !== this && (this.negative = 1), this._strip();
    }, a.prototype.sub = function(u) {
      return this.clone().isub(u);
    };
    function U(x, u, h) {
      h.negative = u.negative ^ x.negative;
      var g = x.length + u.length | 0;
      h.length = g, g = g - 1 | 0;
      var y = x.words[0] | 0, m = u.words[0] | 0, _ = y * m, R = _ & 67108863, b = _ / 67108864 | 0;
      h.words[0] = R;
      for (var l = 1; l < g; l++) {
        for (var v = b >>> 26, X = b & 67108863, S = Math.min(l, u.length - 1), Y = Math.max(0, l - x.length + 1); Y <= S; Y++) {
          var fe = l - Y | 0;
          y = x.words[fe] | 0, m = u.words[Y] | 0, _ = y * m + X, v += _ / 67108864 | 0, X = _ & 67108863;
        }
        h.words[l] = X | 0, b = v | 0;
      }
      return b !== 0 ? h.words[l] = b | 0 : h.length--, h._strip();
    }
    var G = function(u, h, g) {
      var y = u.words, m = h.words, _ = g.words, R = 0, b, l, v, X = y[0] | 0, S = X & 8191, Y = X >>> 13, fe = y[1] | 0, oe = fe & 8191, de = fe >>> 13, Ie = y[2] | 0, ye = Ie & 8191, be = Ie >>> 13, rt = y[3] | 0, xe = rt & 8191, Ne = rt >>> 13, j = y[4] | 0, z = j & 8191, ee = j >>> 13, ve = y[5] | 0, me = ve & 8191, Ae = ve >>> 13, it = y[6] | 0, ke = it & 8191, qe = it >>> 13, or = y[7] | 0, Oe = or & 8191, T = or >>> 13, A = y[8] | 0, E = A & 8191, F = A >>> 13, ie = y[9] | 0, ne = ie & 8191, ce = ie >>> 13, nt = m[0] | 0, Be = nt & 8191, Ce = nt >>> 13, _t = m[1] | 0, Me = _t & 8191, pt = _t >>> 13, qr = m[2] | 0, Xe = qr & 8191, yt = qr >>> 13, Zr = m[3] | 0, He = Zr & 8191, dt = Zr >>> 13, Hr = m[4] | 0, Ze = Hr & 8191, mt = Hr >>> 13, zr = m[5] | 0, Qe = zr & 8191, tt = zr >>> 13, Wr = m[6] | 0, q = Wr & 8191, Q = Wr >>> 13, ae = m[7] | 0, k = ae & 8191, re = ae >>> 13, Ee = m[8] | 0, pe = Ee & 8191, _e = Ee >>> 13, bt = m[9] | 0, Te = bt & 8191, Re = bt >>> 13;
      g.negative = u.negative ^ h.negative, g.length = 19, b = Math.imul(S, Be), l = Math.imul(S, Ce), l = l + Math.imul(Y, Be) | 0, v = Math.imul(Y, Ce);
      var Dr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, b = Math.imul(oe, Be), l = Math.imul(oe, Ce), l = l + Math.imul(de, Be) | 0, v = Math.imul(de, Ce), b = b + Math.imul(S, Me) | 0, l = l + Math.imul(S, pt) | 0, l = l + Math.imul(Y, Me) | 0, v = v + Math.imul(Y, pt) | 0;
      var vt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, b = Math.imul(ye, Be), l = Math.imul(ye, Ce), l = l + Math.imul(be, Be) | 0, v = Math.imul(be, Ce), b = b + Math.imul(oe, Me) | 0, l = l + Math.imul(oe, pt) | 0, l = l + Math.imul(de, Me) | 0, v = v + Math.imul(de, pt) | 0, b = b + Math.imul(S, Xe) | 0, l = l + Math.imul(S, yt) | 0, l = l + Math.imul(Y, Xe) | 0, v = v + Math.imul(Y, yt) | 0;
      var pr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, b = Math.imul(xe, Be), l = Math.imul(xe, Ce), l = l + Math.imul(Ne, Be) | 0, v = Math.imul(Ne, Ce), b = b + Math.imul(ye, Me) | 0, l = l + Math.imul(ye, pt) | 0, l = l + Math.imul(be, Me) | 0, v = v + Math.imul(be, pt) | 0, b = b + Math.imul(oe, Xe) | 0, l = l + Math.imul(oe, yt) | 0, l = l + Math.imul(de, Xe) | 0, v = v + Math.imul(de, yt) | 0, b = b + Math.imul(S, He) | 0, l = l + Math.imul(S, dt) | 0, l = l + Math.imul(Y, He) | 0, v = v + Math.imul(Y, dt) | 0;
      var Pr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, b = Math.imul(z, Be), l = Math.imul(z, Ce), l = l + Math.imul(ee, Be) | 0, v = Math.imul(ee, Ce), b = b + Math.imul(xe, Me) | 0, l = l + Math.imul(xe, pt) | 0, l = l + Math.imul(Ne, Me) | 0, v = v + Math.imul(Ne, pt) | 0, b = b + Math.imul(ye, Xe) | 0, l = l + Math.imul(ye, yt) | 0, l = l + Math.imul(be, Xe) | 0, v = v + Math.imul(be, yt) | 0, b = b + Math.imul(oe, He) | 0, l = l + Math.imul(oe, dt) | 0, l = l + Math.imul(de, He) | 0, v = v + Math.imul(de, dt) | 0, b = b + Math.imul(S, Ze) | 0, l = l + Math.imul(S, mt) | 0, l = l + Math.imul(Y, Ze) | 0, v = v + Math.imul(Y, mt) | 0;
      var Lr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, b = Math.imul(me, Be), l = Math.imul(me, Ce), l = l + Math.imul(Ae, Be) | 0, v = Math.imul(Ae, Ce), b = b + Math.imul(z, Me) | 0, l = l + Math.imul(z, pt) | 0, l = l + Math.imul(ee, Me) | 0, v = v + Math.imul(ee, pt) | 0, b = b + Math.imul(xe, Xe) | 0, l = l + Math.imul(xe, yt) | 0, l = l + Math.imul(Ne, Xe) | 0, v = v + Math.imul(Ne, yt) | 0, b = b + Math.imul(ye, He) | 0, l = l + Math.imul(ye, dt) | 0, l = l + Math.imul(be, He) | 0, v = v + Math.imul(be, dt) | 0, b = b + Math.imul(oe, Ze) | 0, l = l + Math.imul(oe, mt) | 0, l = l + Math.imul(de, Ze) | 0, v = v + Math.imul(de, mt) | 0, b = b + Math.imul(S, Qe) | 0, l = l + Math.imul(S, tt) | 0, l = l + Math.imul(Y, Qe) | 0, v = v + Math.imul(Y, tt) | 0;
      var Kr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Kr >>> 26) | 0, Kr &= 67108863, b = Math.imul(ke, Be), l = Math.imul(ke, Ce), l = l + Math.imul(qe, Be) | 0, v = Math.imul(qe, Ce), b = b + Math.imul(me, Me) | 0, l = l + Math.imul(me, pt) | 0, l = l + Math.imul(Ae, Me) | 0, v = v + Math.imul(Ae, pt) | 0, b = b + Math.imul(z, Xe) | 0, l = l + Math.imul(z, yt) | 0, l = l + Math.imul(ee, Xe) | 0, v = v + Math.imul(ee, yt) | 0, b = b + Math.imul(xe, He) | 0, l = l + Math.imul(xe, dt) | 0, l = l + Math.imul(Ne, He) | 0, v = v + Math.imul(Ne, dt) | 0, b = b + Math.imul(ye, Ze) | 0, l = l + Math.imul(ye, mt) | 0, l = l + Math.imul(be, Ze) | 0, v = v + Math.imul(be, mt) | 0, b = b + Math.imul(oe, Qe) | 0, l = l + Math.imul(oe, tt) | 0, l = l + Math.imul(de, Qe) | 0, v = v + Math.imul(de, tt) | 0, b = b + Math.imul(S, q) | 0, l = l + Math.imul(S, Q) | 0, l = l + Math.imul(Y, q) | 0, v = v + Math.imul(Y, Q) | 0;
      var $r = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, b = Math.imul(Oe, Be), l = Math.imul(Oe, Ce), l = l + Math.imul(T, Be) | 0, v = Math.imul(T, Ce), b = b + Math.imul(ke, Me) | 0, l = l + Math.imul(ke, pt) | 0, l = l + Math.imul(qe, Me) | 0, v = v + Math.imul(qe, pt) | 0, b = b + Math.imul(me, Xe) | 0, l = l + Math.imul(me, yt) | 0, l = l + Math.imul(Ae, Xe) | 0, v = v + Math.imul(Ae, yt) | 0, b = b + Math.imul(z, He) | 0, l = l + Math.imul(z, dt) | 0, l = l + Math.imul(ee, He) | 0, v = v + Math.imul(ee, dt) | 0, b = b + Math.imul(xe, Ze) | 0, l = l + Math.imul(xe, mt) | 0, l = l + Math.imul(Ne, Ze) | 0, v = v + Math.imul(Ne, mt) | 0, b = b + Math.imul(ye, Qe) | 0, l = l + Math.imul(ye, tt) | 0, l = l + Math.imul(be, Qe) | 0, v = v + Math.imul(be, tt) | 0, b = b + Math.imul(oe, q) | 0, l = l + Math.imul(oe, Q) | 0, l = l + Math.imul(de, q) | 0, v = v + Math.imul(de, Q) | 0, b = b + Math.imul(S, k) | 0, l = l + Math.imul(S, re) | 0, l = l + Math.imul(Y, k) | 0, v = v + Math.imul(Y, re) | 0;
      var Fr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, b = Math.imul(E, Be), l = Math.imul(E, Ce), l = l + Math.imul(F, Be) | 0, v = Math.imul(F, Ce), b = b + Math.imul(Oe, Me) | 0, l = l + Math.imul(Oe, pt) | 0, l = l + Math.imul(T, Me) | 0, v = v + Math.imul(T, pt) | 0, b = b + Math.imul(ke, Xe) | 0, l = l + Math.imul(ke, yt) | 0, l = l + Math.imul(qe, Xe) | 0, v = v + Math.imul(qe, yt) | 0, b = b + Math.imul(me, He) | 0, l = l + Math.imul(me, dt) | 0, l = l + Math.imul(Ae, He) | 0, v = v + Math.imul(Ae, dt) | 0, b = b + Math.imul(z, Ze) | 0, l = l + Math.imul(z, mt) | 0, l = l + Math.imul(ee, Ze) | 0, v = v + Math.imul(ee, mt) | 0, b = b + Math.imul(xe, Qe) | 0, l = l + Math.imul(xe, tt) | 0, l = l + Math.imul(Ne, Qe) | 0, v = v + Math.imul(Ne, tt) | 0, b = b + Math.imul(ye, q) | 0, l = l + Math.imul(ye, Q) | 0, l = l + Math.imul(be, q) | 0, v = v + Math.imul(be, Q) | 0, b = b + Math.imul(oe, k) | 0, l = l + Math.imul(oe, re) | 0, l = l + Math.imul(de, k) | 0, v = v + Math.imul(de, re) | 0, b = b + Math.imul(S, pe) | 0, l = l + Math.imul(S, _e) | 0, l = l + Math.imul(Y, pe) | 0, v = v + Math.imul(Y, _e) | 0;
      var Ur = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, b = Math.imul(ne, Be), l = Math.imul(ne, Ce), l = l + Math.imul(ce, Be) | 0, v = Math.imul(ce, Ce), b = b + Math.imul(E, Me) | 0, l = l + Math.imul(E, pt) | 0, l = l + Math.imul(F, Me) | 0, v = v + Math.imul(F, pt) | 0, b = b + Math.imul(Oe, Xe) | 0, l = l + Math.imul(Oe, yt) | 0, l = l + Math.imul(T, Xe) | 0, v = v + Math.imul(T, yt) | 0, b = b + Math.imul(ke, He) | 0, l = l + Math.imul(ke, dt) | 0, l = l + Math.imul(qe, He) | 0, v = v + Math.imul(qe, dt) | 0, b = b + Math.imul(me, Ze) | 0, l = l + Math.imul(me, mt) | 0, l = l + Math.imul(Ae, Ze) | 0, v = v + Math.imul(Ae, mt) | 0, b = b + Math.imul(z, Qe) | 0, l = l + Math.imul(z, tt) | 0, l = l + Math.imul(ee, Qe) | 0, v = v + Math.imul(ee, tt) | 0, b = b + Math.imul(xe, q) | 0, l = l + Math.imul(xe, Q) | 0, l = l + Math.imul(Ne, q) | 0, v = v + Math.imul(Ne, Q) | 0, b = b + Math.imul(ye, k) | 0, l = l + Math.imul(ye, re) | 0, l = l + Math.imul(be, k) | 0, v = v + Math.imul(be, re) | 0, b = b + Math.imul(oe, pe) | 0, l = l + Math.imul(oe, _e) | 0, l = l + Math.imul(de, pe) | 0, v = v + Math.imul(de, _e) | 0, b = b + Math.imul(S, Te) | 0, l = l + Math.imul(S, Re) | 0, l = l + Math.imul(Y, Te) | 0, v = v + Math.imul(Y, Re) | 0;
      var ar = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, b = Math.imul(ne, Me), l = Math.imul(ne, pt), l = l + Math.imul(ce, Me) | 0, v = Math.imul(ce, pt), b = b + Math.imul(E, Xe) | 0, l = l + Math.imul(E, yt) | 0, l = l + Math.imul(F, Xe) | 0, v = v + Math.imul(F, yt) | 0, b = b + Math.imul(Oe, He) | 0, l = l + Math.imul(Oe, dt) | 0, l = l + Math.imul(T, He) | 0, v = v + Math.imul(T, dt) | 0, b = b + Math.imul(ke, Ze) | 0, l = l + Math.imul(ke, mt) | 0, l = l + Math.imul(qe, Ze) | 0, v = v + Math.imul(qe, mt) | 0, b = b + Math.imul(me, Qe) | 0, l = l + Math.imul(me, tt) | 0, l = l + Math.imul(Ae, Qe) | 0, v = v + Math.imul(Ae, tt) | 0, b = b + Math.imul(z, q) | 0, l = l + Math.imul(z, Q) | 0, l = l + Math.imul(ee, q) | 0, v = v + Math.imul(ee, Q) | 0, b = b + Math.imul(xe, k) | 0, l = l + Math.imul(xe, re) | 0, l = l + Math.imul(Ne, k) | 0, v = v + Math.imul(Ne, re) | 0, b = b + Math.imul(ye, pe) | 0, l = l + Math.imul(ye, _e) | 0, l = l + Math.imul(be, pe) | 0, v = v + Math.imul(be, _e) | 0, b = b + Math.imul(oe, Te) | 0, l = l + Math.imul(oe, Re) | 0, l = l + Math.imul(de, Te) | 0, v = v + Math.imul(de, Re) | 0;
      var gr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, b = Math.imul(ne, Xe), l = Math.imul(ne, yt), l = l + Math.imul(ce, Xe) | 0, v = Math.imul(ce, yt), b = b + Math.imul(E, He) | 0, l = l + Math.imul(E, dt) | 0, l = l + Math.imul(F, He) | 0, v = v + Math.imul(F, dt) | 0, b = b + Math.imul(Oe, Ze) | 0, l = l + Math.imul(Oe, mt) | 0, l = l + Math.imul(T, Ze) | 0, v = v + Math.imul(T, mt) | 0, b = b + Math.imul(ke, Qe) | 0, l = l + Math.imul(ke, tt) | 0, l = l + Math.imul(qe, Qe) | 0, v = v + Math.imul(qe, tt) | 0, b = b + Math.imul(me, q) | 0, l = l + Math.imul(me, Q) | 0, l = l + Math.imul(Ae, q) | 0, v = v + Math.imul(Ae, Q) | 0, b = b + Math.imul(z, k) | 0, l = l + Math.imul(z, re) | 0, l = l + Math.imul(ee, k) | 0, v = v + Math.imul(ee, re) | 0, b = b + Math.imul(xe, pe) | 0, l = l + Math.imul(xe, _e) | 0, l = l + Math.imul(Ne, pe) | 0, v = v + Math.imul(Ne, _e) | 0, b = b + Math.imul(ye, Te) | 0, l = l + Math.imul(ye, Re) | 0, l = l + Math.imul(be, Te) | 0, v = v + Math.imul(be, Re) | 0;
      var zt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, b = Math.imul(ne, He), l = Math.imul(ne, dt), l = l + Math.imul(ce, He) | 0, v = Math.imul(ce, dt), b = b + Math.imul(E, Ze) | 0, l = l + Math.imul(E, mt) | 0, l = l + Math.imul(F, Ze) | 0, v = v + Math.imul(F, mt) | 0, b = b + Math.imul(Oe, Qe) | 0, l = l + Math.imul(Oe, tt) | 0, l = l + Math.imul(T, Qe) | 0, v = v + Math.imul(T, tt) | 0, b = b + Math.imul(ke, q) | 0, l = l + Math.imul(ke, Q) | 0, l = l + Math.imul(qe, q) | 0, v = v + Math.imul(qe, Q) | 0, b = b + Math.imul(me, k) | 0, l = l + Math.imul(me, re) | 0, l = l + Math.imul(Ae, k) | 0, v = v + Math.imul(Ae, re) | 0, b = b + Math.imul(z, pe) | 0, l = l + Math.imul(z, _e) | 0, l = l + Math.imul(ee, pe) | 0, v = v + Math.imul(ee, _e) | 0, b = b + Math.imul(xe, Te) | 0, l = l + Math.imul(xe, Re) | 0, l = l + Math.imul(Ne, Te) | 0, v = v + Math.imul(Ne, Re) | 0;
      var lr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, b = Math.imul(ne, Ze), l = Math.imul(ne, mt), l = l + Math.imul(ce, Ze) | 0, v = Math.imul(ce, mt), b = b + Math.imul(E, Qe) | 0, l = l + Math.imul(E, tt) | 0, l = l + Math.imul(F, Qe) | 0, v = v + Math.imul(F, tt) | 0, b = b + Math.imul(Oe, q) | 0, l = l + Math.imul(Oe, Q) | 0, l = l + Math.imul(T, q) | 0, v = v + Math.imul(T, Q) | 0, b = b + Math.imul(ke, k) | 0, l = l + Math.imul(ke, re) | 0, l = l + Math.imul(qe, k) | 0, v = v + Math.imul(qe, re) | 0, b = b + Math.imul(me, pe) | 0, l = l + Math.imul(me, _e) | 0, l = l + Math.imul(Ae, pe) | 0, v = v + Math.imul(Ae, _e) | 0, b = b + Math.imul(z, Te) | 0, l = l + Math.imul(z, Re) | 0, l = l + Math.imul(ee, Te) | 0, v = v + Math.imul(ee, Re) | 0;
      var dr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, b = Math.imul(ne, Qe), l = Math.imul(ne, tt), l = l + Math.imul(ce, Qe) | 0, v = Math.imul(ce, tt), b = b + Math.imul(E, q) | 0, l = l + Math.imul(E, Q) | 0, l = l + Math.imul(F, q) | 0, v = v + Math.imul(F, Q) | 0, b = b + Math.imul(Oe, k) | 0, l = l + Math.imul(Oe, re) | 0, l = l + Math.imul(T, k) | 0, v = v + Math.imul(T, re) | 0, b = b + Math.imul(ke, pe) | 0, l = l + Math.imul(ke, _e) | 0, l = l + Math.imul(qe, pe) | 0, v = v + Math.imul(qe, _e) | 0, b = b + Math.imul(me, Te) | 0, l = l + Math.imul(me, Re) | 0, l = l + Math.imul(Ae, Te) | 0, v = v + Math.imul(Ae, Re) | 0;
      var wt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, b = Math.imul(ne, q), l = Math.imul(ne, Q), l = l + Math.imul(ce, q) | 0, v = Math.imul(ce, Q), b = b + Math.imul(E, k) | 0, l = l + Math.imul(E, re) | 0, l = l + Math.imul(F, k) | 0, v = v + Math.imul(F, re) | 0, b = b + Math.imul(Oe, pe) | 0, l = l + Math.imul(Oe, _e) | 0, l = l + Math.imul(T, pe) | 0, v = v + Math.imul(T, _e) | 0, b = b + Math.imul(ke, Te) | 0, l = l + Math.imul(ke, Re) | 0, l = l + Math.imul(qe, Te) | 0, v = v + Math.imul(qe, Re) | 0;
      var Le = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, b = Math.imul(ne, k), l = Math.imul(ne, re), l = l + Math.imul(ce, k) | 0, v = Math.imul(ce, re), b = b + Math.imul(E, pe) | 0, l = l + Math.imul(E, _e) | 0, l = l + Math.imul(F, pe) | 0, v = v + Math.imul(F, _e) | 0, b = b + Math.imul(Oe, Te) | 0, l = l + Math.imul(Oe, Re) | 0, l = l + Math.imul(T, Te) | 0, v = v + Math.imul(T, Re) | 0;
      var Fe = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, b = Math.imul(ne, pe), l = Math.imul(ne, _e), l = l + Math.imul(ce, pe) | 0, v = Math.imul(ce, _e), b = b + Math.imul(E, Te) | 0, l = l + Math.imul(E, Re) | 0, l = l + Math.imul(F, Te) | 0, v = v + Math.imul(F, Re) | 0;
      var gt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, b = Math.imul(ne, Te), l = Math.imul(ne, Re), l = l + Math.imul(ce, Te) | 0, v = Math.imul(ce, Re);
      var et = (R + b | 0) + ((l & 8191) << 13) | 0;
      return R = (v + (l >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, _[0] = Dr, _[1] = vt, _[2] = pr, _[3] = Pr, _[4] = Lr, _[5] = Kr, _[6] = $r, _[7] = Fr, _[8] = Ur, _[9] = ar, _[10] = gr, _[11] = zt, _[12] = lr, _[13] = dr, _[14] = wt, _[15] = Le, _[16] = Fe, _[17] = gt, _[18] = et, R !== 0 && (_[19] = R, g.length++), g;
    };
    Math.imul || (G = U);
    function D(x, u, h) {
      h.negative = u.negative ^ x.negative, h.length = x.length + u.length;
      for (var g = 0, y = 0, m = 0; m < h.length - 1; m++) {
        var _ = y;
        y = 0;
        for (var R = g & 67108863, b = Math.min(m, u.length - 1), l = Math.max(0, m - x.length + 1); l <= b; l++) {
          var v = m - l, X = x.words[v] | 0, S = u.words[l] | 0, Y = X * S, fe = Y & 67108863;
          _ = _ + (Y / 67108864 | 0) | 0, fe = fe + R | 0, R = fe & 67108863, _ = _ + (fe >>> 26) | 0, y += _ >>> 26, _ &= 67108863;
        }
        h.words[m] = R, g = _, _ = y;
      }
      return g !== 0 ? h.words[m] = g : h.length--, h._strip();
    }
    function Z(x, u, h) {
      return D(x, u, h);
    }
    a.prototype.mulTo = function(u, h) {
      var g, y = this.length + u.length;
      return this.length === 10 && u.length === 10 ? g = G(this, u, h) : y < 63 ? g = U(this, u, h) : y < 1024 ? g = D(this, u, h) : g = Z(this, u, h), g;
    }, a.prototype.mul = function(u) {
      var h = new a(null);
      return h.words = new Array(this.length + u.length), this.mulTo(u, h);
    }, a.prototype.mulf = function(u) {
      var h = new a(null);
      return h.words = new Array(this.length + u.length), Z(this, u, h);
    }, a.prototype.imul = function(u) {
      return this.clone().mulTo(u, this);
    }, a.prototype.imuln = function(u) {
      var h = u < 0;
      h && (u = -u), o(typeof u == "number"), o(u < 67108864);
      for (var g = 0, y = 0; y < this.length; y++) {
        var m = (this.words[y] | 0) * u, _ = (m & 67108863) + (g & 67108863);
        g >>= 26, g += m / 67108864 | 0, g += _ >>> 26, this.words[y] = _ & 67108863;
      }
      return g !== 0 && (this.words[y] = g, this.length++), h ? this.ineg() : this;
    }, a.prototype.muln = function(u) {
      return this.clone().imuln(u);
    }, a.prototype.sqr = function() {
      return this.mul(this);
    }, a.prototype.isqr = function() {
      return this.imul(this.clone());
    }, a.prototype.pow = function(u) {
      var h = P(u);
      if (h.length === 0)
        return new a(1);
      for (var g = this, y = 0; y < h.length && h[y] === 0; y++, g = g.sqr())
        ;
      if (++y < h.length)
        for (var m = g.sqr(); y < h.length; y++, m = m.sqr())
          h[y] !== 0 && (g = g.mul(m));
      return g;
    }, a.prototype.iushln = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26, y = 67108863 >>> 26 - h << 26 - h, m;
      if (h !== 0) {
        var _ = 0;
        for (m = 0; m < this.length; m++) {
          var R = this.words[m] & y, b = (this.words[m] | 0) - R << h;
          this.words[m] = b | _, _ = R >>> 26 - h;
        }
        _ && (this.words[m] = _, this.length++);
      }
      if (g !== 0) {
        for (m = this.length - 1; m >= 0; m--)
          this.words[m + g] = this.words[m];
        for (m = 0; m < g; m++)
          this.words[m] = 0;
        this.length += g;
      }
      return this._strip();
    }, a.prototype.ishln = function(u) {
      return o(this.negative === 0), this.iushln(u);
    }, a.prototype.iushrn = function(u, h, g) {
      o(typeof u == "number" && u >= 0);
      var y;
      h ? y = (h - h % 26) / 26 : y = 0;
      var m = u % 26, _ = Math.min((u - m) / 26, this.length), R = 67108863 ^ 67108863 >>> m << m, b = g;
      if (y -= _, y = Math.max(0, y), b) {
        for (var l = 0; l < _; l++)
          b.words[l] = this.words[l];
        b.length = _;
      }
      if (_ !== 0)
        if (this.length > _)
          for (this.length -= _, l = 0; l < this.length; l++)
            this.words[l] = this.words[l + _];
        else
          this.words[0] = 0, this.length = 1;
      var v = 0;
      for (l = this.length - 1; l >= 0 && (v !== 0 || l >= y); l--) {
        var X = this.words[l] | 0;
        this.words[l] = v << 26 - m | X >>> m, v = X & R;
      }
      return b && v !== 0 && (b.words[b.length++] = v), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, a.prototype.ishrn = function(u, h, g) {
      return o(this.negative === 0), this.iushrn(u, h, g);
    }, a.prototype.shln = function(u) {
      return this.clone().ishln(u);
    }, a.prototype.ushln = function(u) {
      return this.clone().iushln(u);
    }, a.prototype.shrn = function(u) {
      return this.clone().ishrn(u);
    }, a.prototype.ushrn = function(u) {
      return this.clone().iushrn(u);
    }, a.prototype.testn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26, y = 1 << h;
      if (this.length <= g)
        return !1;
      var m = this.words[g];
      return !!(m & y);
    }, a.prototype.imaskn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26;
      if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g)
        return this;
      if (h !== 0 && g++, this.length = Math.min(g, this.length), h !== 0) {
        var y = 67108863 ^ 67108863 >>> h << h;
        this.words[this.length - 1] &= y;
      }
      return this._strip();
    }, a.prototype.maskn = function(u) {
      return this.clone().imaskn(u);
    }, a.prototype.iaddn = function(u) {
      return o(typeof u == "number"), o(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
    }, a.prototype._iaddn = function(u) {
      this.words[0] += u;
      for (var h = 0; h < this.length && this.words[h] >= 67108864; h++)
        this.words[h] -= 67108864, h === this.length - 1 ? this.words[h + 1] = 1 : this.words[h + 1]++;
      return this.length = Math.max(this.length, h + 1), this;
    }, a.prototype.isubn = function(u) {
      if (o(typeof u == "number"), o(u < 67108864), u < 0)
        return this.iaddn(-u);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(u), this.negative = 1, this;
      if (this.words[0] -= u, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var h = 0; h < this.length && this.words[h] < 0; h++)
          this.words[h] += 67108864, this.words[h + 1] -= 1;
      return this._strip();
    }, a.prototype.addn = function(u) {
      return this.clone().iaddn(u);
    }, a.prototype.subn = function(u) {
      return this.clone().isubn(u);
    }, a.prototype.iabs = function() {
      return this.negative = 0, this;
    }, a.prototype.abs = function() {
      return this.clone().iabs();
    }, a.prototype._ishlnsubmul = function(u, h, g) {
      var y = u.length + g, m;
      this._expand(y);
      var _, R = 0;
      for (m = 0; m < u.length; m++) {
        _ = (this.words[m + g] | 0) + R;
        var b = (u.words[m] | 0) * h;
        _ -= b & 67108863, R = (_ >> 26) - (b / 67108864 | 0), this.words[m + g] = _ & 67108863;
      }
      for (; m < this.length - g; m++)
        _ = (this.words[m + g] | 0) + R, R = _ >> 26, this.words[m + g] = _ & 67108863;
      if (R === 0)
        return this._strip();
      for (o(R === -1), R = 0, m = 0; m < this.length; m++)
        _ = -(this.words[m] | 0) + R, R = _ >> 26, this.words[m] = _ & 67108863;
      return this.negative = 1, this._strip();
    }, a.prototype._wordDiv = function(u, h) {
      var g = this.length - u.length, y = this.clone(), m = u, _ = m.words[m.length - 1] | 0, R = this._countBits(_);
      g = 26 - R, g !== 0 && (m = m.ushln(g), y.iushln(g), _ = m.words[m.length - 1] | 0);
      var b = y.length - m.length, l;
      if (h !== "mod") {
        l = new a(null), l.length = b + 1, l.words = new Array(l.length);
        for (var v = 0; v < l.length; v++)
          l.words[v] = 0;
      }
      var X = y.clone()._ishlnsubmul(m, 1, b);
      X.negative === 0 && (y = X, l && (l.words[b] = 1));
      for (var S = b - 1; S >= 0; S--) {
        var Y = (y.words[m.length + S] | 0) * 67108864 + (y.words[m.length + S - 1] | 0);
        for (Y = Math.min(Y / _ | 0, 67108863), y._ishlnsubmul(m, Y, S); y.negative !== 0; )
          Y--, y.negative = 0, y._ishlnsubmul(m, 1, S), y.isZero() || (y.negative ^= 1);
        l && (l.words[S] = Y);
      }
      return l && l._strip(), y._strip(), h !== "div" && g !== 0 && y.iushrn(g), {
        div: l || null,
        mod: y
      };
    }, a.prototype.divmod = function(u, h, g) {
      if (o(!u.isZero()), this.isZero())
        return {
          div: new a(0),
          mod: new a(0)
        };
      var y, m, _;
      return this.negative !== 0 && u.negative === 0 ? (_ = this.neg().divmod(u, h), h !== "mod" && (y = _.div.neg()), h !== "div" && (m = _.mod.neg(), g && m.negative !== 0 && m.iadd(u)), {
        div: y,
        mod: m
      }) : this.negative === 0 && u.negative !== 0 ? (_ = this.divmod(u.neg(), h), h !== "mod" && (y = _.div.neg()), {
        div: y,
        mod: _.mod
      }) : (this.negative & u.negative) !== 0 ? (_ = this.neg().divmod(u.neg(), h), h !== "div" && (m = _.mod.neg(), g && m.negative !== 0 && m.isub(u)), {
        div: _.div,
        mod: m
      }) : u.length > this.length || this.cmp(u) < 0 ? {
        div: new a(0),
        mod: this
      } : u.length === 1 ? h === "div" ? {
        div: this.divn(u.words[0]),
        mod: null
      } : h === "mod" ? {
        div: null,
        mod: new a(this.modrn(u.words[0]))
      } : {
        div: this.divn(u.words[0]),
        mod: new a(this.modrn(u.words[0]))
      } : this._wordDiv(u, h);
    }, a.prototype.div = function(u) {
      return this.divmod(u, "div", !1).div;
    }, a.prototype.mod = function(u) {
      return this.divmod(u, "mod", !1).mod;
    }, a.prototype.umod = function(u) {
      return this.divmod(u, "mod", !0).mod;
    }, a.prototype.divRound = function(u) {
      var h = this.divmod(u);
      if (h.mod.isZero())
        return h.div;
      var g = h.div.negative !== 0 ? h.mod.isub(u) : h.mod, y = u.ushrn(1), m = u.andln(1), _ = g.cmp(y);
      return _ < 0 || m === 1 && _ === 0 ? h.div : h.div.negative !== 0 ? h.div.isubn(1) : h.div.iaddn(1);
    }, a.prototype.modrn = function(u) {
      var h = u < 0;
      h && (u = -u), o(u <= 67108863);
      for (var g = (1 << 26) % u, y = 0, m = this.length - 1; m >= 0; m--)
        y = (g * y + (this.words[m] | 0)) % u;
      return h ? -y : y;
    }, a.prototype.modn = function(u) {
      return this.modrn(u);
    }, a.prototype.idivn = function(u) {
      var h = u < 0;
      h && (u = -u), o(u <= 67108863);
      for (var g = 0, y = this.length - 1; y >= 0; y--) {
        var m = (this.words[y] | 0) + g * 67108864;
        this.words[y] = m / u | 0, g = m % u;
      }
      return this._strip(), h ? this.ineg() : this;
    }, a.prototype.divn = function(u) {
      return this.clone().idivn(u);
    }, a.prototype.egcd = function(u) {
      o(u.negative === 0), o(!u.isZero());
      var h = this, g = u.clone();
      h.negative !== 0 ? h = h.umod(u) : h = h.clone();
      for (var y = new a(1), m = new a(0), _ = new a(0), R = new a(1), b = 0; h.isEven() && g.isEven(); )
        h.iushrn(1), g.iushrn(1), ++b;
      for (var l = g.clone(), v = h.clone(); !h.isZero(); ) {
        for (var X = 0, S = 1; (h.words[0] & S) === 0 && X < 26; ++X, S <<= 1)
          ;
        if (X > 0)
          for (h.iushrn(X); X-- > 0; )
            (y.isOdd() || m.isOdd()) && (y.iadd(l), m.isub(v)), y.iushrn(1), m.iushrn(1);
        for (var Y = 0, fe = 1; (g.words[0] & fe) === 0 && Y < 26; ++Y, fe <<= 1)
          ;
        if (Y > 0)
          for (g.iushrn(Y); Y-- > 0; )
            (_.isOdd() || R.isOdd()) && (_.iadd(l), R.isub(v)), _.iushrn(1), R.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), y.isub(_), m.isub(R)) : (g.isub(h), _.isub(y), R.isub(m));
      }
      return {
        a: _,
        b: R,
        gcd: g.iushln(b)
      };
    }, a.prototype._invmp = function(u) {
      o(u.negative === 0), o(!u.isZero());
      var h = this, g = u.clone();
      h.negative !== 0 ? h = h.umod(u) : h = h.clone();
      for (var y = new a(1), m = new a(0), _ = g.clone(); h.cmpn(1) > 0 && g.cmpn(1) > 0; ) {
        for (var R = 0, b = 1; (h.words[0] & b) === 0 && R < 26; ++R, b <<= 1)
          ;
        if (R > 0)
          for (h.iushrn(R); R-- > 0; )
            y.isOdd() && y.iadd(_), y.iushrn(1);
        for (var l = 0, v = 1; (g.words[0] & v) === 0 && l < 26; ++l, v <<= 1)
          ;
        if (l > 0)
          for (g.iushrn(l); l-- > 0; )
            m.isOdd() && m.iadd(_), m.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), y.isub(m)) : (g.isub(h), m.isub(y));
      }
      var X;
      return h.cmpn(1) === 0 ? X = y : X = m, X.cmpn(0) < 0 && X.iadd(u), X;
    }, a.prototype.gcd = function(u) {
      if (this.isZero())
        return u.abs();
      if (u.isZero())
        return this.abs();
      var h = this.clone(), g = u.clone();
      h.negative = 0, g.negative = 0;
      for (var y = 0; h.isEven() && g.isEven(); y++)
        h.iushrn(1), g.iushrn(1);
      do {
        for (; h.isEven(); )
          h.iushrn(1);
        for (; g.isEven(); )
          g.iushrn(1);
        var m = h.cmp(g);
        if (m < 0) {
          var _ = h;
          h = g, g = _;
        } else if (m === 0 || g.cmpn(1) === 0)
          break;
        h.isub(g);
      } while (!0);
      return g.iushln(y);
    }, a.prototype.invm = function(u) {
      return this.egcd(u).a.umod(u);
    }, a.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, a.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, a.prototype.andln = function(u) {
      return this.words[0] & u;
    }, a.prototype.bincn = function(u) {
      o(typeof u == "number");
      var h = u % 26, g = (u - h) / 26, y = 1 << h;
      if (this.length <= g)
        return this._expand(g + 1), this.words[g] |= y, this;
      for (var m = y, _ = g; m !== 0 && _ < this.length; _++) {
        var R = this.words[_] | 0;
        R += m, m = R >>> 26, R &= 67108863, this.words[_] = R;
      }
      return m !== 0 && (this.words[_] = m, this.length++), this;
    }, a.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, a.prototype.cmpn = function(u) {
      var h = u < 0;
      if (this.negative !== 0 && !h)
        return -1;
      if (this.negative === 0 && h)
        return 1;
      this._strip();
      var g;
      if (this.length > 1)
        g = 1;
      else {
        h && (u = -u), o(u <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        g = y === u ? 0 : y < u ? -1 : 1;
      }
      return this.negative !== 0 ? -g | 0 : g;
    }, a.prototype.cmp = function(u) {
      if (this.negative !== 0 && u.negative === 0)
        return -1;
      if (this.negative === 0 && u.negative !== 0)
        return 1;
      var h = this.ucmp(u);
      return this.negative !== 0 ? -h | 0 : h;
    }, a.prototype.ucmp = function(u) {
      if (this.length > u.length)
        return 1;
      if (this.length < u.length)
        return -1;
      for (var h = 0, g = this.length - 1; g >= 0; g--) {
        var y = this.words[g] | 0, m = u.words[g] | 0;
        if (y !== m) {
          y < m ? h = -1 : y > m && (h = 1);
          break;
        }
      }
      return h;
    }, a.prototype.gtn = function(u) {
      return this.cmpn(u) === 1;
    }, a.prototype.gt = function(u) {
      return this.cmp(u) === 1;
    }, a.prototype.gten = function(u) {
      return this.cmpn(u) >= 0;
    }, a.prototype.gte = function(u) {
      return this.cmp(u) >= 0;
    }, a.prototype.ltn = function(u) {
      return this.cmpn(u) === -1;
    }, a.prototype.lt = function(u) {
      return this.cmp(u) === -1;
    }, a.prototype.lten = function(u) {
      return this.cmpn(u) <= 0;
    }, a.prototype.lte = function(u) {
      return this.cmp(u) <= 0;
    }, a.prototype.eqn = function(u) {
      return this.cmpn(u) === 0;
    }, a.prototype.eq = function(u) {
      return this.cmp(u) === 0;
    }, a.red = function(u) {
      return new O(u);
    }, a.prototype.toRed = function(u) {
      return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
    }, a.prototype.fromRed = function() {
      return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, a.prototype._forceRed = function(u) {
      return this.red = u, this;
    }, a.prototype.forceRed = function(u) {
      return o(!this.red, "Already a number in reduction context"), this._forceRed(u);
    }, a.prototype.redAdd = function(u) {
      return o(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
    }, a.prototype.redIAdd = function(u) {
      return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
    }, a.prototype.redSub = function(u) {
      return o(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
    }, a.prototype.redISub = function(u) {
      return o(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
    }, a.prototype.redShl = function(u) {
      return o(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
    }, a.prototype.redMul = function(u) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
    }, a.prototype.redIMul = function(u) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
    }, a.prototype.redSqr = function() {
      return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, a.prototype.redISqr = function() {
      return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, a.prototype.redSqrt = function() {
      return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, a.prototype.redInvm = function() {
      return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, a.prototype.redNeg = function() {
      return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, a.prototype.redPow = function(u) {
      return o(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
    };
    var J = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function te(x, u) {
      this.name = x, this.p = new a(u, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    te.prototype._tmp = function() {
      var u = new a(null);
      return u.words = new Array(Math.ceil(this.n / 13)), u;
    }, te.prototype.ireduce = function(u) {
      var h = u, g;
      do
        this.split(h, this.tmp), h = this.imulK(h), h = h.iadd(this.tmp), g = h.bitLength();
      while (g > this.n);
      var y = g < this.n ? -1 : h.ucmp(this.p);
      return y === 0 ? (h.words[0] = 0, h.length = 1) : y > 0 ? h.isub(this.p) : h.strip !== void 0 ? h.strip() : h._strip(), h;
    }, te.prototype.split = function(u, h) {
      u.iushrn(this.n, 0, h);
    }, te.prototype.imulK = function(u) {
      return u.imul(this.k);
    };
    function ue() {
      te.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    c(ue, te), ue.prototype.split = function(u, h) {
      for (var g = 4194303, y = Math.min(u.length, 9), m = 0; m < y; m++)
        h.words[m] = u.words[m];
      if (h.length = y, u.length <= 9) {
        u.words[0] = 0, u.length = 1;
        return;
      }
      var _ = u.words[9];
      for (h.words[h.length++] = _ & g, m = 10; m < u.length; m++) {
        var R = u.words[m] | 0;
        u.words[m - 10] = (R & g) << 4 | _ >>> 22, _ = R;
      }
      _ >>>= 22, u.words[m - 10] = _, _ === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
    }, ue.prototype.imulK = function(u) {
      u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
      for (var h = 0, g = 0; g < u.length; g++) {
        var y = u.words[g] | 0;
        h += y * 977, u.words[g] = h & 67108863, h = y * 64 + (h / 67108864 | 0);
      }
      return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
    };
    function he() {
      te.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    c(he, te);
    function Se() {
      te.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    c(Se, te);
    function C() {
      te.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    c(C, te), C.prototype.imulK = function(u) {
      for (var h = 0, g = 0; g < u.length; g++) {
        var y = (u.words[g] | 0) * 19 + h, m = y & 67108863;
        y >>>= 26, u.words[g] = m, h = y;
      }
      return h !== 0 && (u.words[u.length++] = h), u;
    }, a._prime = function(u) {
      if (J[u])
        return J[u];
      var h;
      if (u === "k256")
        h = new ue();
      else if (u === "p224")
        h = new he();
      else if (u === "p192")
        h = new Se();
      else if (u === "p25519")
        h = new C();
      else
        throw new Error("Unknown prime " + u);
      return J[u] = h, h;
    };
    function O(x) {
      if (typeof x == "string") {
        var u = a._prime(x);
        this.m = u.p, this.prime = u;
      } else
        o(x.gtn(1), "modulus must be greater than 1"), this.m = x, this.prime = null;
    }
    O.prototype._verify1 = function(u) {
      o(u.negative === 0, "red works only with positives"), o(u.red, "red works only with red numbers");
    }, O.prototype._verify2 = function(u, h) {
      o((u.negative | h.negative) === 0, "red works only with positives"), o(
        u.red && u.red === h.red,
        "red works only with red numbers"
      );
    }, O.prototype.imod = function(u) {
      return this.prime ? this.prime.ireduce(u)._forceRed(this) : (I(u, u.umod(this.m)._forceRed(this)), u);
    }, O.prototype.neg = function(u) {
      return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
    }, O.prototype.add = function(u, h) {
      this._verify2(u, h);
      var g = u.add(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
    }, O.prototype.iadd = function(u, h) {
      this._verify2(u, h);
      var g = u.iadd(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g;
    }, O.prototype.sub = function(u, h) {
      this._verify2(u, h);
      var g = u.sub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
    }, O.prototype.isub = function(u, h) {
      this._verify2(u, h);
      var g = u.isub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g;
    }, O.prototype.shl = function(u, h) {
      return this._verify1(u), this.imod(u.ushln(h));
    }, O.prototype.imul = function(u, h) {
      return this._verify2(u, h), this.imod(u.imul(h));
    }, O.prototype.mul = function(u, h) {
      return this._verify2(u, h), this.imod(u.mul(h));
    }, O.prototype.isqr = function(u) {
      return this.imul(u, u.clone());
    }, O.prototype.sqr = function(u) {
      return this.mul(u, u);
    }, O.prototype.sqrt = function(u) {
      if (u.isZero())
        return u.clone();
      var h = this.m.andln(3);
      if (o(h % 2 === 1), h === 3) {
        var g = this.m.add(new a(1)).iushrn(2);
        return this.pow(u, g);
      }
      for (var y = this.m.subn(1), m = 0; !y.isZero() && y.andln(1) === 0; )
        m++, y.iushrn(1);
      o(!y.isZero());
      var _ = new a(1).toRed(this), R = _.redNeg(), b = this.m.subn(1).iushrn(1), l = this.m.bitLength();
      for (l = new a(2 * l * l).toRed(this); this.pow(l, b).cmp(R) !== 0; )
        l.redIAdd(R);
      for (var v = this.pow(l, y), X = this.pow(u, y.addn(1).iushrn(1)), S = this.pow(u, y), Y = m; S.cmp(_) !== 0; ) {
        for (var fe = S, oe = 0; fe.cmp(_) !== 0; oe++)
          fe = fe.redSqr();
        o(oe < Y);
        var de = this.pow(v, new a(1).iushln(Y - oe - 1));
        X = X.redMul(de), v = de.redSqr(), S = S.redMul(v), Y = oe;
      }
      return X;
    }, O.prototype.invm = function(u) {
      var h = u._invmp(this.m);
      return h.negative !== 0 ? (h.negative = 0, this.imod(h).redNeg()) : this.imod(h);
    }, O.prototype.pow = function(u, h) {
      if (h.isZero())
        return new a(1).toRed(this);
      if (h.cmpn(1) === 0)
        return u.clone();
      var g = 4, y = new Array(1 << g);
      y[0] = new a(1).toRed(this), y[1] = u;
      for (var m = 2; m < y.length; m++)
        y[m] = this.mul(y[m - 1], u);
      var _ = y[0], R = 0, b = 0, l = h.bitLength() % 26;
      for (l === 0 && (l = 26), m = h.length - 1; m >= 0; m--) {
        for (var v = h.words[m], X = l - 1; X >= 0; X--) {
          var S = v >> X & 1;
          if (_ !== y[0] && (_ = this.sqr(_)), S === 0 && R === 0) {
            b = 0;
            continue;
          }
          R <<= 1, R |= S, b++, !(b !== g && (m !== 0 || X !== 0)) && (_ = this.mul(_, y[R]), b = 0, R = 0);
        }
        l = 26;
      }
      return _;
    }, O.prototype.convertTo = function(u) {
      var h = u.umod(this.m);
      return h === u ? h.clone() : h;
    }, O.prototype.convertFrom = function(u) {
      var h = u.clone();
      return h.red = null, h;
    }, a.mont = function(u) {
      return new V(u);
    };
    function V(x) {
      O.call(this, x), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    c(V, O), V.prototype.convertTo = function(u) {
      return this.imod(u.ushln(this.shift));
    }, V.prototype.convertFrom = function(u) {
      var h = this.imod(u.mul(this.rinv));
      return h.red = null, h;
    }, V.prototype.imul = function(u, h) {
      if (u.isZero() || h.isZero())
        return u.words[0] = 0, u.length = 1, u;
      var g = u.imul(h), y = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = g.isub(y).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, V.prototype.mul = function(u, h) {
      if (u.isZero() || h.isZero())
        return new a(0)._forceRed(this);
      var g = u.mul(h), y = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = g.isub(y).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, V.prototype.invm = function(u) {
      var h = this.imod(u._invmp(this.m).mul(this.r2));
      return h._forceRed(this);
    };
  })(n, commonjsGlobal);
})(bn$2);
const _BN = bn$2.exports, version$l = "logger/5.7.0";
let _permanentCensorErrors = !1, _censorErrors = !1;
const LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels.default, _globalLogger = null;
function _checkNormalize() {
  try {
    const n = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
      try {
        if ("test".normalize(e) !== "test")
          throw new Error("bad normalize");
      } catch {
        n.push(e);
      }
    }), n.length)
      throw new Error("missing " + n.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (n) {
    return n.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(n) {
  n.DEBUG = "DEBUG", n.INFO = "INFO", n.WARNING = "WARNING", n.ERROR = "ERROR", n.OFF = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(n) {
  n.UNKNOWN_ERROR = "UNKNOWN_ERROR", n.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", n.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", n.NETWORK_ERROR = "NETWORK_ERROR", n.SERVER_ERROR = "SERVER_ERROR", n.TIMEOUT = "TIMEOUT", n.BUFFER_OVERRUN = "BUFFER_OVERRUN", n.NUMERIC_FAULT = "NUMERIC_FAULT", n.MISSING_NEW = "MISSING_NEW", n.INVALID_ARGUMENT = "INVALID_ARGUMENT", n.MISSING_ARGUMENT = "MISSING_ARGUMENT", n.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", n.CALL_EXCEPTION = "CALL_EXCEPTION", n.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", n.NONCE_EXPIRED = "NONCE_EXPIRED", n.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", n.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", n.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", n.ACTION_REJECTED = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(e) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: e,
      writable: !1
    });
  }
  _log(e, t) {
    const o = e.toLowerCase();
    LogLevels[o] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(_logLevel > LogLevels[o]) && console.log.apply(console, t);
  }
  debug(...e) {
    this._log(Logger.levels.DEBUG, e);
  }
  info(...e) {
    this._log(Logger.levels.INFO, e);
  }
  warn(...e) {
    this._log(Logger.levels.WARNING, e);
  }
  makeError(e, t, o) {
    if (_censorErrors)
      return this.makeError("censored error", t, {});
    t || (t = Logger.errors.UNKNOWN_ERROR), o || (o = {});
    const c = [];
    Object.keys(o).forEach((w) => {
      const M = o[w];
      try {
        if (M instanceof Uint8Array) {
          let I = "";
          for (let B = 0; B < M.length; B++)
            I += HEX[M[B] >> 4], I += HEX[M[B] & 15];
          c.push(w + "=Uint8Array(0x" + I + ")");
        } else
          c.push(w + "=" + JSON.stringify(M));
      } catch {
        c.push(w + "=" + JSON.stringify(o[w].toString()));
      }
    }), c.push(`code=${t}`), c.push(`version=${this.version}`);
    const a = e;
    let d = "";
    switch (t) {
      case ErrorCode.NUMERIC_FAULT: {
        d = "NUMERIC_FAULT";
        const w = e;
        switch (w) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            d += "-" + w;
            break;
          case "negative-power":
          case "negative-width":
            d += "-unsupported";
            break;
          case "unbound-bitwise-result":
            d += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        d = t;
        break;
    }
    d && (e += " [ See: https://links.ethers.org/v5-errors-" + d + " ]"), c.length && (e += " (" + c.join(", ") + ")");
    const p = new Error(e);
    return p.reason = a, p.code = t, Object.keys(o).forEach(function(w) {
      p[w] = o[w];
    }), p;
  }
  throwError(e, t, o) {
    throw this.makeError(e, t, o);
  }
  throwArgumentError(e, t, o) {
    return this.throwError(e, Logger.errors.INVALID_ARGUMENT, {
      argument: t,
      value: o
    });
  }
  assert(e, t, o, c) {
    e || this.throwError(t, o, c);
  }
  assertArgument(e, t, o, c) {
    e || this.throwArgumentError(t, o, c);
  }
  checkNormalize(e) {
    _normalizeError && this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: _normalizeError
    });
  }
  checkSafeUint53(e, t) {
    typeof e == "number" && (t == null && (t = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(t, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: e
    }), e % 1 && this.throwError(t, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: e
    }));
  }
  checkArgumentCount(e, t, o) {
    o ? o = ": " + o : o = "", e < t && this.throwError("missing argument" + o, Logger.errors.MISSING_ARGUMENT, {
      count: e,
      expectedCount: t
    }), e > t && this.throwError("too many arguments" + o, Logger.errors.UNEXPECTED_ARGUMENT, {
      count: e,
      expectedCount: t
    });
  }
  checkNew(e, t) {
    (e === Object || e == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: t.name });
  }
  checkAbstract(e, t) {
    e === t ? this.throwError("cannot instantiate abstract class " + JSON.stringify(t.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: "new" }) : (e === Object || e == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: t.name });
  }
  static globalLogger() {
    return _globalLogger || (_globalLogger = new Logger(version$l)), _globalLogger;
  }
  static setCensorship(e, t) {
    if (!e && t && this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), _permanentCensorErrors) {
      if (!e)
        return;
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!e, _permanentCensorErrors = !!t;
  }
  static setLogLevel(e) {
    const t = LogLevels[e.toLowerCase()];
    if (t == null) {
      Logger.globalLogger().warn("invalid log level - " + e);
      return;
    }
    _logLevel = t;
  }
  static from(e) {
    return new Logger(e);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const lib_esm$k = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get LogLevel() {
    return LogLevel;
  },
  get ErrorCode() {
    return ErrorCode;
  },
  Logger
}, Symbol.toStringTag, { value: "Module" })), version$k = "bytes/5.7.0", logger$r = new Logger(version$k);
function isHexable(n) {
  return !!n.toHexString;
}
function addSlice(n) {
  return n.slice || (n.slice = function() {
    const e = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(n, e)));
  }), n;
}
function isBytesLike(n) {
  return isHexString(n) && !(n.length % 2) || isBytes(n);
}
function isInteger(n) {
  return typeof n == "number" && n == n && n % 1 === 0;
}
function isBytes(n) {
  if (n == null)
    return !1;
  if (n.constructor === Uint8Array)
    return !0;
  if (typeof n == "string" || !isInteger(n.length) || n.length < 0)
    return !1;
  for (let e = 0; e < n.length; e++) {
    const t = n[e];
    if (!isInteger(t) || t < 0 || t >= 256)
      return !1;
  }
  return !0;
}
function arrayify(n, e) {
  if (e || (e = {}), typeof n == "number") {
    logger$r.checkSafeUint53(n, "invalid arrayify value");
    const t = [];
    for (; n; )
      t.unshift(n & 255), n = parseInt(String(n / 256));
    return t.length === 0 && t.push(0), addSlice(new Uint8Array(t));
  }
  if (e.allowMissingPrefix && typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), isHexable(n) && (n = n.toHexString()), isHexString(n)) {
    let t = n.substring(2);
    t.length % 2 && (e.hexPad === "left" ? t = "0" + t : e.hexPad === "right" ? t += "0" : logger$r.throwArgumentError("hex data is odd-length", "value", n));
    const o = [];
    for (let c = 0; c < t.length; c += 2)
      o.push(parseInt(t.substring(c, c + 2), 16));
    return addSlice(new Uint8Array(o));
  }
  return isBytes(n) ? addSlice(new Uint8Array(n)) : logger$r.throwArgumentError("invalid arrayify value", "value", n);
}
function concat(n) {
  const e = n.map((c) => arrayify(c)), t = e.reduce((c, a) => c + a.length, 0), o = new Uint8Array(t);
  return e.reduce((c, a) => (o.set(a, c), c + a.length), 0), addSlice(o);
}
function stripZeros(n) {
  let e = arrayify(n);
  if (e.length === 0)
    return e;
  let t = 0;
  for (; t < e.length && e[t] === 0; )
    t++;
  return t && (e = e.slice(t)), e;
}
function zeroPad(n, e) {
  n = arrayify(n), n.length > e && logger$r.throwArgumentError("value out of range", "value", arguments[0]);
  const t = new Uint8Array(e);
  return t.set(n, e - n.length), addSlice(t);
}
function isHexString(n, e) {
  return !(typeof n != "string" || !n.match(/^0x[0-9A-Fa-f]*$/) || e && n.length !== 2 + 2 * e);
}
const HexCharacters = "0123456789abcdef";
function hexlify(n, e) {
  if (e || (e = {}), typeof n == "number") {
    logger$r.checkSafeUint53(n, "invalid hexlify value");
    let t = "";
    for (; n; )
      t = HexCharacters[n & 15] + t, n = Math.floor(n / 16);
    return t.length ? (t.length % 2 && (t = "0" + t), "0x" + t) : "0x00";
  }
  if (typeof n == "bigint")
    return n = n.toString(16), n.length % 2 ? "0x0" + n : "0x" + n;
  if (e.allowMissingPrefix && typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), isHexable(n))
    return n.toHexString();
  if (isHexString(n))
    return n.length % 2 && (e.hexPad === "left" ? n = "0x0" + n.substring(2) : e.hexPad === "right" ? n += "0" : logger$r.throwArgumentError("hex data is odd-length", "value", n)), n.toLowerCase();
  if (isBytes(n)) {
    let t = "0x";
    for (let o = 0; o < n.length; o++) {
      let c = n[o];
      t += HexCharacters[(c & 240) >> 4] + HexCharacters[c & 15];
    }
    return t;
  }
  return logger$r.throwArgumentError("invalid hexlify value", "value", n);
}
function hexDataLength(n) {
  if (typeof n != "string")
    n = hexlify(n);
  else if (!isHexString(n) || n.length % 2)
    return null;
  return (n.length - 2) / 2;
}
function hexDataSlice(n, e, t) {
  return typeof n != "string" ? n = hexlify(n) : (!isHexString(n) || n.length % 2) && logger$r.throwArgumentError("invalid hexData", "value", n), e = 2 + 2 * e, t != null ? "0x" + n.substring(e, 2 + 2 * t) : "0x" + n.substring(e);
}
function hexConcat(n) {
  let e = "0x";
  return n.forEach((t) => {
    e += hexlify(t).substring(2);
  }), e;
}
function hexValue(n) {
  const e = hexStripZeros(hexlify(n, { hexPad: "left" }));
  return e === "0x" ? "0x0" : e;
}
function hexStripZeros(n) {
  typeof n != "string" && (n = hexlify(n)), isHexString(n) || logger$r.throwArgumentError("invalid hex string", "value", n), n = n.substring(2);
  let e = 0;
  for (; e < n.length && n[e] === "0"; )
    e++;
  return "0x" + n.substring(e);
}
function hexZeroPad(n, e) {
  for (typeof n != "string" ? n = hexlify(n) : isHexString(n) || logger$r.throwArgumentError("invalid hex string", "value", n), n.length > 2 * e + 2 && logger$r.throwArgumentError("value out of range", "value", arguments[1]); n.length < 2 * e + 2; )
    n = "0x0" + n.substring(2);
  return n;
}
function splitSignature(n) {
  const e = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(n)) {
    let t = arrayify(n);
    t.length === 64 ? (e.v = 27 + (t[32] >> 7), t[32] &= 127, e.r = hexlify(t.slice(0, 32)), e.s = hexlify(t.slice(32, 64))) : t.length === 65 ? (e.r = hexlify(t.slice(0, 32)), e.s = hexlify(t.slice(32, 64)), e.v = t[64]) : logger$r.throwArgumentError("invalid signature string", "signature", n), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : logger$r.throwArgumentError("signature invalid v byte", "signature", n)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (t[32] |= 128), e._vs = hexlify(t.slice(32, 64));
  } else {
    if (e.r = n.r, e.s = n.s, e.v = n.v, e.recoveryParam = n.recoveryParam, e._vs = n._vs, e._vs != null) {
      const c = zeroPad(arrayify(e._vs), 32);
      e._vs = hexlify(c);
      const a = c[0] >= 128 ? 1 : 0;
      e.recoveryParam == null ? e.recoveryParam = a : e.recoveryParam !== a && logger$r.throwArgumentError("signature recoveryParam mismatch _vs", "signature", n), c[0] &= 127;
      const d = hexlify(c);
      e.s == null ? e.s = d : e.s !== d && logger$r.throwArgumentError("signature v mismatch _vs", "signature", n);
    }
    if (e.recoveryParam == null)
      e.v == null ? logger$r.throwArgumentError("signature missing v and recoveryParam", "signature", n) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
    else if (e.v == null)
      e.v = 27 + e.recoveryParam;
    else {
      const c = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
      e.recoveryParam !== c && logger$r.throwArgumentError("signature recoveryParam mismatch v", "signature", n);
    }
    e.r == null || !isHexString(e.r) ? logger$r.throwArgumentError("signature missing or invalid r", "signature", n) : e.r = hexZeroPad(e.r, 32), e.s == null || !isHexString(e.s) ? logger$r.throwArgumentError("signature missing or invalid s", "signature", n) : e.s = hexZeroPad(e.s, 32);
    const t = arrayify(e.s);
    t[0] >= 128 && logger$r.throwArgumentError("signature s out of range", "signature", n), e.recoveryParam && (t[0] |= 128);
    const o = hexlify(t);
    e._vs && (isHexString(e._vs) || logger$r.throwArgumentError("signature invalid _vs", "signature", n), e._vs = hexZeroPad(e._vs, 32)), e._vs == null ? e._vs = o : e._vs !== o && logger$r.throwArgumentError("signature _vs mismatch v and s", "signature", n);
  }
  return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;
}
function joinSignature(n) {
  return n = splitSignature(n), hexlify(concat([
    n.r,
    n.s,
    n.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
const lib_esm$j = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isBytesLike,
  isBytes,
  arrayify,
  concat,
  stripZeros,
  zeroPad,
  isHexString,
  hexlify,
  hexDataLength,
  hexDataSlice,
  hexConcat,
  hexValue,
  hexStripZeros,
  hexZeroPad,
  splitSignature,
  joinSignature
}, Symbol.toStringTag, { value: "Module" })), version$j = "bignumber/5.7.0";
var BN$1 = _BN.BN;
const logger$q = new Logger(version$j), _constructorGuard$3 = {}, MAX_SAFE = 9007199254740991;
function isBigNumberish(n) {
  return n != null && (BigNumber.isBigNumber(n) || typeof n == "number" && n % 1 === 0 || typeof n == "string" && !!n.match(/^-?[0-9]+$/) || isHexString(n) || typeof n == "bigint" || isBytes(n));
}
let _warnedToStringRadix = !1;
class BigNumber {
  constructor(e, t) {
    e !== _constructorGuard$3 && logger$q.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = t, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(e) {
    return toBigNumber(toBN(this).fromTwos(e));
  }
  toTwos(e) {
    return toBigNumber(toBN(this).toTwos(e));
  }
  abs() {
    return this._hex[0] === "-" ? BigNumber.from(this._hex.substring(1)) : this;
  }
  add(e) {
    return toBigNumber(toBN(this).add(toBN(e)));
  }
  sub(e) {
    return toBigNumber(toBN(this).sub(toBN(e)));
  }
  div(e) {
    return BigNumber.from(e).isZero() && throwFault$1("division-by-zero", "div"), toBigNumber(toBN(this).div(toBN(e)));
  }
  mul(e) {
    return toBigNumber(toBN(this).mul(toBN(e)));
  }
  mod(e) {
    const t = toBN(e);
    return t.isNeg() && throwFault$1("division-by-zero", "mod"), toBigNumber(toBN(this).umod(t));
  }
  pow(e) {
    const t = toBN(e);
    return t.isNeg() && throwFault$1("negative-power", "pow"), toBigNumber(toBN(this).pow(t));
  }
  and(e) {
    const t = toBN(e);
    return (this.isNegative() || t.isNeg()) && throwFault$1("unbound-bitwise-result", "and"), toBigNumber(toBN(this).and(t));
  }
  or(e) {
    const t = toBN(e);
    return (this.isNegative() || t.isNeg()) && throwFault$1("unbound-bitwise-result", "or"), toBigNumber(toBN(this).or(t));
  }
  xor(e) {
    const t = toBN(e);
    return (this.isNegative() || t.isNeg()) && throwFault$1("unbound-bitwise-result", "xor"), toBigNumber(toBN(this).xor(t));
  }
  mask(e) {
    return (this.isNegative() || e < 0) && throwFault$1("negative-width", "mask"), toBigNumber(toBN(this).maskn(e));
  }
  shl(e) {
    return (this.isNegative() || e < 0) && throwFault$1("negative-width", "shl"), toBigNumber(toBN(this).shln(e));
  }
  shr(e) {
    return (this.isNegative() || e < 0) && throwFault$1("negative-width", "shr"), toBigNumber(toBN(this).shrn(e));
  }
  eq(e) {
    return toBN(this).eq(toBN(e));
  }
  lt(e) {
    return toBN(this).lt(toBN(e));
  }
  lte(e) {
    return toBN(this).lte(toBN(e));
  }
  gt(e) {
    return toBN(this).gt(toBN(e));
  }
  gte(e) {
    return toBN(this).gte(toBN(e));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return logger$q.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? _warnedToStringRadix || (_warnedToStringRadix = !0, logger$q.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? logger$q.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {}) : logger$q.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {})), toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(e) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(e) {
    if (e instanceof BigNumber)
      return e;
    if (typeof e == "string")
      return e.match(/^-?0x[0-9a-f]+$/i) ? new BigNumber(_constructorGuard$3, toHex$1(e)) : e.match(/^-?[0-9]+$/) ? new BigNumber(_constructorGuard$3, toHex$1(new BN$1(e))) : logger$q.throwArgumentError("invalid BigNumber string", "value", e);
    if (typeof e == "number")
      return e % 1 && throwFault$1("underflow", "BigNumber.from", e), (e >= MAX_SAFE || e <= -MAX_SAFE) && throwFault$1("overflow", "BigNumber.from", e), BigNumber.from(String(e));
    const t = e;
    if (typeof t == "bigint")
      return BigNumber.from(t.toString());
    if (isBytes(t))
      return BigNumber.from(hexlify(t));
    if (t)
      if (t.toHexString) {
        const o = t.toHexString();
        if (typeof o == "string")
          return BigNumber.from(o);
      } else {
        let o = t._hex;
        if (o == null && t.type === "BigNumber" && (o = t.hex), typeof o == "string" && (isHexString(o) || o[0] === "-" && isHexString(o.substring(1))))
          return BigNumber.from(o);
      }
    return logger$q.throwArgumentError("invalid BigNumber value", "value", e);
  }
  static isBigNumber(e) {
    return !!(e && e._isBigNumber);
  }
}
function toHex$1(n) {
  if (typeof n != "string")
    return toHex$1(n.toString(16));
  if (n[0] === "-")
    return n = n.substring(1), n[0] === "-" && logger$q.throwArgumentError("invalid hex", "value", n), n = toHex$1(n), n === "0x00" ? n : "-" + n;
  if (n.substring(0, 2) !== "0x" && (n = "0x" + n), n === "0x")
    return "0x00";
  for (n.length % 2 && (n = "0x0" + n.substring(2)); n.length > 4 && n.substring(0, 4) === "0x00"; )
    n = "0x" + n.substring(4);
  return n;
}
function toBigNumber(n) {
  return BigNumber.from(toHex$1(n));
}
function toBN(n) {
  const e = BigNumber.from(n).toHexString();
  return e[0] === "-" ? new BN$1("-" + e.substring(3), 16) : new BN$1(e.substring(2), 16);
}
function throwFault$1(n, e, t) {
  const o = { fault: n, operation: e };
  return t != null && (o.value = t), logger$q.throwError(n, Logger.errors.NUMERIC_FAULT, o);
}
function _base36To16(n) {
  return new BN$1(n, 36).toString(16);
}
function _base16To36(n) {
  return new BN$1(n, 16).toString(36);
}
const logger$p = new Logger(version$j), _constructorGuard$2 = {}, Zero$2 = BigNumber.from(0), NegativeOne$2 = BigNumber.from(-1);
function throwFault(n, e, t, o) {
  const c = { fault: e, operation: t };
  return o !== void 0 && (c.value = o), logger$p.throwError(n, Logger.errors.NUMERIC_FAULT, c);
}
let zeros = "0";
for (; zeros.length < 256; )
  zeros += zeros;
function getMultiplier(n) {
  if (typeof n != "number")
    try {
      n = BigNumber.from(n).toNumber();
    } catch {
    }
  return typeof n == "number" && n >= 0 && n <= 256 && !(n % 1) ? "1" + zeros.substring(0, n) : logger$p.throwArgumentError("invalid decimal size", "decimals", n);
}
function formatFixed(n, e) {
  e == null && (e = 0);
  const t = getMultiplier(e);
  n = BigNumber.from(n);
  const o = n.lt(Zero$2);
  o && (n = n.mul(NegativeOne$2));
  let c = n.mod(t).toString();
  for (; c.length < t.length - 1; )
    c = "0" + c;
  c = c.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const a = n.div(t).toString();
  return t.length === 1 ? n = a : n = a + "." + c, o && (n = "-" + n), n;
}
function parseFixed(n, e) {
  e == null && (e = 0);
  const t = getMultiplier(e);
  (typeof n != "string" || !n.match(/^-?[0-9.]+$/)) && logger$p.throwArgumentError("invalid decimal value", "value", n);
  const o = n.substring(0, 1) === "-";
  o && (n = n.substring(1)), n === "." && logger$p.throwArgumentError("missing value", "value", n);
  const c = n.split(".");
  c.length > 2 && logger$p.throwArgumentError("too many decimal points", "value", n);
  let a = c[0], d = c[1];
  for (a || (a = "0"), d || (d = "0"); d[d.length - 1] === "0"; )
    d = d.substring(0, d.length - 1);
  for (d.length > t.length - 1 && throwFault("fractional component exceeds decimals", "underflow", "parseFixed"), d === "" && (d = "0"); d.length < t.length - 1; )
    d += "0";
  const p = BigNumber.from(a), w = BigNumber.from(d);
  let M = p.mul(t).add(w);
  return o && (M = M.mul(NegativeOne$2)), M;
}
class FixedFormat {
  constructor(e, t, o, c) {
    e !== _constructorGuard$2 && logger$p.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.signed = t, this.width = o, this.decimals = c, this.name = (t ? "" : "u") + "fixed" + String(o) + "x" + String(c), this._multiplier = getMultiplier(c), Object.freeze(this);
  }
  static from(e) {
    if (e instanceof FixedFormat)
      return e;
    typeof e == "number" && (e = `fixed128x${e}`);
    let t = !0, o = 128, c = 18;
    if (typeof e == "string") {
      if (e !== "fixed")
        if (e === "ufixed")
          t = !1;
        else {
          const a = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          a || logger$p.throwArgumentError("invalid fixed format", "format", e), t = a[1] !== "u", o = parseInt(a[2]), c = parseInt(a[3]);
        }
    } else if (e) {
      const a = (d, p, w) => e[d] == null ? w : (typeof e[d] !== p && logger$p.throwArgumentError("invalid fixed format (" + d + " not " + p + ")", "format." + d, e[d]), e[d]);
      t = a("signed", "boolean", t), o = a("width", "number", o), c = a("decimals", "number", c);
    }
    return o % 8 && logger$p.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", o), c > 80 && logger$p.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", c), new FixedFormat(_constructorGuard$2, t, o, c);
  }
}
class FixedNumber {
  constructor(e, t, o, c) {
    e !== _constructorGuard$2 && logger$p.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.format = c, this._hex = t, this._value = o, this._isFixedNumber = !0, Object.freeze(this);
  }
  _checkFormat(e) {
    this.format.name !== e.format.name && logger$p.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", e);
  }
  addUnsafe(e) {
    this._checkFormat(e);
    const t = parseFixed(this._value, this.format.decimals), o = parseFixed(e._value, e.format.decimals);
    return FixedNumber.fromValue(t.add(o), this.format.decimals, this.format);
  }
  subUnsafe(e) {
    this._checkFormat(e);
    const t = parseFixed(this._value, this.format.decimals), o = parseFixed(e._value, e.format.decimals);
    return FixedNumber.fromValue(t.sub(o), this.format.decimals, this.format);
  }
  mulUnsafe(e) {
    this._checkFormat(e);
    const t = parseFixed(this._value, this.format.decimals), o = parseFixed(e._value, e.format.decimals);
    return FixedNumber.fromValue(t.mul(o).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(e) {
    this._checkFormat(e);
    const t = parseFixed(this._value, this.format.decimals), o = parseFixed(e._value, e.format.decimals);
    return FixedNumber.fromValue(t.mul(this.format._multiplier).div(o), this.format.decimals, this.format);
  }
  floor() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let t = FixedNumber.from(e[0], this.format);
    const o = !e[1].match(/^(0*)$/);
    return this.isNegative() && o && (t = t.subUnsafe(ONE.toFormat(t.format))), t;
  }
  ceiling() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let t = FixedNumber.from(e[0], this.format);
    const o = !e[1].match(/^(0*)$/);
    return !this.isNegative() && o && (t = t.addUnsafe(ONE.toFormat(t.format))), t;
  }
  round(e) {
    e == null && (e = 0);
    const t = this.toString().split(".");
    if (t.length === 1 && t.push("0"), (e < 0 || e > 80 || e % 1) && logger$p.throwArgumentError("invalid decimal count", "decimals", e), t[1].length <= e)
      return this;
    const o = FixedNumber.from("1" + zeros.substring(0, e), this.format), c = BUMP.toFormat(this.format);
    return this.mulUnsafe(o).addUnsafe(c).floor().divUnsafe(o);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(e) {
    if (e == null)
      return this._hex;
    e % 8 && logger$p.throwArgumentError("invalid byte width", "width", e);
    const t = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(e).toHexString();
    return hexZeroPad(t, e / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(e) {
    return FixedNumber.fromString(this._value, e);
  }
  static fromValue(e, t, o) {
    return o == null && t != null && !isBigNumberish(t) && (o = t, t = null), t == null && (t = 0), o == null && (o = "fixed"), FixedNumber.fromString(formatFixed(e, t), FixedFormat.from(o));
  }
  static fromString(e, t) {
    t == null && (t = "fixed");
    const o = FixedFormat.from(t), c = parseFixed(e, o.decimals);
    !o.signed && c.lt(Zero$2) && throwFault("unsigned value cannot be negative", "overflow", "value", e);
    let a = null;
    o.signed ? a = c.toTwos(o.width).toHexString() : (a = c.toHexString(), a = hexZeroPad(a, o.width / 8));
    const d = formatFixed(c, o.decimals);
    return new FixedNumber(_constructorGuard$2, a, d, o);
  }
  static fromBytes(e, t) {
    t == null && (t = "fixed");
    const o = FixedFormat.from(t);
    if (arrayify(e).length > o.width / 8)
      throw new Error("overflow");
    let c = BigNumber.from(e);
    o.signed && (c = c.fromTwos(o.width));
    const a = c.toTwos((o.signed ? 0 : 1) + o.width).toHexString(), d = formatFixed(c, o.decimals);
    return new FixedNumber(_constructorGuard$2, a, d, o);
  }
  static from(e, t) {
    if (typeof e == "string")
      return FixedNumber.fromString(e, t);
    if (isBytes(e))
      return FixedNumber.fromBytes(e, t);
    try {
      return FixedNumber.fromValue(e, 0, t);
    } catch (o) {
      if (o.code !== Logger.errors.INVALID_ARGUMENT)
        throw o;
    }
    return logger$p.throwArgumentError("invalid FixedNumber value", "value", e);
  }
  static isFixedNumber(e) {
    return !!(e && e._isFixedNumber);
  }
}
const ONE = FixedNumber.from(1), BUMP = FixedNumber.from("0.5"), version$i = "properties/5.7.0";
var __awaiter$7 = globalThis && globalThis.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
const logger$o = new Logger(version$i);
function defineReadOnly(n, e, t) {
  Object.defineProperty(n, e, {
    enumerable: !0,
    value: t,
    writable: !1
  });
}
function getStatic(n, e) {
  for (let t = 0; t < 32; t++) {
    if (n[e])
      return n[e];
    if (!n.prototype || typeof n.prototype != "object")
      break;
    n = Object.getPrototypeOf(n.prototype).constructor;
  }
  return null;
}
function resolveProperties(n) {
  return __awaiter$7(this, void 0, void 0, function* () {
    const e = Object.keys(n).map((o) => {
      const c = n[o];
      return Promise.resolve(c).then((a) => ({ key: o, value: a }));
    });
    return (yield Promise.all(e)).reduce((o, c) => (o[c.key] = c.value, o), {});
  });
}
function checkProperties(n, e) {
  (!n || typeof n != "object") && logger$o.throwArgumentError("invalid object", "object", n), Object.keys(n).forEach((t) => {
    e[t] || logger$o.throwArgumentError("invalid object key - " + t, "transaction:" + t, n);
  });
}
function shallowCopy(n) {
  const e = {};
  for (const t in n)
    e[t] = n[t];
  return e;
}
const opaque = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function _isFrozen(n) {
  if (n == null || opaque[typeof n])
    return !0;
  if (Array.isArray(n) || typeof n == "object") {
    if (!Object.isFrozen(n))
      return !1;
    const e = Object.keys(n);
    for (let t = 0; t < e.length; t++) {
      let o = null;
      try {
        o = n[e[t]];
      } catch {
        continue;
      }
      if (!_isFrozen(o))
        return !1;
    }
    return !0;
  }
  return logger$o.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n);
}
function _deepCopy(n) {
  if (_isFrozen(n))
    return n;
  if (Array.isArray(n))
    return Object.freeze(n.map((e) => deepCopy(e)));
  if (typeof n == "object") {
    const e = {};
    for (const t in n) {
      const o = n[t];
      o !== void 0 && defineReadOnly(e, t, deepCopy(o));
    }
    return e;
  }
  return logger$o.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n);
}
function deepCopy(n) {
  return _deepCopy(n);
}
class Description {
  constructor(e) {
    for (const t in e)
      this[t] = deepCopy(e[t]);
  }
}
const lib_esm$i = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defineReadOnly,
  getStatic,
  resolveProperties,
  checkProperties,
  shallowCopy,
  deepCopy,
  Description
}, Symbol.toStringTag, { value: "Module" })), version$h = "abi/5.7.0", logger$n = new Logger(version$h), _constructorGuard$1 = {};
let ModifiersBytes = { calldata: !0, memory: !0, storage: !0 }, ModifiersNest = { calldata: !0, memory: !0 };
function checkModifier(n, e) {
  if (n === "bytes" || n === "string") {
    if (ModifiersBytes[e])
      return !0;
  } else if (n === "address") {
    if (e === "payable")
      return !0;
  } else if ((n.indexOf("[") >= 0 || n === "tuple") && ModifiersNest[e])
    return !0;
  return (ModifiersBytes[e] || e === "payable") && logger$n.throwArgumentError("invalid modifier", "name", e), !1;
}
function parseParamType(n, e) {
  let t = n;
  function o(p) {
    logger$n.throwArgumentError(`unexpected character at position ${p}`, "param", n);
  }
  n = n.replace(/\s/g, " ");
  function c(p) {
    let w = { type: "", name: "", parent: p, state: { allowType: !0 } };
    return e && (w.indexed = !1), w;
  }
  let a = { type: "", name: "", state: { allowType: !0 } }, d = a;
  for (let p = 0; p < n.length; p++) {
    let w = n[p];
    switch (w) {
      case "(":
        d.state.allowType && d.type === "" ? d.type = "tuple" : d.state.allowParams || o(p), d.state.allowType = !1, d.type = verifyType(d.type), d.components = [c(d)], d = d.components[0];
        break;
      case ")":
        delete d.state, d.name === "indexed" && (e || o(p), d.indexed = !0, d.name = ""), checkModifier(d.type, d.name) && (d.name = ""), d.type = verifyType(d.type);
        let M = d;
        d = d.parent, d || o(p), delete M.parent, d.state.allowParams = !1, d.state.allowName = !0, d.state.allowArray = !0;
        break;
      case ",":
        delete d.state, d.name === "indexed" && (e || o(p), d.indexed = !0, d.name = ""), checkModifier(d.type, d.name) && (d.name = ""), d.type = verifyType(d.type);
        let I = c(d.parent);
        d.parent.components.push(I), delete d.parent, d = I;
        break;
      case " ":
        d.state.allowType && d.type !== "" && (d.type = verifyType(d.type), delete d.state.allowType, d.state.allowName = !0, d.state.allowParams = !0), d.state.allowName && d.name !== "" && (d.name === "indexed" ? (e || o(p), d.indexed && o(p), d.indexed = !0, d.name = "") : checkModifier(d.type, d.name) ? d.name = "" : d.state.allowName = !1);
        break;
      case "[":
        d.state.allowArray || o(p), d.type += w, d.state.allowArray = !1, d.state.allowName = !1, d.state.readArray = !0;
        break;
      case "]":
        d.state.readArray || o(p), d.type += w, d.state.readArray = !1, d.state.allowArray = !0, d.state.allowName = !0;
        break;
      default:
        d.state.allowType ? (d.type += w, d.state.allowParams = !0, d.state.allowArray = !0) : d.state.allowName ? (d.name += w, delete d.state.allowArray) : d.state.readArray ? d.type += w : o(p);
    }
  }
  return d.parent && logger$n.throwArgumentError("unexpected eof", "param", n), delete a.state, d.name === "indexed" ? (e || o(t.length - 7), d.indexed && o(t.length - 7), d.indexed = !0, d.name = "") : checkModifier(d.type, d.name) && (d.name = ""), a.type = verifyType(a.type), a;
}
function populate(n, e) {
  for (let t in e)
    defineReadOnly(n, t, e[t]);
}
const FormatTypes = Object.freeze({
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
}), paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(e, t) {
    e !== _constructorGuard$1 && logger$n.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new ParamType()"
    }), populate(this, t);
    let o = this.type.match(paramTypeArray);
    o ? populate(this, {
      arrayLength: parseInt(o[2] || "-1"),
      arrayChildren: ParamType.fromObject({
        type: o[1],
        components: this.components
      }),
      baseType: "array"
    }) : populate(this, {
      arrayLength: null,
      arrayChildren: null,
      baseType: this.components != null ? "tuple" : this.type
    }), this._isParamType = !0, Object.freeze(this);
  }
  format(e) {
    if (e || (e = FormatTypes.sighash), FormatTypes[e] || logger$n.throwArgumentError("invalid format type", "format", e), e === FormatTypes.json) {
      let o = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      return typeof this.indexed == "boolean" && (o.indexed = this.indexed), this.components && (o.components = this.components.map((c) => JSON.parse(c.format(e)))), JSON.stringify(o);
    }
    let t = "";
    return this.baseType === "array" ? (t += this.arrayChildren.format(e), t += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (e !== FormatTypes.sighash && (t += this.type), t += "(" + this.components.map((o) => o.format(e)).join(e === FormatTypes.full ? ", " : ",") + ")") : t += this.type, e !== FormatTypes.sighash && (this.indexed === !0 && (t += " indexed"), e === FormatTypes.full && this.name && (t += " " + this.name)), t;
  }
  static from(e, t) {
    return typeof e == "string" ? ParamType.fromString(e, t) : ParamType.fromObject(e);
  }
  static fromObject(e) {
    return ParamType.isParamType(e) ? e : new ParamType(_constructorGuard$1, {
      name: e.name || null,
      type: verifyType(e.type),
      indexed: e.indexed == null ? null : !!e.indexed,
      components: e.components ? e.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(e, t) {
    function o(c) {
      return ParamType.fromObject({
        name: c.name,
        type: c.type,
        indexed: c.indexed,
        components: c.components
      });
    }
    return o(parseParamType(e, !!t));
  }
  static isParamType(e) {
    return !!(e != null && e._isParamType);
  }
}
function parseParams(n, e) {
  return splitNesting(n).map((t) => ParamType.fromString(t, e));
}
class Fragment {
  constructor(e, t) {
    e !== _constructorGuard$1 && logger$n.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new Fragment()"
    }), populate(this, t), this._isFragment = !0, Object.freeze(this);
  }
  static from(e) {
    return Fragment.isFragment(e) ? e : typeof e == "string" ? Fragment.fromString(e) : Fragment.fromObject(e);
  }
  static fromObject(e) {
    if (Fragment.isFragment(e))
      return e;
    switch (e.type) {
      case "function":
        return FunctionFragment.fromObject(e);
      case "event":
        return EventFragment.fromObject(e);
      case "constructor":
        return ConstructorFragment.fromObject(e);
      case "error":
        return ErrorFragment.fromObject(e);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$n.throwArgumentError("invalid fragment object", "value", e);
  }
  static fromString(e) {
    return e = e.replace(/\s/g, " "), e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), e = e.trim(), e.split(" ")[0] === "event" ? EventFragment.fromString(e.substring(5).trim()) : e.split(" ")[0] === "function" ? FunctionFragment.fromString(e.substring(8).trim()) : e.split("(")[0].trim() === "constructor" ? ConstructorFragment.fromString(e.trim()) : e.split(" ")[0] === "error" ? ErrorFragment.fromString(e.substring(5).trim()) : logger$n.throwArgumentError("unsupported fragment", "value", e);
  }
  static isFragment(e) {
    return !!(e && e._isFragment);
  }
}
class EventFragment extends Fragment {
  format(e) {
    if (e || (e = FormatTypes.sighash), FormatTypes[e] || logger$n.throwArgumentError("invalid format type", "format", e), e === FormatTypes.json)
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((o) => JSON.parse(o.format(e)))
      });
    let t = "";
    return e !== FormatTypes.sighash && (t += "event "), t += this.name + "(" + this.inputs.map((o) => o.format(e)).join(e === FormatTypes.full ? ", " : ",") + ") ", e !== FormatTypes.sighash && this.anonymous && (t += "anonymous "), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? EventFragment.fromString(e) : EventFragment.fromObject(e);
  }
  static fromObject(e) {
    if (EventFragment.isEventFragment(e))
      return e;
    e.type !== "event" && logger$n.throwArgumentError("invalid event object", "value", e);
    const t = {
      name: verifyIdentifier(e.name),
      anonymous: e.anonymous,
      inputs: e.inputs ? e.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$1, t);
  }
  static fromString(e) {
    let t = e.match(regexParen);
    t || logger$n.throwArgumentError("invalid event string", "value", e);
    let o = !1;
    return t[3].split(" ").forEach((c) => {
      switch (c.trim()) {
        case "anonymous":
          o = !0;
          break;
        case "":
          break;
        default:
          logger$n.warn("unknown modifier: " + c);
      }
    }), EventFragment.fromObject({
      name: t[1].trim(),
      anonymous: o,
      inputs: parseParams(t[2], !0),
      type: "event"
    });
  }
  static isEventFragment(e) {
    return e && e._isFragment && e.type === "event";
  }
}
function parseGas(n, e) {
  e.gas = null;
  let t = n.split("@");
  return t.length !== 1 ? (t.length > 2 && logger$n.throwArgumentError("invalid human-readable ABI signature", "value", n), t[1].match(/^[0-9]+$/) || logger$n.throwArgumentError("invalid human-readable ABI signature gas", "value", n), e.gas = BigNumber.from(t[1]), t[0]) : n;
}
function parseModifiers(n, e) {
  e.constant = !1, e.payable = !1, e.stateMutability = "nonpayable", n.split(" ").forEach((t) => {
    switch (t.trim()) {
      case "constant":
        e.constant = !0;
        break;
      case "payable":
        e.payable = !0, e.stateMutability = "payable";
        break;
      case "nonpayable":
        e.payable = !1, e.stateMutability = "nonpayable";
        break;
      case "pure":
        e.constant = !0, e.stateMutability = "pure";
        break;
      case "view":
        e.constant = !0, e.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + t);
    }
  });
}
function verifyState(n) {
  let e = {
    constant: !1,
    payable: !0,
    stateMutability: "payable"
  };
  return n.stateMutability != null ? (e.stateMutability = n.stateMutability, e.constant = e.stateMutability === "view" || e.stateMutability === "pure", n.constant != null && !!n.constant !== e.constant && logger$n.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", n), e.payable = e.stateMutability === "payable", n.payable != null && !!n.payable !== e.payable && logger$n.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", n)) : n.payable != null ? (e.payable = !!n.payable, n.constant == null && !e.payable && n.type !== "constructor" && logger$n.throwArgumentError("unable to determine stateMutability", "value", n), e.constant = !!n.constant, e.constant ? e.stateMutability = "view" : e.stateMutability = e.payable ? "payable" : "nonpayable", e.payable && e.constant && logger$n.throwArgumentError("cannot have constant payable function", "value", n)) : n.constant != null ? (e.constant = !!n.constant, e.payable = !e.constant, e.stateMutability = e.constant ? "view" : "payable") : n.type !== "constructor" && logger$n.throwArgumentError("unable to determine stateMutability", "value", n), e;
}
class ConstructorFragment extends Fragment {
  format(e) {
    if (e || (e = FormatTypes.sighash), FormatTypes[e] || logger$n.throwArgumentError("invalid format type", "format", e), e === FormatTypes.json)
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((o) => JSON.parse(o.format(e)))
      });
    e === FormatTypes.sighash && logger$n.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "format(sighash)"
    });
    let t = "constructor(" + this.inputs.map((o) => o.format(e)).join(e === FormatTypes.full ? ", " : ",") + ") ";
    return this.stateMutability && this.stateMutability !== "nonpayable" && (t += this.stateMutability + " "), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? ConstructorFragment.fromString(e) : ConstructorFragment.fromObject(e);
  }
  static fromObject(e) {
    if (ConstructorFragment.isConstructorFragment(e))
      return e;
    e.type !== "constructor" && logger$n.throwArgumentError("invalid constructor object", "value", e);
    let t = verifyState(e);
    t.constant && logger$n.throwArgumentError("constructor cannot be constant", "value", e);
    const o = {
      name: null,
      type: e.type,
      inputs: e.inputs ? e.inputs.map(ParamType.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? BigNumber.from(e.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$1, o);
  }
  static fromString(e) {
    let t = { type: "constructor" };
    e = parseGas(e, t);
    let o = e.match(regexParen);
    return (!o || o[1].trim() !== "constructor") && logger$n.throwArgumentError("invalid constructor string", "value", e), t.inputs = parseParams(o[2].trim(), !1), parseModifiers(o[3].trim(), t), ConstructorFragment.fromObject(t);
  }
  static isConstructorFragment(e) {
    return e && e._isFragment && e.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(e) {
    if (e || (e = FormatTypes.sighash), FormatTypes[e] || logger$n.throwArgumentError("invalid format type", "format", e), e === FormatTypes.json)
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((o) => JSON.parse(o.format(e))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(e)))
      });
    let t = "";
    return e !== FormatTypes.sighash && (t += "function "), t += this.name + "(" + this.inputs.map((o) => o.format(e)).join(e === FormatTypes.full ? ", " : ",") + ") ", e !== FormatTypes.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (t += this.stateMutability + " ") : this.constant && (t += "view "), this.outputs && this.outputs.length && (t += "returns (" + this.outputs.map((o) => o.format(e)).join(", ") + ") "), this.gas != null && (t += "@" + this.gas.toString() + " ")), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? FunctionFragment.fromString(e) : FunctionFragment.fromObject(e);
  }
  static fromObject(e) {
    if (FunctionFragment.isFunctionFragment(e))
      return e;
    e.type !== "function" && logger$n.throwArgumentError("invalid function object", "value", e);
    let t = verifyState(e);
    const o = {
      type: e.type,
      name: verifyIdentifier(e.name),
      constant: t.constant,
      inputs: e.inputs ? e.inputs.map(ParamType.fromObject) : [],
      outputs: e.outputs ? e.outputs.map(ParamType.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? BigNumber.from(e.gas) : null
    };
    return new FunctionFragment(_constructorGuard$1, o);
  }
  static fromString(e) {
    let t = { type: "function" };
    e = parseGas(e, t);
    let o = e.split(" returns ");
    o.length > 2 && logger$n.throwArgumentError("invalid function string", "value", e);
    let c = o[0].match(regexParen);
    if (c || logger$n.throwArgumentError("invalid function signature", "value", e), t.name = c[1].trim(), t.name && verifyIdentifier(t.name), t.inputs = parseParams(c[2], !1), parseModifiers(c[3].trim(), t), o.length > 1) {
      let a = o[1].match(regexParen);
      (a[1].trim() != "" || a[3].trim() != "") && logger$n.throwArgumentError("unexpected tokens", "value", e), t.outputs = parseParams(a[2], !1);
    } else
      t.outputs = [];
    return FunctionFragment.fromObject(t);
  }
  static isFunctionFragment(e) {
    return e && e._isFragment && e.type === "function";
  }
}
function checkForbidden(n) {
  const e = n.format();
  return (e === "Error(string)" || e === "Panic(uint256)") && logger$n.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", n), n;
}
class ErrorFragment extends Fragment {
  format(e) {
    if (e || (e = FormatTypes.sighash), FormatTypes[e] || logger$n.throwArgumentError("invalid format type", "format", e), e === FormatTypes.json)
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((o) => JSON.parse(o.format(e)))
      });
    let t = "";
    return e !== FormatTypes.sighash && (t += "error "), t += this.name + "(" + this.inputs.map((o) => o.format(e)).join(e === FormatTypes.full ? ", " : ",") + ") ", t.trim();
  }
  static from(e) {
    return typeof e == "string" ? ErrorFragment.fromString(e) : ErrorFragment.fromObject(e);
  }
  static fromObject(e) {
    if (ErrorFragment.isErrorFragment(e))
      return e;
    e.type !== "error" && logger$n.throwArgumentError("invalid error object", "value", e);
    const t = {
      type: e.type,
      name: verifyIdentifier(e.name),
      inputs: e.inputs ? e.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$1, t));
  }
  static fromString(e) {
    let t = { type: "error" }, o = e.match(regexParen);
    return o || logger$n.throwArgumentError("invalid error signature", "value", e), t.name = o[1].trim(), t.name && verifyIdentifier(t.name), t.inputs = parseParams(o[2], !1), checkForbidden(ErrorFragment.fromObject(t));
  }
  static isErrorFragment(e) {
    return e && e._isFragment && e.type === "error";
  }
}
function verifyType(n) {
  return n.match(/^uint($|[^1-9])/) ? n = "uint256" + n.substring(4) : n.match(/^int($|[^1-9])/) && (n = "int256" + n.substring(3)), n;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(n) {
  return (!n || !n.match(regexIdentifier)) && logger$n.throwArgumentError(`invalid identifier "${n}"`, "value", n), n;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(n) {
  n = n.trim();
  let e = [], t = "", o = 0;
  for (let c = 0; c < n.length; c++) {
    let a = n[c];
    a === "," && o === 0 ? (e.push(t), t = "") : (t += a, a === "(" ? o++ : a === ")" && (o--, o === -1 && logger$n.throwArgumentError("unbalanced parenthesis", "value", n)));
  }
  return t && e.push(t), e;
}
const logger$m = new Logger(version$h);
function checkResultErrors(n) {
  const e = [], t = function(o, c) {
    if (!!Array.isArray(c))
      for (let a in c) {
        const d = o.slice();
        d.push(a);
        try {
          t(d, c[a]);
        } catch (p) {
          e.push({ path: d, error: p });
        }
      }
  };
  return t([], n), e;
}
class Coder {
  constructor(e, t, o, c) {
    this.name = e, this.type = t, this.localName = o, this.dynamic = c;
  }
  _throwError(e, t) {
    logger$m.throwArgumentError(e, this.localName, t);
  }
}
class Writer {
  constructor(e) {
    defineReadOnly(this, "wordSize", e || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(e);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(e) {
    return this._data.push(e), this._dataLength += e.length, e.length;
  }
  appendWriter(e) {
    return this._writeData(concat(e._data));
  }
  writeBytes(e) {
    let t = arrayify(e);
    const o = t.length % this.wordSize;
    return o && (t = concat([t, this._padding.slice(o)])), this._writeData(t);
  }
  _getValue(e) {
    let t = arrayify(BigNumber.from(e));
    return t.length > this.wordSize && logger$m.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
      length: this.wordSize,
      offset: t.length
    }), t.length % this.wordSize && (t = concat([this._padding.slice(t.length % this.wordSize), t])), t;
  }
  writeValue(e) {
    return this._writeData(this._getValue(e));
  }
  writeUpdatableValue() {
    const e = this._data.length;
    return this._data.push(this._padding), this._dataLength += this.wordSize, (t) => {
      this._data[e] = this._getValue(t);
    };
  }
}
class Reader {
  constructor(e, t, o, c) {
    defineReadOnly(this, "_data", arrayify(e)), defineReadOnly(this, "wordSize", t || 32), defineReadOnly(this, "_coerceFunc", o), defineReadOnly(this, "allowLoose", c), this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(e, t) {
    let o = e.match("^u?int([0-9]+)$");
    return o && parseInt(o[1]) <= 48 && (t = t.toNumber()), t;
  }
  coerce(e, t) {
    return this._coerceFunc ? this._coerceFunc(e, t) : Reader.coerce(e, t);
  }
  _peekBytes(e, t, o) {
    let c = Math.ceil(t / this.wordSize) * this.wordSize;
    return this._offset + c > this._data.length && (this.allowLoose && o && this._offset + t <= this._data.length ? c = t : logger$m.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
      length: this._data.length,
      offset: this._offset + c
    })), this._data.slice(this._offset, this._offset + c);
  }
  subReader(e) {
    return new Reader(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(e, t) {
    let o = this._peekBytes(0, e, !!t);
    return this._offset += o.length, o.slice(0, e);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}
var sha3$1 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(n) {
  (function() {
    var e = "input is invalid type", t = "finalize already called", o = typeof window == "object", c = o ? window : {};
    c.JS_SHA3_NO_WINDOW && (o = !1);
    var a = !o && typeof self == "object", d = !c.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    d ? c = commonjsGlobal : a && (c = self);
    var p = !c.JS_SHA3_NO_COMMON_JS && !0 && n.exports, w = !c.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", M = "0123456789abcdef".split(""), I = [31, 7936, 2031616, 520093696], B = [4, 1024, 262144, 67108864], H = [1, 256, 65536, 16777216], L = [6, 1536, 393216, 100663296], W = [0, 8, 16, 24], $ = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], P = [224, 256, 384, 512], U = [128, 256], G = ["hex", "buffer", "arrayBuffer", "array", "digest"], D = {
      128: 168,
      256: 136
    };
    (c.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(S) {
      return Object.prototype.toString.call(S) === "[object Array]";
    }), w && (c.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(S) {
      return typeof S == "object" && S.buffer && S.buffer.constructor === ArrayBuffer;
    });
    for (var Z = function(S, Y, fe) {
      return function(oe) {
        return new l(S, Y, S).update(oe)[fe]();
      };
    }, J = function(S, Y, fe) {
      return function(oe, de) {
        return new l(S, Y, de).update(oe)[fe]();
      };
    }, te = function(S, Y, fe) {
      return function(oe, de, Ie, ye) {
        return u["cshake" + S].update(oe, de, Ie, ye)[fe]();
      };
    }, ue = function(S, Y, fe) {
      return function(oe, de, Ie, ye) {
        return u["kmac" + S].update(oe, de, Ie, ye)[fe]();
      };
    }, he = function(S, Y, fe, oe) {
      for (var de = 0; de < G.length; ++de) {
        var Ie = G[de];
        S[Ie] = Y(fe, oe, Ie);
      }
      return S;
    }, Se = function(S, Y) {
      var fe = Z(S, Y, "hex");
      return fe.create = function() {
        return new l(S, Y, S);
      }, fe.update = function(oe) {
        return fe.create().update(oe);
      }, he(fe, Z, S, Y);
    }, C = function(S, Y) {
      var fe = J(S, Y, "hex");
      return fe.create = function(oe) {
        return new l(S, Y, oe);
      }, fe.update = function(oe, de) {
        return fe.create(de).update(oe);
      }, he(fe, J, S, Y);
    }, O = function(S, Y) {
      var fe = D[S], oe = te(S, Y, "hex");
      return oe.create = function(de, Ie, ye) {
        return !Ie && !ye ? u["shake" + S].create(de) : new l(S, Y, de).bytepad([Ie, ye], fe);
      }, oe.update = function(de, Ie, ye, be) {
        return oe.create(Ie, ye, be).update(de);
      }, he(oe, te, S, Y);
    }, V = function(S, Y) {
      var fe = D[S], oe = ue(S, Y, "hex");
      return oe.create = function(de, Ie, ye) {
        return new v(S, Y, Ie).bytepad(["KMAC", ye], fe).bytepad([de], fe);
      }, oe.update = function(de, Ie, ye, be) {
        return oe.create(de, ye, be).update(Ie);
      }, he(oe, ue, S, Y);
    }, x = [
      { name: "keccak", padding: H, bits: P, createMethod: Se },
      { name: "sha3", padding: L, bits: P, createMethod: Se },
      { name: "shake", padding: I, bits: U, createMethod: C },
      { name: "cshake", padding: B, bits: U, createMethod: O },
      { name: "kmac", padding: B, bits: U, createMethod: V }
    ], u = {}, h = [], g = 0; g < x.length; ++g)
      for (var y = x[g], m = y.bits, _ = 0; _ < m.length; ++_) {
        var R = y.name + "_" + m[_];
        if (h.push(R), u[R] = y.createMethod(m[_], y.padding), y.name !== "sha3") {
          var b = y.name + m[_];
          h.push(b), u[b] = u[R];
        }
      }
    function l(S, Y, fe) {
      this.blocks = [], this.s = [], this.padding = Y, this.outputBits = fe, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (S << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = fe >> 5, this.extraBytes = (fe & 31) >> 3;
      for (var oe = 0; oe < 50; ++oe)
        this.s[oe] = 0;
    }
    l.prototype.update = function(S) {
      if (this.finalized)
        throw new Error(t);
      var Y, fe = typeof S;
      if (fe !== "string") {
        if (fe === "object") {
          if (S === null)
            throw new Error(e);
          if (w && S.constructor === ArrayBuffer)
            S = new Uint8Array(S);
          else if (!Array.isArray(S) && (!w || !ArrayBuffer.isView(S)))
            throw new Error(e);
        } else
          throw new Error(e);
        Y = !0;
      }
      for (var oe = this.blocks, de = this.byteCount, Ie = S.length, ye = this.blockCount, be = 0, rt = this.s, xe, Ne; be < Ie; ) {
        if (this.reset)
          for (this.reset = !1, oe[0] = this.block, xe = 1; xe < ye + 1; ++xe)
            oe[xe] = 0;
        if (Y)
          for (xe = this.start; be < Ie && xe < de; ++be)
            oe[xe >> 2] |= S[be] << W[xe++ & 3];
        else
          for (xe = this.start; be < Ie && xe < de; ++be)
            Ne = S.charCodeAt(be), Ne < 128 ? oe[xe >> 2] |= Ne << W[xe++ & 3] : Ne < 2048 ? (oe[xe >> 2] |= (192 | Ne >> 6) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne & 63) << W[xe++ & 3]) : Ne < 55296 || Ne >= 57344 ? (oe[xe >> 2] |= (224 | Ne >> 12) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne >> 6 & 63) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne & 63) << W[xe++ & 3]) : (Ne = 65536 + ((Ne & 1023) << 10 | S.charCodeAt(++be) & 1023), oe[xe >> 2] |= (240 | Ne >> 18) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne >> 12 & 63) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne >> 6 & 63) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne & 63) << W[xe++ & 3]);
        if (this.lastByteIndex = xe, xe >= de) {
          for (this.start = xe - de, this.block = oe[ye], xe = 0; xe < ye; ++xe)
            rt[xe] ^= oe[xe];
          X(rt), this.reset = !0;
        } else
          this.start = xe;
      }
      return this;
    }, l.prototype.encode = function(S, Y) {
      var fe = S & 255, oe = 1, de = [fe];
      for (S = S >> 8, fe = S & 255; fe > 0; )
        de.unshift(fe), S = S >> 8, fe = S & 255, ++oe;
      return Y ? de.push(oe) : de.unshift(oe), this.update(de), de.length;
    }, l.prototype.encodeString = function(S) {
      var Y, fe = typeof S;
      if (fe !== "string") {
        if (fe === "object") {
          if (S === null)
            throw new Error(e);
          if (w && S.constructor === ArrayBuffer)
            S = new Uint8Array(S);
          else if (!Array.isArray(S) && (!w || !ArrayBuffer.isView(S)))
            throw new Error(e);
        } else
          throw new Error(e);
        Y = !0;
      }
      var oe = 0, de = S.length;
      if (Y)
        oe = de;
      else
        for (var Ie = 0; Ie < S.length; ++Ie) {
          var ye = S.charCodeAt(Ie);
          ye < 128 ? oe += 1 : ye < 2048 ? oe += 2 : ye < 55296 || ye >= 57344 ? oe += 3 : (ye = 65536 + ((ye & 1023) << 10 | S.charCodeAt(++Ie) & 1023), oe += 4);
        }
      return oe += this.encode(oe * 8), this.update(S), oe;
    }, l.prototype.bytepad = function(S, Y) {
      for (var fe = this.encode(Y), oe = 0; oe < S.length; ++oe)
        fe += this.encodeString(S[oe]);
      var de = Y - fe % Y, Ie = [];
      return Ie.length = de, this.update(Ie), this;
    }, l.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var S = this.blocks, Y = this.lastByteIndex, fe = this.blockCount, oe = this.s;
        if (S[Y >> 2] |= this.padding[Y & 3], this.lastByteIndex === this.byteCount)
          for (S[0] = S[fe], Y = 1; Y < fe + 1; ++Y)
            S[Y] = 0;
        for (S[fe - 1] |= 2147483648, Y = 0; Y < fe; ++Y)
          oe[Y] ^= S[Y];
        X(oe);
      }
    }, l.prototype.toString = l.prototype.hex = function() {
      this.finalize();
      for (var S = this.blockCount, Y = this.s, fe = this.outputBlocks, oe = this.extraBytes, de = 0, Ie = 0, ye = "", be; Ie < fe; ) {
        for (de = 0; de < S && Ie < fe; ++de, ++Ie)
          be = Y[de], ye += M[be >> 4 & 15] + M[be & 15] + M[be >> 12 & 15] + M[be >> 8 & 15] + M[be >> 20 & 15] + M[be >> 16 & 15] + M[be >> 28 & 15] + M[be >> 24 & 15];
        Ie % S === 0 && (X(Y), de = 0);
      }
      return oe && (be = Y[de], ye += M[be >> 4 & 15] + M[be & 15], oe > 1 && (ye += M[be >> 12 & 15] + M[be >> 8 & 15]), oe > 2 && (ye += M[be >> 20 & 15] + M[be >> 16 & 15])), ye;
    }, l.prototype.arrayBuffer = function() {
      this.finalize();
      var S = this.blockCount, Y = this.s, fe = this.outputBlocks, oe = this.extraBytes, de = 0, Ie = 0, ye = this.outputBits >> 3, be;
      oe ? be = new ArrayBuffer(fe + 1 << 2) : be = new ArrayBuffer(ye);
      for (var rt = new Uint32Array(be); Ie < fe; ) {
        for (de = 0; de < S && Ie < fe; ++de, ++Ie)
          rt[Ie] = Y[de];
        Ie % S === 0 && X(Y);
      }
      return oe && (rt[de] = Y[de], be = be.slice(0, ye)), be;
    }, l.prototype.buffer = l.prototype.arrayBuffer, l.prototype.digest = l.prototype.array = function() {
      this.finalize();
      for (var S = this.blockCount, Y = this.s, fe = this.outputBlocks, oe = this.extraBytes, de = 0, Ie = 0, ye = [], be, rt; Ie < fe; ) {
        for (de = 0; de < S && Ie < fe; ++de, ++Ie)
          be = Ie << 2, rt = Y[de], ye[be] = rt & 255, ye[be + 1] = rt >> 8 & 255, ye[be + 2] = rt >> 16 & 255, ye[be + 3] = rt >> 24 & 255;
        Ie % S === 0 && X(Y);
      }
      return oe && (be = Ie << 2, rt = Y[de], ye[be] = rt & 255, oe > 1 && (ye[be + 1] = rt >> 8 & 255), oe > 2 && (ye[be + 2] = rt >> 16 & 255)), ye;
    };
    function v(S, Y, fe) {
      l.call(this, S, Y, fe);
    }
    v.prototype = new l(), v.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), l.prototype.finalize.call(this);
    };
    var X = function(S) {
      var Y, fe, oe, de, Ie, ye, be, rt, xe, Ne, j, z, ee, ve, me, Ae, it, ke, qe, or, Oe, T, A, E, F, ie, ne, ce, nt, Be, Ce, _t, Me, pt, qr, Xe, yt, Zr, He, dt, Hr, Ze, mt, zr, Qe, tt, Wr, q, Q, ae, k, re, Ee, pe, _e, bt, Te, Re, Dr, vt, pr, Pr, Lr;
      for (oe = 0; oe < 48; oe += 2)
        de = S[0] ^ S[10] ^ S[20] ^ S[30] ^ S[40], Ie = S[1] ^ S[11] ^ S[21] ^ S[31] ^ S[41], ye = S[2] ^ S[12] ^ S[22] ^ S[32] ^ S[42], be = S[3] ^ S[13] ^ S[23] ^ S[33] ^ S[43], rt = S[4] ^ S[14] ^ S[24] ^ S[34] ^ S[44], xe = S[5] ^ S[15] ^ S[25] ^ S[35] ^ S[45], Ne = S[6] ^ S[16] ^ S[26] ^ S[36] ^ S[46], j = S[7] ^ S[17] ^ S[27] ^ S[37] ^ S[47], z = S[8] ^ S[18] ^ S[28] ^ S[38] ^ S[48], ee = S[9] ^ S[19] ^ S[29] ^ S[39] ^ S[49], Y = z ^ (ye << 1 | be >>> 31), fe = ee ^ (be << 1 | ye >>> 31), S[0] ^= Y, S[1] ^= fe, S[10] ^= Y, S[11] ^= fe, S[20] ^= Y, S[21] ^= fe, S[30] ^= Y, S[31] ^= fe, S[40] ^= Y, S[41] ^= fe, Y = de ^ (rt << 1 | xe >>> 31), fe = Ie ^ (xe << 1 | rt >>> 31), S[2] ^= Y, S[3] ^= fe, S[12] ^= Y, S[13] ^= fe, S[22] ^= Y, S[23] ^= fe, S[32] ^= Y, S[33] ^= fe, S[42] ^= Y, S[43] ^= fe, Y = ye ^ (Ne << 1 | j >>> 31), fe = be ^ (j << 1 | Ne >>> 31), S[4] ^= Y, S[5] ^= fe, S[14] ^= Y, S[15] ^= fe, S[24] ^= Y, S[25] ^= fe, S[34] ^= Y, S[35] ^= fe, S[44] ^= Y, S[45] ^= fe, Y = rt ^ (z << 1 | ee >>> 31), fe = xe ^ (ee << 1 | z >>> 31), S[6] ^= Y, S[7] ^= fe, S[16] ^= Y, S[17] ^= fe, S[26] ^= Y, S[27] ^= fe, S[36] ^= Y, S[37] ^= fe, S[46] ^= Y, S[47] ^= fe, Y = Ne ^ (de << 1 | Ie >>> 31), fe = j ^ (Ie << 1 | de >>> 31), S[8] ^= Y, S[9] ^= fe, S[18] ^= Y, S[19] ^= fe, S[28] ^= Y, S[29] ^= fe, S[38] ^= Y, S[39] ^= fe, S[48] ^= Y, S[49] ^= fe, ve = S[0], me = S[1], tt = S[11] << 4 | S[10] >>> 28, Wr = S[10] << 4 | S[11] >>> 28, ce = S[20] << 3 | S[21] >>> 29, nt = S[21] << 3 | S[20] >>> 29, vt = S[31] << 9 | S[30] >>> 23, pr = S[30] << 9 | S[31] >>> 23, Ze = S[40] << 18 | S[41] >>> 14, mt = S[41] << 18 | S[40] >>> 14, pt = S[2] << 1 | S[3] >>> 31, qr = S[3] << 1 | S[2] >>> 31, Ae = S[13] << 12 | S[12] >>> 20, it = S[12] << 12 | S[13] >>> 20, q = S[22] << 10 | S[23] >>> 22, Q = S[23] << 10 | S[22] >>> 22, Be = S[33] << 13 | S[32] >>> 19, Ce = S[32] << 13 | S[33] >>> 19, Pr = S[42] << 2 | S[43] >>> 30, Lr = S[43] << 2 | S[42] >>> 30, pe = S[5] << 30 | S[4] >>> 2, _e = S[4] << 30 | S[5] >>> 2, Xe = S[14] << 6 | S[15] >>> 26, yt = S[15] << 6 | S[14] >>> 26, ke = S[25] << 11 | S[24] >>> 21, qe = S[24] << 11 | S[25] >>> 21, ae = S[34] << 15 | S[35] >>> 17, k = S[35] << 15 | S[34] >>> 17, _t = S[45] << 29 | S[44] >>> 3, Me = S[44] << 29 | S[45] >>> 3, E = S[6] << 28 | S[7] >>> 4, F = S[7] << 28 | S[6] >>> 4, bt = S[17] << 23 | S[16] >>> 9, Te = S[16] << 23 | S[17] >>> 9, Zr = S[26] << 25 | S[27] >>> 7, He = S[27] << 25 | S[26] >>> 7, or = S[36] << 21 | S[37] >>> 11, Oe = S[37] << 21 | S[36] >>> 11, re = S[47] << 24 | S[46] >>> 8, Ee = S[46] << 24 | S[47] >>> 8, zr = S[8] << 27 | S[9] >>> 5, Qe = S[9] << 27 | S[8] >>> 5, ie = S[18] << 20 | S[19] >>> 12, ne = S[19] << 20 | S[18] >>> 12, Re = S[29] << 7 | S[28] >>> 25, Dr = S[28] << 7 | S[29] >>> 25, dt = S[38] << 8 | S[39] >>> 24, Hr = S[39] << 8 | S[38] >>> 24, T = S[48] << 14 | S[49] >>> 18, A = S[49] << 14 | S[48] >>> 18, S[0] = ve ^ ~Ae & ke, S[1] = me ^ ~it & qe, S[10] = E ^ ~ie & ce, S[11] = F ^ ~ne & nt, S[20] = pt ^ ~Xe & Zr, S[21] = qr ^ ~yt & He, S[30] = zr ^ ~tt & q, S[31] = Qe ^ ~Wr & Q, S[40] = pe ^ ~bt & Re, S[41] = _e ^ ~Te & Dr, S[2] = Ae ^ ~ke & or, S[3] = it ^ ~qe & Oe, S[12] = ie ^ ~ce & Be, S[13] = ne ^ ~nt & Ce, S[22] = Xe ^ ~Zr & dt, S[23] = yt ^ ~He & Hr, S[32] = tt ^ ~q & ae, S[33] = Wr ^ ~Q & k, S[42] = bt ^ ~Re & vt, S[43] = Te ^ ~Dr & pr, S[4] = ke ^ ~or & T, S[5] = qe ^ ~Oe & A, S[14] = ce ^ ~Be & _t, S[15] = nt ^ ~Ce & Me, S[24] = Zr ^ ~dt & Ze, S[25] = He ^ ~Hr & mt, S[34] = q ^ ~ae & re, S[35] = Q ^ ~k & Ee, S[44] = Re ^ ~vt & Pr, S[45] = Dr ^ ~pr & Lr, S[6] = or ^ ~T & ve, S[7] = Oe ^ ~A & me, S[16] = Be ^ ~_t & E, S[17] = Ce ^ ~Me & F, S[26] = dt ^ ~Ze & pt, S[27] = Hr ^ ~mt & qr, S[36] = ae ^ ~re & zr, S[37] = k ^ ~Ee & Qe, S[46] = vt ^ ~Pr & pe, S[47] = pr ^ ~Lr & _e, S[8] = T ^ ~ve & Ae, S[9] = A ^ ~me & it, S[18] = _t ^ ~E & ie, S[19] = Me ^ ~F & ne, S[28] = Ze ^ ~pt & Xe, S[29] = mt ^ ~qr & yt, S[38] = re ^ ~zr & tt, S[39] = Ee ^ ~Qe & Wr, S[48] = Pr ^ ~pe & bt, S[49] = Lr ^ ~_e & Te, S[0] ^= $[oe], S[1] ^= $[oe + 1];
    };
    if (p)
      n.exports = u;
    else
      for (g = 0; g < h.length; ++g)
        c[h[g]] = u[h[g]];
  })();
})(sha3$1);
const sha3 = sha3$1.exports;
function keccak256$1(n) {
  return "0x" + sha3.keccak_256(arrayify(n));
}
const lib_esm$h = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keccak256: keccak256$1
}, Symbol.toStringTag, { value: "Module" })), version$g = "rlp/5.7.0", logger$l = new Logger(version$g);
function arrayifyInteger(n) {
  const e = [];
  for (; n; )
    e.unshift(n & 255), n >>= 8;
  return e;
}
function unarrayifyInteger(n, e, t) {
  let o = 0;
  for (let c = 0; c < t; c++)
    o = o * 256 + n[e + c];
  return o;
}
function _encode(n) {
  if (Array.isArray(n)) {
    let o = [];
    if (n.forEach(function(a) {
      o = o.concat(_encode(a));
    }), o.length <= 55)
      return o.unshift(192 + o.length), o;
    const c = arrayifyInteger(o.length);
    return c.unshift(247 + c.length), c.concat(o);
  }
  isBytesLike(n) || logger$l.throwArgumentError("RLP object must be BytesLike", "object", n);
  const e = Array.prototype.slice.call(arrayify(n));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const t = arrayifyInteger(e.length);
  return t.unshift(183 + t.length), t.concat(e);
}
function encode$1(n) {
  return hexlify(_encode(n));
}
function _decodeChildren(n, e, t, o) {
  const c = [];
  for (; t < e + 1 + o; ) {
    const a = _decode(n, t);
    c.push(a.result), t += a.consumed, t > e + 1 + o && logger$l.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + o, result: c };
}
function _decode(n, e) {
  if (n.length === 0 && logger$l.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {}), n[e] >= 248) {
    const t = n[e] - 247;
    e + 1 + t > n.length && logger$l.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    const o = unarrayifyInteger(n, e + 1, t);
    return e + 1 + t + o > n.length && logger$l.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {}), _decodeChildren(n, e, e + 1 + t, t + o);
  } else if (n[e] >= 192) {
    const t = n[e] - 192;
    return e + 1 + t > n.length && logger$l.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {}), _decodeChildren(n, e, e + 1, t);
  } else if (n[e] >= 184) {
    const t = n[e] - 183;
    e + 1 + t > n.length && logger$l.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    const o = unarrayifyInteger(n, e + 1, t);
    e + 1 + t + o > n.length && logger$l.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    const c = hexlify(n.slice(e + 1 + t, e + 1 + t + o));
    return { consumed: 1 + t + o, result: c };
  } else if (n[e] >= 128) {
    const t = n[e] - 128;
    e + 1 + t > n.length && logger$l.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    const o = hexlify(n.slice(e + 1, e + 1 + t));
    return { consumed: 1 + t, result: o };
  }
  return { consumed: 1, result: hexlify(n[e]) };
}
function decode$1(n) {
  const e = arrayify(n), t = _decode(e, 0);
  return t.consumed !== e.length && logger$l.throwArgumentError("invalid rlp data", "data", n), t.result;
}
const lib_esm$g = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  encode: encode$1,
  decode: decode$1
}, Symbol.toStringTag, { value: "Module" })), version$f = "address/5.7.0", logger$k = new Logger(version$f);
function getChecksumAddress(n) {
  isHexString(n, 20) || logger$k.throwArgumentError("invalid address", "address", n), n = n.toLowerCase();
  const e = n.substring(2).split(""), t = new Uint8Array(40);
  for (let c = 0; c < 40; c++)
    t[c] = e[c].charCodeAt(0);
  const o = arrayify(keccak256$1(t));
  for (let c = 0; c < 40; c += 2)
    o[c >> 1] >> 4 >= 8 && (e[c] = e[c].toUpperCase()), (o[c >> 1] & 15) >= 8 && (e[c + 1] = e[c + 1].toUpperCase());
  return "0x" + e.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(n) {
  return Math.log10 ? Math.log10(n) : Math.log(n) / Math.LN10;
}
const ibanLookup = {};
for (let n = 0; n < 10; n++)
  ibanLookup[String(n)] = String(n);
for (let n = 0; n < 26; n++)
  ibanLookup[String.fromCharCode(65 + n)] = String(10 + n);
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(n) {
  n = n.toUpperCase(), n = n.substring(4) + n.substring(0, 2) + "00";
  let e = n.split("").map((o) => ibanLookup[o]).join("");
  for (; e.length >= safeDigits; ) {
    let o = e.substring(0, safeDigits);
    e = parseInt(o, 10) % 97 + e.substring(o.length);
  }
  let t = String(98 - parseInt(e, 10) % 97);
  for (; t.length < 2; )
    t = "0" + t;
  return t;
}
function getAddress(n) {
  let e = null;
  if (typeof n != "string" && logger$k.throwArgumentError("invalid address", "address", n), n.match(/^(0x)?[0-9a-fA-F]{40}$/))
    n.substring(0, 2) !== "0x" && (n = "0x" + n), e = getChecksumAddress(n), n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== n && logger$k.throwArgumentError("bad address checksum", "address", n);
  else if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (n.substring(2, 4) !== ibanChecksum(n) && logger$k.throwArgumentError("bad icap checksum", "address", n), e = _base36To16(n.substring(4)); e.length < 40; )
      e = "0" + e;
    e = getChecksumAddress("0x" + e);
  } else
    logger$k.throwArgumentError("invalid address", "address", n);
  return e;
}
function isAddress(n) {
  try {
    return getAddress(n), !0;
  } catch {
  }
  return !1;
}
function getIcapAddress(n) {
  let e = _base16To36(getAddress(n).substring(2)).toUpperCase();
  for (; e.length < 30; )
    e = "0" + e;
  return "XE" + ibanChecksum("XE00" + e) + e;
}
function getContractAddress(n) {
  let e = null;
  try {
    e = getAddress(n.from);
  } catch {
    logger$k.throwArgumentError("missing from address", "transaction", n);
  }
  const t = stripZeros(arrayify(BigNumber.from(n.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256$1(encode$1([e, t])), 12));
}
function getCreate2Address(n, e, t) {
  return hexDataLength(e) !== 32 && logger$k.throwArgumentError("salt must be 32 bytes", "salt", e), hexDataLength(t) !== 32 && logger$k.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", t), getAddress(hexDataSlice(keccak256$1(concat(["0xff", getAddress(n), e, t])), 12));
}
const lib_esm$f = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAddress,
  isAddress,
  getIcapAddress,
  getContractAddress,
  getCreate2Address
}, Symbol.toStringTag, { value: "Module" }));
class AddressCoder extends Coder {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, t) {
    try {
      t = getAddress(t);
    } catch (o) {
      this._throwError(o.message, t);
    }
    return e.writeValue(t);
  }
  decode(e) {
    return getAddress(hexZeroPad(e.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(e) {
    super(e.name, e.type, void 0, e.dynamic), this.coder = e;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, t) {
    return this.coder.encode(e, t);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
const logger$j = new Logger(version$h);
function pack$1(n, e, t) {
  let o = null;
  if (Array.isArray(t))
    o = t;
  else if (t && typeof t == "object") {
    let w = {};
    o = e.map((M) => {
      const I = M.localName;
      return I || logger$j.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: M,
        value: t
      }), w[I] && logger$j.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: M,
        value: t
      }), w[I] = !0, t[I];
    });
  } else
    logger$j.throwArgumentError("invalid tuple value", "tuple", t);
  e.length !== o.length && logger$j.throwArgumentError("types/value length mismatch", "tuple", t);
  let c = new Writer(n.wordSize), a = new Writer(n.wordSize), d = [];
  e.forEach((w, M) => {
    let I = o[M];
    if (w.dynamic) {
      let B = a.length;
      w.encode(a, I);
      let H = c.writeUpdatableValue();
      d.push((L) => {
        H(L + B);
      });
    } else
      w.encode(c, I);
  }), d.forEach((w) => {
    w(c.length);
  });
  let p = n.appendWriter(c);
  return p += n.appendWriter(a), p;
}
function unpack(n, e) {
  let t = [], o = n.subReader(0);
  e.forEach((a) => {
    let d = null;
    if (a.dynamic) {
      let p = n.readValue(), w = o.subReader(p.toNumber());
      try {
        d = a.decode(w);
      } catch (M) {
        if (M.code === Logger.errors.BUFFER_OVERRUN)
          throw M;
        d = M, d.baseType = a.name, d.name = a.localName, d.type = a.type;
      }
    } else
      try {
        d = a.decode(n);
      } catch (p) {
        if (p.code === Logger.errors.BUFFER_OVERRUN)
          throw p;
        d = p, d.baseType = a.name, d.name = a.localName, d.type = a.type;
      }
    d != null && t.push(d);
  });
  const c = e.reduce((a, d) => {
    const p = d.localName;
    return p && (a[p] || (a[p] = 0), a[p]++), a;
  }, {});
  e.forEach((a, d) => {
    let p = a.localName;
    if (!p || c[p] !== 1 || (p === "length" && (p = "_length"), t[p] != null))
      return;
    const w = t[d];
    w instanceof Error ? Object.defineProperty(t, p, {
      enumerable: !0,
      get: () => {
        throw w;
      }
    }) : t[p] = w;
  });
  for (let a = 0; a < t.length; a++) {
    const d = t[a];
    d instanceof Error && Object.defineProperty(t, a, {
      enumerable: !0,
      get: () => {
        throw d;
      }
    });
  }
  return Object.freeze(t);
}
class ArrayCoder extends Coder {
  constructor(e, t, o) {
    const c = e.type + "[" + (t >= 0 ? t : "") + "]", a = t === -1 || e.dynamic;
    super("array", c, o, a), this.coder = e, this.length = t;
  }
  defaultValue() {
    const e = this.coder.defaultValue(), t = [];
    for (let o = 0; o < this.length; o++)
      t.push(e);
    return t;
  }
  encode(e, t) {
    Array.isArray(t) || this._throwError("expected array value", t);
    let o = this.length;
    o === -1 && (o = t.length, e.writeValue(t.length)), logger$j.checkArgumentCount(t.length, o, "coder array" + (this.localName ? " " + this.localName : ""));
    let c = [];
    for (let a = 0; a < t.length; a++)
      c.push(this.coder);
    return pack$1(e, c, t);
  }
  decode(e) {
    let t = this.length;
    t === -1 && (t = e.readValue().toNumber(), t * 32 > e._data.length && logger$j.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
      length: e._data.length,
      count: t
    }));
    let o = [];
    for (let c = 0; c < t; c++)
      o.push(new AnonymousCoder(this.coder));
    return e.coerce(this.name, unpack(e, o));
  }
}
class BooleanCoder extends Coder {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, t) {
    return e.writeValue(t ? 1 : 0);
  }
  decode(e) {
    return e.coerce(this.type, !e.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(e, t) {
    super(e, e, t, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, t) {
    t = arrayify(t);
    let o = e.writeValue(t.length);
    return o += e.writeBytes(t), o;
  }
  decode(e) {
    return e.readBytes(e.readValue().toNumber(), !0);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return e.coerce(this.name, hexlify(super.decode(e)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(e, t) {
    let o = "bytes" + String(e);
    super(o, o, t, !1), this.size = e;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(e, t) {
    let o = arrayify(t);
    return o.length !== this.size && this._throwError("incorrect data length", t), e.writeBytes(o);
  }
  decode(e) {
    return e.coerce(this.name, hexlify(e.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, t) {
    return t != null && this._throwError("not null", t), e.writeBytes([]);
  }
  decode(e) {
    return e.readBytes(0), e.coerce(this.name, null);
  }
}
const NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1), Zero$1 = /* @__PURE__ */ BigNumber.from(0), One$1 = /* @__PURE__ */ BigNumber.from(1), MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
class NumberCoder extends Coder {
  constructor(e, t, o) {
    const c = (t ? "int" : "uint") + e * 8;
    super(c, c, o, !1), this.size = e, this.signed = t;
  }
  defaultValue() {
    return 0;
  }
  encode(e, t) {
    let o = BigNumber.from(t), c = MaxUint256$1.mask(e.wordSize * 8);
    if (this.signed) {
      let a = c.mask(this.size * 8 - 1);
      (o.gt(a) || o.lt(a.add(One$1).mul(NegativeOne$1))) && this._throwError("value out-of-bounds", t);
    } else
      (o.lt(Zero$1) || o.gt(c.mask(this.size * 8))) && this._throwError("value out-of-bounds", t);
    return o = o.toTwos(this.size * 8).mask(this.size * 8), this.signed && (o = o.fromTwos(this.size * 8).toTwos(8 * e.wordSize)), e.writeValue(o);
  }
  decode(e) {
    let t = e.readValue().mask(this.size * 8);
    return this.signed && (t = t.fromTwos(this.size * 8)), e.coerce(this.name, t);
  }
}
const version$e = "strings/5.7.0", logger$i = new Logger(version$e);
var UnicodeNormalizationForm;
(function(n) {
  n.current = "", n.NFC = "NFC", n.NFD = "NFD", n.NFKC = "NFKC", n.NFKD = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(n) {
  n.UNEXPECTED_CONTINUE = "unexpected continuation byte", n.BAD_PREFIX = "bad codepoint prefix", n.OVERRUN = "string overrun", n.MISSING_CONTINUE = "missing continuation byte", n.OUT_OF_RANGE = "out of UTF-8 range", n.UTF16_SURROGATE = "UTF-16 surrogate", n.OVERLONG = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(n, e, t, o, c) {
  return logger$i.throwArgumentError(`invalid codepoint at offset ${e}; ${n}`, "bytes", t);
}
function ignoreFunc(n, e, t, o, c) {
  if (n === Utf8ErrorReason.BAD_PREFIX || n === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let a = 0;
    for (let d = e + 1; d < t.length && t[d] >> 6 === 2; d++)
      a++;
    return a;
  }
  return n === Utf8ErrorReason.OVERRUN ? t.length - e - 1 : 0;
}
function replaceFunc(n, e, t, o, c) {
  return n === Utf8ErrorReason.OVERLONG ? (o.push(c), 0) : (o.push(65533), ignoreFunc(n, e, t));
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(n, e) {
  e == null && (e = Utf8ErrorFuncs.error), n = arrayify(n);
  const t = [];
  let o = 0;
  for (; o < n.length; ) {
    const c = n[o++];
    if (c >> 7 === 0) {
      t.push(c);
      continue;
    }
    let a = null, d = null;
    if ((c & 224) === 192)
      a = 1, d = 127;
    else if ((c & 240) === 224)
      a = 2, d = 2047;
    else if ((c & 248) === 240)
      a = 3, d = 65535;
    else {
      (c & 192) === 128 ? o += e(Utf8ErrorReason.UNEXPECTED_CONTINUE, o - 1, n, t) : o += e(Utf8ErrorReason.BAD_PREFIX, o - 1, n, t);
      continue;
    }
    if (o - 1 + a >= n.length) {
      o += e(Utf8ErrorReason.OVERRUN, o - 1, n, t);
      continue;
    }
    let p = c & (1 << 8 - a - 1) - 1;
    for (let w = 0; w < a; w++) {
      let M = n[o];
      if ((M & 192) != 128) {
        o += e(Utf8ErrorReason.MISSING_CONTINUE, o, n, t), p = null;
        break;
      }
      p = p << 6 | M & 63, o++;
    }
    if (p !== null) {
      if (p > 1114111) {
        o += e(Utf8ErrorReason.OUT_OF_RANGE, o - 1 - a, n, t, p);
        continue;
      }
      if (p >= 55296 && p <= 57343) {
        o += e(Utf8ErrorReason.UTF16_SURROGATE, o - 1 - a, n, t, p);
        continue;
      }
      if (p <= d) {
        o += e(Utf8ErrorReason.OVERLONG, o - 1 - a, n, t, p);
        continue;
      }
      t.push(p);
    }
  }
  return t;
}
function toUtf8Bytes(n, e = UnicodeNormalizationForm.current) {
  e != UnicodeNormalizationForm.current && (logger$i.checkNormalize(), n = n.normalize(e));
  let t = [];
  for (let o = 0; o < n.length; o++) {
    const c = n.charCodeAt(o);
    if (c < 128)
      t.push(c);
    else if (c < 2048)
      t.push(c >> 6 | 192), t.push(c & 63 | 128);
    else if ((c & 64512) == 55296) {
      o++;
      const a = n.charCodeAt(o);
      if (o >= n.length || (a & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const d = 65536 + ((c & 1023) << 10) + (a & 1023);
      t.push(d >> 18 | 240), t.push(d >> 12 & 63 | 128), t.push(d >> 6 & 63 | 128), t.push(d & 63 | 128);
    } else
      t.push(c >> 12 | 224), t.push(c >> 6 & 63 | 128), t.push(c & 63 | 128);
  }
  return arrayify(t);
}
function escapeChar(n) {
  const e = "0000" + n.toString(16);
  return "\\u" + e.substring(e.length - 4);
}
function _toEscapedUtf8String(n, e) {
  return '"' + getUtf8CodePoints(n, e).map((t) => {
    if (t < 256) {
      switch (t) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (t >= 32 && t < 127)
        return String.fromCharCode(t);
    }
    return t <= 65535 ? escapeChar(t) : (t -= 65536, escapeChar((t >> 10 & 1023) + 55296) + escapeChar((t & 1023) + 56320));
  }).join("") + '"';
}
function _toUtf8String(n) {
  return n.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
}
function toUtf8String(n, e) {
  return _toUtf8String(getUtf8CodePoints(n, e));
}
function toUtf8CodePoints(n, e = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(n, e));
}
function formatBytes32String(n) {
  const e = toUtf8Bytes(n);
  if (e.length > 31)
    throw new Error("bytes32 string must be less than 32 bytes");
  return hexlify(concat([e, HashZero]).slice(0, 32));
}
function parseBytes32String(n) {
  const e = arrayify(n);
  if (e.length !== 32)
    throw new Error("invalid bytes32 - not 32 bytes long");
  if (e[31] !== 0)
    throw new Error("invalid bytes32 string - no null terminator");
  let t = 31;
  for (; e[t - 1] === 0; )
    t--;
  return toUtf8String(e.slice(0, t));
}
function bytes2(n) {
  if (n.length % 4 !== 0)
    throw new Error("bad data");
  let e = [];
  for (let t = 0; t < n.length; t += 4)
    e.push(parseInt(n.substring(t, t + 4), 16));
  return e;
}
function createTable(n, e) {
  e || (e = function(c) {
    return [parseInt(c, 16)];
  });
  let t = 0, o = {};
  return n.split(",").forEach((c) => {
    let a = c.split(":");
    t += parseInt(a[0], 16), o[t] = e(a[1]);
  }), o;
}
function createRangeTable(n) {
  let e = 0;
  return n.split(",").map((t) => {
    let o = t.split("-");
    o.length === 1 ? o[1] = "0" : o[1] === "" && (o[1] = "1");
    let c = e + parseInt(o[0], 16);
    return e = parseInt(o[1], 16), { l: c, h: e };
  });
}
function matchMap(n, e) {
  let t = 0;
  for (let o = 0; o < e.length; o++) {
    let c = e[o];
    if (t += c.l, n >= t && n <= t + c.h && (n - t) % (c.d || 1) === 0) {
      if (c.e && c.e.indexOf(n - t) !== -1)
        continue;
      return c;
    }
  }
  return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"), Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((n) => parseInt(n, 16)), Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
], Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"), Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"), Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2), Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(n) {
  return n.reduce((e, t) => (t.forEach((o) => {
    e.push(o);
  }), e), []);
}
function _nameprepTableA1(n) {
  return !!matchMap(n, Table_A_1_ranges);
}
function _nameprepTableB2(n) {
  let e = matchMap(n, Table_B_2_ranges);
  if (e)
    return [n + e.s];
  let t = Table_B_2_lut_abs[n];
  if (t)
    return t;
  let o = Table_B_2_lut_rel[n];
  if (o)
    return [n + o[0]];
  let c = Table_B_2_complex[n];
  return c || null;
}
function _nameprepTableC(n) {
  return !!matchMap(n, Table_C_ranges);
}
function nameprep(n) {
  if (n.match(/^[a-z0-9-]*$/i) && n.length <= 59)
    return n.toLowerCase();
  let e = toUtf8CodePoints(n);
  e = flatten(e.map((o) => {
    if (Table_B_1_flags.indexOf(o) >= 0)
      return [];
    if (o >= 65024 && o <= 65039)
      return [];
    let c = _nameprepTableB2(o);
    return c || [o];
  })), e = toUtf8CodePoints(_toUtf8String(e), UnicodeNormalizationForm.NFKC), e.forEach((o) => {
    if (_nameprepTableC(o))
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
  }), e.forEach((o) => {
    if (_nameprepTableA1(o))
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
  });
  let t = _toUtf8String(e);
  if (t.substring(0, 1) === "-" || t.substring(2, 4) === "--" || t.substring(t.length - 1) === "-")
    throw new Error("invalid hyphen");
  return t;
}
const lib_esm$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _toEscapedUtf8String,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String,
  Utf8ErrorFuncs,
  get Utf8ErrorReason() {
    return Utf8ErrorReason;
  },
  get UnicodeNormalizationForm() {
    return UnicodeNormalizationForm;
  },
  formatBytes32String,
  parseBytes32String,
  nameprep
}, Symbol.toStringTag, { value: "Module" }));
class StringCoder extends DynamicBytesCoder {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, t) {
    return super.encode(e, toUtf8Bytes(t));
  }
  decode(e) {
    return toUtf8String(super.decode(e));
  }
}
class TupleCoder extends Coder {
  constructor(e, t) {
    let o = !1;
    const c = [];
    e.forEach((d) => {
      d.dynamic && (o = !0), c.push(d.type);
    });
    const a = "tuple(" + c.join(",") + ")";
    super("tuple", a, t, o), this.coders = e;
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((o) => {
      e.push(o.defaultValue());
    });
    const t = this.coders.reduce((o, c) => {
      const a = c.localName;
      return a && (o[a] || (o[a] = 0), o[a]++), o;
    }, {});
    return this.coders.forEach((o, c) => {
      let a = o.localName;
      !a || t[a] !== 1 || (a === "length" && (a = "_length"), e[a] == null && (e[a] = e[c]));
    }), Object.freeze(e);
  }
  encode(e, t) {
    return pack$1(e, this.coders, t);
  }
  decode(e) {
    return e.coerce(this.name, unpack(e, this.coders));
  }
}
const logger$h = new Logger(version$h), paramTypeBytes = new RegExp(/^bytes([0-9]*)$/), paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(e) {
    defineReadOnly(this, "coerceFunc", e || null);
  }
  _getCoder(e) {
    switch (e.baseType) {
      case "address":
        return new AddressCoder(e.name);
      case "bool":
        return new BooleanCoder(e.name);
      case "string":
        return new StringCoder(e.name);
      case "bytes":
        return new BytesCoder(e.name);
      case "array":
        return new ArrayCoder(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
      case "tuple":
        return new TupleCoder((e.components || []).map((o) => this._getCoder(o)), e.name);
      case "":
        return new NullCoder(e.name);
    }
    let t = e.type.match(paramTypeNumber);
    if (t) {
      let o = parseInt(t[2] || "256");
      return (o === 0 || o > 256 || o % 8 !== 0) && logger$h.throwArgumentError("invalid " + t[1] + " bit length", "param", e), new NumberCoder(o / 8, t[1] === "int", e.name);
    }
    if (t = e.type.match(paramTypeBytes), t) {
      let o = parseInt(t[1]);
      return (o === 0 || o > 32) && logger$h.throwArgumentError("invalid bytes length", "param", e), new FixedBytesCoder(o, e.name);
    }
    return logger$h.throwArgumentError("invalid type", "type", e.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(e, t) {
    return new Reader(e, this._getWordSize(), this.coerceFunc, t);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(e) {
    const t = e.map((c) => this._getCoder(ParamType.from(c)));
    return new TupleCoder(t, "_").defaultValue();
  }
  encode(e, t) {
    e.length !== t.length && logger$h.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
      count: { types: e.length, values: t.length },
      value: { types: e, values: t }
    });
    const o = e.map((d) => this._getCoder(ParamType.from(d))), c = new TupleCoder(o, "_"), a = this._getWriter();
    return c.encode(a, t), a.data;
  }
  decode(e, t, o) {
    const c = e.map((d) => this._getCoder(ParamType.from(d)));
    return new TupleCoder(c, "_").decode(this._getReader(arrayify(t), o));
  }
}
const defaultAbiCoder = new AbiCoder();
function id(n) {
  return keccak256$1(toUtf8Bytes(n));
}
const version$d = "hash/5.7.0";
function decode(n) {
  n = atob(n);
  const e = [];
  for (let t = 0; t < n.length; t++)
    e.push(n.charCodeAt(t));
  return arrayify(e);
}
function encode(n) {
  n = arrayify(n);
  let e = "";
  for (let t = 0; t < n.length; t++)
    e += String.fromCharCode(n[t]);
  return btoa(e);
}
const lib_esm$d = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode,
  encode
}, Symbol.toStringTag, { value: "Module" }));
function flat(n, e) {
  e == null && (e = 1);
  const t = [], o = t.forEach, c = function(a, d) {
    o.call(a, function(p) {
      d > 0 && Array.isArray(p) ? c(p, d - 1) : t.push(p);
    });
  };
  return c(n, e), t;
}
function fromEntries(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const o = n[t];
    e[o[0]] = o[1];
  }
  return e;
}
function decode_arithmetic(n) {
  let e = 0;
  function t() {
    return n[e++] << 8 | n[e++];
  }
  let o = t(), c = 1, a = [0, 1];
  for (let J = 1; J < o; J++)
    a.push(c += t());
  let d = t(), p = e;
  e += d;
  let w = 0, M = 0;
  function I() {
    return w == 0 && (M = M << 8 | n[e++], w = 8), M >> --w & 1;
  }
  const B = 31, H = Math.pow(2, B), L = H >>> 1, W = L >> 1, $ = H - 1;
  let P = 0;
  for (let J = 0; J < B; J++)
    P = P << 1 | I();
  let U = [], G = 0, D = H;
  for (; ; ) {
    let J = Math.floor(((P - G + 1) * c - 1) / D), te = 0, ue = o;
    for (; ue - te > 1; ) {
      let C = te + ue >>> 1;
      J < a[C] ? ue = C : te = C;
    }
    if (te == 0)
      break;
    U.push(te);
    let he = G + Math.floor(D * a[te] / c), Se = G + Math.floor(D * a[te + 1] / c) - 1;
    for (; ((he ^ Se) & L) == 0; )
      P = P << 1 & $ | I(), he = he << 1 & $, Se = Se << 1 & $ | 1;
    for (; he & ~Se & W; )
      P = P & L | P << 1 & $ >>> 1 | I(), he = he << 1 ^ L, Se = (Se ^ L) << 1 | L | 1;
    G = he, D = 1 + Se - he;
  }
  let Z = o - 4;
  return U.map((J) => {
    switch (J - Z) {
      case 3:
        return Z + 65792 + (n[p++] << 16 | n[p++] << 8 | n[p++]);
      case 2:
        return Z + 256 + (n[p++] << 8 | n[p++]);
      case 1:
        return Z + n[p++];
      default:
        return J - 1;
    }
  });
}
function read_payload(n) {
  let e = 0;
  return () => n[e++];
}
function read_compressed_payload(n) {
  return read_payload(decode_arithmetic(n));
}
function signed(n) {
  return n & 1 ? ~n >> 1 : n >> 1;
}
function read_counts(n, e) {
  let t = Array(n);
  for (let o = 0; o < n; o++)
    t[o] = 1 + e();
  return t;
}
function read_ascending(n, e) {
  let t = Array(n);
  for (let o = 0, c = -1; o < n; o++)
    t[o] = c += 1 + e();
  return t;
}
function read_deltas(n, e) {
  let t = Array(n);
  for (let o = 0, c = 0; o < n; o++)
    t[o] = c += signed(e());
  return t;
}
function read_member_array(n, e) {
  let t = read_ascending(n(), n), o = n(), c = read_ascending(o, n), a = read_counts(o, n);
  for (let d = 0; d < o; d++)
    for (let p = 0; p < a[d]; p++)
      t.push(c[d] + p);
  return e ? t.map((d) => e[d]) : t;
}
function read_mapped_map(n) {
  let e = [];
  for (; ; ) {
    let t = n();
    if (t == 0)
      break;
    e.push(read_linear_table(t, n));
  }
  for (; ; ) {
    let t = n() - 1;
    if (t < 0)
      break;
    e.push(read_replacement_table(t, n));
  }
  return fromEntries(flat(e));
}
function read_zero_terminated_array(n) {
  let e = [];
  for (; ; ) {
    let t = n();
    if (t == 0)
      break;
    e.push(t);
  }
  return e;
}
function read_transposed(n, e, t) {
  let o = Array(n).fill(void 0).map(() => []);
  for (let c = 0; c < e; c++)
    read_deltas(n, t).forEach((a, d) => o[d].push(a));
  return o;
}
function read_linear_table(n, e) {
  let t = 1 + e(), o = e(), c = read_zero_terminated_array(e), a = read_transposed(c.length, 1 + n, e);
  return flat(a.map((d, p) => {
    const w = d[0], M = d.slice(1);
    return Array(c[p]).fill(void 0).map((I, B) => {
      let H = B * o;
      return [w + B * t, M.map((L) => L + H)];
    });
  }));
}
function read_replacement_table(n, e) {
  let t = 1 + e();
  return read_transposed(t, 1 + n, e).map((c) => [c[0], c.slice(1)]);
}
function read_emoji_trie(n) {
  let e = read_member_array(n).sort((o, c) => o - c);
  return t();
  function t() {
    let o = [];
    for (; ; ) {
      let M = read_member_array(n, e);
      if (M.length == 0)
        break;
      o.push({ set: new Set(M), node: t() });
    }
    o.sort((M, I) => I.set.size - M.set.size);
    let c = n(), a = c % 3;
    c = c / 3 | 0;
    let d = !!(c & 1);
    c >>= 1;
    let p = c == 1, w = c == 2;
    return { branches: o, valid: a, fe0f: d, save: p, check: w };
  }
}
function getData() {
  return read_compressed_payload(decode("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const r$1 = getData(), VALID = new Set(read_member_array(r$1)), IGNORED = new Set(read_member_array(r$1)), MAPPED = read_mapped_map(r$1), EMOJI_ROOT = read_emoji_trie(r$1), HYPHEN = 45, UNDERSCORE = 95;
function explode_cp(n) {
  return toUtf8CodePoints(n);
}
function filter_fe0f(n) {
  return n.filter((e) => e != 65039);
}
function ens_normalize_post_check(n) {
  for (let e of n.split(".")) {
    let t = explode_cp(e);
    try {
      for (let o = t.lastIndexOf(UNDERSCORE) - 1; o >= 0; o--)
        if (t[o] !== UNDERSCORE)
          throw new Error("underscore only allowed at start");
      if (t.length >= 4 && t.every((o) => o < 128) && t[2] === HYPHEN && t[3] === HYPHEN)
        throw new Error("invalid label extension");
    } catch (o) {
      throw new Error(`Invalid label "${e}": ${o.message}`);
    }
  }
  return n;
}
function ens_normalize(n) {
  return ens_normalize_post_check(normalize(n, filter_fe0f));
}
function normalize(n, e) {
  let t = explode_cp(n).reverse(), o = [];
  for (; t.length; ) {
    let c = consume_emoji_reversed(t);
    if (c) {
      o.push(...e(c));
      continue;
    }
    let a = t.pop();
    if (VALID.has(a)) {
      o.push(a);
      continue;
    }
    if (IGNORED.has(a))
      continue;
    let d = MAPPED[a];
    if (d) {
      o.push(...d);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${a.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...o)));
}
function nfc(n) {
  return n.normalize("NFC");
}
function consume_emoji_reversed(n, e) {
  var t;
  let o = EMOJI_ROOT, c, a, d = [], p = n.length;
  for (e && (e.length = 0); p; ) {
    let w = n[--p];
    if (o = (t = o.branches.find((M) => M.set.has(w))) === null || t === void 0 ? void 0 : t.node, !o)
      break;
    if (o.save)
      a = w;
    else if (o.check && w === a)
      break;
    d.push(w), o.fe0f && (d.push(65039), p > 0 && n[p - 1] == 65039 && p--), o.valid && (c = d.slice(), o.valid == 2 && c.splice(1, 1), e && e.push(...n.slice(p).reverse()), n.length = p);
  }
  return c;
}
const logger$g = new Logger(version$d), Zeros$1 = new Uint8Array(32);
Zeros$1.fill(0);
function checkComponent(n) {
  if (n.length === 0)
    throw new Error("invalid ENS name; empty component");
  return n;
}
function ensNameSplit(n) {
  const e = toUtf8Bytes(ens_normalize(n)), t = [];
  if (n.length === 0)
    return t;
  let o = 0;
  for (let c = 0; c < e.length; c++)
    e[c] === 46 && (t.push(checkComponent(e.slice(o, c))), o = c + 1);
  if (o >= e.length)
    throw new Error("invalid ENS name; empty component");
  return t.push(checkComponent(e.slice(o))), t;
}
function ensNormalize(n) {
  return ensNameSplit(n).map((e) => toUtf8String(e)).join(".");
}
function isValidName(n) {
  try {
    return ensNameSplit(n).length !== 0;
  } catch {
  }
  return !1;
}
function namehash(n) {
  typeof n != "string" && logger$g.throwArgumentError("invalid ENS name; not a string", "name", n);
  let e = Zeros$1;
  const t = ensNameSplit(n);
  for (; t.length; )
    e = keccak256$1(concat([e, keccak256$1(t.pop())]));
  return hexlify(e);
}
function dnsEncode(n) {
  return hexlify(concat(ensNameSplit(n).map((e) => {
    if (e.length > 63)
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const t = new Uint8Array(e.length + 1);
    return t.set(e, 1), t[0] = t.length - 1, t;
  }))) + "00";
}
const messagePrefix = `Ethereum Signed Message:
`;
function hashMessage(n) {
  return typeof n == "string" && (n = toUtf8Bytes(n)), keccak256$1(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(n.length)),
    n
  ]));
}
var __awaiter$6 = globalThis && globalThis.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
const logger$f = new Logger(version$d), padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1), Zero = BigNumber.from(0), One = BigNumber.from(1), MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(n) {
  const e = arrayify(n), t = e.length % 32;
  return t ? hexConcat([e, padding.slice(t)]) : hexlify(e);
}
const hexTrue = hexZeroPad(One.toHexString(), 32), hexFalse = hexZeroPad(Zero.toHexString(), 32), domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(n) {
  return function(e) {
    return typeof e != "string" && logger$f.throwArgumentError(`invalid domain value for ${JSON.stringify(n)}`, `domain.${n}`, e), e;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(n) {
    try {
      return BigNumber.from(n).toString();
    } catch {
    }
    return logger$f.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", n);
  },
  verifyingContract: function(n) {
    try {
      return getAddress(n).toLowerCase();
    } catch {
    }
    return logger$f.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", n);
  },
  salt: function(n) {
    try {
      const e = arrayify(n);
      if (e.length !== 32)
        throw new Error("bad length");
      return hexlify(e);
    } catch {
    }
    return logger$f.throwArgumentError('invalid domain value "salt"', "domain.salt", n);
  }
};
function getBaseEncoder(n) {
  {
    const e = n.match(/^(u?)int(\d*)$/);
    if (e) {
      const t = e[1] === "", o = parseInt(e[2] || "256");
      (o % 8 !== 0 || o > 256 || e[2] && e[2] !== String(o)) && logger$f.throwArgumentError("invalid numeric width", "type", n);
      const c = MaxUint256.mask(t ? o - 1 : o), a = t ? c.add(One).mul(NegativeOne) : Zero;
      return function(d) {
        const p = BigNumber.from(d);
        return (p.lt(a) || p.gt(c)) && logger$f.throwArgumentError(`value out-of-bounds for ${n}`, "value", d), hexZeroPad(p.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const e = n.match(/^bytes(\d+)$/);
    if (e) {
      const t = parseInt(e[1]);
      return (t === 0 || t > 32 || e[1] !== String(t)) && logger$f.throwArgumentError("invalid bytes width", "type", n), function(o) {
        return arrayify(o).length !== t && logger$f.throwArgumentError(`invalid length for ${n}`, "value", o), hexPadRight(o);
      };
    }
  }
  switch (n) {
    case "address":
      return function(e) {
        return hexZeroPad(getAddress(e), 32);
      };
    case "bool":
      return function(e) {
        return e ? hexTrue : hexFalse;
      };
    case "bytes":
      return function(e) {
        return keccak256$1(e);
      };
    case "string":
      return function(e) {
        return id(e);
      };
  }
  return null;
}
function encodeType(n, e) {
  return `${n}(${e.map(({ name: t, type: o }) => o + " " + t).join(",")})`;
}
class TypedDataEncoder {
  constructor(e) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(e))), defineReadOnly(this, "_encoderCache", {}), defineReadOnly(this, "_types", {});
    const t = {}, o = {}, c = {};
    Object.keys(e).forEach((p) => {
      t[p] = {}, o[p] = [], c[p] = {};
    });
    for (const p in e) {
      const w = {};
      e[p].forEach((M) => {
        w[M.name] && logger$f.throwArgumentError(`duplicate variable name ${JSON.stringify(M.name)} in ${JSON.stringify(p)}`, "types", e), w[M.name] = !0;
        const I = M.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        I === p && logger$f.throwArgumentError(`circular type reference to ${JSON.stringify(I)}`, "types", e), !getBaseEncoder(I) && (o[I] || logger$f.throwArgumentError(`unknown type ${JSON.stringify(I)}`, "types", e), o[I].push(p), t[p][I] = !0);
      });
    }
    const a = Object.keys(o).filter((p) => o[p].length === 0);
    a.length === 0 ? logger$f.throwArgumentError("missing primary type", "types", e) : a.length > 1 && logger$f.throwArgumentError(`ambiguous primary types or unused types: ${a.map((p) => JSON.stringify(p)).join(", ")}`, "types", e), defineReadOnly(this, "primaryType", a[0]);
    function d(p, w) {
      w[p] && logger$f.throwArgumentError(`circular type reference to ${JSON.stringify(p)}`, "types", e), w[p] = !0, Object.keys(t[p]).forEach((M) => {
        !o[M] || (d(M, w), Object.keys(w).forEach((I) => {
          c[I][M] = !0;
        }));
      }), delete w[p];
    }
    d(this.primaryType, {});
    for (const p in c) {
      const w = Object.keys(c[p]);
      w.sort(), this._types[p] = encodeType(p, e[p]) + w.map((M) => encodeType(M, e[M])).join("");
    }
  }
  getEncoder(e) {
    let t = this._encoderCache[e];
    return t || (t = this._encoderCache[e] = this._getEncoder(e)), t;
  }
  _getEncoder(e) {
    {
      const c = getBaseEncoder(e);
      if (c)
        return c;
    }
    const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (t) {
      const c = t[1], a = this.getEncoder(c), d = parseInt(t[3]);
      return (p) => {
        d >= 0 && p.length !== d && logger$f.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", p);
        let w = p.map(a);
        return this._types[c] && (w = w.map(keccak256$1)), keccak256$1(hexConcat(w));
      };
    }
    const o = this.types[e];
    if (o) {
      const c = id(this._types[e]);
      return (a) => {
        const d = o.map(({ name: p, type: w }) => {
          const M = this.getEncoder(w)(a[p]);
          return this._types[w] ? keccak256$1(M) : M;
        });
        return d.unshift(c), hexConcat(d);
      };
    }
    return logger$f.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  encodeType(e) {
    const t = this._types[e];
    return t || logger$f.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e), t;
  }
  encodeData(e, t) {
    return this.getEncoder(e)(t);
  }
  hashStruct(e, t) {
    return keccak256$1(this.encodeData(e, t));
  }
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  _visit(e, t, o) {
    if (getBaseEncoder(e))
      return o(e, t);
    const c = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (c) {
      const d = c[1], p = parseInt(c[3]);
      return p >= 0 && t.length !== p && logger$f.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", t), t.map((w) => this._visit(d, w, o));
    }
    const a = this.types[e];
    return a ? a.reduce((d, { name: p, type: w }) => (d[p] = this._visit(w, t[p], o), d), {}) : logger$f.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  visit(e, t) {
    return this._visit(this.primaryType, e, t);
  }
  static from(e) {
    return new TypedDataEncoder(e);
  }
  static getPrimaryType(e) {
    return TypedDataEncoder.from(e).primaryType;
  }
  static hashStruct(e, t, o) {
    return TypedDataEncoder.from(t).hashStruct(e, o);
  }
  static hashDomain(e) {
    const t = [];
    for (const o in e) {
      const c = domainFieldTypes[o];
      c || logger$f.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(o)}`, "domain", e), t.push({ name: o, type: c });
    }
    return t.sort((o, c) => domainFieldNames.indexOf(o.name) - domainFieldNames.indexOf(c.name)), TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: t }, e);
  }
  static encode(e, t, o) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(e),
      TypedDataEncoder.from(t).hash(o)
    ]);
  }
  static hash(e, t, o) {
    return keccak256$1(TypedDataEncoder.encode(e, t, o));
  }
  static resolveNames(e, t, o, c) {
    return __awaiter$6(this, void 0, void 0, function* () {
      e = shallowCopy(e);
      const a = {};
      e.verifyingContract && !isHexString(e.verifyingContract, 20) && (a[e.verifyingContract] = "0x");
      const d = TypedDataEncoder.from(t);
      d.visit(o, (p, w) => (p === "address" && !isHexString(w, 20) && (a[w] = "0x"), w));
      for (const p in a)
        a[p] = yield c(p);
      return e.verifyingContract && a[e.verifyingContract] && (e.verifyingContract = a[e.verifyingContract]), o = d.visit(o, (p, w) => p === "address" && a[w] ? a[w] : w), { domain: e, value: o };
    });
  }
  static getPayload(e, t, o) {
    TypedDataEncoder.hashDomain(e);
    const c = {}, a = [];
    domainFieldNames.forEach((w) => {
      const M = e[w];
      M != null && (c[w] = domainChecks[w](M), a.push({ name: w, type: domainFieldTypes[w] }));
    });
    const d = TypedDataEncoder.from(t), p = shallowCopy(t);
    return p.EIP712Domain ? logger$f.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", t) : p.EIP712Domain = a, d.encode(o), {
      types: p,
      domain: c,
      primaryType: d.primaryType,
      message: d.visit(o, (w, M) => {
        if (w.match(/^bytes(\d*)/))
          return hexlify(arrayify(M));
        if (w.match(/^u?int/))
          return BigNumber.from(M).toString();
        switch (w) {
          case "address":
            return M.toLowerCase();
          case "bool":
            return !!M;
          case "string":
            return typeof M != "string" && logger$f.throwArgumentError("invalid string", "value", M), M;
        }
        return logger$f.throwArgumentError("unsupported type", "type", w);
      })
    };
  }
}
const lib_esm$c = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id,
  dnsEncode,
  namehash,
  isValidName,
  ensNormalize,
  messagePrefix,
  hashMessage,
  _TypedDataEncoder: TypedDataEncoder
}, Symbol.toStringTag, { value: "Module" })), logger$e = new Logger(version$h);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(n, e) {
  const t = new Error(`deferred error during ABI decoding triggered accessing ${n}`);
  return t.error = e, t;
}
class Interface {
  constructor(e) {
    let t = [];
    typeof e == "string" ? t = JSON.parse(e) : t = e, defineReadOnly(this, "fragments", t.map((o) => Fragment.from(o)).filter((o) => o != null)), defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")()), defineReadOnly(this, "functions", {}), defineReadOnly(this, "errors", {}), defineReadOnly(this, "events", {}), defineReadOnly(this, "structs", {}), this.fragments.forEach((o) => {
      let c = null;
      switch (o.type) {
        case "constructor":
          if (this.deploy) {
            logger$e.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", o);
          return;
        case "function":
          c = this.functions;
          break;
        case "event":
          c = this.events;
          break;
        case "error":
          c = this.errors;
          break;
        default:
          return;
      }
      let a = o.format();
      if (c[a]) {
        logger$e.warn("duplicate definition - " + a);
        return;
      }
      c[a] = o;
    }), this.deploy || defineReadOnly(this, "deploy", ConstructorFragment.from({
      payable: !1,
      type: "constructor"
    })), defineReadOnly(this, "_isInterface", !0);
  }
  format(e) {
    e || (e = FormatTypes.full), e === FormatTypes.sighash && logger$e.throwArgumentError("interface does not support formatting sighash", "format", e);
    const t = this.fragments.map((o) => o.format(e));
    return e === FormatTypes.json ? JSON.stringify(t.map((o) => JSON.parse(o))) : t;
  }
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(e) {
    return getAddress(e);
  }
  static getSighash(e) {
    return hexDataSlice(id(e.format()), 0, 4);
  }
  static getEventTopic(e) {
    return id(e.format());
  }
  getFunction(e) {
    if (isHexString(e)) {
      for (const o in this.functions)
        if (e === this.getSighash(o))
          return this.functions[o];
      logger$e.throwArgumentError("no matching function", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const o = e.trim(), c = Object.keys(this.functions).filter((a) => a.split("(")[0] === o);
      return c.length === 0 ? logger$e.throwArgumentError("no matching function", "name", o) : c.length > 1 && logger$e.throwArgumentError("multiple matching functions", "name", o), this.functions[c[0]];
    }
    const t = this.functions[FunctionFragment.fromString(e).format()];
    return t || logger$e.throwArgumentError("no matching function", "signature", e), t;
  }
  getEvent(e) {
    if (isHexString(e)) {
      const o = e.toLowerCase();
      for (const c in this.events)
        if (o === this.getEventTopic(c))
          return this.events[c];
      logger$e.throwArgumentError("no matching event", "topichash", o);
    }
    if (e.indexOf("(") === -1) {
      const o = e.trim(), c = Object.keys(this.events).filter((a) => a.split("(")[0] === o);
      return c.length === 0 ? logger$e.throwArgumentError("no matching event", "name", o) : c.length > 1 && logger$e.throwArgumentError("multiple matching events", "name", o), this.events[c[0]];
    }
    const t = this.events[EventFragment.fromString(e).format()];
    return t || logger$e.throwArgumentError("no matching event", "signature", e), t;
  }
  getError(e) {
    if (isHexString(e)) {
      const o = getStatic(this.constructor, "getSighash");
      for (const c in this.errors) {
        const a = this.errors[c];
        if (e === o(a))
          return this.errors[c];
      }
      logger$e.throwArgumentError("no matching error", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const o = e.trim(), c = Object.keys(this.errors).filter((a) => a.split("(")[0] === o);
      return c.length === 0 ? logger$e.throwArgumentError("no matching error", "name", o) : c.length > 1 && logger$e.throwArgumentError("multiple matching errors", "name", o), this.errors[c[0]];
    }
    const t = this.errors[FunctionFragment.fromString(e).format()];
    return t || logger$e.throwArgumentError("no matching error", "signature", e), t;
  }
  getSighash(e) {
    if (typeof e == "string")
      try {
        e = this.getFunction(e);
      } catch (t) {
        try {
          e = this.getError(e);
        } catch {
          throw t;
        }
      }
    return getStatic(this.constructor, "getSighash")(e);
  }
  getEventTopic(e) {
    return typeof e == "string" && (e = this.getEvent(e)), getStatic(this.constructor, "getEventTopic")(e);
  }
  _decodeParams(e, t) {
    return this._abiCoder.decode(e, t);
  }
  _encodeParams(e, t) {
    return this._abiCoder.encode(e, t);
  }
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  decodeErrorResult(e, t) {
    typeof e == "string" && (e = this.getError(e));
    const o = arrayify(t);
    return hexlify(o.slice(0, 4)) !== this.getSighash(e) && logger$e.throwArgumentError(`data signature does not match error ${e.name}.`, "data", hexlify(o)), this._decodeParams(e.inputs, o.slice(4));
  }
  encodeErrorResult(e, t) {
    return typeof e == "string" && (e = this.getError(e)), hexlify(concat([
      this.getSighash(e),
      this._encodeParams(e.inputs, t || [])
    ]));
  }
  decodeFunctionData(e, t) {
    typeof e == "string" && (e = this.getFunction(e));
    const o = arrayify(t);
    return hexlify(o.slice(0, 4)) !== this.getSighash(e) && logger$e.throwArgumentError(`data signature does not match function ${e.name}.`, "data", hexlify(o)), this._decodeParams(e.inputs, o.slice(4));
  }
  encodeFunctionData(e, t) {
    return typeof e == "string" && (e = this.getFunction(e)), hexlify(concat([
      this.getSighash(e),
      this._encodeParams(e.inputs, t || [])
    ]));
  }
  decodeFunctionResult(e, t) {
    typeof e == "string" && (e = this.getFunction(e));
    let o = arrayify(t), c = null, a = "", d = null, p = null, w = null;
    switch (o.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(e.outputs, o);
        } catch {
        }
        break;
      case 4: {
        const M = hexlify(o.slice(0, 4)), I = BuiltinErrors[M];
        if (I)
          d = this._abiCoder.decode(I.inputs, o.slice(4)), p = I.name, w = I.signature, I.reason && (c = d[0]), p === "Error" ? a = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(d[0])}` : p === "Panic" && (a = `; VM Exception while processing transaction: reverted with panic code ${d[0]}`);
        else
          try {
            const B = this.getError(M);
            d = this._abiCoder.decode(B.inputs, o.slice(4)), p = B.name, w = B.format();
          } catch {
          }
        break;
      }
    }
    return logger$e.throwError("call revert exception" + a, Logger.errors.CALL_EXCEPTION, {
      method: e.format(),
      data: hexlify(t),
      errorArgs: d,
      errorName: p,
      errorSignature: w,
      reason: c
    });
  }
  encodeFunctionResult(e, t) {
    return typeof e == "string" && (e = this.getFunction(e)), hexlify(this._abiCoder.encode(e.outputs, t || []));
  }
  encodeFilterTopics(e, t) {
    typeof e == "string" && (e = this.getEvent(e)), t.length > e.inputs.length && logger$e.throwError("too many arguments for " + e.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
      argument: "values",
      value: t
    });
    let o = [];
    e.anonymous || o.push(this.getEventTopic(e));
    const c = (a, d) => a.type === "string" ? id(d) : a.type === "bytes" ? keccak256$1(hexlify(d)) : (a.type === "bool" && typeof d == "boolean" && (d = d ? "0x01" : "0x00"), a.type.match(/^u?int/) && (d = BigNumber.from(d).toHexString()), a.type === "address" && this._abiCoder.encode(["address"], [d]), hexZeroPad(hexlify(d), 32));
    for (t.forEach((a, d) => {
      let p = e.inputs[d];
      if (!p.indexed) {
        a != null && logger$e.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + p.name, a);
        return;
      }
      a == null ? o.push(null) : p.baseType === "array" || p.baseType === "tuple" ? logger$e.throwArgumentError("filtering with tuples or arrays not supported", "contract." + p.name, a) : Array.isArray(a) ? o.push(a.map((w) => c(p, w))) : o.push(c(p, a));
    }); o.length && o[o.length - 1] === null; )
      o.pop();
    return o;
  }
  encodeEventLog(e, t) {
    typeof e == "string" && (e = this.getEvent(e));
    const o = [], c = [], a = [];
    return e.anonymous || o.push(this.getEventTopic(e)), t.length !== e.inputs.length && logger$e.throwArgumentError("event arguments/values mismatch", "values", t), e.inputs.forEach((d, p) => {
      const w = t[p];
      if (d.indexed)
        if (d.type === "string")
          o.push(id(w));
        else if (d.type === "bytes")
          o.push(keccak256$1(w));
        else {
          if (d.baseType === "tuple" || d.baseType === "array")
            throw new Error("not implemented");
          o.push(this._abiCoder.encode([d.type], [w]));
        }
      else
        c.push(d), a.push(w);
    }), {
      data: this._abiCoder.encode(c, a),
      topics: o
    };
  }
  decodeEventLog(e, t, o) {
    if (typeof e == "string" && (e = this.getEvent(e)), o != null && !e.anonymous) {
      let H = this.getEventTopic(e);
      (!isHexString(o[0], 32) || o[0].toLowerCase() !== H) && logger$e.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: H, value: o[0] }), o = o.slice(1);
    }
    let c = [], a = [], d = [];
    e.inputs.forEach((H, L) => {
      H.indexed ? H.type === "string" || H.type === "bytes" || H.baseType === "tuple" || H.baseType === "array" ? (c.push(ParamType.fromObject({ type: "bytes32", name: H.name })), d.push(!0)) : (c.push(H), d.push(!1)) : (a.push(H), d.push(!1));
    });
    let p = o != null ? this._abiCoder.decode(c, concat(o)) : null, w = this._abiCoder.decode(a, t, !0), M = [], I = 0, B = 0;
    e.inputs.forEach((H, L) => {
      if (H.indexed)
        if (p == null)
          M[L] = new Indexed({ _isIndexed: !0, hash: null });
        else if (d[L])
          M[L] = new Indexed({ _isIndexed: !0, hash: p[B++] });
        else
          try {
            M[L] = p[B++];
          } catch (W) {
            M[L] = W;
          }
      else
        try {
          M[L] = w[I++];
        } catch (W) {
          M[L] = W;
        }
      if (H.name && M[H.name] == null) {
        const W = M[L];
        W instanceof Error ? Object.defineProperty(M, H.name, {
          enumerable: !0,
          get: () => {
            throw wrapAccessError(`property ${JSON.stringify(H.name)}`, W);
          }
        }) : M[H.name] = W;
      }
    });
    for (let H = 0; H < M.length; H++) {
      const L = M[H];
      L instanceof Error && Object.defineProperty(M, H, {
        enumerable: !0,
        get: () => {
          throw wrapAccessError(`index ${H}`, L);
        }
      });
    }
    return Object.freeze(M);
  }
  parseTransaction(e) {
    let t = this.getFunction(e.data.substring(0, 10).toLowerCase());
    return t ? new TransactionDescription({
      args: this._abiCoder.decode(t.inputs, "0x" + e.data.substring(10)),
      functionFragment: t,
      name: t.name,
      signature: t.format(),
      sighash: this.getSighash(t),
      value: BigNumber.from(e.value || "0")
    }) : null;
  }
  parseLog(e) {
    let t = this.getEvent(e.topics[0]);
    return !t || t.anonymous ? null : new LogDescription({
      eventFragment: t,
      name: t.name,
      signature: t.format(),
      topic: this.getEventTopic(t),
      args: this.decodeEventLog(t, e.data, e.topics)
    });
  }
  parseError(e) {
    const t = hexlify(e);
    let o = this.getError(t.substring(0, 10).toLowerCase());
    return o ? new ErrorDescription({
      args: this._abiCoder.decode(o.inputs, "0x" + t.substring(10)),
      errorFragment: o,
      name: o.name,
      signature: o.format(),
      sighash: this.getSighash(o)
    }) : null;
  }
  static isInterface(e) {
    return !!(e && e._isInterface);
  }
}
const lib_esm$b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  Fragment,
  FunctionFragment,
  ParamType,
  FormatTypes,
  AbiCoder,
  defaultAbiCoder,
  Interface,
  Indexed,
  checkResultErrors,
  LogDescription,
  TransactionDescription
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$b), require$$1 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$f), require$$2 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$d);
class BaseX {
  constructor(e) {
    defineReadOnly(this, "alphabet", e), defineReadOnly(this, "base", e.length), defineReadOnly(this, "_alphabetMap", {}), defineReadOnly(this, "_leader", e.charAt(0));
    for (let t = 0; t < e.length; t++)
      this._alphabetMap[e.charAt(t)] = t;
  }
  encode(e) {
    let t = arrayify(e);
    if (t.length === 0)
      return "";
    let o = [0];
    for (let a = 0; a < t.length; ++a) {
      let d = t[a];
      for (let p = 0; p < o.length; ++p)
        d += o[p] << 8, o[p] = d % this.base, d = d / this.base | 0;
      for (; d > 0; )
        o.push(d % this.base), d = d / this.base | 0;
    }
    let c = "";
    for (let a = 0; t[a] === 0 && a < t.length - 1; ++a)
      c += this._leader;
    for (let a = o.length - 1; a >= 0; --a)
      c += this.alphabet[o[a]];
    return c;
  }
  decode(e) {
    if (typeof e != "string")
      throw new TypeError("Expected String");
    let t = [];
    if (e.length === 0)
      return new Uint8Array(t);
    t.push(0);
    for (let o = 0; o < e.length; o++) {
      let c = this._alphabetMap[e[o]];
      if (c === void 0)
        throw new Error("Non-base" + this.base + " character");
      let a = c;
      for (let d = 0; d < t.length; ++d)
        a += t[d] * this.base, t[d] = a & 255, a >>= 8;
      for (; a > 0; )
        t.push(a & 255), a >>= 8;
    }
    for (let o = 0; e[o] === this._leader && o < e.length - 1; ++o)
      t.push(0);
    return arrayify(new Uint8Array(t.reverse()));
  }
}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567"), Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), lib_esm$a = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseX,
  Base32,
  Base58
}, Symbol.toStringTag, { value: "Module" })), require$$3 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$a), require$$4 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$j), require$$5 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$c);
var hash = {}, utils$9 = {}, minimalisticAssert$1 = assert$b;
function assert$b(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
assert$b.equal = function n(e, t, o) {
  if (e != t)
    throw new Error(o || "Assertion failed: " + e + " != " + t);
};
var assert$a = minimalisticAssert$1, inherits = inherits_browser$1.exports;
utils$9.inherits = inherits;
function isSurrogatePair(n, e) {
  return (n.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= n.length ? !1 : (n.charCodeAt(e + 1) & 64512) === 56320;
}
function toArray(n, e) {
  if (Array.isArray(n))
    return n.slice();
  if (!n)
    return [];
  var t = [];
  if (typeof n == "string")
    if (e) {
      if (e === "hex")
        for (n = n.replace(/[^a-z0-9]+/ig, ""), n.length % 2 !== 0 && (n = "0" + n), c = 0; c < n.length; c += 2)
          t.push(parseInt(n[c] + n[c + 1], 16));
    } else
      for (var o = 0, c = 0; c < n.length; c++) {
        var a = n.charCodeAt(c);
        a < 128 ? t[o++] = a : a < 2048 ? (t[o++] = a >> 6 | 192, t[o++] = a & 63 | 128) : isSurrogatePair(n, c) ? (a = 65536 + ((a & 1023) << 10) + (n.charCodeAt(++c) & 1023), t[o++] = a >> 18 | 240, t[o++] = a >> 12 & 63 | 128, t[o++] = a >> 6 & 63 | 128, t[o++] = a & 63 | 128) : (t[o++] = a >> 12 | 224, t[o++] = a >> 6 & 63 | 128, t[o++] = a & 63 | 128);
      }
  else
    for (c = 0; c < n.length; c++)
      t[c] = n[c] | 0;
  return t;
}
utils$9.toArray = toArray;
function toHex(n) {
  for (var e = "", t = 0; t < n.length; t++)
    e += zero2(n[t].toString(16));
  return e;
}
utils$9.toHex = toHex;
function htonl(n) {
  var e = n >>> 24 | n >>> 8 & 65280 | n << 8 & 16711680 | (n & 255) << 24;
  return e >>> 0;
}
utils$9.htonl = htonl;
function toHex32(n, e) {
  for (var t = "", o = 0; o < n.length; o++) {
    var c = n[o];
    e === "little" && (c = htonl(c)), t += zero8(c.toString(16));
  }
  return t;
}
utils$9.toHex32 = toHex32;
function zero2(n) {
  return n.length === 1 ? "0" + n : n;
}
utils$9.zero2 = zero2;
function zero8(n) {
  return n.length === 7 ? "0" + n : n.length === 6 ? "00" + n : n.length === 5 ? "000" + n : n.length === 4 ? "0000" + n : n.length === 3 ? "00000" + n : n.length === 2 ? "000000" + n : n.length === 1 ? "0000000" + n : n;
}
utils$9.zero8 = zero8;
function join32(n, e, t, o) {
  var c = t - e;
  assert$a(c % 4 === 0);
  for (var a = new Array(c / 4), d = 0, p = e; d < a.length; d++, p += 4) {
    var w;
    o === "big" ? w = n[p] << 24 | n[p + 1] << 16 | n[p + 2] << 8 | n[p + 3] : w = n[p + 3] << 24 | n[p + 2] << 16 | n[p + 1] << 8 | n[p], a[d] = w >>> 0;
  }
  return a;
}
utils$9.join32 = join32;
function split32(n, e) {
  for (var t = new Array(n.length * 4), o = 0, c = 0; o < n.length; o++, c += 4) {
    var a = n[o];
    e === "big" ? (t[c] = a >>> 24, t[c + 1] = a >>> 16 & 255, t[c + 2] = a >>> 8 & 255, t[c + 3] = a & 255) : (t[c + 3] = a >>> 24, t[c + 2] = a >>> 16 & 255, t[c + 1] = a >>> 8 & 255, t[c] = a & 255);
  }
  return t;
}
utils$9.split32 = split32;
function rotr32$1(n, e) {
  return n >>> e | n << 32 - e;
}
utils$9.rotr32 = rotr32$1;
function rotl32$2(n, e) {
  return n << e | n >>> 32 - e;
}
utils$9.rotl32 = rotl32$2;
function sum32$3(n, e) {
  return n + e >>> 0;
}
utils$9.sum32 = sum32$3;
function sum32_3$1(n, e, t) {
  return n + e + t >>> 0;
}
utils$9.sum32_3 = sum32_3$1;
function sum32_4$2(n, e, t, o) {
  return n + e + t + o >>> 0;
}
utils$9.sum32_4 = sum32_4$2;
function sum32_5$2(n, e, t, o, c) {
  return n + e + t + o + c >>> 0;
}
utils$9.sum32_5 = sum32_5$2;
function sum64$1(n, e, t, o) {
  var c = n[e], a = n[e + 1], d = o + a >>> 0, p = (d < o ? 1 : 0) + t + c;
  n[e] = p >>> 0, n[e + 1] = d;
}
utils$9.sum64 = sum64$1;
function sum64_hi$1(n, e, t, o) {
  var c = e + o >>> 0, a = (c < e ? 1 : 0) + n + t;
  return a >>> 0;
}
utils$9.sum64_hi = sum64_hi$1;
function sum64_lo$1(n, e, t, o) {
  var c = e + o;
  return c >>> 0;
}
utils$9.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(n, e, t, o, c, a, d, p) {
  var w = 0, M = e;
  M = M + o >>> 0, w += M < e ? 1 : 0, M = M + a >>> 0, w += M < a ? 1 : 0, M = M + p >>> 0, w += M < p ? 1 : 0;
  var I = n + t + c + d + w;
  return I >>> 0;
}
utils$9.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(n, e, t, o, c, a, d, p) {
  var w = e + o + a + p;
  return w >>> 0;
}
utils$9.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(n, e, t, o, c, a, d, p, w, M) {
  var I = 0, B = e;
  B = B + o >>> 0, I += B < e ? 1 : 0, B = B + a >>> 0, I += B < a ? 1 : 0, B = B + p >>> 0, I += B < p ? 1 : 0, B = B + M >>> 0, I += B < M ? 1 : 0;
  var H = n + t + c + d + w + I;
  return H >>> 0;
}
utils$9.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(n, e, t, o, c, a, d, p, w, M) {
  var I = e + o + a + p + M;
  return I >>> 0;
}
utils$9.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(n, e, t) {
  var o = e << 32 - t | n >>> t;
  return o >>> 0;
}
utils$9.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(n, e, t) {
  var o = n << 32 - t | e >>> t;
  return o >>> 0;
}
utils$9.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(n, e, t) {
  return n >>> t;
}
utils$9.shr64_hi = shr64_hi$1;
function shr64_lo$1(n, e, t) {
  var o = n << 32 - t | e >>> t;
  return o >>> 0;
}
utils$9.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$8 = utils$9, assert$9 = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function n(e, t) {
  if (e = utils$8.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var o = e.length % this._delta8;
    this.pending = e.slice(e.length - o, e.length), this.pending.length === 0 && (this.pending = null), e = utils$8.join32(e, 0, e.length - o, this.endian);
    for (var c = 0; c < e.length; c += this._delta32)
      this._update(e, c, c + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function n(e) {
  return this.update(this._pad()), assert$9(this.pending === null), this._digest(e);
};
BlockHash$4.prototype._pad = function n() {
  var e = this.pendingTotal, t = this._delta8, o = t - (e + this.padLength) % t, c = new Array(o + this.padLength);
  c[0] = 128;
  for (var a = 1; a < o; a++)
    c[a] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var d = 8; d < this.padLength; d++)
      c[a++] = 0;
    c[a++] = 0, c[a++] = 0, c[a++] = 0, c[a++] = 0, c[a++] = e >>> 24 & 255, c[a++] = e >>> 16 & 255, c[a++] = e >>> 8 & 255, c[a++] = e & 255;
  } else
    for (c[a++] = e & 255, c[a++] = e >>> 8 & 255, c[a++] = e >>> 16 & 255, c[a++] = e >>> 24 & 255, c[a++] = 0, c[a++] = 0, c[a++] = 0, c[a++] = 0, d = 8; d < this.padLength; d++)
      c[a++] = 0;
  return c;
};
var sha = {}, common$4 = {}, utils$7 = utils$9, rotr32 = utils$7.rotr32;
function ft_1$1(n, e, t, o) {
  if (n === 0)
    return ch32$1(e, t, o);
  if (n === 1 || n === 3)
    return p32(e, t, o);
  if (n === 2)
    return maj32$1(e, t, o);
}
common$4.ft_1 = ft_1$1;
function ch32$1(n, e, t) {
  return n & e ^ ~n & t;
}
common$4.ch32 = ch32$1;
function maj32$1(n, e, t) {
  return n & e ^ n & t ^ e & t;
}
common$4.maj32 = maj32$1;
function p32(n, e, t) {
  return n ^ e ^ t;
}
common$4.p32 = p32;
function s0_256$1(n) {
  return rotr32(n, 2) ^ rotr32(n, 13) ^ rotr32(n, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(n) {
  return rotr32(n, 6) ^ rotr32(n, 11) ^ rotr32(n, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(n) {
  return rotr32(n, 7) ^ rotr32(n, 18) ^ n >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(n) {
  return rotr32(n, 17) ^ rotr32(n, 19) ^ n >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$6 = utils$9, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$6.rotl32, sum32$2 = utils$6.sum32, sum32_5$1 = utils$6.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$6.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function n(e, t) {
  for (var o = this.W, c = 0; c < 16; c++)
    o[c] = e[t + c];
  for (; c < o.length; c++)
    o[c] = rotl32$1(o[c - 3] ^ o[c - 8] ^ o[c - 14] ^ o[c - 16], 1);
  var a = this.h[0], d = this.h[1], p = this.h[2], w = this.h[3], M = this.h[4];
  for (c = 0; c < o.length; c++) {
    var I = ~~(c / 20), B = sum32_5$1(rotl32$1(a, 5), ft_1(I, d, p, w), M, o[c], sha1_K[I]);
    M = w, w = p, p = rotl32$1(d, 30), d = a, a = B;
  }
  this.h[0] = sum32$2(this.h[0], a), this.h[1] = sum32$2(this.h[1], d), this.h[2] = sum32$2(this.h[2], p), this.h[3] = sum32$2(this.h[3], w), this.h[4] = sum32$2(this.h[4], M);
};
SHA1.prototype._digest = function n(e) {
  return e === "hex" ? utils$6.toHex32(this.h, "big") : utils$6.split32(this.h, "big");
};
var utils$5 = utils$9, common$2 = common$5, shaCommon = common$4, assert$8 = minimalisticAssert$1, sum32$1 = utils$5.sum32, sum32_4$1 = utils$5.sum32_4, sum32_5 = utils$5.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$5.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function n(e, t) {
  for (var o = this.W, c = 0; c < 16; c++)
    o[c] = e[t + c];
  for (; c < o.length; c++)
    o[c] = sum32_4$1(g1_256(o[c - 2]), o[c - 7], g0_256(o[c - 15]), o[c - 16]);
  var a = this.h[0], d = this.h[1], p = this.h[2], w = this.h[3], M = this.h[4], I = this.h[5], B = this.h[6], H = this.h[7];
  for (assert$8(this.k.length === o.length), c = 0; c < o.length; c++) {
    var L = sum32_5(H, s1_256(M), ch32(M, I, B), this.k[c], o[c]), W = sum32$1(s0_256(a), maj32(a, d, p));
    H = B, B = I, I = M, M = sum32$1(w, L), w = p, p = d, d = a, a = sum32$1(L, W);
  }
  this.h[0] = sum32$1(this.h[0], a), this.h[1] = sum32$1(this.h[1], d), this.h[2] = sum32$1(this.h[2], p), this.h[3] = sum32$1(this.h[3], w), this.h[4] = sum32$1(this.h[4], M), this.h[5] = sum32$1(this.h[5], I), this.h[6] = sum32$1(this.h[6], B), this.h[7] = sum32$1(this.h[7], H);
};
SHA256$1.prototype._digest = function n(e) {
  return e === "hex" ? utils$5.toHex32(this.h, "big") : utils$5.split32(this.h, "big");
};
var utils$4 = utils$9, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$4.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function n(e) {
  return e === "hex" ? utils$4.toHex32(this.h.slice(0, 7), "big") : utils$4.split32(this.h.slice(0, 7), "big");
};
var utils$3 = utils$9, common$1 = common$5, assert$7 = minimalisticAssert$1, rotr64_hi = utils$3.rotr64_hi, rotr64_lo = utils$3.rotr64_lo, shr64_hi = utils$3.shr64_hi, shr64_lo = utils$3.shr64_lo, sum64 = utils$3.sum64, sum64_hi = utils$3.sum64_hi, sum64_lo = utils$3.sum64_lo, sum64_4_hi = utils$3.sum64_4_hi, sum64_4_lo = utils$3.sum64_4_lo, sum64_5_hi = utils$3.sum64_5_hi, sum64_5_lo = utils$3.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$3.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function n(e, t) {
  for (var o = this.W, c = 0; c < 32; c++)
    o[c] = e[t + c];
  for (; c < o.length; c += 2) {
    var a = g1_512_hi(o[c - 4], o[c - 3]), d = g1_512_lo(o[c - 4], o[c - 3]), p = o[c - 14], w = o[c - 13], M = g0_512_hi(o[c - 30], o[c - 29]), I = g0_512_lo(o[c - 30], o[c - 29]), B = o[c - 32], H = o[c - 31];
    o[c] = sum64_4_hi(
      a,
      d,
      p,
      w,
      M,
      I,
      B,
      H
    ), o[c + 1] = sum64_4_lo(
      a,
      d,
      p,
      w,
      M,
      I,
      B,
      H
    );
  }
};
SHA512$1.prototype._update = function n(e, t) {
  this._prepareBlock(e, t);
  var o = this.W, c = this.h[0], a = this.h[1], d = this.h[2], p = this.h[3], w = this.h[4], M = this.h[5], I = this.h[6], B = this.h[7], H = this.h[8], L = this.h[9], W = this.h[10], $ = this.h[11], P = this.h[12], U = this.h[13], G = this.h[14], D = this.h[15];
  assert$7(this.k.length === o.length);
  for (var Z = 0; Z < o.length; Z += 2) {
    var J = G, te = D, ue = s1_512_hi(H, L), he = s1_512_lo(H, L), Se = ch64_hi(H, L, W, $, P), C = ch64_lo(H, L, W, $, P, U), O = this.k[Z], V = this.k[Z + 1], x = o[Z], u = o[Z + 1], h = sum64_5_hi(
      J,
      te,
      ue,
      he,
      Se,
      C,
      O,
      V,
      x,
      u
    ), g = sum64_5_lo(
      J,
      te,
      ue,
      he,
      Se,
      C,
      O,
      V,
      x,
      u
    );
    J = s0_512_hi(c, a), te = s0_512_lo(c, a), ue = maj64_hi(c, a, d, p, w), he = maj64_lo(c, a, d, p, w, M);
    var y = sum64_hi(J, te, ue, he), m = sum64_lo(J, te, ue, he);
    G = P, D = U, P = W, U = $, W = H, $ = L, H = sum64_hi(I, B, h, g), L = sum64_lo(B, B, h, g), I = w, B = M, w = d, M = p, d = c, p = a, c = sum64_hi(h, g, y, m), a = sum64_lo(h, g, y, m);
  }
  sum64(this.h, 0, c, a), sum64(this.h, 2, d, p), sum64(this.h, 4, w, M), sum64(this.h, 6, I, B), sum64(this.h, 8, H, L), sum64(this.h, 10, W, $), sum64(this.h, 12, P, U), sum64(this.h, 14, G, D);
};
SHA512$1.prototype._digest = function n(e) {
  return e === "hex" ? utils$3.toHex32(this.h, "big") : utils$3.split32(this.h, "big");
};
function ch64_hi(n, e, t, o, c) {
  var a = n & t ^ ~n & c;
  return a < 0 && (a += 4294967296), a;
}
function ch64_lo(n, e, t, o, c, a) {
  var d = e & o ^ ~e & a;
  return d < 0 && (d += 4294967296), d;
}
function maj64_hi(n, e, t, o, c) {
  var a = n & t ^ n & c ^ t & c;
  return a < 0 && (a += 4294967296), a;
}
function maj64_lo(n, e, t, o, c, a) {
  var d = e & o ^ e & a ^ o & a;
  return d < 0 && (d += 4294967296), d;
}
function s0_512_hi(n, e) {
  var t = rotr64_hi(n, e, 28), o = rotr64_hi(e, n, 2), c = rotr64_hi(e, n, 7), a = t ^ o ^ c;
  return a < 0 && (a += 4294967296), a;
}
function s0_512_lo(n, e) {
  var t = rotr64_lo(n, e, 28), o = rotr64_lo(e, n, 2), c = rotr64_lo(e, n, 7), a = t ^ o ^ c;
  return a < 0 && (a += 4294967296), a;
}
function s1_512_hi(n, e) {
  var t = rotr64_hi(n, e, 14), o = rotr64_hi(n, e, 18), c = rotr64_hi(e, n, 9), a = t ^ o ^ c;
  return a < 0 && (a += 4294967296), a;
}
function s1_512_lo(n, e) {
  var t = rotr64_lo(n, e, 14), o = rotr64_lo(n, e, 18), c = rotr64_lo(e, n, 9), a = t ^ o ^ c;
  return a < 0 && (a += 4294967296), a;
}
function g0_512_hi(n, e) {
  var t = rotr64_hi(n, e, 1), o = rotr64_hi(n, e, 8), c = shr64_hi(n, e, 7), a = t ^ o ^ c;
  return a < 0 && (a += 4294967296), a;
}
function g0_512_lo(n, e) {
  var t = rotr64_lo(n, e, 1), o = rotr64_lo(n, e, 8), c = shr64_lo(n, e, 7), a = t ^ o ^ c;
  return a < 0 && (a += 4294967296), a;
}
function g1_512_hi(n, e) {
  var t = rotr64_hi(n, e, 19), o = rotr64_hi(e, n, 29), c = shr64_hi(n, e, 6), a = t ^ o ^ c;
  return a < 0 && (a += 4294967296), a;
}
function g1_512_lo(n, e) {
  var t = rotr64_lo(n, e, 19), o = rotr64_lo(e, n, 29), c = shr64_lo(n, e, 6), a = t ^ o ^ c;
  return a < 0 && (a += 4294967296), a;
}
var utils$2 = utils$9, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$2.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function n(e) {
  return e === "hex" ? utils$2.toHex32(this.h.slice(0, 12), "big") : utils$2.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$1 = utils$9, common = common$5, rotl32 = utils$1.rotl32, sum32 = utils$1.sum32, sum32_3 = utils$1.sum32_3, sum32_4 = utils$1.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$1.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function n(e, t) {
  for (var o = this.h[0], c = this.h[1], a = this.h[2], d = this.h[3], p = this.h[4], w = o, M = c, I = a, B = d, H = p, L = 0; L < 80; L++) {
    var W = sum32(
      rotl32(
        sum32_4(o, f(L, c, a, d), e[r[L] + t], K(L)),
        s[L]
      ),
      p
    );
    o = p, p = d, d = rotl32(a, 10), a = c, c = W, W = sum32(
      rotl32(
        sum32_4(w, f(79 - L, M, I, B), e[rh[L] + t], Kh$1(L)),
        sh$1[L]
      ),
      H
    ), w = H, H = B, B = rotl32(I, 10), I = M, M = W;
  }
  W = sum32_3(this.h[1], a, B), this.h[1] = sum32_3(this.h[2], d, H), this.h[2] = sum32_3(this.h[3], p, w), this.h[3] = sum32_3(this.h[4], o, M), this.h[4] = sum32_3(this.h[0], c, I), this.h[0] = W;
};
RIPEMD160.prototype._digest = function n(e) {
  return e === "hex" ? utils$1.toHex32(this.h, "little") : utils$1.split32(this.h, "little");
};
function f(n, e, t, o) {
  return n <= 15 ? e ^ t ^ o : n <= 31 ? e & t | ~e & o : n <= 47 ? (e | ~t) ^ o : n <= 63 ? e & o | t & ~o : e ^ (t | ~o);
}
function K(n) {
  return n <= 15 ? 0 : n <= 31 ? 1518500249 : n <= 47 ? 1859775393 : n <= 63 ? 2400959708 : 2840853838;
}
function Kh$1(n) {
  return n <= 15 ? 1352829926 : n <= 31 ? 1548603684 : n <= 47 ? 1836072691 : n <= 63 ? 2053994217 : 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh$1 = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils = utils$9, assert$6 = minimalisticAssert$1;
function Hmac(n, e, t) {
  if (!(this instanceof Hmac))
    return new Hmac(n, e, t);
  this.Hash = n, this.blockSize = n.blockSize / 8, this.outSize = n.outSize / 8, this.inner = null, this.outer = null, this._init(utils.toArray(e, t));
}
var hmac = Hmac;
Hmac.prototype._init = function n(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), assert$6(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++)
    e.push(0);
  for (t = 0; t < e.length; t++)
    e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++)
    e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
Hmac.prototype.update = function n(e, t) {
  return this.inner.update(e, t), this;
};
Hmac.prototype.digest = function n(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(n) {
  var e = n;
  e.utils = utils$9, e.common = common$5, e.sha = sha, e.ripemd = ripemd, e.hmac = hmac, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(hash);
var SupportedAlgorithm;
(function(n) {
  n.sha256 = "sha256", n.sha512 = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));
const version$c = "sha2/5.7.0", logger$d = new Logger(version$c);
function ripemd160(n) {
  return "0x" + hash.ripemd160().update(arrayify(n)).digest("hex");
}
function sha256$1(n) {
  return "0x" + hash.sha256().update(arrayify(n)).digest("hex");
}
function sha512(n) {
  return "0x" + hash.sha512().update(arrayify(n)).digest("hex");
}
function computeHmac(n, e, t) {
  return SupportedAlgorithm[n] || logger$d.throwError("unsupported algorithm " + n, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "hmac",
    algorithm: n
  }), "0x" + hash.hmac(hash[n], arrayify(e)).update(arrayify(t)).digest("hex");
}
const lib_esm$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  computeHmac,
  ripemd160,
  sha256: sha256$1,
  sha512,
  get SupportedAlgorithm() {
    return SupportedAlgorithm;
  }
}, Symbol.toStringTag, { value: "Module" }));
function pbkdf2$1(n, e, t, o, c) {
  n = arrayify(n), e = arrayify(e);
  let a, d = 1;
  const p = new Uint8Array(o), w = new Uint8Array(e.length + 4);
  w.set(e);
  let M, I;
  for (let B = 1; B <= d; B++) {
    w[e.length] = B >> 24 & 255, w[e.length + 1] = B >> 16 & 255, w[e.length + 2] = B >> 8 & 255, w[e.length + 3] = B & 255;
    let H = arrayify(computeHmac(c, n, w));
    a || (a = H.length, I = new Uint8Array(a), d = Math.ceil(o / a), M = o - (d - 1) * a), I.set(H);
    for (let $ = 1; $ < t; $++) {
      H = arrayify(computeHmac(c, n, H));
      for (let P = 0; P < a; P++)
        I[P] ^= H[P];
    }
    const L = (B - 1) * a, W = B === d ? M : a;
    p.set(arrayify(I).slice(0, W), L);
  }
  return hexlify(p);
}
var bn$1 = { exports: {} };
(function(n) {
  (function(e, t) {
    function o(x, u) {
      if (!x)
        throw new Error(u || "Assertion failed");
    }
    function c(x, u) {
      x.super_ = u;
      var h = function() {
      };
      h.prototype = u.prototype, x.prototype = new h(), x.prototype.constructor = x;
    }
    function a(x, u, h) {
      if (a.isBN(x))
        return x;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, x !== null && ((u === "le" || u === "be") && (h = u, u = 10), this._init(x || 0, u || 10, h || "be"));
    }
    typeof e == "object" ? e.exports = a : t.BN = a, a.BN = a, a.wordSize = 26;
    var d;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? d = window.Buffer : d = require$$0$3.Buffer;
    } catch {
    }
    a.isBN = function(u) {
      return u instanceof a ? !0 : u !== null && typeof u == "object" && u.constructor.wordSize === a.wordSize && Array.isArray(u.words);
    }, a.max = function(u, h) {
      return u.cmp(h) > 0 ? u : h;
    }, a.min = function(u, h) {
      return u.cmp(h) < 0 ? u : h;
    }, a.prototype._init = function(u, h, g) {
      if (typeof u == "number")
        return this._initNumber(u, h, g);
      if (typeof u == "object")
        return this._initArray(u, h, g);
      h === "hex" && (h = 16), o(h === (h | 0) && h >= 2 && h <= 36), u = u.toString().replace(/\s+/g, "");
      var y = 0;
      u[0] === "-" && (y++, this.negative = 1), y < u.length && (h === 16 ? this._parseHex(u, y, g) : (this._parseBase(u, h, y), g === "le" && this._initArray(this.toArray(), h, g)));
    }, a.prototype._initNumber = function(u, h, g) {
      u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [
        u & 67108863,
        u / 67108864 & 67108863
      ], this.length = 2) : (o(u < 9007199254740992), this.words = [
        u & 67108863,
        u / 67108864 & 67108863,
        1
      ], this.length = 3), g === "le" && this._initArray(this.toArray(), h, g);
    }, a.prototype._initArray = function(u, h, g) {
      if (o(typeof u.length == "number"), u.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var m, _, R = 0;
      if (g === "be")
        for (y = u.length - 1, m = 0; y >= 0; y -= 3)
          _ = u[y] | u[y - 1] << 8 | u[y - 2] << 16, this.words[m] |= _ << R & 67108863, this.words[m + 1] = _ >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, m++);
      else if (g === "le")
        for (y = 0, m = 0; y < u.length; y += 3)
          _ = u[y] | u[y + 1] << 8 | u[y + 2] << 16, this.words[m] |= _ << R & 67108863, this.words[m + 1] = _ >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, m++);
      return this._strip();
    };
    function p(x, u) {
      var h = x.charCodeAt(u);
      if (h >= 48 && h <= 57)
        return h - 48;
      if (h >= 65 && h <= 70)
        return h - 55;
      if (h >= 97 && h <= 102)
        return h - 87;
      o(!1, "Invalid character in " + x);
    }
    function w(x, u, h) {
      var g = p(x, h);
      return h - 1 >= u && (g |= p(x, h - 1) << 4), g;
    }
    a.prototype._parseHex = function(u, h, g) {
      this.length = Math.ceil((u.length - h) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var m = 0, _ = 0, R;
      if (g === "be")
        for (y = u.length - 1; y >= h; y -= 2)
          R = w(u, h, y) << m, this.words[_] |= R & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= R >>> 26) : m += 8;
      else {
        var b = u.length - h;
        for (y = b % 2 === 0 ? h + 1 : h; y < u.length; y += 2)
          R = w(u, h, y) << m, this.words[_] |= R & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= R >>> 26) : m += 8;
      }
      this._strip();
    };
    function M(x, u, h, g) {
      for (var y = 0, m = 0, _ = Math.min(x.length, h), R = u; R < _; R++) {
        var b = x.charCodeAt(R) - 48;
        y *= g, b >= 49 ? m = b - 49 + 10 : b >= 17 ? m = b - 17 + 10 : m = b, o(b >= 0 && m < g, "Invalid character"), y += m;
      }
      return y;
    }
    a.prototype._parseBase = function(u, h, g) {
      this.words = [0], this.length = 1;
      for (var y = 0, m = 1; m <= 67108863; m *= h)
        y++;
      y--, m = m / h | 0;
      for (var _ = u.length - g, R = _ % y, b = Math.min(_, _ - R) + g, l = 0, v = g; v < b; v += y)
        l = M(u, v, v + y, h), this.imuln(m), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      if (R !== 0) {
        var X = 1;
        for (l = M(u, v, u.length, h), v = 0; v < R; v++)
          X *= h;
        this.imuln(X), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      }
      this._strip();
    }, a.prototype.copy = function(u) {
      u.words = new Array(this.length);
      for (var h = 0; h < this.length; h++)
        u.words[h] = this.words[h];
      u.length = this.length, u.negative = this.negative, u.red = this.red;
    };
    function I(x, u) {
      x.words = u.words, x.length = u.length, x.negative = u.negative, x.red = u.red;
    }
    if (a.prototype._move = function(u) {
      I(u, this);
    }, a.prototype.clone = function() {
      var u = new a(null);
      return this.copy(u), u;
    }, a.prototype._expand = function(u) {
      for (; this.length < u; )
        this.words[this.length++] = 0;
      return this;
    }, a.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, a.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        a.prototype[Symbol.for("nodejs.util.inspect.custom")] = B;
      } catch {
        a.prototype.inspect = B;
      }
    else
      a.prototype.inspect = B;
    function B() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var H = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], L = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], W = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    a.prototype.toString = function(u, h) {
      u = u || 10, h = h | 0 || 1;
      var g;
      if (u === 16 || u === "hex") {
        g = "";
        for (var y = 0, m = 0, _ = 0; _ < this.length; _++) {
          var R = this.words[_], b = ((R << y | m) & 16777215).toString(16);
          m = R >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, _--), m !== 0 || _ !== this.length - 1 ? g = H[6 - b.length] + b + g : g = b + g;
        }
        for (m !== 0 && (g = m.toString(16) + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      if (u === (u | 0) && u >= 2 && u <= 36) {
        var l = L[u], v = W[u];
        g = "";
        var X = this.clone();
        for (X.negative = 0; !X.isZero(); ) {
          var S = X.modrn(v).toString(u);
          X = X.idivn(v), X.isZero() ? g = S + g : g = H[l - S.length] + S + g;
        }
        for (this.isZero() && (g = "0" + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      o(!1, "Base should be between 2 and 36");
    }, a.prototype.toNumber = function() {
      var u = this.words[0];
      return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
    }, a.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, d && (a.prototype.toBuffer = function(u, h) {
      return this.toArrayLike(d, u, h);
    }), a.prototype.toArray = function(u, h) {
      return this.toArrayLike(Array, u, h);
    };
    var $ = function(u, h) {
      return u.allocUnsafe ? u.allocUnsafe(h) : new u(h);
    };
    a.prototype.toArrayLike = function(u, h, g) {
      this._strip();
      var y = this.byteLength(), m = g || Math.max(1, y);
      o(y <= m, "byte array longer than desired length"), o(m > 0, "Requested array length <= 0");
      var _ = $(u, m), R = h === "le" ? "LE" : "BE";
      return this["_toArrayLike" + R](_, y), _;
    }, a.prototype._toArrayLikeLE = function(u, h) {
      for (var g = 0, y = 0, m = 0, _ = 0; m < this.length; m++) {
        var R = this.words[m] << _ | y;
        u[g++] = R & 255, g < u.length && (u[g++] = R >> 8 & 255), g < u.length && (u[g++] = R >> 16 & 255), _ === 6 ? (g < u.length && (u[g++] = R >> 24 & 255), y = 0, _ = 0) : (y = R >>> 24, _ += 2);
      }
      if (g < u.length)
        for (u[g++] = y; g < u.length; )
          u[g++] = 0;
    }, a.prototype._toArrayLikeBE = function(u, h) {
      for (var g = u.length - 1, y = 0, m = 0, _ = 0; m < this.length; m++) {
        var R = this.words[m] << _ | y;
        u[g--] = R & 255, g >= 0 && (u[g--] = R >> 8 & 255), g >= 0 && (u[g--] = R >> 16 & 255), _ === 6 ? (g >= 0 && (u[g--] = R >> 24 & 255), y = 0, _ = 0) : (y = R >>> 24, _ += 2);
      }
      if (g >= 0)
        for (u[g--] = y; g >= 0; )
          u[g--] = 0;
    }, Math.clz32 ? a.prototype._countBits = function(u) {
      return 32 - Math.clz32(u);
    } : a.prototype._countBits = function(u) {
      var h = u, g = 0;
      return h >= 4096 && (g += 13, h >>>= 13), h >= 64 && (g += 7, h >>>= 7), h >= 8 && (g += 4, h >>>= 4), h >= 2 && (g += 2, h >>>= 2), g + h;
    }, a.prototype._zeroBits = function(u) {
      if (u === 0)
        return 26;
      var h = u, g = 0;
      return (h & 8191) === 0 && (g += 13, h >>>= 13), (h & 127) === 0 && (g += 7, h >>>= 7), (h & 15) === 0 && (g += 4, h >>>= 4), (h & 3) === 0 && (g += 2, h >>>= 2), (h & 1) === 0 && g++, g;
    }, a.prototype.bitLength = function() {
      var u = this.words[this.length - 1], h = this._countBits(u);
      return (this.length - 1) * 26 + h;
    };
    function P(x) {
      for (var u = new Array(x.bitLength()), h = 0; h < u.length; h++) {
        var g = h / 26 | 0, y = h % 26;
        u[h] = x.words[g] >>> y & 1;
      }
      return u;
    }
    a.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var u = 0, h = 0; h < this.length; h++) {
        var g = this._zeroBits(this.words[h]);
        if (u += g, g !== 26)
          break;
      }
      return u;
    }, a.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, a.prototype.toTwos = function(u) {
      return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
    }, a.prototype.fromTwos = function(u) {
      return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
    }, a.prototype.isNeg = function() {
      return this.negative !== 0;
    }, a.prototype.neg = function() {
      return this.clone().ineg();
    }, a.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, a.prototype.iuor = function(u) {
      for (; this.length < u.length; )
        this.words[this.length++] = 0;
      for (var h = 0; h < u.length; h++)
        this.words[h] = this.words[h] | u.words[h];
      return this._strip();
    }, a.prototype.ior = function(u) {
      return o((this.negative | u.negative) === 0), this.iuor(u);
    }, a.prototype.or = function(u) {
      return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
    }, a.prototype.uor = function(u) {
      return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
    }, a.prototype.iuand = function(u) {
      var h;
      this.length > u.length ? h = u : h = this;
      for (var g = 0; g < h.length; g++)
        this.words[g] = this.words[g] & u.words[g];
      return this.length = h.length, this._strip();
    }, a.prototype.iand = function(u) {
      return o((this.negative | u.negative) === 0), this.iuand(u);
    }, a.prototype.and = function(u) {
      return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
    }, a.prototype.uand = function(u) {
      return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
    }, a.prototype.iuxor = function(u) {
      var h, g;
      this.length > u.length ? (h = this, g = u) : (h = u, g = this);
      for (var y = 0; y < g.length; y++)
        this.words[y] = h.words[y] ^ g.words[y];
      if (this !== h)
        for (; y < h.length; y++)
          this.words[y] = h.words[y];
      return this.length = h.length, this._strip();
    }, a.prototype.ixor = function(u) {
      return o((this.negative | u.negative) === 0), this.iuxor(u);
    }, a.prototype.xor = function(u) {
      return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
    }, a.prototype.uxor = function(u) {
      return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
    }, a.prototype.inotn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = Math.ceil(u / 26) | 0, g = u % 26;
      this._expand(h), g > 0 && h--;
      for (var y = 0; y < h; y++)
        this.words[y] = ~this.words[y] & 67108863;
      return g > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - g), this._strip();
    }, a.prototype.notn = function(u) {
      return this.clone().inotn(u);
    }, a.prototype.setn = function(u, h) {
      o(typeof u == "number" && u >= 0);
      var g = u / 26 | 0, y = u % 26;
      return this._expand(g + 1), h ? this.words[g] = this.words[g] | 1 << y : this.words[g] = this.words[g] & ~(1 << y), this._strip();
    }, a.prototype.iadd = function(u) {
      var h;
      if (this.negative !== 0 && u.negative === 0)
        return this.negative = 0, h = this.isub(u), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && u.negative !== 0)
        return u.negative = 0, h = this.isub(u), u.negative = 1, h._normSign();
      var g, y;
      this.length > u.length ? (g = this, y = u) : (g = u, y = this);
      for (var m = 0, _ = 0; _ < y.length; _++)
        h = (g.words[_] | 0) + (y.words[_] | 0) + m, this.words[_] = h & 67108863, m = h >>> 26;
      for (; m !== 0 && _ < g.length; _++)
        h = (g.words[_] | 0) + m, this.words[_] = h & 67108863, m = h >>> 26;
      if (this.length = g.length, m !== 0)
        this.words[this.length] = m, this.length++;
      else if (g !== this)
        for (; _ < g.length; _++)
          this.words[_] = g.words[_];
      return this;
    }, a.prototype.add = function(u) {
      var h;
      return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, h = this.sub(u), u.negative ^= 1, h) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, h = u.sub(this), this.negative = 1, h) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
    }, a.prototype.isub = function(u) {
      if (u.negative !== 0) {
        u.negative = 0;
        var h = this.iadd(u);
        return u.negative = 1, h._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
      var g = this.cmp(u);
      if (g === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, m;
      g > 0 ? (y = this, m = u) : (y = u, m = this);
      for (var _ = 0, R = 0; R < m.length; R++)
        h = (y.words[R] | 0) - (m.words[R] | 0) + _, _ = h >> 26, this.words[R] = h & 67108863;
      for (; _ !== 0 && R < y.length; R++)
        h = (y.words[R] | 0) + _, _ = h >> 26, this.words[R] = h & 67108863;
      if (_ === 0 && R < y.length && y !== this)
        for (; R < y.length; R++)
          this.words[R] = y.words[R];
      return this.length = Math.max(this.length, R), y !== this && (this.negative = 1), this._strip();
    }, a.prototype.sub = function(u) {
      return this.clone().isub(u);
    };
    function U(x, u, h) {
      h.negative = u.negative ^ x.negative;
      var g = x.length + u.length | 0;
      h.length = g, g = g - 1 | 0;
      var y = x.words[0] | 0, m = u.words[0] | 0, _ = y * m, R = _ & 67108863, b = _ / 67108864 | 0;
      h.words[0] = R;
      for (var l = 1; l < g; l++) {
        for (var v = b >>> 26, X = b & 67108863, S = Math.min(l, u.length - 1), Y = Math.max(0, l - x.length + 1); Y <= S; Y++) {
          var fe = l - Y | 0;
          y = x.words[fe] | 0, m = u.words[Y] | 0, _ = y * m + X, v += _ / 67108864 | 0, X = _ & 67108863;
        }
        h.words[l] = X | 0, b = v | 0;
      }
      return b !== 0 ? h.words[l] = b | 0 : h.length--, h._strip();
    }
    var G = function(u, h, g) {
      var y = u.words, m = h.words, _ = g.words, R = 0, b, l, v, X = y[0] | 0, S = X & 8191, Y = X >>> 13, fe = y[1] | 0, oe = fe & 8191, de = fe >>> 13, Ie = y[2] | 0, ye = Ie & 8191, be = Ie >>> 13, rt = y[3] | 0, xe = rt & 8191, Ne = rt >>> 13, j = y[4] | 0, z = j & 8191, ee = j >>> 13, ve = y[5] | 0, me = ve & 8191, Ae = ve >>> 13, it = y[6] | 0, ke = it & 8191, qe = it >>> 13, or = y[7] | 0, Oe = or & 8191, T = or >>> 13, A = y[8] | 0, E = A & 8191, F = A >>> 13, ie = y[9] | 0, ne = ie & 8191, ce = ie >>> 13, nt = m[0] | 0, Be = nt & 8191, Ce = nt >>> 13, _t = m[1] | 0, Me = _t & 8191, pt = _t >>> 13, qr = m[2] | 0, Xe = qr & 8191, yt = qr >>> 13, Zr = m[3] | 0, He = Zr & 8191, dt = Zr >>> 13, Hr = m[4] | 0, Ze = Hr & 8191, mt = Hr >>> 13, zr = m[5] | 0, Qe = zr & 8191, tt = zr >>> 13, Wr = m[6] | 0, q = Wr & 8191, Q = Wr >>> 13, ae = m[7] | 0, k = ae & 8191, re = ae >>> 13, Ee = m[8] | 0, pe = Ee & 8191, _e = Ee >>> 13, bt = m[9] | 0, Te = bt & 8191, Re = bt >>> 13;
      g.negative = u.negative ^ h.negative, g.length = 19, b = Math.imul(S, Be), l = Math.imul(S, Ce), l = l + Math.imul(Y, Be) | 0, v = Math.imul(Y, Ce);
      var Dr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, b = Math.imul(oe, Be), l = Math.imul(oe, Ce), l = l + Math.imul(de, Be) | 0, v = Math.imul(de, Ce), b = b + Math.imul(S, Me) | 0, l = l + Math.imul(S, pt) | 0, l = l + Math.imul(Y, Me) | 0, v = v + Math.imul(Y, pt) | 0;
      var vt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, b = Math.imul(ye, Be), l = Math.imul(ye, Ce), l = l + Math.imul(be, Be) | 0, v = Math.imul(be, Ce), b = b + Math.imul(oe, Me) | 0, l = l + Math.imul(oe, pt) | 0, l = l + Math.imul(de, Me) | 0, v = v + Math.imul(de, pt) | 0, b = b + Math.imul(S, Xe) | 0, l = l + Math.imul(S, yt) | 0, l = l + Math.imul(Y, Xe) | 0, v = v + Math.imul(Y, yt) | 0;
      var pr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, b = Math.imul(xe, Be), l = Math.imul(xe, Ce), l = l + Math.imul(Ne, Be) | 0, v = Math.imul(Ne, Ce), b = b + Math.imul(ye, Me) | 0, l = l + Math.imul(ye, pt) | 0, l = l + Math.imul(be, Me) | 0, v = v + Math.imul(be, pt) | 0, b = b + Math.imul(oe, Xe) | 0, l = l + Math.imul(oe, yt) | 0, l = l + Math.imul(de, Xe) | 0, v = v + Math.imul(de, yt) | 0, b = b + Math.imul(S, He) | 0, l = l + Math.imul(S, dt) | 0, l = l + Math.imul(Y, He) | 0, v = v + Math.imul(Y, dt) | 0;
      var Pr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, b = Math.imul(z, Be), l = Math.imul(z, Ce), l = l + Math.imul(ee, Be) | 0, v = Math.imul(ee, Ce), b = b + Math.imul(xe, Me) | 0, l = l + Math.imul(xe, pt) | 0, l = l + Math.imul(Ne, Me) | 0, v = v + Math.imul(Ne, pt) | 0, b = b + Math.imul(ye, Xe) | 0, l = l + Math.imul(ye, yt) | 0, l = l + Math.imul(be, Xe) | 0, v = v + Math.imul(be, yt) | 0, b = b + Math.imul(oe, He) | 0, l = l + Math.imul(oe, dt) | 0, l = l + Math.imul(de, He) | 0, v = v + Math.imul(de, dt) | 0, b = b + Math.imul(S, Ze) | 0, l = l + Math.imul(S, mt) | 0, l = l + Math.imul(Y, Ze) | 0, v = v + Math.imul(Y, mt) | 0;
      var Lr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, b = Math.imul(me, Be), l = Math.imul(me, Ce), l = l + Math.imul(Ae, Be) | 0, v = Math.imul(Ae, Ce), b = b + Math.imul(z, Me) | 0, l = l + Math.imul(z, pt) | 0, l = l + Math.imul(ee, Me) | 0, v = v + Math.imul(ee, pt) | 0, b = b + Math.imul(xe, Xe) | 0, l = l + Math.imul(xe, yt) | 0, l = l + Math.imul(Ne, Xe) | 0, v = v + Math.imul(Ne, yt) | 0, b = b + Math.imul(ye, He) | 0, l = l + Math.imul(ye, dt) | 0, l = l + Math.imul(be, He) | 0, v = v + Math.imul(be, dt) | 0, b = b + Math.imul(oe, Ze) | 0, l = l + Math.imul(oe, mt) | 0, l = l + Math.imul(de, Ze) | 0, v = v + Math.imul(de, mt) | 0, b = b + Math.imul(S, Qe) | 0, l = l + Math.imul(S, tt) | 0, l = l + Math.imul(Y, Qe) | 0, v = v + Math.imul(Y, tt) | 0;
      var Kr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Kr >>> 26) | 0, Kr &= 67108863, b = Math.imul(ke, Be), l = Math.imul(ke, Ce), l = l + Math.imul(qe, Be) | 0, v = Math.imul(qe, Ce), b = b + Math.imul(me, Me) | 0, l = l + Math.imul(me, pt) | 0, l = l + Math.imul(Ae, Me) | 0, v = v + Math.imul(Ae, pt) | 0, b = b + Math.imul(z, Xe) | 0, l = l + Math.imul(z, yt) | 0, l = l + Math.imul(ee, Xe) | 0, v = v + Math.imul(ee, yt) | 0, b = b + Math.imul(xe, He) | 0, l = l + Math.imul(xe, dt) | 0, l = l + Math.imul(Ne, He) | 0, v = v + Math.imul(Ne, dt) | 0, b = b + Math.imul(ye, Ze) | 0, l = l + Math.imul(ye, mt) | 0, l = l + Math.imul(be, Ze) | 0, v = v + Math.imul(be, mt) | 0, b = b + Math.imul(oe, Qe) | 0, l = l + Math.imul(oe, tt) | 0, l = l + Math.imul(de, Qe) | 0, v = v + Math.imul(de, tt) | 0, b = b + Math.imul(S, q) | 0, l = l + Math.imul(S, Q) | 0, l = l + Math.imul(Y, q) | 0, v = v + Math.imul(Y, Q) | 0;
      var $r = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, b = Math.imul(Oe, Be), l = Math.imul(Oe, Ce), l = l + Math.imul(T, Be) | 0, v = Math.imul(T, Ce), b = b + Math.imul(ke, Me) | 0, l = l + Math.imul(ke, pt) | 0, l = l + Math.imul(qe, Me) | 0, v = v + Math.imul(qe, pt) | 0, b = b + Math.imul(me, Xe) | 0, l = l + Math.imul(me, yt) | 0, l = l + Math.imul(Ae, Xe) | 0, v = v + Math.imul(Ae, yt) | 0, b = b + Math.imul(z, He) | 0, l = l + Math.imul(z, dt) | 0, l = l + Math.imul(ee, He) | 0, v = v + Math.imul(ee, dt) | 0, b = b + Math.imul(xe, Ze) | 0, l = l + Math.imul(xe, mt) | 0, l = l + Math.imul(Ne, Ze) | 0, v = v + Math.imul(Ne, mt) | 0, b = b + Math.imul(ye, Qe) | 0, l = l + Math.imul(ye, tt) | 0, l = l + Math.imul(be, Qe) | 0, v = v + Math.imul(be, tt) | 0, b = b + Math.imul(oe, q) | 0, l = l + Math.imul(oe, Q) | 0, l = l + Math.imul(de, q) | 0, v = v + Math.imul(de, Q) | 0, b = b + Math.imul(S, k) | 0, l = l + Math.imul(S, re) | 0, l = l + Math.imul(Y, k) | 0, v = v + Math.imul(Y, re) | 0;
      var Fr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, b = Math.imul(E, Be), l = Math.imul(E, Ce), l = l + Math.imul(F, Be) | 0, v = Math.imul(F, Ce), b = b + Math.imul(Oe, Me) | 0, l = l + Math.imul(Oe, pt) | 0, l = l + Math.imul(T, Me) | 0, v = v + Math.imul(T, pt) | 0, b = b + Math.imul(ke, Xe) | 0, l = l + Math.imul(ke, yt) | 0, l = l + Math.imul(qe, Xe) | 0, v = v + Math.imul(qe, yt) | 0, b = b + Math.imul(me, He) | 0, l = l + Math.imul(me, dt) | 0, l = l + Math.imul(Ae, He) | 0, v = v + Math.imul(Ae, dt) | 0, b = b + Math.imul(z, Ze) | 0, l = l + Math.imul(z, mt) | 0, l = l + Math.imul(ee, Ze) | 0, v = v + Math.imul(ee, mt) | 0, b = b + Math.imul(xe, Qe) | 0, l = l + Math.imul(xe, tt) | 0, l = l + Math.imul(Ne, Qe) | 0, v = v + Math.imul(Ne, tt) | 0, b = b + Math.imul(ye, q) | 0, l = l + Math.imul(ye, Q) | 0, l = l + Math.imul(be, q) | 0, v = v + Math.imul(be, Q) | 0, b = b + Math.imul(oe, k) | 0, l = l + Math.imul(oe, re) | 0, l = l + Math.imul(de, k) | 0, v = v + Math.imul(de, re) | 0, b = b + Math.imul(S, pe) | 0, l = l + Math.imul(S, _e) | 0, l = l + Math.imul(Y, pe) | 0, v = v + Math.imul(Y, _e) | 0;
      var Ur = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, b = Math.imul(ne, Be), l = Math.imul(ne, Ce), l = l + Math.imul(ce, Be) | 0, v = Math.imul(ce, Ce), b = b + Math.imul(E, Me) | 0, l = l + Math.imul(E, pt) | 0, l = l + Math.imul(F, Me) | 0, v = v + Math.imul(F, pt) | 0, b = b + Math.imul(Oe, Xe) | 0, l = l + Math.imul(Oe, yt) | 0, l = l + Math.imul(T, Xe) | 0, v = v + Math.imul(T, yt) | 0, b = b + Math.imul(ke, He) | 0, l = l + Math.imul(ke, dt) | 0, l = l + Math.imul(qe, He) | 0, v = v + Math.imul(qe, dt) | 0, b = b + Math.imul(me, Ze) | 0, l = l + Math.imul(me, mt) | 0, l = l + Math.imul(Ae, Ze) | 0, v = v + Math.imul(Ae, mt) | 0, b = b + Math.imul(z, Qe) | 0, l = l + Math.imul(z, tt) | 0, l = l + Math.imul(ee, Qe) | 0, v = v + Math.imul(ee, tt) | 0, b = b + Math.imul(xe, q) | 0, l = l + Math.imul(xe, Q) | 0, l = l + Math.imul(Ne, q) | 0, v = v + Math.imul(Ne, Q) | 0, b = b + Math.imul(ye, k) | 0, l = l + Math.imul(ye, re) | 0, l = l + Math.imul(be, k) | 0, v = v + Math.imul(be, re) | 0, b = b + Math.imul(oe, pe) | 0, l = l + Math.imul(oe, _e) | 0, l = l + Math.imul(de, pe) | 0, v = v + Math.imul(de, _e) | 0, b = b + Math.imul(S, Te) | 0, l = l + Math.imul(S, Re) | 0, l = l + Math.imul(Y, Te) | 0, v = v + Math.imul(Y, Re) | 0;
      var ar = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, b = Math.imul(ne, Me), l = Math.imul(ne, pt), l = l + Math.imul(ce, Me) | 0, v = Math.imul(ce, pt), b = b + Math.imul(E, Xe) | 0, l = l + Math.imul(E, yt) | 0, l = l + Math.imul(F, Xe) | 0, v = v + Math.imul(F, yt) | 0, b = b + Math.imul(Oe, He) | 0, l = l + Math.imul(Oe, dt) | 0, l = l + Math.imul(T, He) | 0, v = v + Math.imul(T, dt) | 0, b = b + Math.imul(ke, Ze) | 0, l = l + Math.imul(ke, mt) | 0, l = l + Math.imul(qe, Ze) | 0, v = v + Math.imul(qe, mt) | 0, b = b + Math.imul(me, Qe) | 0, l = l + Math.imul(me, tt) | 0, l = l + Math.imul(Ae, Qe) | 0, v = v + Math.imul(Ae, tt) | 0, b = b + Math.imul(z, q) | 0, l = l + Math.imul(z, Q) | 0, l = l + Math.imul(ee, q) | 0, v = v + Math.imul(ee, Q) | 0, b = b + Math.imul(xe, k) | 0, l = l + Math.imul(xe, re) | 0, l = l + Math.imul(Ne, k) | 0, v = v + Math.imul(Ne, re) | 0, b = b + Math.imul(ye, pe) | 0, l = l + Math.imul(ye, _e) | 0, l = l + Math.imul(be, pe) | 0, v = v + Math.imul(be, _e) | 0, b = b + Math.imul(oe, Te) | 0, l = l + Math.imul(oe, Re) | 0, l = l + Math.imul(de, Te) | 0, v = v + Math.imul(de, Re) | 0;
      var gr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, b = Math.imul(ne, Xe), l = Math.imul(ne, yt), l = l + Math.imul(ce, Xe) | 0, v = Math.imul(ce, yt), b = b + Math.imul(E, He) | 0, l = l + Math.imul(E, dt) | 0, l = l + Math.imul(F, He) | 0, v = v + Math.imul(F, dt) | 0, b = b + Math.imul(Oe, Ze) | 0, l = l + Math.imul(Oe, mt) | 0, l = l + Math.imul(T, Ze) | 0, v = v + Math.imul(T, mt) | 0, b = b + Math.imul(ke, Qe) | 0, l = l + Math.imul(ke, tt) | 0, l = l + Math.imul(qe, Qe) | 0, v = v + Math.imul(qe, tt) | 0, b = b + Math.imul(me, q) | 0, l = l + Math.imul(me, Q) | 0, l = l + Math.imul(Ae, q) | 0, v = v + Math.imul(Ae, Q) | 0, b = b + Math.imul(z, k) | 0, l = l + Math.imul(z, re) | 0, l = l + Math.imul(ee, k) | 0, v = v + Math.imul(ee, re) | 0, b = b + Math.imul(xe, pe) | 0, l = l + Math.imul(xe, _e) | 0, l = l + Math.imul(Ne, pe) | 0, v = v + Math.imul(Ne, _e) | 0, b = b + Math.imul(ye, Te) | 0, l = l + Math.imul(ye, Re) | 0, l = l + Math.imul(be, Te) | 0, v = v + Math.imul(be, Re) | 0;
      var zt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, b = Math.imul(ne, He), l = Math.imul(ne, dt), l = l + Math.imul(ce, He) | 0, v = Math.imul(ce, dt), b = b + Math.imul(E, Ze) | 0, l = l + Math.imul(E, mt) | 0, l = l + Math.imul(F, Ze) | 0, v = v + Math.imul(F, mt) | 0, b = b + Math.imul(Oe, Qe) | 0, l = l + Math.imul(Oe, tt) | 0, l = l + Math.imul(T, Qe) | 0, v = v + Math.imul(T, tt) | 0, b = b + Math.imul(ke, q) | 0, l = l + Math.imul(ke, Q) | 0, l = l + Math.imul(qe, q) | 0, v = v + Math.imul(qe, Q) | 0, b = b + Math.imul(me, k) | 0, l = l + Math.imul(me, re) | 0, l = l + Math.imul(Ae, k) | 0, v = v + Math.imul(Ae, re) | 0, b = b + Math.imul(z, pe) | 0, l = l + Math.imul(z, _e) | 0, l = l + Math.imul(ee, pe) | 0, v = v + Math.imul(ee, _e) | 0, b = b + Math.imul(xe, Te) | 0, l = l + Math.imul(xe, Re) | 0, l = l + Math.imul(Ne, Te) | 0, v = v + Math.imul(Ne, Re) | 0;
      var lr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, b = Math.imul(ne, Ze), l = Math.imul(ne, mt), l = l + Math.imul(ce, Ze) | 0, v = Math.imul(ce, mt), b = b + Math.imul(E, Qe) | 0, l = l + Math.imul(E, tt) | 0, l = l + Math.imul(F, Qe) | 0, v = v + Math.imul(F, tt) | 0, b = b + Math.imul(Oe, q) | 0, l = l + Math.imul(Oe, Q) | 0, l = l + Math.imul(T, q) | 0, v = v + Math.imul(T, Q) | 0, b = b + Math.imul(ke, k) | 0, l = l + Math.imul(ke, re) | 0, l = l + Math.imul(qe, k) | 0, v = v + Math.imul(qe, re) | 0, b = b + Math.imul(me, pe) | 0, l = l + Math.imul(me, _e) | 0, l = l + Math.imul(Ae, pe) | 0, v = v + Math.imul(Ae, _e) | 0, b = b + Math.imul(z, Te) | 0, l = l + Math.imul(z, Re) | 0, l = l + Math.imul(ee, Te) | 0, v = v + Math.imul(ee, Re) | 0;
      var dr = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, b = Math.imul(ne, Qe), l = Math.imul(ne, tt), l = l + Math.imul(ce, Qe) | 0, v = Math.imul(ce, tt), b = b + Math.imul(E, q) | 0, l = l + Math.imul(E, Q) | 0, l = l + Math.imul(F, q) | 0, v = v + Math.imul(F, Q) | 0, b = b + Math.imul(Oe, k) | 0, l = l + Math.imul(Oe, re) | 0, l = l + Math.imul(T, k) | 0, v = v + Math.imul(T, re) | 0, b = b + Math.imul(ke, pe) | 0, l = l + Math.imul(ke, _e) | 0, l = l + Math.imul(qe, pe) | 0, v = v + Math.imul(qe, _e) | 0, b = b + Math.imul(me, Te) | 0, l = l + Math.imul(me, Re) | 0, l = l + Math.imul(Ae, Te) | 0, v = v + Math.imul(Ae, Re) | 0;
      var wt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, b = Math.imul(ne, q), l = Math.imul(ne, Q), l = l + Math.imul(ce, q) | 0, v = Math.imul(ce, Q), b = b + Math.imul(E, k) | 0, l = l + Math.imul(E, re) | 0, l = l + Math.imul(F, k) | 0, v = v + Math.imul(F, re) | 0, b = b + Math.imul(Oe, pe) | 0, l = l + Math.imul(Oe, _e) | 0, l = l + Math.imul(T, pe) | 0, v = v + Math.imul(T, _e) | 0, b = b + Math.imul(ke, Te) | 0, l = l + Math.imul(ke, Re) | 0, l = l + Math.imul(qe, Te) | 0, v = v + Math.imul(qe, Re) | 0;
      var Le = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, b = Math.imul(ne, k), l = Math.imul(ne, re), l = l + Math.imul(ce, k) | 0, v = Math.imul(ce, re), b = b + Math.imul(E, pe) | 0, l = l + Math.imul(E, _e) | 0, l = l + Math.imul(F, pe) | 0, v = v + Math.imul(F, _e) | 0, b = b + Math.imul(Oe, Te) | 0, l = l + Math.imul(Oe, Re) | 0, l = l + Math.imul(T, Te) | 0, v = v + Math.imul(T, Re) | 0;
      var Fe = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, b = Math.imul(ne, pe), l = Math.imul(ne, _e), l = l + Math.imul(ce, pe) | 0, v = Math.imul(ce, _e), b = b + Math.imul(E, Te) | 0, l = l + Math.imul(E, Re) | 0, l = l + Math.imul(F, Te) | 0, v = v + Math.imul(F, Re) | 0;
      var gt = (R + b | 0) + ((l & 8191) << 13) | 0;
      R = (v + (l >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, b = Math.imul(ne, Te), l = Math.imul(ne, Re), l = l + Math.imul(ce, Te) | 0, v = Math.imul(ce, Re);
      var et = (R + b | 0) + ((l & 8191) << 13) | 0;
      return R = (v + (l >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, _[0] = Dr, _[1] = vt, _[2] = pr, _[3] = Pr, _[4] = Lr, _[5] = Kr, _[6] = $r, _[7] = Fr, _[8] = Ur, _[9] = ar, _[10] = gr, _[11] = zt, _[12] = lr, _[13] = dr, _[14] = wt, _[15] = Le, _[16] = Fe, _[17] = gt, _[18] = et, R !== 0 && (_[19] = R, g.length++), g;
    };
    Math.imul || (G = U);
    function D(x, u, h) {
      h.negative = u.negative ^ x.negative, h.length = x.length + u.length;
      for (var g = 0, y = 0, m = 0; m < h.length - 1; m++) {
        var _ = y;
        y = 0;
        for (var R = g & 67108863, b = Math.min(m, u.length - 1), l = Math.max(0, m - x.length + 1); l <= b; l++) {
          var v = m - l, X = x.words[v] | 0, S = u.words[l] | 0, Y = X * S, fe = Y & 67108863;
          _ = _ + (Y / 67108864 | 0) | 0, fe = fe + R | 0, R = fe & 67108863, _ = _ + (fe >>> 26) | 0, y += _ >>> 26, _ &= 67108863;
        }
        h.words[m] = R, g = _, _ = y;
      }
      return g !== 0 ? h.words[m] = g : h.length--, h._strip();
    }
    function Z(x, u, h) {
      return D(x, u, h);
    }
    a.prototype.mulTo = function(u, h) {
      var g, y = this.length + u.length;
      return this.length === 10 && u.length === 10 ? g = G(this, u, h) : y < 63 ? g = U(this, u, h) : y < 1024 ? g = D(this, u, h) : g = Z(this, u, h), g;
    }, a.prototype.mul = function(u) {
      var h = new a(null);
      return h.words = new Array(this.length + u.length), this.mulTo(u, h);
    }, a.prototype.mulf = function(u) {
      var h = new a(null);
      return h.words = new Array(this.length + u.length), Z(this, u, h);
    }, a.prototype.imul = function(u) {
      return this.clone().mulTo(u, this);
    }, a.prototype.imuln = function(u) {
      var h = u < 0;
      h && (u = -u), o(typeof u == "number"), o(u < 67108864);
      for (var g = 0, y = 0; y < this.length; y++) {
        var m = (this.words[y] | 0) * u, _ = (m & 67108863) + (g & 67108863);
        g >>= 26, g += m / 67108864 | 0, g += _ >>> 26, this.words[y] = _ & 67108863;
      }
      return g !== 0 && (this.words[y] = g, this.length++), h ? this.ineg() : this;
    }, a.prototype.muln = function(u) {
      return this.clone().imuln(u);
    }, a.prototype.sqr = function() {
      return this.mul(this);
    }, a.prototype.isqr = function() {
      return this.imul(this.clone());
    }, a.prototype.pow = function(u) {
      var h = P(u);
      if (h.length === 0)
        return new a(1);
      for (var g = this, y = 0; y < h.length && h[y] === 0; y++, g = g.sqr())
        ;
      if (++y < h.length)
        for (var m = g.sqr(); y < h.length; y++, m = m.sqr())
          h[y] !== 0 && (g = g.mul(m));
      return g;
    }, a.prototype.iushln = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26, y = 67108863 >>> 26 - h << 26 - h, m;
      if (h !== 0) {
        var _ = 0;
        for (m = 0; m < this.length; m++) {
          var R = this.words[m] & y, b = (this.words[m] | 0) - R << h;
          this.words[m] = b | _, _ = R >>> 26 - h;
        }
        _ && (this.words[m] = _, this.length++);
      }
      if (g !== 0) {
        for (m = this.length - 1; m >= 0; m--)
          this.words[m + g] = this.words[m];
        for (m = 0; m < g; m++)
          this.words[m] = 0;
        this.length += g;
      }
      return this._strip();
    }, a.prototype.ishln = function(u) {
      return o(this.negative === 0), this.iushln(u);
    }, a.prototype.iushrn = function(u, h, g) {
      o(typeof u == "number" && u >= 0);
      var y;
      h ? y = (h - h % 26) / 26 : y = 0;
      var m = u % 26, _ = Math.min((u - m) / 26, this.length), R = 67108863 ^ 67108863 >>> m << m, b = g;
      if (y -= _, y = Math.max(0, y), b) {
        for (var l = 0; l < _; l++)
          b.words[l] = this.words[l];
        b.length = _;
      }
      if (_ !== 0)
        if (this.length > _)
          for (this.length -= _, l = 0; l < this.length; l++)
            this.words[l] = this.words[l + _];
        else
          this.words[0] = 0, this.length = 1;
      var v = 0;
      for (l = this.length - 1; l >= 0 && (v !== 0 || l >= y); l--) {
        var X = this.words[l] | 0;
        this.words[l] = v << 26 - m | X >>> m, v = X & R;
      }
      return b && v !== 0 && (b.words[b.length++] = v), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, a.prototype.ishrn = function(u, h, g) {
      return o(this.negative === 0), this.iushrn(u, h, g);
    }, a.prototype.shln = function(u) {
      return this.clone().ishln(u);
    }, a.prototype.ushln = function(u) {
      return this.clone().iushln(u);
    }, a.prototype.shrn = function(u) {
      return this.clone().ishrn(u);
    }, a.prototype.ushrn = function(u) {
      return this.clone().iushrn(u);
    }, a.prototype.testn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26, y = 1 << h;
      if (this.length <= g)
        return !1;
      var m = this.words[g];
      return !!(m & y);
    }, a.prototype.imaskn = function(u) {
      o(typeof u == "number" && u >= 0);
      var h = u % 26, g = (u - h) / 26;
      if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g)
        return this;
      if (h !== 0 && g++, this.length = Math.min(g, this.length), h !== 0) {
        var y = 67108863 ^ 67108863 >>> h << h;
        this.words[this.length - 1] &= y;
      }
      return this._strip();
    }, a.prototype.maskn = function(u) {
      return this.clone().imaskn(u);
    }, a.prototype.iaddn = function(u) {
      return o(typeof u == "number"), o(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
    }, a.prototype._iaddn = function(u) {
      this.words[0] += u;
      for (var h = 0; h < this.length && this.words[h] >= 67108864; h++)
        this.words[h] -= 67108864, h === this.length - 1 ? this.words[h + 1] = 1 : this.words[h + 1]++;
      return this.length = Math.max(this.length, h + 1), this;
    }, a.prototype.isubn = function(u) {
      if (o(typeof u == "number"), o(u < 67108864), u < 0)
        return this.iaddn(-u);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(u), this.negative = 1, this;
      if (this.words[0] -= u, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var h = 0; h < this.length && this.words[h] < 0; h++)
          this.words[h] += 67108864, this.words[h + 1] -= 1;
      return this._strip();
    }, a.prototype.addn = function(u) {
      return this.clone().iaddn(u);
    }, a.prototype.subn = function(u) {
      return this.clone().isubn(u);
    }, a.prototype.iabs = function() {
      return this.negative = 0, this;
    }, a.prototype.abs = function() {
      return this.clone().iabs();
    }, a.prototype._ishlnsubmul = function(u, h, g) {
      var y = u.length + g, m;
      this._expand(y);
      var _, R = 0;
      for (m = 0; m < u.length; m++) {
        _ = (this.words[m + g] | 0) + R;
        var b = (u.words[m] | 0) * h;
        _ -= b & 67108863, R = (_ >> 26) - (b / 67108864 | 0), this.words[m + g] = _ & 67108863;
      }
      for (; m < this.length - g; m++)
        _ = (this.words[m + g] | 0) + R, R = _ >> 26, this.words[m + g] = _ & 67108863;
      if (R === 0)
        return this._strip();
      for (o(R === -1), R = 0, m = 0; m < this.length; m++)
        _ = -(this.words[m] | 0) + R, R = _ >> 26, this.words[m] = _ & 67108863;
      return this.negative = 1, this._strip();
    }, a.prototype._wordDiv = function(u, h) {
      var g = this.length - u.length, y = this.clone(), m = u, _ = m.words[m.length - 1] | 0, R = this._countBits(_);
      g = 26 - R, g !== 0 && (m = m.ushln(g), y.iushln(g), _ = m.words[m.length - 1] | 0);
      var b = y.length - m.length, l;
      if (h !== "mod") {
        l = new a(null), l.length = b + 1, l.words = new Array(l.length);
        for (var v = 0; v < l.length; v++)
          l.words[v] = 0;
      }
      var X = y.clone()._ishlnsubmul(m, 1, b);
      X.negative === 0 && (y = X, l && (l.words[b] = 1));
      for (var S = b - 1; S >= 0; S--) {
        var Y = (y.words[m.length + S] | 0) * 67108864 + (y.words[m.length + S - 1] | 0);
        for (Y = Math.min(Y / _ | 0, 67108863), y._ishlnsubmul(m, Y, S); y.negative !== 0; )
          Y--, y.negative = 0, y._ishlnsubmul(m, 1, S), y.isZero() || (y.negative ^= 1);
        l && (l.words[S] = Y);
      }
      return l && l._strip(), y._strip(), h !== "div" && g !== 0 && y.iushrn(g), {
        div: l || null,
        mod: y
      };
    }, a.prototype.divmod = function(u, h, g) {
      if (o(!u.isZero()), this.isZero())
        return {
          div: new a(0),
          mod: new a(0)
        };
      var y, m, _;
      return this.negative !== 0 && u.negative === 0 ? (_ = this.neg().divmod(u, h), h !== "mod" && (y = _.div.neg()), h !== "div" && (m = _.mod.neg(), g && m.negative !== 0 && m.iadd(u)), {
        div: y,
        mod: m
      }) : this.negative === 0 && u.negative !== 0 ? (_ = this.divmod(u.neg(), h), h !== "mod" && (y = _.div.neg()), {
        div: y,
        mod: _.mod
      }) : (this.negative & u.negative) !== 0 ? (_ = this.neg().divmod(u.neg(), h), h !== "div" && (m = _.mod.neg(), g && m.negative !== 0 && m.isub(u)), {
        div: _.div,
        mod: m
      }) : u.length > this.length || this.cmp(u) < 0 ? {
        div: new a(0),
        mod: this
      } : u.length === 1 ? h === "div" ? {
        div: this.divn(u.words[0]),
        mod: null
      } : h === "mod" ? {
        div: null,
        mod: new a(this.modrn(u.words[0]))
      } : {
        div: this.divn(u.words[0]),
        mod: new a(this.modrn(u.words[0]))
      } : this._wordDiv(u, h);
    }, a.prototype.div = function(u) {
      return this.divmod(u, "div", !1).div;
    }, a.prototype.mod = function(u) {
      return this.divmod(u, "mod", !1).mod;
    }, a.prototype.umod = function(u) {
      return this.divmod(u, "mod", !0).mod;
    }, a.prototype.divRound = function(u) {
      var h = this.divmod(u);
      if (h.mod.isZero())
        return h.div;
      var g = h.div.negative !== 0 ? h.mod.isub(u) : h.mod, y = u.ushrn(1), m = u.andln(1), _ = g.cmp(y);
      return _ < 0 || m === 1 && _ === 0 ? h.div : h.div.negative !== 0 ? h.div.isubn(1) : h.div.iaddn(1);
    }, a.prototype.modrn = function(u) {
      var h = u < 0;
      h && (u = -u), o(u <= 67108863);
      for (var g = (1 << 26) % u, y = 0, m = this.length - 1; m >= 0; m--)
        y = (g * y + (this.words[m] | 0)) % u;
      return h ? -y : y;
    }, a.prototype.modn = function(u) {
      return this.modrn(u);
    }, a.prototype.idivn = function(u) {
      var h = u < 0;
      h && (u = -u), o(u <= 67108863);
      for (var g = 0, y = this.length - 1; y >= 0; y--) {
        var m = (this.words[y] | 0) + g * 67108864;
        this.words[y] = m / u | 0, g = m % u;
      }
      return this._strip(), h ? this.ineg() : this;
    }, a.prototype.divn = function(u) {
      return this.clone().idivn(u);
    }, a.prototype.egcd = function(u) {
      o(u.negative === 0), o(!u.isZero());
      var h = this, g = u.clone();
      h.negative !== 0 ? h = h.umod(u) : h = h.clone();
      for (var y = new a(1), m = new a(0), _ = new a(0), R = new a(1), b = 0; h.isEven() && g.isEven(); )
        h.iushrn(1), g.iushrn(1), ++b;
      for (var l = g.clone(), v = h.clone(); !h.isZero(); ) {
        for (var X = 0, S = 1; (h.words[0] & S) === 0 && X < 26; ++X, S <<= 1)
          ;
        if (X > 0)
          for (h.iushrn(X); X-- > 0; )
            (y.isOdd() || m.isOdd()) && (y.iadd(l), m.isub(v)), y.iushrn(1), m.iushrn(1);
        for (var Y = 0, fe = 1; (g.words[0] & fe) === 0 && Y < 26; ++Y, fe <<= 1)
          ;
        if (Y > 0)
          for (g.iushrn(Y); Y-- > 0; )
            (_.isOdd() || R.isOdd()) && (_.iadd(l), R.isub(v)), _.iushrn(1), R.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), y.isub(_), m.isub(R)) : (g.isub(h), _.isub(y), R.isub(m));
      }
      return {
        a: _,
        b: R,
        gcd: g.iushln(b)
      };
    }, a.prototype._invmp = function(u) {
      o(u.negative === 0), o(!u.isZero());
      var h = this, g = u.clone();
      h.negative !== 0 ? h = h.umod(u) : h = h.clone();
      for (var y = new a(1), m = new a(0), _ = g.clone(); h.cmpn(1) > 0 && g.cmpn(1) > 0; ) {
        for (var R = 0, b = 1; (h.words[0] & b) === 0 && R < 26; ++R, b <<= 1)
          ;
        if (R > 0)
          for (h.iushrn(R); R-- > 0; )
            y.isOdd() && y.iadd(_), y.iushrn(1);
        for (var l = 0, v = 1; (g.words[0] & v) === 0 && l < 26; ++l, v <<= 1)
          ;
        if (l > 0)
          for (g.iushrn(l); l-- > 0; )
            m.isOdd() && m.iadd(_), m.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), y.isub(m)) : (g.isub(h), m.isub(y));
      }
      var X;
      return h.cmpn(1) === 0 ? X = y : X = m, X.cmpn(0) < 0 && X.iadd(u), X;
    }, a.prototype.gcd = function(u) {
      if (this.isZero())
        return u.abs();
      if (u.isZero())
        return this.abs();
      var h = this.clone(), g = u.clone();
      h.negative = 0, g.negative = 0;
      for (var y = 0; h.isEven() && g.isEven(); y++)
        h.iushrn(1), g.iushrn(1);
      do {
        for (; h.isEven(); )
          h.iushrn(1);
        for (; g.isEven(); )
          g.iushrn(1);
        var m = h.cmp(g);
        if (m < 0) {
          var _ = h;
          h = g, g = _;
        } else if (m === 0 || g.cmpn(1) === 0)
          break;
        h.isub(g);
      } while (!0);
      return g.iushln(y);
    }, a.prototype.invm = function(u) {
      return this.egcd(u).a.umod(u);
    }, a.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, a.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, a.prototype.andln = function(u) {
      return this.words[0] & u;
    }, a.prototype.bincn = function(u) {
      o(typeof u == "number");
      var h = u % 26, g = (u - h) / 26, y = 1 << h;
      if (this.length <= g)
        return this._expand(g + 1), this.words[g] |= y, this;
      for (var m = y, _ = g; m !== 0 && _ < this.length; _++) {
        var R = this.words[_] | 0;
        R += m, m = R >>> 26, R &= 67108863, this.words[_] = R;
      }
      return m !== 0 && (this.words[_] = m, this.length++), this;
    }, a.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, a.prototype.cmpn = function(u) {
      var h = u < 0;
      if (this.negative !== 0 && !h)
        return -1;
      if (this.negative === 0 && h)
        return 1;
      this._strip();
      var g;
      if (this.length > 1)
        g = 1;
      else {
        h && (u = -u), o(u <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        g = y === u ? 0 : y < u ? -1 : 1;
      }
      return this.negative !== 0 ? -g | 0 : g;
    }, a.prototype.cmp = function(u) {
      if (this.negative !== 0 && u.negative === 0)
        return -1;
      if (this.negative === 0 && u.negative !== 0)
        return 1;
      var h = this.ucmp(u);
      return this.negative !== 0 ? -h | 0 : h;
    }, a.prototype.ucmp = function(u) {
      if (this.length > u.length)
        return 1;
      if (this.length < u.length)
        return -1;
      for (var h = 0, g = this.length - 1; g >= 0; g--) {
        var y = this.words[g] | 0, m = u.words[g] | 0;
        if (y !== m) {
          y < m ? h = -1 : y > m && (h = 1);
          break;
        }
      }
      return h;
    }, a.prototype.gtn = function(u) {
      return this.cmpn(u) === 1;
    }, a.prototype.gt = function(u) {
      return this.cmp(u) === 1;
    }, a.prototype.gten = function(u) {
      return this.cmpn(u) >= 0;
    }, a.prototype.gte = function(u) {
      return this.cmp(u) >= 0;
    }, a.prototype.ltn = function(u) {
      return this.cmpn(u) === -1;
    }, a.prototype.lt = function(u) {
      return this.cmp(u) === -1;
    }, a.prototype.lten = function(u) {
      return this.cmpn(u) <= 0;
    }, a.prototype.lte = function(u) {
      return this.cmp(u) <= 0;
    }, a.prototype.eqn = function(u) {
      return this.cmpn(u) === 0;
    }, a.prototype.eq = function(u) {
      return this.cmp(u) === 0;
    }, a.red = function(u) {
      return new O(u);
    }, a.prototype.toRed = function(u) {
      return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
    }, a.prototype.fromRed = function() {
      return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, a.prototype._forceRed = function(u) {
      return this.red = u, this;
    }, a.prototype.forceRed = function(u) {
      return o(!this.red, "Already a number in reduction context"), this._forceRed(u);
    }, a.prototype.redAdd = function(u) {
      return o(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
    }, a.prototype.redIAdd = function(u) {
      return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
    }, a.prototype.redSub = function(u) {
      return o(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
    }, a.prototype.redISub = function(u) {
      return o(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
    }, a.prototype.redShl = function(u) {
      return o(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
    }, a.prototype.redMul = function(u) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
    }, a.prototype.redIMul = function(u) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
    }, a.prototype.redSqr = function() {
      return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, a.prototype.redISqr = function() {
      return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, a.prototype.redSqrt = function() {
      return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, a.prototype.redInvm = function() {
      return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, a.prototype.redNeg = function() {
      return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, a.prototype.redPow = function(u) {
      return o(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
    };
    var J = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function te(x, u) {
      this.name = x, this.p = new a(u, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    te.prototype._tmp = function() {
      var u = new a(null);
      return u.words = new Array(Math.ceil(this.n / 13)), u;
    }, te.prototype.ireduce = function(u) {
      var h = u, g;
      do
        this.split(h, this.tmp), h = this.imulK(h), h = h.iadd(this.tmp), g = h.bitLength();
      while (g > this.n);
      var y = g < this.n ? -1 : h.ucmp(this.p);
      return y === 0 ? (h.words[0] = 0, h.length = 1) : y > 0 ? h.isub(this.p) : h.strip !== void 0 ? h.strip() : h._strip(), h;
    }, te.prototype.split = function(u, h) {
      u.iushrn(this.n, 0, h);
    }, te.prototype.imulK = function(u) {
      return u.imul(this.k);
    };
    function ue() {
      te.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    c(ue, te), ue.prototype.split = function(u, h) {
      for (var g = 4194303, y = Math.min(u.length, 9), m = 0; m < y; m++)
        h.words[m] = u.words[m];
      if (h.length = y, u.length <= 9) {
        u.words[0] = 0, u.length = 1;
        return;
      }
      var _ = u.words[9];
      for (h.words[h.length++] = _ & g, m = 10; m < u.length; m++) {
        var R = u.words[m] | 0;
        u.words[m - 10] = (R & g) << 4 | _ >>> 22, _ = R;
      }
      _ >>>= 22, u.words[m - 10] = _, _ === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
    }, ue.prototype.imulK = function(u) {
      u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
      for (var h = 0, g = 0; g < u.length; g++) {
        var y = u.words[g] | 0;
        h += y * 977, u.words[g] = h & 67108863, h = y * 64 + (h / 67108864 | 0);
      }
      return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
    };
    function he() {
      te.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    c(he, te);
    function Se() {
      te.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    c(Se, te);
    function C() {
      te.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    c(C, te), C.prototype.imulK = function(u) {
      for (var h = 0, g = 0; g < u.length; g++) {
        var y = (u.words[g] | 0) * 19 + h, m = y & 67108863;
        y >>>= 26, u.words[g] = m, h = y;
      }
      return h !== 0 && (u.words[u.length++] = h), u;
    }, a._prime = function(u) {
      if (J[u])
        return J[u];
      var h;
      if (u === "k256")
        h = new ue();
      else if (u === "p224")
        h = new he();
      else if (u === "p192")
        h = new Se();
      else if (u === "p25519")
        h = new C();
      else
        throw new Error("Unknown prime " + u);
      return J[u] = h, h;
    };
    function O(x) {
      if (typeof x == "string") {
        var u = a._prime(x);
        this.m = u.p, this.prime = u;
      } else
        o(x.gtn(1), "modulus must be greater than 1"), this.m = x, this.prime = null;
    }
    O.prototype._verify1 = function(u) {
      o(u.negative === 0, "red works only with positives"), o(u.red, "red works only with red numbers");
    }, O.prototype._verify2 = function(u, h) {
      o((u.negative | h.negative) === 0, "red works only with positives"), o(
        u.red && u.red === h.red,
        "red works only with red numbers"
      );
    }, O.prototype.imod = function(u) {
      return this.prime ? this.prime.ireduce(u)._forceRed(this) : (I(u, u.umod(this.m)._forceRed(this)), u);
    }, O.prototype.neg = function(u) {
      return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
    }, O.prototype.add = function(u, h) {
      this._verify2(u, h);
      var g = u.add(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
    }, O.prototype.iadd = function(u, h) {
      this._verify2(u, h);
      var g = u.iadd(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g;
    }, O.prototype.sub = function(u, h) {
      this._verify2(u, h);
      var g = u.sub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
    }, O.prototype.isub = function(u, h) {
      this._verify2(u, h);
      var g = u.isub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g;
    }, O.prototype.shl = function(u, h) {
      return this._verify1(u), this.imod(u.ushln(h));
    }, O.prototype.imul = function(u, h) {
      return this._verify2(u, h), this.imod(u.imul(h));
    }, O.prototype.mul = function(u, h) {
      return this._verify2(u, h), this.imod(u.mul(h));
    }, O.prototype.isqr = function(u) {
      return this.imul(u, u.clone());
    }, O.prototype.sqr = function(u) {
      return this.mul(u, u);
    }, O.prototype.sqrt = function(u) {
      if (u.isZero())
        return u.clone();
      var h = this.m.andln(3);
      if (o(h % 2 === 1), h === 3) {
        var g = this.m.add(new a(1)).iushrn(2);
        return this.pow(u, g);
      }
      for (var y = this.m.subn(1), m = 0; !y.isZero() && y.andln(1) === 0; )
        m++, y.iushrn(1);
      o(!y.isZero());
      var _ = new a(1).toRed(this), R = _.redNeg(), b = this.m.subn(1).iushrn(1), l = this.m.bitLength();
      for (l = new a(2 * l * l).toRed(this); this.pow(l, b).cmp(R) !== 0; )
        l.redIAdd(R);
      for (var v = this.pow(l, y), X = this.pow(u, y.addn(1).iushrn(1)), S = this.pow(u, y), Y = m; S.cmp(_) !== 0; ) {
        for (var fe = S, oe = 0; fe.cmp(_) !== 0; oe++)
          fe = fe.redSqr();
        o(oe < Y);
        var de = this.pow(v, new a(1).iushln(Y - oe - 1));
        X = X.redMul(de), v = de.redSqr(), S = S.redMul(v), Y = oe;
      }
      return X;
    }, O.prototype.invm = function(u) {
      var h = u._invmp(this.m);
      return h.negative !== 0 ? (h.negative = 0, this.imod(h).redNeg()) : this.imod(h);
    }, O.prototype.pow = function(u, h) {
      if (h.isZero())
        return new a(1).toRed(this);
      if (h.cmpn(1) === 0)
        return u.clone();
      var g = 4, y = new Array(1 << g);
      y[0] = new a(1).toRed(this), y[1] = u;
      for (var m = 2; m < y.length; m++)
        y[m] = this.mul(y[m - 1], u);
      var _ = y[0], R = 0, b = 0, l = h.bitLength() % 26;
      for (l === 0 && (l = 26), m = h.length - 1; m >= 0; m--) {
        for (var v = h.words[m], X = l - 1; X >= 0; X--) {
          var S = v >> X & 1;
          if (_ !== y[0] && (_ = this.sqr(_)), S === 0 && R === 0) {
            b = 0;
            continue;
          }
          R <<= 1, R |= S, b++, !(b !== g && (m !== 0 || X !== 0)) && (_ = this.mul(_, y[R]), b = 0, R = 0);
        }
        l = 26;
      }
      return _;
    }, O.prototype.convertTo = function(u) {
      var h = u.umod(this.m);
      return h === u ? h.clone() : h;
    }, O.prototype.convertFrom = function(u) {
      var h = u.clone();
      return h.red = null, h;
    }, a.mont = function(u) {
      return new V(u);
    };
    function V(x) {
      O.call(this, x), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    c(V, O), V.prototype.convertTo = function(u) {
      return this.imod(u.ushln(this.shift));
    }, V.prototype.convertFrom = function(u) {
      var h = this.imod(u.mul(this.rinv));
      return h.red = null, h;
    }, V.prototype.imul = function(u, h) {
      if (u.isZero() || h.isZero())
        return u.words[0] = 0, u.length = 1, u;
      var g = u.imul(h), y = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = g.isub(y).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, V.prototype.mul = function(u, h) {
      if (u.isZero() || h.isZero())
        return new a(0)._forceRed(this);
      var g = u.mul(h), y = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = g.isub(y).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, V.prototype.invm = function(u) {
      var h = this.imod(u._invmp(this.m).mul(this.r2));
      return h._forceRed(this);
    };
  })(n, commonjsGlobal);
})(bn$1);
const BN = bn$1.exports;
function createCommonjsModule(n, e, t) {
  return t = {
    path: e,
    exports: {},
    require: function(o, c) {
      return commonjsRequire(o, c == null ? t.path : c);
    }
  }, n(t, t.exports), t.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
assert.equal = function n(e, t, o) {
  if (e != t)
    throw new Error(o || "Assertion failed: " + e + " != " + t);
};
var utils_1$1 = createCommonjsModule(function(n, e) {
  var t = e;
  function o(d, p) {
    if (Array.isArray(d))
      return d.slice();
    if (!d)
      return [];
    var w = [];
    if (typeof d != "string") {
      for (var M = 0; M < d.length; M++)
        w[M] = d[M] | 0;
      return w;
    }
    if (p === "hex") {
      d = d.replace(/[^a-z0-9]+/ig, ""), d.length % 2 !== 0 && (d = "0" + d);
      for (var M = 0; M < d.length; M += 2)
        w.push(parseInt(d[M] + d[M + 1], 16));
    } else
      for (var M = 0; M < d.length; M++) {
        var I = d.charCodeAt(M), B = I >> 8, H = I & 255;
        B ? w.push(B, H) : w.push(H);
      }
    return w;
  }
  t.toArray = o;
  function c(d) {
    return d.length === 1 ? "0" + d : d;
  }
  t.zero2 = c;
  function a(d) {
    for (var p = "", w = 0; w < d.length; w++)
      p += c(d[w].toString(16));
    return p;
  }
  t.toHex = a, t.encode = function(p, w) {
    return w === "hex" ? a(p) : p;
  };
}), utils_1$1$1 = createCommonjsModule(function(n, e) {
  var t = e;
  t.assert = minimalisticAssert, t.toArray = utils_1$1.toArray, t.zero2 = utils_1$1.zero2, t.toHex = utils_1$1.toHex, t.encode = utils_1$1.encode;
  function o(w, M, I) {
    var B = new Array(Math.max(w.bitLength(), I) + 1);
    B.fill(0);
    for (var H = 1 << M + 1, L = w.clone(), W = 0; W < B.length; W++) {
      var $, P = L.andln(H - 1);
      L.isOdd() ? (P > (H >> 1) - 1 ? $ = (H >> 1) - P : $ = P, L.isubn($)) : $ = 0, B[W] = $, L.iushrn(1);
    }
    return B;
  }
  t.getNAF = o;
  function c(w, M) {
    var I = [
      [],
      []
    ];
    w = w.clone(), M = M.clone();
    for (var B = 0, H = 0, L; w.cmpn(-B) > 0 || M.cmpn(-H) > 0; ) {
      var W = w.andln(3) + B & 3, $ = M.andln(3) + H & 3;
      W === 3 && (W = -1), $ === 3 && ($ = -1);
      var P;
      (W & 1) === 0 ? P = 0 : (L = w.andln(7) + B & 7, (L === 3 || L === 5) && $ === 2 ? P = -W : P = W), I[0].push(P);
      var U;
      ($ & 1) === 0 ? U = 0 : (L = M.andln(7) + H & 7, (L === 3 || L === 5) && W === 2 ? U = -$ : U = $), I[1].push(U), 2 * B === P + 1 && (B = 1 - B), 2 * H === U + 1 && (H = 1 - H), w.iushrn(1), M.iushrn(1);
    }
    return I;
  }
  t.getJSF = c;
  function a(w, M, I) {
    var B = "_" + M;
    w.prototype[M] = function() {
      return this[B] !== void 0 ? this[B] : this[B] = I.call(this);
    };
  }
  t.cachedProperty = a;
  function d(w) {
    return typeof w == "string" ? t.toArray(w, "hex") : w;
  }
  t.parseBytes = d;
  function p(w) {
    return new BN(w, "hex", "le");
  }
  t.intFromLE = p;
}), getNAF = utils_1$1$1.getNAF, getJSF = utils_1$1$1.getJSF, assert$1 = utils_1$1$1.assert;
function BaseCurve(n, e) {
  this.type = n, this.p = new BN(e.p, 16), this.red = e.prime ? BN.red(e.prime) : BN.mont(this.p), this.zero = new BN(0).toRed(this.red), this.one = new BN(1).toRed(this.red), this.two = new BN(2).toRed(this.red), this.n = e.n && new BN(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var t = this.n && this.p.div(this.n);
  !t || t.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base = BaseCurve;
BaseCurve.prototype.point = function n() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function n() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function n(e, t) {
  assert$1(e.precomputed);
  var o = e._getDoubles(), c = getNAF(t, 1, this._bitLength), a = (1 << o.step + 1) - (o.step % 2 === 0 ? 2 : 1);
  a /= 3;
  var d = [], p, w;
  for (p = 0; p < c.length; p += o.step) {
    w = 0;
    for (var M = p + o.step - 1; M >= p; M--)
      w = (w << 1) + c[M];
    d.push(w);
  }
  for (var I = this.jpoint(null, null, null), B = this.jpoint(null, null, null), H = a; H > 0; H--) {
    for (p = 0; p < d.length; p++)
      w = d[p], w === H ? B = B.mixedAdd(o.points[p]) : w === -H && (B = B.mixedAdd(o.points[p].neg()));
    I = I.add(B);
  }
  return I.toP();
};
BaseCurve.prototype._wnafMul = function n(e, t) {
  var o = 4, c = e._getNAFPoints(o);
  o = c.wnd;
  for (var a = c.points, d = getNAF(t, o, this._bitLength), p = this.jpoint(null, null, null), w = d.length - 1; w >= 0; w--) {
    for (var M = 0; w >= 0 && d[w] === 0; w--)
      M++;
    if (w >= 0 && M++, p = p.dblp(M), w < 0)
      break;
    var I = d[w];
    assert$1(I !== 0), e.type === "affine" ? I > 0 ? p = p.mixedAdd(a[I - 1 >> 1]) : p = p.mixedAdd(a[-I - 1 >> 1].neg()) : I > 0 ? p = p.add(a[I - 1 >> 1]) : p = p.add(a[-I - 1 >> 1].neg());
  }
  return e.type === "affine" ? p.toP() : p;
};
BaseCurve.prototype._wnafMulAdd = function n(e, t, o, c, a) {
  var d = this._wnafT1, p = this._wnafT2, w = this._wnafT3, M = 0, I, B, H;
  for (I = 0; I < c; I++) {
    H = t[I];
    var L = H._getNAFPoints(e);
    d[I] = L.wnd, p[I] = L.points;
  }
  for (I = c - 1; I >= 1; I -= 2) {
    var W = I - 1, $ = I;
    if (d[W] !== 1 || d[$] !== 1) {
      w[W] = getNAF(o[W], d[W], this._bitLength), w[$] = getNAF(o[$], d[$], this._bitLength), M = Math.max(w[W].length, M), M = Math.max(w[$].length, M);
      continue;
    }
    var P = [
      t[W],
      null,
      null,
      t[$]
    ];
    t[W].y.cmp(t[$].y) === 0 ? (P[1] = t[W].add(t[$]), P[2] = t[W].toJ().mixedAdd(t[$].neg())) : t[W].y.cmp(t[$].y.redNeg()) === 0 ? (P[1] = t[W].toJ().mixedAdd(t[$]), P[2] = t[W].add(t[$].neg())) : (P[1] = t[W].toJ().mixedAdd(t[$]), P[2] = t[W].toJ().mixedAdd(t[$].neg()));
    var U = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ], G = getJSF(o[W], o[$]);
    for (M = Math.max(G[0].length, M), w[W] = new Array(M), w[$] = new Array(M), B = 0; B < M; B++) {
      var D = G[0][B] | 0, Z = G[1][B] | 0;
      w[W][B] = U[(D + 1) * 3 + (Z + 1)], w[$][B] = 0, p[W] = P;
    }
  }
  var J = this.jpoint(null, null, null), te = this._wnafT4;
  for (I = M; I >= 0; I--) {
    for (var ue = 0; I >= 0; ) {
      var he = !0;
      for (B = 0; B < c; B++)
        te[B] = w[B][I] | 0, te[B] !== 0 && (he = !1);
      if (!he)
        break;
      ue++, I--;
    }
    if (I >= 0 && ue++, J = J.dblp(ue), I < 0)
      break;
    for (B = 0; B < c; B++) {
      var Se = te[B];
      Se !== 0 && (Se > 0 ? H = p[B][Se - 1 >> 1] : Se < 0 && (H = p[B][-Se - 1 >> 1].neg()), H.type === "affine" ? J = J.mixedAdd(H) : J = J.add(H));
    }
  }
  for (I = 0; I < c; I++)
    p[I] = null;
  return a ? J : J.toP();
};
function BasePoint(n, e) {
  this.curve = n, this.type = e, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function n() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function n() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function n(e, t) {
  e = utils_1$1$1.toArray(e, t);
  var o = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * o) {
    e[0] === 6 ? assert$1(e[e.length - 1] % 2 === 0) : e[0] === 7 && assert$1(e[e.length - 1] % 2 === 1);
    var c = this.point(
      e.slice(1, 1 + o),
      e.slice(1 + o, 1 + 2 * o)
    );
    return c;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === o)
    return this.pointFromX(e.slice(1, 1 + o), e[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function n(e) {
  return this.encode(e, !0);
};
BasePoint.prototype._encode = function n(e) {
  var t = this.curve.p.byteLength(), o = this.getX().toArray("be", t);
  return e ? [this.getY().isEven() ? 2 : 3].concat(o) : [4].concat(o, this.getY().toArray("be", t));
};
BasePoint.prototype.encode = function n(e, t) {
  return utils_1$1$1.encode(this._encode(t), e);
};
BasePoint.prototype.precompute = function n(e) {
  if (this.precomputed)
    return this;
  var t = {
    doubles: null,
    naf: null,
    beta: null
  };
  return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this;
};
BasePoint.prototype._hasDoubles = function n(e) {
  if (!this.precomputed)
    return !1;
  var t = this.precomputed.doubles;
  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;
};
BasePoint.prototype._getDoubles = function n(e, t) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var o = [this], c = this, a = 0; a < t; a += e) {
    for (var d = 0; d < e; d++)
      c = c.dbl();
    o.push(c);
  }
  return {
    step: e,
    points: o
  };
};
BasePoint.prototype._getNAFPoints = function n(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var t = [this], o = (1 << e) - 1, c = o === 1 ? null : this.dbl(), a = 1; a < o; a++)
    t[a] = t[a - 1].add(c);
  return {
    wnd: e,
    points: t
  };
};
BasePoint.prototype._getBeta = function n() {
  return null;
};
BasePoint.prototype.dblp = function n(e) {
  for (var t = this, o = 0; o < e; o++)
    t = t.dbl();
  return t;
};
var inherits_browser = createCommonjsModule(function(n) {
  typeof Object.create == "function" ? n.exports = function(t, o) {
    o && (t.super_ = o, t.prototype = Object.create(o.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : n.exports = function(t, o) {
    if (o) {
      t.super_ = o;
      var c = function() {
      };
      c.prototype = o.prototype, t.prototype = new c(), t.prototype.constructor = t;
    }
  };
}), assert$2 = utils_1$1$1.assert;
function ShortCurve(n) {
  base.call(this, "short", n), this.a = new BN(n.a, 16).toRed(this.red), this.b = new BN(n.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(n), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function n(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var t, o;
    if (e.beta)
      t = new BN(e.beta, 16).toRed(this.red);
    else {
      var c = this._getEndoRoots(this.p);
      t = c[0].cmp(c[1]) < 0 ? c[0] : c[1], t = t.toRed(this.red);
    }
    if (e.lambda)
      o = new BN(e.lambda, 16);
    else {
      var a = this._getEndoRoots(this.n);
      this.g.mul(a[0]).x.cmp(this.g.x.redMul(t)) === 0 ? o = a[0] : (o = a[1], assert$2(this.g.mul(o).x.cmp(this.g.x.redMul(t)) === 0));
    }
    var d;
    return e.basis ? d = e.basis.map(function(p) {
      return {
        a: new BN(p.a, 16),
        b: new BN(p.b, 16)
      };
    }) : d = this._getEndoBasis(o), {
      beta: t,
      lambda: o,
      basis: d
    };
  }
};
ShortCurve.prototype._getEndoRoots = function n(e) {
  var t = e === this.p ? this.red : BN.mont(e), o = new BN(2).toRed(t).redInvm(), c = o.redNeg(), a = new BN(3).toRed(t).redNeg().redSqrt().redMul(o), d = c.redAdd(a).fromRed(), p = c.redSub(a).fromRed();
  return [d, p];
};
ShortCurve.prototype._getEndoBasis = function n(e) {
  for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o = e, c = this.n.clone(), a = new BN(1), d = new BN(0), p = new BN(0), w = new BN(1), M, I, B, H, L, W, $, P = 0, U, G; o.cmpn(0) !== 0; ) {
    var D = c.div(o);
    U = c.sub(D.mul(o)), G = p.sub(D.mul(a));
    var Z = w.sub(D.mul(d));
    if (!B && U.cmp(t) < 0)
      M = $.neg(), I = a, B = U.neg(), H = G;
    else if (B && ++P === 2)
      break;
    $ = U, c = o, o = U, p = a, a = G, w = d, d = Z;
  }
  L = U.neg(), W = G;
  var J = B.sqr().add(H.sqr()), te = L.sqr().add(W.sqr());
  return te.cmp(J) >= 0 && (L = M, W = I), B.negative && (B = B.neg(), H = H.neg()), L.negative && (L = L.neg(), W = W.neg()), [
    { a: B, b: H },
    { a: L, b: W }
  ];
};
ShortCurve.prototype._endoSplit = function n(e) {
  var t = this.endo.basis, o = t[0], c = t[1], a = c.b.mul(e).divRound(this.n), d = o.b.neg().mul(e).divRound(this.n), p = a.mul(o.a), w = d.mul(c.a), M = a.mul(o.b), I = d.mul(c.b), B = e.sub(p).sub(w), H = M.add(I).neg();
  return { k1: B, k2: H };
};
ShortCurve.prototype.pointFromX = function n(e, t) {
  e = new BN(e, 16), e.red || (e = e.toRed(this.red));
  var o = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), c = o.redSqrt();
  if (c.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var a = c.fromRed().isOdd();
  return (t && !a || !t && a) && (c = c.redNeg()), this.point(e, c);
};
ShortCurve.prototype.validate = function n(e) {
  if (e.inf)
    return !0;
  var t = e.x, o = e.y, c = this.a.redMul(t), a = t.redSqr().redMul(t).redIAdd(c).redIAdd(this.b);
  return o.redSqr().redISub(a).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function n(e, t, o) {
  for (var c = this._endoWnafT1, a = this._endoWnafT2, d = 0; d < e.length; d++) {
    var p = this._endoSplit(t[d]), w = e[d], M = w._getBeta();
    p.k1.negative && (p.k1.ineg(), w = w.neg(!0)), p.k2.negative && (p.k2.ineg(), M = M.neg(!0)), c[d * 2] = w, c[d * 2 + 1] = M, a[d * 2] = p.k1, a[d * 2 + 1] = p.k2;
  }
  for (var I = this._wnafMulAdd(1, c, a, d * 2, o), B = 0; B < d * 2; B++)
    c[B] = null, a[B] = null;
  return I;
};
function Point(n, e, t, o) {
  base.BasePoint.call(this, n, "affine"), e === null && t === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN(e, 16), this.y = new BN(t, 16), o && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function n(e, t, o) {
  return new Point(this, e, t, o);
};
ShortCurve.prototype.pointFromJSON = function n(e, t) {
  return Point.fromJSON(this, e, t);
};
Point.prototype._getBeta = function n() {
  if (!!this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var o = this.curve, c = function(a) {
        return o.point(a.x.redMul(o.endo.beta), a.y);
      };
      e.beta = t, t.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(c)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(c)
        }
      };
    }
    return t;
  }
};
Point.prototype.toJSON = function n() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point.fromJSON = function n(e, t, o) {
  typeof t == "string" && (t = JSON.parse(t));
  var c = e.point(t[0], t[1], o);
  if (!t[2])
    return c;
  function a(p) {
    return e.point(p[0], p[1], o);
  }
  var d = t[2];
  return c.precomputed = {
    beta: null,
    doubles: d.doubles && {
      step: d.doubles.step,
      points: [c].concat(d.doubles.points.map(a))
    },
    naf: d.naf && {
      wnd: d.naf.wnd,
      points: [c].concat(d.naf.points.map(a))
    }
  }, c;
};
Point.prototype.inspect = function n() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function n() {
  return this.inf;
};
Point.prototype.add = function n(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var t = this.y.redSub(e.y);
  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
  var o = t.redSqr().redISub(this.x).redISub(e.x), c = t.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, c);
};
Point.prototype.dbl = function n() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var t = this.curve.a, o = this.x.redSqr(), c = e.redInvm(), a = o.redAdd(o).redIAdd(o).redIAdd(t).redMul(c), d = a.redSqr().redISub(this.x.redAdd(this.x)), p = a.redMul(this.x.redSub(d)).redISub(this.y);
  return this.curve.point(d, p);
};
Point.prototype.getX = function n() {
  return this.x.fromRed();
};
Point.prototype.getY = function n() {
  return this.y.fromRed();
};
Point.prototype.mul = function n(e) {
  return e = new BN(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
Point.prototype.mulAdd = function n(e, t, o) {
  var c = [this, t], a = [e, o];
  return this.curve.endo ? this.curve._endoWnafMulAdd(c, a) : this.curve._wnafMulAdd(1, c, a, 2);
};
Point.prototype.jmulAdd = function n(e, t, o) {
  var c = [this, t], a = [e, o];
  return this.curve.endo ? this.curve._endoWnafMulAdd(c, a, !0) : this.curve._wnafMulAdd(1, c, a, 2, !0);
};
Point.prototype.eq = function n(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
Point.prototype.neg = function n(e) {
  if (this.inf)
    return this;
  var t = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var o = this.precomputed, c = function(a) {
      return a.neg();
    };
    t.precomputed = {
      naf: o.naf && {
        wnd: o.naf.wnd,
        points: o.naf.points.map(c)
      },
      doubles: o.doubles && {
        step: o.doubles.step,
        points: o.doubles.points.map(c)
      }
    };
  }
  return t;
};
Point.prototype.toJ = function n() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function JPoint(n, e, t, o) {
  base.BasePoint.call(this, n, "jacobian"), e === null && t === null && o === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN(0)) : (this.x = new BN(e, 16), this.y = new BN(t, 16), this.z = new BN(o, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function n(e, t, o) {
  return new JPoint(this, e, t, o);
};
JPoint.prototype.toP = function n() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), t = e.redSqr(), o = this.x.redMul(t), c = this.y.redMul(t).redMul(e);
  return this.curve.point(o, c);
};
JPoint.prototype.neg = function n() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function n(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var t = e.z.redSqr(), o = this.z.redSqr(), c = this.x.redMul(t), a = e.x.redMul(o), d = this.y.redMul(t.redMul(e.z)), p = e.y.redMul(o.redMul(this.z)), w = c.redSub(a), M = d.redSub(p);
  if (w.cmpn(0) === 0)
    return M.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var I = w.redSqr(), B = I.redMul(w), H = c.redMul(I), L = M.redSqr().redIAdd(B).redISub(H).redISub(H), W = M.redMul(H.redISub(L)).redISub(d.redMul(B)), $ = this.z.redMul(e.z).redMul(w);
  return this.curve.jpoint(L, W, $);
};
JPoint.prototype.mixedAdd = function n(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var t = this.z.redSqr(), o = this.x, c = e.x.redMul(t), a = this.y, d = e.y.redMul(t).redMul(this.z), p = o.redSub(c), w = a.redSub(d);
  if (p.cmpn(0) === 0)
    return w.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var M = p.redSqr(), I = M.redMul(p), B = o.redMul(M), H = w.redSqr().redIAdd(I).redISub(B).redISub(B), L = w.redMul(B.redISub(H)).redISub(a.redMul(I)), W = this.z.redMul(p);
  return this.curve.jpoint(H, L, W);
};
JPoint.prototype.dblp = function n(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var t;
  if (this.curve.zeroA || this.curve.threeA) {
    var o = this;
    for (t = 0; t < e; t++)
      o = o.dbl();
    return o;
  }
  var c = this.curve.a, a = this.curve.tinv, d = this.x, p = this.y, w = this.z, M = w.redSqr().redSqr(), I = p.redAdd(p);
  for (t = 0; t < e; t++) {
    var B = d.redSqr(), H = I.redSqr(), L = H.redSqr(), W = B.redAdd(B).redIAdd(B).redIAdd(c.redMul(M)), $ = d.redMul(H), P = W.redSqr().redISub($.redAdd($)), U = $.redISub(P), G = W.redMul(U);
    G = G.redIAdd(G).redISub(L);
    var D = I.redMul(w);
    t + 1 < e && (M = M.redMul(L)), d = P, w = D, I = G;
  }
  return this.curve.jpoint(d, I.redMul(a), w);
};
JPoint.prototype.dbl = function n() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function n() {
  var e, t, o;
  if (this.zOne) {
    var c = this.x.redSqr(), a = this.y.redSqr(), d = a.redSqr(), p = this.x.redAdd(a).redSqr().redISub(c).redISub(d);
    p = p.redIAdd(p);
    var w = c.redAdd(c).redIAdd(c), M = w.redSqr().redISub(p).redISub(p), I = d.redIAdd(d);
    I = I.redIAdd(I), I = I.redIAdd(I), e = M, t = w.redMul(p.redISub(M)).redISub(I), o = this.y.redAdd(this.y);
  } else {
    var B = this.x.redSqr(), H = this.y.redSqr(), L = H.redSqr(), W = this.x.redAdd(H).redSqr().redISub(B).redISub(L);
    W = W.redIAdd(W);
    var $ = B.redAdd(B).redIAdd(B), P = $.redSqr(), U = L.redIAdd(L);
    U = U.redIAdd(U), U = U.redIAdd(U), e = P.redISub(W).redISub(W), t = $.redMul(W.redISub(e)).redISub(U), o = this.y.redMul(this.z), o = o.redIAdd(o);
  }
  return this.curve.jpoint(e, t, o);
};
JPoint.prototype._threeDbl = function n() {
  var e, t, o;
  if (this.zOne) {
    var c = this.x.redSqr(), a = this.y.redSqr(), d = a.redSqr(), p = this.x.redAdd(a).redSqr().redISub(c).redISub(d);
    p = p.redIAdd(p);
    var w = c.redAdd(c).redIAdd(c).redIAdd(this.curve.a), M = w.redSqr().redISub(p).redISub(p);
    e = M;
    var I = d.redIAdd(d);
    I = I.redIAdd(I), I = I.redIAdd(I), t = w.redMul(p.redISub(M)).redISub(I), o = this.y.redAdd(this.y);
  } else {
    var B = this.z.redSqr(), H = this.y.redSqr(), L = this.x.redMul(H), W = this.x.redSub(B).redMul(this.x.redAdd(B));
    W = W.redAdd(W).redIAdd(W);
    var $ = L.redIAdd(L);
    $ = $.redIAdd($);
    var P = $.redAdd($);
    e = W.redSqr().redISub(P), o = this.y.redAdd(this.z).redSqr().redISub(H).redISub(B);
    var U = H.redSqr();
    U = U.redIAdd(U), U = U.redIAdd(U), U = U.redIAdd(U), t = W.redMul($.redISub(e)).redISub(U);
  }
  return this.curve.jpoint(e, t, o);
};
JPoint.prototype._dbl = function n() {
  var e = this.curve.a, t = this.x, o = this.y, c = this.z, a = c.redSqr().redSqr(), d = t.redSqr(), p = o.redSqr(), w = d.redAdd(d).redIAdd(d).redIAdd(e.redMul(a)), M = t.redAdd(t);
  M = M.redIAdd(M);
  var I = M.redMul(p), B = w.redSqr().redISub(I.redAdd(I)), H = I.redISub(B), L = p.redSqr();
  L = L.redIAdd(L), L = L.redIAdd(L), L = L.redIAdd(L);
  var W = w.redMul(H).redISub(L), $ = o.redAdd(o).redMul(c);
  return this.curve.jpoint(B, W, $);
};
JPoint.prototype.trpl = function n() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), t = this.y.redSqr(), o = this.z.redSqr(), c = t.redSqr(), a = e.redAdd(e).redIAdd(e), d = a.redSqr(), p = this.x.redAdd(t).redSqr().redISub(e).redISub(c);
  p = p.redIAdd(p), p = p.redAdd(p).redIAdd(p), p = p.redISub(d);
  var w = p.redSqr(), M = c.redIAdd(c);
  M = M.redIAdd(M), M = M.redIAdd(M), M = M.redIAdd(M);
  var I = a.redIAdd(p).redSqr().redISub(d).redISub(w).redISub(M), B = t.redMul(I);
  B = B.redIAdd(B), B = B.redIAdd(B);
  var H = this.x.redMul(w).redISub(B);
  H = H.redIAdd(H), H = H.redIAdd(H);
  var L = this.y.redMul(I.redMul(M.redISub(I)).redISub(p.redMul(w)));
  L = L.redIAdd(L), L = L.redIAdd(L), L = L.redIAdd(L);
  var W = this.z.redAdd(p).redSqr().redISub(o).redISub(w);
  return this.curve.jpoint(H, L, W);
};
JPoint.prototype.mul = function n(e, t) {
  return e = new BN(e, t), this.curve._wnafMul(this, e);
};
JPoint.prototype.eq = function n(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var t = this.z.redSqr(), o = e.z.redSqr();
  if (this.x.redMul(o).redISub(e.x.redMul(t)).cmpn(0) !== 0)
    return !1;
  var c = t.redMul(this.z), a = o.redMul(e.z);
  return this.y.redMul(a).redISub(e.y.redMul(c)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function n(e) {
  var t = this.z.redSqr(), o = e.toRed(this.curve.red).redMul(t);
  if (this.x.cmp(o) === 0)
    return !0;
  for (var c = e.clone(), a = this.curve.redN.redMul(t); ; ) {
    if (c.iadd(this.curve.n), c.cmp(this.curve.p) >= 0)
      return !1;
    if (o.redIAdd(a), this.x.cmp(o) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function n() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function n() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(n, e) {
  var t = e;
  t.base = base, t.short = short_1, t.mont = null, t.edwards = null;
}), curves_1 = createCommonjsModule(function(n, e) {
  var t = e, o = utils_1$1$1.assert;
  function c(p) {
    p.type === "short" ? this.curve = new curve_1.short(p) : p.type === "edwards" ? this.curve = new curve_1.edwards(p) : this.curve = new curve_1.mont(p), this.g = this.curve.g, this.n = this.curve.n, this.hash = p.hash, o(this.g.validate(), "Invalid curve"), o(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  t.PresetCurve = c;
  function a(p, w) {
    Object.defineProperty(t, p, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var M = new c(w);
        return Object.defineProperty(t, p, {
          configurable: !0,
          enumerable: !0,
          value: M
        }), M;
      }
    });
  }
  a("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), a("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), a("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), a("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), a("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), a("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), a("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var d;
  try {
    d = null.crash();
  } catch {
    d = void 0;
  }
  a("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      d
    ]
  });
});
function HmacDRBG(n) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(n);
  this.hash = n.hash, this.predResist = !!n.predResist, this.outLen = this.hash.outSize, this.minEntropy = n.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = utils_1$1.toArray(n.entropy, n.entropyEnc || "hex"), t = utils_1$1.toArray(n.nonce, n.nonceEnc || "hex"), o = utils_1$1.toArray(n.pers, n.persEnc || "hex");
  minimalisticAssert(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, t, o);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function n(e, t, o) {
  var c = e.concat(t).concat(o);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var a = 0; a < this.V.length; a++)
    this.K[a] = 0, this.V[a] = 1;
  this._update(c), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function n() {
  return new hash.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function n(e) {
  var t = this._hmac().update(this.V).update([0]);
  e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function n(e, t, o, c) {
  typeof t != "string" && (c = o, o = t, t = null), e = utils_1$1.toArray(e, t), o = utils_1$1.toArray(o, c), minimalisticAssert(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(o || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function n(e, t, o, c) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof t != "string" && (c = o, o = t, t = null), o && (o = utils_1$1.toArray(o, c || "hex"), this._update(o));
  for (var a = []; a.length < e; )
    this.V = this._hmac().update(this.V).digest(), a = a.concat(this.V);
  var d = a.slice(0, e);
  return this._update(o), this._reseed++, utils_1$1.encode(d, t);
};
var assert$3 = utils_1$1$1.assert;
function KeyPair(n, e) {
  this.ec = n, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function n(e, t, o) {
  return t instanceof KeyPair ? t : new KeyPair(e, {
    pub: t,
    pubEnc: o
  });
};
KeyPair.fromPrivate = function n(e, t, o) {
  return t instanceof KeyPair ? t : new KeyPair(e, {
    priv: t,
    privEnc: o
  });
};
KeyPair.prototype.validate = function n() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair.prototype.getPublic = function n(e, t) {
  return typeof e == "string" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;
};
KeyPair.prototype.getPrivate = function n(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair.prototype._importPrivate = function n(e, t) {
  this.priv = new BN(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function n(e, t) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? assert$3(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$3(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, t);
};
KeyPair.prototype.derive = function n(e) {
  return e.validate() || assert$3(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
KeyPair.prototype.sign = function n(e, t, o) {
  return this.ec.sign(e, this, t, o);
};
KeyPair.prototype.verify = function n(e, t) {
  return this.ec.verify(e, t, this);
};
KeyPair.prototype.inspect = function n() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1$1.assert;
function Signature(n, e) {
  if (n instanceof Signature)
    return n;
  this._importDER(n, e) || (assert$4(n.r && n.s, "Signature without r or s"), this.r = new BN(n.r, 16), this.s = new BN(n.s, 16), n.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = n.recoveryParam);
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(n, e) {
  var t = n[e.place++];
  if (!(t & 128))
    return t;
  var o = t & 15;
  if (o === 0 || o > 4)
    return !1;
  for (var c = 0, a = 0, d = e.place; a < o; a++, d++)
    c <<= 8, c |= n[d], c >>>= 0;
  return c <= 127 ? !1 : (e.place = d, c);
}
function rmPadding(n) {
  for (var e = 0, t = n.length - 1; !n[e] && !(n[e + 1] & 128) && e < t; )
    e++;
  return e === 0 ? n : n.slice(e);
}
Signature.prototype._importDER = function n(e, t) {
  e = utils_1$1$1.toArray(e, t);
  var o = new Position();
  if (e[o.place++] !== 48)
    return !1;
  var c = getLength(e, o);
  if (c === !1 || c + o.place !== e.length || e[o.place++] !== 2)
    return !1;
  var a = getLength(e, o);
  if (a === !1)
    return !1;
  var d = e.slice(o.place, a + o.place);
  if (o.place += a, e[o.place++] !== 2)
    return !1;
  var p = getLength(e, o);
  if (p === !1 || e.length !== p + o.place)
    return !1;
  var w = e.slice(o.place, p + o.place);
  if (d[0] === 0)
    if (d[1] & 128)
      d = d.slice(1);
    else
      return !1;
  if (w[0] === 0)
    if (w[1] & 128)
      w = w.slice(1);
    else
      return !1;
  return this.r = new BN(d), this.s = new BN(w), this.recoveryParam = null, !0;
};
function constructLength(n, e) {
  if (e < 128) {
    n.push(e);
    return;
  }
  var t = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (n.push(t | 128); --t; )
    n.push(e >>> (t << 3) & 255);
  n.push(e);
}
Signature.prototype.toDER = function n(e) {
  var t = this.r.toArray(), o = this.s.toArray();
  for (t[0] & 128 && (t = [0].concat(t)), o[0] & 128 && (o = [0].concat(o)), t = rmPadding(t), o = rmPadding(o); !o[0] && !(o[1] & 128); )
    o = o.slice(1);
  var c = [2];
  constructLength(c, t.length), c = c.concat(t), c.push(2), constructLength(c, o.length);
  var a = c.concat(o), d = [48];
  return constructLength(d, a.length), d = d.concat(a), utils_1$1$1.encode(d, e);
};
var rand = function() {
  throw new Error("unsupported");
}, assert$5 = utils_1$1$1.assert;
function EC(n) {
  if (!(this instanceof EC))
    return new EC(n);
  typeof n == "string" && (assert$5(
    Object.prototype.hasOwnProperty.call(curves_1, n),
    "Unknown curve " + n
  ), n = curves_1[n]), n instanceof curves_1.PresetCurve && (n = { curve: n }), this.curve = n.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = n.curve.g, this.g.precompute(n.curve.n.bitLength() + 1), this.hash = n.hash || n.curve.hash;
}
var ec$1 = EC;
EC.prototype.keyPair = function n(e) {
  return new key(this, e);
};
EC.prototype.keyFromPrivate = function n(e, t) {
  return key.fromPrivate(this, e, t);
};
EC.prototype.keyFromPublic = function n(e, t) {
  return key.fromPublic(this, e, t);
};
EC.prototype.genKeyPair = function n(e) {
  e || (e = {});
  for (var t = new hmacDrbg({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || rand(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), o = this.n.byteLength(), c = this.n.sub(new BN(2)); ; ) {
    var a = new BN(t.generate(o));
    if (!(a.cmp(c) > 0))
      return a.iaddn(1), this.keyFromPrivate(a);
  }
};
EC.prototype._truncateToN = function n(e, t) {
  var o = e.byteLength() * 8 - this.n.bitLength();
  return o > 0 && (e = e.ushrn(o)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
EC.prototype.sign = function n(e, t, o, c) {
  typeof o == "object" && (c = o, o = null), c || (c = {}), t = this.keyFromPrivate(t, o), e = this._truncateToN(new BN(e, 16));
  for (var a = this.n.byteLength(), d = t.getPrivate().toArray("be", a), p = e.toArray("be", a), w = new hmacDrbg({
    hash: this.hash,
    entropy: d,
    nonce: p,
    pers: c.pers,
    persEnc: c.persEnc || "utf8"
  }), M = this.n.sub(new BN(1)), I = 0; ; I++) {
    var B = c.k ? c.k(I) : new BN(w.generate(this.n.byteLength()));
    if (B = this._truncateToN(B, !0), !(B.cmpn(1) <= 0 || B.cmp(M) >= 0)) {
      var H = this.g.mul(B);
      if (!H.isInfinity()) {
        var L = H.getX(), W = L.umod(this.n);
        if (W.cmpn(0) !== 0) {
          var $ = B.invm(this.n).mul(W.mul(t.getPrivate()).iadd(e));
          if ($ = $.umod(this.n), $.cmpn(0) !== 0) {
            var P = (H.getY().isOdd() ? 1 : 0) | (L.cmp(W) !== 0 ? 2 : 0);
            return c.canonical && $.cmp(this.nh) > 0 && ($ = this.n.sub($), P ^= 1), new signature({ r: W, s: $, recoveryParam: P });
          }
        }
      }
    }
  }
};
EC.prototype.verify = function n(e, t, o, c) {
  e = this._truncateToN(new BN(e, 16)), o = this.keyFromPublic(o, c), t = new signature(t, "hex");
  var a = t.r, d = t.s;
  if (a.cmpn(1) < 0 || a.cmp(this.n) >= 0 || d.cmpn(1) < 0 || d.cmp(this.n) >= 0)
    return !1;
  var p = d.invm(this.n), w = p.mul(e).umod(this.n), M = p.mul(a).umod(this.n), I;
  return this.curve._maxwellTrick ? (I = this.g.jmulAdd(w, o.getPublic(), M), I.isInfinity() ? !1 : I.eqXToP(a)) : (I = this.g.mulAdd(w, o.getPublic(), M), I.isInfinity() ? !1 : I.getX().umod(this.n).cmp(a) === 0);
};
EC.prototype.recoverPubKey = function(n, e, t, o) {
  assert$5((3 & t) === t, "The recovery param is more than two bits"), e = new signature(e, o);
  var c = this.n, a = new BN(n), d = e.r, p = e.s, w = t & 1, M = t >> 1;
  if (d.cmp(this.curve.p.umod(this.curve.n)) >= 0 && M)
    throw new Error("Unable to find sencond key candinate");
  M ? d = this.curve.pointFromX(d.add(this.curve.n), w) : d = this.curve.pointFromX(d, w);
  var I = e.r.invm(c), B = c.sub(a).mul(I).umod(c), H = p.mul(I).umod(c);
  return this.g.mulAdd(B, d, H);
};
EC.prototype.getKeyRecoveryParam = function(n, e, t, o) {
  if (e = new signature(e, o), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var c = 0; c < 4; c++) {
    var a;
    try {
      a = this.recoverPubKey(n, e, c);
    } catch {
      continue;
    }
    if (a.eq(t))
      return c;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(n, e) {
  var t = e;
  t.version = "6.5.4", t.utils = utils_1$1$1, t.rand = function() {
    throw new Error("unsupported");
  }, t.curve = curve_1, t.curves = curves_1, t.ec = ec$1, t.eddsa = null;
}), EC$1 = elliptic_1.ec;
const version$b = "signing-key/5.7.0", logger$c = new Logger(version$b);
let _curve = null;
function getCurve() {
  return _curve || (_curve = new EC$1("secp256k1")), _curve;
}
class SigningKey {
  constructor(e) {
    defineReadOnly(this, "curve", "secp256k1"), defineReadOnly(this, "privateKey", hexlify(e)), hexDataLength(this.privateKey) !== 32 && logger$c.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const t = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + t.getPublic(!1, "hex")), defineReadOnly(this, "compressedPublicKey", "0x" + t.getPublic(!0, "hex")), defineReadOnly(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const t = getCurve().keyFromPublic(arrayify(this.publicKey)), o = getCurve().keyFromPublic(arrayify(e));
    return "0x" + t.pub.add(o.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const t = getCurve().keyFromPrivate(arrayify(this.privateKey)), o = arrayify(e);
    o.length !== 32 && logger$c.throwArgumentError("bad digest length", "digest", e);
    const c = t.sign(o, { canonical: !0 });
    return splitSignature({
      recoveryParam: c.recoveryParam,
      r: hexZeroPad("0x" + c.r.toString(16), 32),
      s: hexZeroPad("0x" + c.s.toString(16), 32)
    });
  }
  computeSharedSecret(e) {
    const t = getCurve().keyFromPrivate(arrayify(this.privateKey)), o = getCurve().keyFromPublic(arrayify(computePublicKey(e)));
    return hexZeroPad("0x" + t.derive(o.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function recoverPublicKey(n, e) {
  const t = splitSignature(e), o = { r: arrayify(t.r), s: arrayify(t.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(n), o, t.recoveryParam).encode("hex", !1);
}
function computePublicKey(n, e) {
  const t = arrayify(n);
  if (t.length === 32) {
    const o = new SigningKey(t);
    return e ? "0x" + getCurve().keyFromPrivate(t).getPublic(!0, "hex") : o.publicKey;
  } else {
    if (t.length === 33)
      return e ? hexlify(t) : "0x" + getCurve().keyFromPublic(t).getPublic(!1, "hex");
    if (t.length === 65)
      return e ? "0x" + getCurve().keyFromPublic(t).getPublic(!0, "hex") : hexlify(t);
  }
  return logger$c.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const lib_esm$8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SigningKey,
  recoverPublicKey,
  computePublicKey
}, Symbol.toStringTag, { value: "Module" })), version$a = "transactions/5.7.0", logger$b = new Logger(version$a);
var TransactionTypes;
(function(n) {
  n[n.legacy = 0] = "legacy", n[n.eip2930 = 1] = "eip2930", n[n.eip1559 = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(n) {
  return n === "0x" ? null : getAddress(n);
}
function handleNumber(n) {
  return n === "0x" ? Zero$1 : BigNumber.from(n);
}
const transactionFields = [
  { name: "nonce", maxLength: 32, numeric: !0 },
  { name: "gasPrice", maxLength: 32, numeric: !0 },
  { name: "gasLimit", maxLength: 32, numeric: !0 },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: !0 },
  { name: "data" }
], allowedTransactionKeys$1 = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  type: !0,
  value: !0
};
function computeAddress(n) {
  const e = computePublicKey(n);
  return getAddress(hexDataSlice(keccak256$1(hexDataSlice(e, 1)), 12));
}
function recoverAddress(n, e) {
  return computeAddress(recoverPublicKey(arrayify(n), e));
}
function formatNumber(n, e) {
  const t = stripZeros(BigNumber.from(n).toHexString());
  return t.length > 32 && logger$b.throwArgumentError("invalid length for " + e, "transaction:" + e, n), t;
}
function accessSetify(n, e) {
  return {
    address: getAddress(n),
    storageKeys: (e || []).map((t, o) => (hexDataLength(t) !== 32 && logger$b.throwArgumentError("invalid access list storageKey", `accessList[${n}:${o}]`, t), t.toLowerCase()))
  };
}
function accessListify(n) {
  if (Array.isArray(n))
    return n.map((t, o) => Array.isArray(t) ? (t.length > 2 && logger$b.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${o}]`, t), accessSetify(t[0], t[1])) : accessSetify(t.address, t.storageKeys));
  const e = Object.keys(n).map((t) => {
    const o = n[t].reduce((c, a) => (c[a] = !0, c), {});
    return accessSetify(t, Object.keys(o).sort());
  });
  return e.sort((t, o) => t.address.localeCompare(o.address)), e;
}
function formatAccessList(n) {
  return accessListify(n).map((e) => [e.address, e.storageKeys]);
}
function _serializeEip1559(n, e) {
  if (n.gasPrice != null) {
    const o = BigNumber.from(n.gasPrice), c = BigNumber.from(n.maxFeePerGas || 0);
    o.eq(c) || logger$b.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
      gasPrice: o,
      maxFeePerGas: c
    });
  }
  const t = [
    formatNumber(n.chainId || 0, "chainId"),
    formatNumber(n.nonce || 0, "nonce"),
    formatNumber(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(n.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(n.gasLimit || 0, "gasLimit"),
    n.to != null ? getAddress(n.to) : "0x",
    formatNumber(n.value || 0, "value"),
    n.data || "0x",
    formatAccessList(n.accessList || [])
  ];
  if (e) {
    const o = splitSignature(e);
    t.push(formatNumber(o.recoveryParam, "recoveryParam")), t.push(stripZeros(o.r)), t.push(stripZeros(o.s));
  }
  return hexConcat(["0x02", encode$1(t)]);
}
function _serializeEip2930(n, e) {
  const t = [
    formatNumber(n.chainId || 0, "chainId"),
    formatNumber(n.nonce || 0, "nonce"),
    formatNumber(n.gasPrice || 0, "gasPrice"),
    formatNumber(n.gasLimit || 0, "gasLimit"),
    n.to != null ? getAddress(n.to) : "0x",
    formatNumber(n.value || 0, "value"),
    n.data || "0x",
    formatAccessList(n.accessList || [])
  ];
  if (e) {
    const o = splitSignature(e);
    t.push(formatNumber(o.recoveryParam, "recoveryParam")), t.push(stripZeros(o.r)), t.push(stripZeros(o.s));
  }
  return hexConcat(["0x01", encode$1(t)]);
}
function _serialize(n, e) {
  checkProperties(n, allowedTransactionKeys$1);
  const t = [];
  transactionFields.forEach(function(d) {
    let p = n[d.name] || [];
    const w = {};
    d.numeric && (w.hexPad = "left"), p = arrayify(hexlify(p, w)), d.length && p.length !== d.length && p.length > 0 && logger$b.throwArgumentError("invalid length for " + d.name, "transaction:" + d.name, p), d.maxLength && (p = stripZeros(p), p.length > d.maxLength && logger$b.throwArgumentError("invalid length for " + d.name, "transaction:" + d.name, p)), t.push(hexlify(p));
  });
  let o = 0;
  if (n.chainId != null ? (o = n.chainId, typeof o != "number" && logger$b.throwArgumentError("invalid transaction.chainId", "transaction", n)) : e && !isBytesLike(e) && e.v > 28 && (o = Math.floor((e.v - 35) / 2)), o !== 0 && (t.push(hexlify(o)), t.push("0x"), t.push("0x")), !e)
    return encode$1(t);
  const c = splitSignature(e);
  let a = 27 + c.recoveryParam;
  return o !== 0 ? (t.pop(), t.pop(), t.pop(), a += o * 2 + 8, c.v > 28 && c.v !== a && logger$b.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e)) : c.v !== a && logger$b.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e), t.push(hexlify(a)), t.push(stripZeros(arrayify(c.r))), t.push(stripZeros(arrayify(c.s))), encode$1(t);
}
function serialize(n, e) {
  if (n.type == null || n.type === 0)
    return n.accessList != null && logger$b.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", n), _serialize(n, e);
  switch (n.type) {
    case 1:
      return _serializeEip2930(n, e);
    case 2:
      return _serializeEip1559(n, e);
  }
  return logger$b.throwError(`unsupported transaction type: ${n.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: n.type
  });
}
function _parseEipSignature(n, e, t) {
  try {
    const o = handleNumber(e[0]).toNumber();
    if (o !== 0 && o !== 1)
      throw new Error("bad recid");
    n.v = o;
  } catch {
    logger$b.throwArgumentError("invalid v for transaction type: 1", "v", e[0]);
  }
  n.r = hexZeroPad(e[1], 32), n.s = hexZeroPad(e[2], 32);
  try {
    const o = keccak256$1(t(n));
    n.from = recoverAddress(o, { r: n.r, s: n.s, recoveryParam: n.v });
  } catch {
  }
}
function _parseEip1559(n) {
  const e = decode$1(n.slice(1));
  e.length !== 9 && e.length !== 12 && logger$b.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(n));
  const t = handleNumber(e[2]), o = handleNumber(e[3]), c = {
    type: 2,
    chainId: handleNumber(e[0]).toNumber(),
    nonce: handleNumber(e[1]).toNumber(),
    maxPriorityFeePerGas: t,
    maxFeePerGas: o,
    gasPrice: null,
    gasLimit: handleNumber(e[4]),
    to: handleAddress(e[5]),
    value: handleNumber(e[6]),
    data: e[7],
    accessList: accessListify(e[8])
  };
  return e.length === 9 || (c.hash = keccak256$1(n), _parseEipSignature(c, e.slice(9), _serializeEip1559)), c;
}
function _parseEip2930(n) {
  const e = decode$1(n.slice(1));
  e.length !== 8 && e.length !== 11 && logger$b.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(n));
  const t = {
    type: 1,
    chainId: handleNumber(e[0]).toNumber(),
    nonce: handleNumber(e[1]).toNumber(),
    gasPrice: handleNumber(e[2]),
    gasLimit: handleNumber(e[3]),
    to: handleAddress(e[4]),
    value: handleNumber(e[5]),
    data: e[6],
    accessList: accessListify(e[7])
  };
  return e.length === 8 || (t.hash = keccak256$1(n), _parseEipSignature(t, e.slice(8), _serializeEip2930)), t;
}
function _parse(n) {
  const e = decode$1(n);
  e.length !== 9 && e.length !== 6 && logger$b.throwArgumentError("invalid raw transaction", "rawTransaction", n);
  const t = {
    nonce: handleNumber(e[0]).toNumber(),
    gasPrice: handleNumber(e[1]),
    gasLimit: handleNumber(e[2]),
    to: handleAddress(e[3]),
    value: handleNumber(e[4]),
    data: e[5],
    chainId: 0
  };
  if (e.length === 6)
    return t;
  try {
    t.v = BigNumber.from(e[6]).toNumber();
  } catch {
    return t;
  }
  if (t.r = hexZeroPad(e[7], 32), t.s = hexZeroPad(e[8], 32), BigNumber.from(t.r).isZero() && BigNumber.from(t.s).isZero())
    t.chainId = t.v, t.v = 0;
  else {
    t.chainId = Math.floor((t.v - 35) / 2), t.chainId < 0 && (t.chainId = 0);
    let o = t.v - 27;
    const c = e.slice(0, 6);
    t.chainId !== 0 && (c.push(hexlify(t.chainId)), c.push("0x"), c.push("0x"), o -= t.chainId * 2 + 8);
    const a = keccak256$1(encode$1(c));
    try {
      t.from = recoverAddress(a, { r: hexlify(t.r), s: hexlify(t.s), recoveryParam: o });
    } catch {
    }
    t.hash = keccak256$1(n);
  }
  return t.type = null, t;
}
function parse(n) {
  const e = arrayify(n);
  if (e[0] > 127)
    return _parse(e);
  switch (e[0]) {
    case 1:
      return _parseEip2930(e);
    case 2:
      return _parseEip1559(e);
  }
  return logger$b.throwError(`unsupported transaction type: ${e[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: e[0]
  });
}
const lib_esm$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TransactionTypes() {
    return TransactionTypes;
  },
  computeAddress,
  recoverAddress,
  accessListify,
  serialize,
  parse
}, Symbol.toStringTag, { value: "Module" })), version$9 = "wordlists/5.7.0", logger$a = new Logger(version$9);
class Wordlist {
  constructor(e) {
    logger$a.checkAbstract(new.target, Wordlist), defineReadOnly(this, "locale", e);
  }
  split(e) {
    return e.toLowerCase().split(/ +/g);
  }
  join(e) {
    return e.join(" ");
  }
  static check(e) {
    const t = [];
    for (let o = 0; o < 2048; o++) {
      const c = e.getWord(o);
      if (o !== e.getWordIndex(c))
        return "0x";
      t.push(c);
    }
    return id(t.join(`
`) + `
`);
  }
  static register(e, t) {
    t || (t = e.locale);
  }
}
const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(n) {
  if (wordlist == null && (wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), Wordlist.check(n) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"))
    throw wordlist = null, new Error("BIP39 Wordlist for en (English) FAILED");
}
class LangEn extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(e) {
    return loadWords(this), wordlist[e];
  }
  getWordIndex(e) {
    return loadWords(this), wordlist.indexOf(e);
  }
}
const langEn = new LangEn();
Wordlist.register(langEn);
const wordlists = {
  en: langEn
}, version$8 = "hdnode/5.7.0", logger$9 = new Logger(version$8), N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), MasterSecret = toUtf8Bytes("Bitcoin seed"), HardenedBit = 2147483648;
function getUpperMask(n) {
  return (1 << n) - 1 << 8 - n;
}
function getLowerMask(n) {
  return (1 << n) - 1;
}
function bytes32(n) {
  return hexZeroPad(hexlify(n), 32);
}
function base58check(n) {
  return Base58.encode(concat([n, hexDataSlice(sha256$1(sha256$1(n)), 0, 4)]));
}
function getWordlist(n) {
  if (n == null)
    return wordlists.en;
  if (typeof n == "string") {
    const e = wordlists[n];
    return e == null && logger$9.throwArgumentError("unknown locale", "wordlist", n), e;
  }
  return n;
}
const _constructorGuard = {}, defaultPath = "m/44'/60'/0'/0/0";
class HDNode {
  constructor(e, t, o, c, a, d, p, w) {
    if (e !== _constructorGuard)
      throw new Error("HDNode constructor cannot be called directly");
    if (t) {
      const M = new SigningKey(t);
      defineReadOnly(this, "privateKey", M.privateKey), defineReadOnly(this, "publicKey", M.compressedPublicKey);
    } else
      defineReadOnly(this, "privateKey", null), defineReadOnly(this, "publicKey", hexlify(o));
    defineReadOnly(this, "parentFingerprint", c), defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256$1(this.publicKey)), 0, 4)), defineReadOnly(this, "address", computeAddress(this.publicKey)), defineReadOnly(this, "chainCode", a), defineReadOnly(this, "index", d), defineReadOnly(this, "depth", p), w == null ? (defineReadOnly(this, "mnemonic", null), defineReadOnly(this, "path", null)) : typeof w == "string" ? (defineReadOnly(this, "mnemonic", null), defineReadOnly(this, "path", w)) : (defineReadOnly(this, "mnemonic", w), defineReadOnly(this, "path", w.path));
  }
  get extendedKey() {
    if (this.depth >= 256)
      throw new Error("Depth too large!");
    return base58check(concat([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify(this.depth),
      this.parentFingerprint,
      hexZeroPad(hexlify(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(e) {
    if (e > 4294967295)
      throw new Error("invalid index - " + String(e));
    let t = this.path;
    t && (t += "/" + (e & ~HardenedBit));
    const o = new Uint8Array(37);
    if (e & HardenedBit) {
      if (!this.privateKey)
        throw new Error("cannot derive child of neutered node");
      o.set(arrayify(this.privateKey), 1), t && (t += "'");
    } else
      o.set(arrayify(this.publicKey));
    for (let B = 24; B >= 0; B -= 8)
      o[33 + (B >> 3)] = e >> 24 - B & 255;
    const c = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, o)), a = c.slice(0, 32), d = c.slice(32);
    let p = null, w = null;
    this.privateKey ? p = bytes32(BigNumber.from(a).add(this.privateKey).mod(N)) : w = new SigningKey(hexlify(a))._addPoint(this.publicKey);
    let M = t;
    const I = this.mnemonic;
    return I && (M = Object.freeze({
      phrase: I.phrase,
      path: t,
      locale: I.locale || "en"
    })), new HDNode(_constructorGuard, p, w, this.fingerprint, bytes32(d), e, this.depth + 1, M);
  }
  derivePath(e) {
    const t = e.split("/");
    if (t.length === 0 || t[0] === "m" && this.depth !== 0)
      throw new Error("invalid path - " + e);
    t[0] === "m" && t.shift();
    let o = this;
    for (let c = 0; c < t.length; c++) {
      const a = t[c];
      if (a.match(/^[0-9]+'$/)) {
        const d = parseInt(a.substring(0, a.length - 1));
        if (d >= HardenedBit)
          throw new Error("invalid path index - " + a);
        o = o._derive(HardenedBit + d);
      } else if (a.match(/^[0-9]+$/)) {
        const d = parseInt(a);
        if (d >= HardenedBit)
          throw new Error("invalid path index - " + a);
        o = o._derive(d);
      } else
        throw new Error("invalid path component - " + a);
    }
    return o;
  }
  static _fromSeed(e, t) {
    const o = arrayify(e);
    if (o.length < 16 || o.length > 64)
      throw new Error("invalid seed");
    const c = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, o));
    return new HDNode(_constructorGuard, bytes32(c.slice(0, 32)), null, "0x00000000", bytes32(c.slice(32)), 0, 0, t);
  }
  static fromMnemonic(e, t, o) {
    return o = getWordlist(o), e = entropyToMnemonic(mnemonicToEntropy(e, o), o), HDNode._fromSeed(mnemonicToSeed(e, t), {
      phrase: e,
      path: "m",
      locale: o.locale
    });
  }
  static fromSeed(e) {
    return HDNode._fromSeed(e, null);
  }
  static fromExtendedKey(e) {
    const t = Base58.decode(e);
    (t.length !== 82 || base58check(t.slice(0, 78)) !== e) && logger$9.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    const o = t[4], c = hexlify(t.slice(5, 9)), a = parseInt(hexlify(t.slice(9, 13)).substring(2), 16), d = hexlify(t.slice(13, 45)), p = t.slice(45, 78);
    switch (hexlify(t.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard, null, hexlify(p), c, d, a, o, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (p[0] !== 0)
          break;
        return new HDNode(_constructorGuard, hexlify(p.slice(1)), null, c, d, a, o, null);
    }
    return logger$9.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function mnemonicToSeed(n, e) {
  e || (e = "");
  const t = toUtf8Bytes("mnemonic" + e, UnicodeNormalizationForm.NFKD);
  return pbkdf2$1(toUtf8Bytes(n, UnicodeNormalizationForm.NFKD), t, 2048, 64, "sha512");
}
function mnemonicToEntropy(n, e) {
  e = getWordlist(e), logger$9.checkNormalize();
  const t = e.split(n);
  if (t.length % 3 !== 0)
    throw new Error("invalid mnemonic");
  const o = arrayify(new Uint8Array(Math.ceil(11 * t.length / 8)));
  let c = 0;
  for (let M = 0; M < t.length; M++) {
    let I = e.getWordIndex(t[M].normalize("NFKD"));
    if (I === -1)
      throw new Error("invalid mnemonic");
    for (let B = 0; B < 11; B++)
      I & 1 << 10 - B && (o[c >> 3] |= 1 << 7 - c % 8), c++;
  }
  const a = 32 * t.length / 3, d = t.length / 3, p = getUpperMask(d);
  if ((arrayify(sha256$1(o.slice(0, a / 8)))[0] & p) !== (o[o.length - 1] & p))
    throw new Error("invalid checksum");
  return hexlify(o.slice(0, a / 8));
}
function entropyToMnemonic(n, e) {
  if (e = getWordlist(e), n = arrayify(n), n.length % 4 !== 0 || n.length < 16 || n.length > 32)
    throw new Error("invalid entropy");
  const t = [0];
  let o = 11;
  for (let d = 0; d < n.length; d++)
    o > 8 ? (t[t.length - 1] <<= 8, t[t.length - 1] |= n[d], o -= 8) : (t[t.length - 1] <<= o, t[t.length - 1] |= n[d] >> 8 - o, t.push(n[d] & getLowerMask(8 - o)), o += 3);
  const c = n.length / 4, a = arrayify(sha256$1(n))[0] & getUpperMask(c);
  return t[t.length - 1] <<= c, t[t.length - 1] |= a >> 8 - c, e.join(t.map((d) => e.getWord(d)));
}
function isValidMnemonic(n, e) {
  try {
    return mnemonicToEntropy(n, e), !0;
  } catch {
  }
  return !1;
}
function getAccountPath(n) {
  return (typeof n != "number" || n < 0 || n >= HardenedBit || n % 1) && logger$9.throwArgumentError("invalid account index", "index", n), `m/44'/60'/${n}'/0/0`;
}
const lib_esm$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultPath,
  HDNode,
  mnemonicToSeed,
  mnemonicToEntropy,
  entropyToMnemonic,
  isValidMnemonic,
  getAccountPath
}, Symbol.toStringTag, { value: "Module" })), require$$6 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$6);
var aesJs = { exports: {} };
(function(n, e) {
  (function(t) {
    function o(b) {
      return parseInt(b) === b;
    }
    function c(b) {
      if (!o(b.length))
        return !1;
      for (var l = 0; l < b.length; l++)
        if (!o(b[l]) || b[l] < 0 || b[l] > 255)
          return !1;
      return !0;
    }
    function a(b, l) {
      if (b.buffer && ArrayBuffer.isView(b) && b.name === "Uint8Array")
        return l && (b.slice ? b = b.slice() : b = Array.prototype.slice.call(b)), b;
      if (Array.isArray(b)) {
        if (!c(b))
          throw new Error("Array contains invalid value: " + b);
        return new Uint8Array(b);
      }
      if (o(b.length) && c(b))
        return new Uint8Array(b);
      throw new Error("unsupported array-like object");
    }
    function d(b) {
      return new Uint8Array(b);
    }
    function p(b, l, v, X, S) {
      (X != null || S != null) && (b.slice ? b = b.slice(X, S) : b = Array.prototype.slice.call(b, X, S)), l.set(b, v);
    }
    var w = function() {
      function b(v) {
        var X = [], S = 0;
        for (v = encodeURI(v); S < v.length; ) {
          var Y = v.charCodeAt(S++);
          Y === 37 ? (X.push(parseInt(v.substr(S, 2), 16)), S += 2) : X.push(Y);
        }
        return a(X);
      }
      function l(v) {
        for (var X = [], S = 0; S < v.length; ) {
          var Y = v[S];
          Y < 128 ? (X.push(String.fromCharCode(Y)), S++) : Y > 191 && Y < 224 ? (X.push(String.fromCharCode((Y & 31) << 6 | v[S + 1] & 63)), S += 2) : (X.push(String.fromCharCode((Y & 15) << 12 | (v[S + 1] & 63) << 6 | v[S + 2] & 63)), S += 3);
        }
        return X.join("");
      }
      return {
        toBytes: b,
        fromBytes: l
      };
    }(), M = function() {
      function b(X) {
        for (var S = [], Y = 0; Y < X.length; Y += 2)
          S.push(parseInt(X.substr(Y, 2), 16));
        return S;
      }
      var l = "0123456789abcdef";
      function v(X) {
        for (var S = [], Y = 0; Y < X.length; Y++) {
          var fe = X[Y];
          S.push(l[(fe & 240) >> 4] + l[fe & 15]);
        }
        return S.join("");
      }
      return {
        toBytes: b,
        fromBytes: v
      };
    }(), I = { 16: 10, 24: 12, 32: 14 }, B = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145], H = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22], L = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125], W = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986], $ = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766], P = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126], U = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436], G = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890], D = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935], Z = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600], J = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480], te = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795], ue = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855], he = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150], Se = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function C(b) {
      for (var l = [], v = 0; v < b.length; v += 4)
        l.push(
          b[v] << 24 | b[v + 1] << 16 | b[v + 2] << 8 | b[v + 3]
        );
      return l;
    }
    var O = function(b) {
      if (!(this instanceof O))
        throw Error("AES must be instanitated with `new`");
      Object.defineProperty(this, "key", {
        value: a(b, !0)
      }), this._prepare();
    };
    O.prototype._prepare = function() {
      var b = I[this.key.length];
      if (b == null)
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      this._Ke = [], this._Kd = [];
      for (var l = 0; l <= b; l++)
        this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
      for (var v = (b + 1) * 4, X = this.key.length / 4, S = C(this.key), Y, l = 0; l < X; l++)
        Y = l >> 2, this._Ke[Y][l % 4] = S[l], this._Kd[b - Y][l % 4] = S[l];
      for (var fe = 0, oe = X, de; oe < v; ) {
        if (de = S[X - 1], S[0] ^= H[de >> 16 & 255] << 24 ^ H[de >> 8 & 255] << 16 ^ H[de & 255] << 8 ^ H[de >> 24 & 255] ^ B[fe] << 24, fe += 1, X != 8)
          for (var l = 1; l < X; l++)
            S[l] ^= S[l - 1];
        else {
          for (var l = 1; l < X / 2; l++)
            S[l] ^= S[l - 1];
          de = S[X / 2 - 1], S[X / 2] ^= H[de & 255] ^ H[de >> 8 & 255] << 8 ^ H[de >> 16 & 255] << 16 ^ H[de >> 24 & 255] << 24;
          for (var l = X / 2 + 1; l < X; l++)
            S[l] ^= S[l - 1];
        }
        for (var l = 0, Ie, ye; l < X && oe < v; )
          Ie = oe >> 2, ye = oe % 4, this._Ke[Ie][ye] = S[l], this._Kd[b - Ie][ye] = S[l++], oe++;
      }
      for (var Ie = 1; Ie < b; Ie++)
        for (var ye = 0; ye < 4; ye++)
          de = this._Kd[Ie][ye], this._Kd[Ie][ye] = te[de >> 24 & 255] ^ ue[de >> 16 & 255] ^ he[de >> 8 & 255] ^ Se[de & 255];
    }, O.prototype.encrypt = function(b) {
      if (b.length != 16)
        throw new Error("invalid plaintext size (must be 16 bytes)");
      for (var l = this._Ke.length - 1, v = [0, 0, 0, 0], X = C(b), S = 0; S < 4; S++)
        X[S] ^= this._Ke[0][S];
      for (var Y = 1; Y < l; Y++) {
        for (var S = 0; S < 4; S++)
          v[S] = W[X[S] >> 24 & 255] ^ $[X[(S + 1) % 4] >> 16 & 255] ^ P[X[(S + 2) % 4] >> 8 & 255] ^ U[X[(S + 3) % 4] & 255] ^ this._Ke[Y][S];
        X = v.slice();
      }
      for (var fe = d(16), oe, S = 0; S < 4; S++)
        oe = this._Ke[l][S], fe[4 * S] = (H[X[S] >> 24 & 255] ^ oe >> 24) & 255, fe[4 * S + 1] = (H[X[(S + 1) % 4] >> 16 & 255] ^ oe >> 16) & 255, fe[4 * S + 2] = (H[X[(S + 2) % 4] >> 8 & 255] ^ oe >> 8) & 255, fe[4 * S + 3] = (H[X[(S + 3) % 4] & 255] ^ oe) & 255;
      return fe;
    }, O.prototype.decrypt = function(b) {
      if (b.length != 16)
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      for (var l = this._Kd.length - 1, v = [0, 0, 0, 0], X = C(b), S = 0; S < 4; S++)
        X[S] ^= this._Kd[0][S];
      for (var Y = 1; Y < l; Y++) {
        for (var S = 0; S < 4; S++)
          v[S] = G[X[S] >> 24 & 255] ^ D[X[(S + 3) % 4] >> 16 & 255] ^ Z[X[(S + 2) % 4] >> 8 & 255] ^ J[X[(S + 1) % 4] & 255] ^ this._Kd[Y][S];
        X = v.slice();
      }
      for (var fe = d(16), oe, S = 0; S < 4; S++)
        oe = this._Kd[l][S], fe[4 * S] = (L[X[S] >> 24 & 255] ^ oe >> 24) & 255, fe[4 * S + 1] = (L[X[(S + 3) % 4] >> 16 & 255] ^ oe >> 16) & 255, fe[4 * S + 2] = (L[X[(S + 2) % 4] >> 8 & 255] ^ oe >> 8) & 255, fe[4 * S + 3] = (L[X[(S + 1) % 4] & 255] ^ oe) & 255;
      return fe;
    };
    var V = function(b) {
      if (!(this instanceof V))
        throw Error("AES must be instanitated with `new`");
      this.description = "Electronic Code Block", this.name = "ecb", this._aes = new O(b);
    };
    V.prototype.encrypt = function(b) {
      if (b = a(b), b.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var l = d(b.length), v = d(16), X = 0; X < b.length; X += 16)
        p(b, v, 0, X, X + 16), v = this._aes.encrypt(v), p(v, l, X);
      return l;
    }, V.prototype.decrypt = function(b) {
      if (b = a(b), b.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var l = d(b.length), v = d(16), X = 0; X < b.length; X += 16)
        p(b, v, 0, X, X + 16), v = this._aes.decrypt(v), p(v, l, X);
      return l;
    };
    var x = function(b, l) {
      if (!(this instanceof x))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Block Chaining", this.name = "cbc", !l)
        l = d(16);
      else if (l.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastCipherblock = a(l, !0), this._aes = new O(b);
    };
    x.prototype.encrypt = function(b) {
      if (b = a(b), b.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var l = d(b.length), v = d(16), X = 0; X < b.length; X += 16) {
        p(b, v, 0, X, X + 16);
        for (var S = 0; S < 16; S++)
          v[S] ^= this._lastCipherblock[S];
        this._lastCipherblock = this._aes.encrypt(v), p(this._lastCipherblock, l, X);
      }
      return l;
    }, x.prototype.decrypt = function(b) {
      if (b = a(b), b.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var l = d(b.length), v = d(16), X = 0; X < b.length; X += 16) {
        p(b, v, 0, X, X + 16), v = this._aes.decrypt(v);
        for (var S = 0; S < 16; S++)
          l[X + S] = v[S] ^ this._lastCipherblock[S];
        p(b, this._lastCipherblock, 0, X, X + 16);
      }
      return l;
    };
    var u = function(b, l, v) {
      if (!(this instanceof u))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Feedback", this.name = "cfb", !l)
        l = d(16);
      else if (l.length != 16)
        throw new Error("invalid initialation vector size (must be 16 size)");
      v || (v = 1), this.segmentSize = v, this._shiftRegister = a(l, !0), this._aes = new O(b);
    };
    u.prototype.encrypt = function(b) {
      if (b.length % this.segmentSize != 0)
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      for (var l = a(b, !0), v, X = 0; X < l.length; X += this.segmentSize) {
        v = this._aes.encrypt(this._shiftRegister);
        for (var S = 0; S < this.segmentSize; S++)
          l[X + S] ^= v[S];
        p(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), p(l, this._shiftRegister, 16 - this.segmentSize, X, X + this.segmentSize);
      }
      return l;
    }, u.prototype.decrypt = function(b) {
      if (b.length % this.segmentSize != 0)
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      for (var l = a(b, !0), v, X = 0; X < l.length; X += this.segmentSize) {
        v = this._aes.encrypt(this._shiftRegister);
        for (var S = 0; S < this.segmentSize; S++)
          l[X + S] ^= v[S];
        p(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), p(b, this._shiftRegister, 16 - this.segmentSize, X, X + this.segmentSize);
      }
      return l;
    };
    var h = function(b, l) {
      if (!(this instanceof h))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Output Feedback", this.name = "ofb", !l)
        l = d(16);
      else if (l.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastPrecipher = a(l, !0), this._lastPrecipherIndex = 16, this._aes = new O(b);
    };
    h.prototype.encrypt = function(b) {
      for (var l = a(b, !0), v = 0; v < l.length; v++)
        this._lastPrecipherIndex === 16 && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), l[v] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      return l;
    }, h.prototype.decrypt = h.prototype.encrypt;
    var g = function(b) {
      if (!(this instanceof g))
        throw Error("Counter must be instanitated with `new`");
      b !== 0 && !b && (b = 1), typeof b == "number" ? (this._counter = d(16), this.setValue(b)) : this.setBytes(b);
    };
    g.prototype.setValue = function(b) {
      if (typeof b != "number" || parseInt(b) != b)
        throw new Error("invalid counter value (must be an integer)");
      for (var l = 15; l >= 0; --l)
        this._counter[l] = b % 256, b = b >> 8;
    }, g.prototype.setBytes = function(b) {
      if (b = a(b, !0), b.length != 16)
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      this._counter = b;
    }, g.prototype.increment = function() {
      for (var b = 15; b >= 0; b--)
        if (this._counter[b] === 255)
          this._counter[b] = 0;
        else {
          this._counter[b]++;
          break;
        }
    };
    var y = function(b, l) {
      if (!(this instanceof y))
        throw Error("AES must be instanitated with `new`");
      this.description = "Counter", this.name = "ctr", l instanceof g || (l = new g(l)), this._counter = l, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new O(b);
    };
    y.prototype.encrypt = function(b) {
      for (var l = a(b, !0), v = 0; v < l.length; v++)
        this._remainingCounterIndex === 16 && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), l[v] ^= this._remainingCounter[this._remainingCounterIndex++];
      return l;
    }, y.prototype.decrypt = y.prototype.encrypt;
    function m(b) {
      b = a(b, !0);
      var l = 16 - b.length % 16, v = d(b.length + l);
      p(b, v);
      for (var X = b.length; X < v.length; X++)
        v[X] = l;
      return v;
    }
    function _(b) {
      if (b = a(b, !0), b.length < 16)
        throw new Error("PKCS#7 invalid length");
      var l = b[b.length - 1];
      if (l > 16)
        throw new Error("PKCS#7 padding byte out of range");
      for (var v = b.length - l, X = 0; X < l; X++)
        if (b[v + X] !== l)
          throw new Error("PKCS#7 invalid padding byte");
      var S = d(v);
      return p(b, S, 0, 0, v), S;
    }
    var R = {
      AES: O,
      Counter: g,
      ModeOfOperation: {
        ecb: V,
        cbc: x,
        cfb: u,
        ofb: h,
        ctr: y
      },
      utils: {
        hex: M,
        utf8: w
      },
      padding: {
        pkcs7: {
          pad: m,
          strip: _
        }
      },
      _arrayTest: {
        coerceArray: a,
        createArray: d,
        copyArray: p
      }
    };
    n.exports = R;
  })();
})(aesJs);
const aes = aesJs.exports, version$7 = "json-wallets/5.7.0";
function looseArrayify(n) {
  return typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), arrayify(n);
}
function zpad(n, e) {
  for (n = String(n); n.length < e; )
    n = "0" + n;
  return n;
}
function getPassword(n) {
  return typeof n == "string" ? toUtf8Bytes(n, UnicodeNormalizationForm.NFKC) : arrayify(n);
}
function searchPath(n, e) {
  let t = n;
  const o = e.toLowerCase().split("/");
  for (let c = 0; c < o.length; c++) {
    let a = null;
    for (const d in t)
      if (d.toLowerCase() === o[c]) {
        a = t[d];
        break;
      }
    if (a === null)
      return null;
    t = a;
  }
  return t;
}
function uuidV4(n) {
  const e = arrayify(n);
  e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
  const t = hexlify(e);
  return [
    t.substring(2, 10),
    t.substring(10, 14),
    t.substring(14, 18),
    t.substring(18, 22),
    t.substring(22, 34)
  ].join("-");
}
const logger$8 = new Logger(version$7);
class CrowdsaleAccount extends Description {
  isCrowdsaleAccount(e) {
    return !!(e && e._isCrowdsaleAccount);
  }
}
function decrypt$1(n, e) {
  const t = JSON.parse(n);
  e = getPassword(e);
  const o = getAddress(searchPath(t, "ethaddr")), c = looseArrayify(searchPath(t, "encseed"));
  (!c || c.length % 16 !== 0) && logger$8.throwArgumentError("invalid encseed", "json", n);
  const a = arrayify(pbkdf2$1(e, e, 2e3, 32, "sha256")).slice(0, 16), d = c.slice(0, 16), p = c.slice(16), w = new aes.ModeOfOperation.cbc(a, d), M = aes.padding.pkcs7.strip(arrayify(w.decrypt(p)));
  let I = "";
  for (let L = 0; L < M.length; L++)
    I += String.fromCharCode(M[L]);
  const B = toUtf8Bytes(I), H = keccak256$1(B);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: !0,
    address: o,
    privateKey: H
  });
}
function isCrowdsaleWallet(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return e.encseed && e.ethaddr;
}
function isKeystoreWallet(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return !(!e.version || parseInt(e.version) !== e.version || parseInt(e.version) !== 3);
}
function getJsonWalletAddress(n) {
  if (isCrowdsaleWallet(n))
    try {
      return getAddress(JSON.parse(n).ethaddr);
    } catch {
      return null;
    }
  if (isKeystoreWallet(n))
    try {
      return getAddress(JSON.parse(n).address);
    } catch {
      return null;
    }
  return null;
}
var scrypt$1 = { exports: {} };
(function(n, e) {
  (function(t) {
    function c($) {
      const P = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let U = 1779033703, G = 3144134277, D = 1013904242, Z = 2773480762, J = 1359893119, te = 2600822924, ue = 528734635, he = 1541459225;
      const Se = new Uint32Array(64);
      function C(y) {
        let m = 0, _ = y.length;
        for (; _ >= 64; ) {
          let R = U, b = G, l = D, v = Z, X = J, S = te, Y = ue, fe = he, oe, de, Ie, ye, be;
          for (de = 0; de < 16; de++)
            Ie = m + de * 4, Se[de] = (y[Ie] & 255) << 24 | (y[Ie + 1] & 255) << 16 | (y[Ie + 2] & 255) << 8 | y[Ie + 3] & 255;
          for (de = 16; de < 64; de++)
            oe = Se[de - 2], ye = (oe >>> 17 | oe << 32 - 17) ^ (oe >>> 19 | oe << 32 - 19) ^ oe >>> 10, oe = Se[de - 15], be = (oe >>> 7 | oe << 32 - 7) ^ (oe >>> 18 | oe << 32 - 18) ^ oe >>> 3, Se[de] = (ye + Se[de - 7] | 0) + (be + Se[de - 16] | 0) | 0;
          for (de = 0; de < 64; de++)
            ye = (((X >>> 6 | X << 32 - 6) ^ (X >>> 11 | X << 32 - 11) ^ (X >>> 25 | X << 32 - 25)) + (X & S ^ ~X & Y) | 0) + (fe + (P[de] + Se[de] | 0) | 0) | 0, be = ((R >>> 2 | R << 32 - 2) ^ (R >>> 13 | R << 32 - 13) ^ (R >>> 22 | R << 32 - 22)) + (R & b ^ R & l ^ b & l) | 0, fe = Y, Y = S, S = X, X = v + ye | 0, v = l, l = b, b = R, R = ye + be | 0;
          U = U + R | 0, G = G + b | 0, D = D + l | 0, Z = Z + v | 0, J = J + X | 0, te = te + S | 0, ue = ue + Y | 0, he = he + fe | 0, m += 64, _ -= 64;
        }
      }
      C($);
      let O, V = $.length % 64, x = $.length / 536870912 | 0, u = $.length << 3, h = V < 56 ? 56 : 120, g = $.slice($.length - V, $.length);
      for (g.push(128), O = V + 1; O < h; O++)
        g.push(0);
      return g.push(x >>> 24 & 255), g.push(x >>> 16 & 255), g.push(x >>> 8 & 255), g.push(x >>> 0 & 255), g.push(u >>> 24 & 255), g.push(u >>> 16 & 255), g.push(u >>> 8 & 255), g.push(u >>> 0 & 255), C(g), [
        U >>> 24 & 255,
        U >>> 16 & 255,
        U >>> 8 & 255,
        U >>> 0 & 255,
        G >>> 24 & 255,
        G >>> 16 & 255,
        G >>> 8 & 255,
        G >>> 0 & 255,
        D >>> 24 & 255,
        D >>> 16 & 255,
        D >>> 8 & 255,
        D >>> 0 & 255,
        Z >>> 24 & 255,
        Z >>> 16 & 255,
        Z >>> 8 & 255,
        Z >>> 0 & 255,
        J >>> 24 & 255,
        J >>> 16 & 255,
        J >>> 8 & 255,
        J >>> 0 & 255,
        te >>> 24 & 255,
        te >>> 16 & 255,
        te >>> 8 & 255,
        te >>> 0 & 255,
        ue >>> 24 & 255,
        ue >>> 16 & 255,
        ue >>> 8 & 255,
        ue >>> 0 & 255,
        he >>> 24 & 255,
        he >>> 16 & 255,
        he >>> 8 & 255,
        he >>> 0 & 255
      ];
    }
    function a($, P, U) {
      $ = $.length <= 64 ? $ : c($);
      const G = 64 + P.length + 4, D = new Array(G), Z = new Array(64);
      let J, te = [];
      for (J = 0; J < 64; J++)
        D[J] = 54;
      for (J = 0; J < $.length; J++)
        D[J] ^= $[J];
      for (J = 0; J < P.length; J++)
        D[64 + J] = P[J];
      for (J = G - 4; J < G; J++)
        D[J] = 0;
      for (J = 0; J < 64; J++)
        Z[J] = 92;
      for (J = 0; J < $.length; J++)
        Z[J] ^= $[J];
      function ue() {
        for (let he = G - 1; he >= G - 4; he--) {
          if (D[he]++, D[he] <= 255)
            return;
          D[he] = 0;
        }
      }
      for (; U >= 32; )
        ue(), te = te.concat(c(Z.concat(c(D)))), U -= 32;
      return U > 0 && (ue(), te = te.concat(c(Z.concat(c(D))).slice(0, U))), te;
    }
    function d($, P, U, G, D) {
      let Z;
      for (I($, (2 * U - 1) * 16, D, 0, 16), Z = 0; Z < 2 * U; Z++)
        M($, Z * 16, D, 16), w(D, G), I(D, 0, $, P + Z * 16, 16);
      for (Z = 0; Z < U; Z++)
        I($, P + Z * 2 * 16, $, Z * 16, 16);
      for (Z = 0; Z < U; Z++)
        I($, P + (Z * 2 + 1) * 16, $, (Z + U) * 16, 16);
    }
    function p($, P) {
      return $ << P | $ >>> 32 - P;
    }
    function w($, P) {
      I($, 0, P, 0, 16);
      for (let U = 8; U > 0; U -= 2)
        P[4] ^= p(P[0] + P[12], 7), P[8] ^= p(P[4] + P[0], 9), P[12] ^= p(P[8] + P[4], 13), P[0] ^= p(P[12] + P[8], 18), P[9] ^= p(P[5] + P[1], 7), P[13] ^= p(P[9] + P[5], 9), P[1] ^= p(P[13] + P[9], 13), P[5] ^= p(P[1] + P[13], 18), P[14] ^= p(P[10] + P[6], 7), P[2] ^= p(P[14] + P[10], 9), P[6] ^= p(P[2] + P[14], 13), P[10] ^= p(P[6] + P[2], 18), P[3] ^= p(P[15] + P[11], 7), P[7] ^= p(P[3] + P[15], 9), P[11] ^= p(P[7] + P[3], 13), P[15] ^= p(P[11] + P[7], 18), P[1] ^= p(P[0] + P[3], 7), P[2] ^= p(P[1] + P[0], 9), P[3] ^= p(P[2] + P[1], 13), P[0] ^= p(P[3] + P[2], 18), P[6] ^= p(P[5] + P[4], 7), P[7] ^= p(P[6] + P[5], 9), P[4] ^= p(P[7] + P[6], 13), P[5] ^= p(P[4] + P[7], 18), P[11] ^= p(P[10] + P[9], 7), P[8] ^= p(P[11] + P[10], 9), P[9] ^= p(P[8] + P[11], 13), P[10] ^= p(P[9] + P[8], 18), P[12] ^= p(P[15] + P[14], 7), P[13] ^= p(P[12] + P[15], 9), P[14] ^= p(P[13] + P[12], 13), P[15] ^= p(P[14] + P[13], 18);
      for (let U = 0; U < 16; ++U)
        $[U] += P[U];
    }
    function M($, P, U, G) {
      for (let D = 0; D < G; D++)
        U[D] ^= $[P + D];
    }
    function I($, P, U, G, D) {
      for (; D--; )
        U[G++] = $[P++];
    }
    function B($) {
      if (!$ || typeof $.length != "number")
        return !1;
      for (let P = 0; P < $.length; P++) {
        const U = $[P];
        if (typeof U != "number" || U % 1 || U < 0 || U >= 256)
          return !1;
      }
      return !0;
    }
    function H($, P) {
      if (typeof $ != "number" || $ % 1)
        throw new Error("invalid " + P);
      return $;
    }
    function L($, P, U, G, D, Z, J) {
      if (U = H(U, "N"), G = H(G, "r"), D = H(D, "p"), Z = H(Z, "dkLen"), U === 0 || (U & U - 1) !== 0)
        throw new Error("N must be power of 2");
      if (U > 2147483647 / 128 / G)
        throw new Error("N too large");
      if (G > 2147483647 / 128 / D)
        throw new Error("r too large");
      if (!B($))
        throw new Error("password must be an array or buffer");
      if ($ = Array.prototype.slice.call($), !B(P))
        throw new Error("salt must be an array or buffer");
      P = Array.prototype.slice.call(P);
      let te = a($, P, D * 128 * G);
      const ue = new Uint32Array(D * 32 * G);
      for (let X = 0; X < ue.length; X++) {
        const S = X * 4;
        ue[X] = (te[S + 3] & 255) << 24 | (te[S + 2] & 255) << 16 | (te[S + 1] & 255) << 8 | (te[S + 0] & 255) << 0;
      }
      const he = new Uint32Array(64 * G), Se = new Uint32Array(32 * G * U), C = 32 * G, O = new Uint32Array(16), V = new Uint32Array(16), x = D * U * 2;
      let u = 0, h = null, g = !1, y = 0, m = 0, _, R;
      const b = J ? parseInt(1e3 / G) : 4294967295, l = typeof setImmediate < "u" ? setImmediate : setTimeout, v = function() {
        if (g)
          return J(new Error("cancelled"), u / x);
        let X;
        switch (y) {
          case 0:
            R = m * 32 * G, I(ue, R, he, 0, C), y = 1, _ = 0;
          case 1:
            X = U - _, X > b && (X = b);
            for (let Y = 0; Y < X; Y++)
              I(he, 0, Se, (_ + Y) * C, C), d(he, C, G, O, V);
            if (_ += X, u += X, J) {
              const Y = parseInt(1e3 * u / x);
              if (Y !== h) {
                if (g = J(null, u / x), g)
                  break;
                h = Y;
              }
            }
            if (_ < U)
              break;
            _ = 0, y = 2;
          case 2:
            X = U - _, X > b && (X = b);
            for (let Y = 0; Y < X; Y++) {
              const fe = (2 * G - 1) * 16, oe = he[fe] & U - 1;
              M(Se, oe * C, he, C), d(he, C, G, O, V);
            }
            if (_ += X, u += X, J) {
              const Y = parseInt(1e3 * u / x);
              if (Y !== h) {
                if (g = J(null, u / x), g)
                  break;
                h = Y;
              }
            }
            if (_ < U)
              break;
            if (I(he, 0, ue, R, C), m++, m < D) {
              y = 0;
              break;
            }
            te = [];
            for (let Y = 0; Y < ue.length; Y++)
              te.push(ue[Y] >> 0 & 255), te.push(ue[Y] >> 8 & 255), te.push(ue[Y] >> 16 & 255), te.push(ue[Y] >> 24 & 255);
            const S = a($, te, Z);
            return J && J(null, 1, S), S;
        }
        J && l(v);
      };
      if (!J)
        for (; ; ) {
          const X = v();
          if (X != null)
            return X;
        }
      v();
    }
    const W = {
      scrypt: function($, P, U, G, D, Z, J) {
        return new Promise(function(te, ue) {
          let he = 0;
          J && J(0), L($, P, U, G, D, Z, function(Se, C, O) {
            if (Se)
              ue(Se);
            else if (O)
              J && he !== 1 && J(1), te(new Uint8Array(O));
            else if (J && C !== he)
              return he = C, J(C);
          });
        });
      },
      syncScrypt: function($, P, U, G, D, Z) {
        return new Uint8Array(L($, P, U, G, D, Z));
      }
    };
    n.exports = W;
  })();
})(scrypt$1);
const scrypt = scrypt$1.exports, version$6 = "random/5.7.0", logger$7 = new Logger(version$6);
function getGlobal() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
let crypto$1 = anyGlobal.crypto || anyGlobal.msCrypto;
(!crypto$1 || !crypto$1.getRandomValues) && (logger$7.warn("WARNING: Missing strong random number source"), crypto$1 = {
  getRandomValues: function(n) {
    return logger$7.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "crypto.getRandomValues"
    });
  }
});
function randomBytes(n) {
  (n <= 0 || n > 1024 || n % 1 || n != n) && logger$7.throwArgumentError("invalid length", "length", n);
  const e = new Uint8Array(n);
  return crypto$1.getRandomValues(e), arrayify(e);
}
function shuffled(n) {
  n = n.slice();
  for (let e = n.length - 1; e > 0; e--) {
    const t = Math.floor(Math.random() * (e + 1)), o = n[e];
    n[e] = n[t], n[t] = o;
  }
  return n;
}
const lib_esm$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  randomBytes,
  shuffled
}, Symbol.toStringTag, { value: "Module" }));
var __awaiter$5 = globalThis && globalThis.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
const logger$6 = new Logger(version$7);
function hasMnemonic$1(n) {
  return n != null && n.mnemonic && n.mnemonic.phrase;
}
class KeystoreAccount extends Description {
  isKeystoreAccount(e) {
    return !!(e && e._isKeystoreAccount);
  }
}
function _decrypt(n, e, t) {
  if (searchPath(n, "crypto/cipher") === "aes-128-ctr") {
    const c = looseArrayify(searchPath(n, "crypto/cipherparams/iv")), a = new aes.Counter(c), d = new aes.ModeOfOperation.ctr(e, a);
    return arrayify(d.decrypt(t));
  }
  return null;
}
function _getAccount(n, e) {
  const t = looseArrayify(searchPath(n, "crypto/ciphertext"));
  if (hexlify(keccak256$1(concat([e.slice(16, 32), t]))).substring(2) !== searchPath(n, "crypto/mac").toLowerCase())
    throw new Error("invalid password");
  const c = _decrypt(n, e.slice(0, 16), t);
  c || logger$6.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "decrypt"
  });
  const a = e.slice(32, 64), d = computeAddress(c);
  if (n.address) {
    let w = n.address.toLowerCase();
    if (w.substring(0, 2) !== "0x" && (w = "0x" + w), getAddress(w) !== d)
      throw new Error("address mismatch");
  }
  const p = {
    _isKeystoreAccount: !0,
    address: d,
    privateKey: hexlify(c)
  };
  if (searchPath(n, "x-ethers/version") === "0.1") {
    const w = looseArrayify(searchPath(n, "x-ethers/mnemonicCiphertext")), M = looseArrayify(searchPath(n, "x-ethers/mnemonicCounter")), I = new aes.Counter(M), B = new aes.ModeOfOperation.ctr(a, I), H = searchPath(n, "x-ethers/path") || defaultPath, L = searchPath(n, "x-ethers/locale") || "en", W = arrayify(B.decrypt(w));
    try {
      const $ = entropyToMnemonic(W, L), P = HDNode.fromMnemonic($, null, L).derivePath(H);
      if (P.privateKey != p.privateKey)
        throw new Error("mnemonic mismatch");
      p.mnemonic = P.mnemonic;
    } catch ($) {
      if ($.code !== Logger.errors.INVALID_ARGUMENT || $.argument !== "wordlist")
        throw $;
    }
  }
  return new KeystoreAccount(p);
}
function pbkdf2Sync(n, e, t, o, c) {
  return arrayify(pbkdf2$1(n, e, t, o, c));
}
function pbkdf2(n, e, t, o, c) {
  return Promise.resolve(pbkdf2Sync(n, e, t, o, c));
}
function _computeKdfKey(n, e, t, o, c) {
  const a = getPassword(e), d = searchPath(n, "crypto/kdf");
  if (d && typeof d == "string") {
    const p = function(w, M) {
      return logger$6.throwArgumentError("invalid key-derivation function parameters", w, M);
    };
    if (d.toLowerCase() === "scrypt") {
      const w = looseArrayify(searchPath(n, "crypto/kdfparams/salt")), M = parseInt(searchPath(n, "crypto/kdfparams/n")), I = parseInt(searchPath(n, "crypto/kdfparams/r")), B = parseInt(searchPath(n, "crypto/kdfparams/p"));
      (!M || !I || !B) && p("kdf", d), (M & M - 1) !== 0 && p("N", M);
      const H = parseInt(searchPath(n, "crypto/kdfparams/dklen"));
      return H !== 32 && p("dklen", H), o(a, w, M, I, B, 64, c);
    } else if (d.toLowerCase() === "pbkdf2") {
      const w = looseArrayify(searchPath(n, "crypto/kdfparams/salt"));
      let M = null;
      const I = searchPath(n, "crypto/kdfparams/prf");
      I === "hmac-sha256" ? M = "sha256" : I === "hmac-sha512" ? M = "sha512" : p("prf", I);
      const B = parseInt(searchPath(n, "crypto/kdfparams/c")), H = parseInt(searchPath(n, "crypto/kdfparams/dklen"));
      return H !== 32 && p("dklen", H), t(a, w, B, H, M);
    }
  }
  return logger$6.throwArgumentError("unsupported key-derivation function", "kdf", d);
}
function decryptSync(n, e) {
  const t = JSON.parse(n), o = _computeKdfKey(t, e, pbkdf2Sync, scrypt.syncScrypt);
  return _getAccount(t, o);
}
function decrypt(n, e, t) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const o = JSON.parse(n), c = yield _computeKdfKey(o, e, pbkdf2, scrypt.scrypt, t);
    return _getAccount(o, c);
  });
}
function encrypt(n, e, t, o) {
  try {
    if (getAddress(n.address) !== computeAddress(n.privateKey))
      throw new Error("address/privateKey mismatch");
    if (hasMnemonic$1(n)) {
      const P = n.mnemonic;
      if (HDNode.fromMnemonic(P.phrase, null, P.locale).derivePath(P.path || defaultPath).privateKey != n.privateKey)
        throw new Error("mnemonic mismatch");
    }
  } catch (P) {
    return Promise.reject(P);
  }
  typeof t == "function" && !o && (o = t, t = {}), t || (t = {});
  const c = arrayify(n.privateKey), a = getPassword(e);
  let d = null, p = null, w = null;
  if (hasMnemonic$1(n)) {
    const P = n.mnemonic;
    d = arrayify(mnemonicToEntropy(P.phrase, P.locale || "en")), p = P.path || defaultPath, w = P.locale || "en";
  }
  let M = t.client;
  M || (M = "ethers.js");
  let I = null;
  t.salt ? I = arrayify(t.salt) : I = randomBytes(32);
  let B = null;
  if (t.iv) {
    if (B = arrayify(t.iv), B.length !== 16)
      throw new Error("invalid iv");
  } else
    B = randomBytes(16);
  let H = null;
  if (t.uuid) {
    if (H = arrayify(t.uuid), H.length !== 16)
      throw new Error("invalid uuid");
  } else
    H = randomBytes(16);
  let L = 1 << 17, W = 8, $ = 1;
  return t.scrypt && (t.scrypt.N && (L = t.scrypt.N), t.scrypt.r && (W = t.scrypt.r), t.scrypt.p && ($ = t.scrypt.p)), scrypt.scrypt(a, I, L, W, $, 64, o).then((P) => {
    P = arrayify(P);
    const U = P.slice(0, 16), G = P.slice(16, 32), D = P.slice(32, 64), Z = new aes.Counter(B), J = new aes.ModeOfOperation.ctr(U, Z), te = arrayify(J.encrypt(c)), ue = keccak256$1(concat([G, te])), he = {
      address: n.address.substring(2).toLowerCase(),
      id: uuidV4(H),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(B).substring(2)
        },
        ciphertext: hexlify(te).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(I).substring(2),
          n: L,
          dklen: 32,
          p: $,
          r: W
        },
        mac: ue.substring(2)
      }
    };
    if (d) {
      const Se = randomBytes(16), C = new aes.Counter(Se), O = new aes.ModeOfOperation.ctr(D, C), V = arrayify(O.encrypt(d)), x = new Date(), u = x.getUTCFullYear() + "-" + zpad(x.getUTCMonth() + 1, 2) + "-" + zpad(x.getUTCDate(), 2) + "T" + zpad(x.getUTCHours(), 2) + "-" + zpad(x.getUTCMinutes(), 2) + "-" + zpad(x.getUTCSeconds(), 2) + ".0Z";
      he["x-ethers"] = {
        client: M,
        gethFilename: "UTC--" + u + "--" + he.address,
        mnemonicCounter: hexlify(Se).substring(2),
        mnemonicCiphertext: hexlify(V).substring(2),
        path: p,
        locale: w,
        version: "0.1"
      };
    }
    return JSON.stringify(he);
  });
}
function decryptJsonWallet(n, e, t) {
  if (isCrowdsaleWallet(n)) {
    t && t(0);
    const o = decrypt$1(n, e);
    return t && t(1), Promise.resolve(o);
  }
  return isKeystoreWallet(n) ? decrypt(n, e, t) : Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(n, e) {
  if (isCrowdsaleWallet(n))
    return decrypt$1(n, e);
  if (isKeystoreWallet(n))
    return decryptSync(n, e);
  throw new Error("invalid JSON wallet");
}
const lib_esm$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decryptCrowdsale: decrypt$1,
  decryptKeystore: decrypt,
  decryptKeystoreSync: decryptSync,
  encryptKeystore: encrypt,
  isCrowdsaleWallet,
  isKeystoreWallet,
  getJsonWalletAddress,
  decryptJsonWallet,
  decryptJsonWalletSync
}, Symbol.toStringTag, { value: "Module" })), require$$7 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$4), require$$8 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$h), require$$9 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$k), require$$10 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$9), version$5 = "solidity/5.7.0", regexBytes = new RegExp("^bytes([0-9]+)$"), regexNumber = new RegExp("^(u?int)([0-9]*)$"), regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$"), Zeros = "0000000000000000000000000000000000000000000000000000000000000000", logger$5 = new Logger(version$5);
function _pack(n, e, t) {
  switch (n) {
    case "address":
      return t ? zeroPad(e, 32) : arrayify(e);
    case "string":
      return toUtf8Bytes(e);
    case "bytes":
      return arrayify(e);
    case "bool":
      return e = e ? "0x01" : "0x00", t ? zeroPad(e, 32) : arrayify(e);
  }
  let o = n.match(regexNumber);
  if (o) {
    let c = parseInt(o[2] || "256");
    return (o[2] && String(c) !== o[2] || c % 8 !== 0 || c === 0 || c > 256) && logger$5.throwArgumentError("invalid number type", "type", n), t && (c = 256), e = BigNumber.from(e).toTwos(c), zeroPad(e, c / 8);
  }
  if (o = n.match(regexBytes), o) {
    const c = parseInt(o[1]);
    return (String(c) !== o[1] || c === 0 || c > 32) && logger$5.throwArgumentError("invalid bytes type", "type", n), arrayify(e).byteLength !== c && logger$5.throwArgumentError(`invalid value for ${n}`, "value", e), t ? arrayify((e + Zeros).substring(0, 66)) : e;
  }
  if (o = n.match(regexArray), o && Array.isArray(e)) {
    const c = o[1];
    parseInt(o[2] || String(e.length)) != e.length && logger$5.throwArgumentError(`invalid array length for ${n}`, "value", e);
    const d = [];
    return e.forEach(function(p) {
      d.push(_pack(c, p, !0));
    }), concat(d);
  }
  return logger$5.throwArgumentError("invalid type", "type", n);
}
function pack(n, e) {
  n.length != e.length && logger$5.throwArgumentError("wrong number of values; expected ${ types.length }", "values", e);
  const t = [];
  return n.forEach(function(o, c) {
    t.push(_pack(o, e[c]));
  }), hexlify(concat(t));
}
function keccak256(n, e) {
  return keccak256$1(pack(n, e));
}
function sha256(n, e) {
  return sha256$1(pack(n, e));
}
const lib_esm$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  pack,
  keccak256,
  sha256
}, Symbol.toStringTag, { value: "Module" })), require$$11 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$3), require$$12 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$5), require$$13 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$i), require$$14 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$g), require$$15 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$8), require$$16 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$e), require$$17 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$7), version$4 = "units/5.7.0", logger$4 = new Logger(version$4), names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function commify(n) {
  const e = String(n).split(".");
  (e.length > 2 || !e[0].match(/^-?[0-9]*$/) || e[1] && !e[1].match(/^[0-9]*$/) || n === "." || n === "-.") && logger$4.throwArgumentError("invalid value", "value", n);
  let t = e[0], o = "";
  for (t.substring(0, 1) === "-" && (o = "-", t = t.substring(1)); t.substring(0, 1) === "0"; )
    t = t.substring(1);
  t === "" && (t = "0");
  let c = "";
  for (e.length === 2 && (c = "." + (e[1] || "0")); c.length > 2 && c[c.length - 1] === "0"; )
    c = c.substring(0, c.length - 1);
  const a = [];
  for (; t.length; )
    if (t.length <= 3) {
      a.unshift(t);
      break;
    } else {
      const d = t.length - 3;
      a.unshift(t.substring(d)), t = t.substring(0, d);
    }
  return o + a.join(",") + c;
}
function formatUnits(n, e) {
  if (typeof e == "string") {
    const t = names.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return formatFixed(n, e != null ? e : 18);
}
function parseUnits(n, e) {
  if (typeof n != "string" && logger$4.throwArgumentError("value must be a string", "value", n), typeof e == "string") {
    const t = names.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return parseFixed(n, e != null ? e : 18);
}
function formatEther(n) {
  return formatUnits(n, 18);
}
function parseEther(n) {
  return parseUnits(n, 18);
}
const lib_esm$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commify,
  formatUnits,
  parseUnits,
  formatEther,
  parseEther
}, Symbol.toStringTag, { value: "Module" })), require$$18 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$2), version$3 = "abstract-provider/5.7.0";
var __awaiter$4 = globalThis && globalThis.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
const logger$3 = new Logger(version$3);
class Provider$1 {
  constructor() {
    logger$3.checkAbstract(new.target, Provider$1), defineReadOnly(this, "_isProvider", !0);
  }
  getFeeData() {
    return __awaiter$4(this, void 0, void 0, function* () {
      const { block: e, gasPrice: t } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((d) => null)
      });
      let o = null, c = null, a = null;
      return e && e.baseFeePerGas && (o = e.baseFeePerGas, a = BigNumber.from("1500000000"), c = e.baseFeePerGas.mul(2).add(a)), { lastBaseFeePerGas: o, maxFeePerGas: c, maxPriorityFeePerGas: a, gasPrice: t };
    });
  }
  addListener(e, t) {
    return this.on(e, t);
  }
  removeListener(e, t) {
    return this.off(e, t);
  }
  static isProvider(e) {
    return !!(e && e._isProvider);
  }
}
const version$2 = "abstract-signer/5.7.0";
var __awaiter$3 = globalThis && globalThis.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
const logger$2 = new Logger(version$2), allowedTransactionKeys = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
], forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
class Signer {
  constructor() {
    logger$2.checkAbstract(new.target, Signer), defineReadOnly(this, "_isSigner", !0);
  }
  getBalance(e) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e);
    });
  }
  getTransactionCount(e) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e);
    });
  }
  estimateGas(e) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const t = yield resolveProperties(this.checkTransaction(e));
      return yield this.provider.estimateGas(t);
    });
  }
  call(e, t) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const o = yield resolveProperties(this.checkTransaction(e));
      return yield this.provider.call(o, t);
    });
  }
  sendTransaction(e) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const t = yield this.populateTransaction(e), o = yield this.signTransaction(t);
      return yield this.provider.sendTransaction(o);
    });
  }
  getChainId() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId;
    });
  }
  getGasPrice() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._checkProvider("getFeeData"), yield this.provider.getFeeData();
    });
  }
  resolveName(e) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._checkProvider("resolveName"), yield this.provider.resolveName(e);
    });
  }
  checkTransaction(e) {
    for (const o in e)
      allowedTransactionKeys.indexOf(o) === -1 && logger$2.throwArgumentError("invalid transaction key: " + o, "transaction", e);
    const t = shallowCopy(e);
    return t.from == null ? t.from = this.getAddress() : t.from = Promise.all([
      Promise.resolve(t.from),
      this.getAddress()
    ]).then((o) => (o[0].toLowerCase() !== o[1].toLowerCase() && logger$2.throwArgumentError("from address mismatch", "transaction", e), o[0])), t;
  }
  populateTransaction(e) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const t = yield resolveProperties(this.checkTransaction(e));
      t.to != null && (t.to = Promise.resolve(t.to).then((c) => __awaiter$3(this, void 0, void 0, function* () {
        if (c == null)
          return null;
        const a = yield this.resolveName(c);
        return a == null && logger$2.throwArgumentError("provided ENS name resolves to null", "tx.to", c), a;
      })), t.to.catch((c) => {
      }));
      const o = t.maxFeePerGas != null || t.maxPriorityFeePerGas != null;
      if (t.gasPrice != null && (t.type === 2 || o) ? logger$2.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e) : (t.type === 0 || t.type === 1) && o && logger$2.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e), (t.type === 2 || t.type == null) && t.maxFeePerGas != null && t.maxPriorityFeePerGas != null)
        t.type = 2;
      else if (t.type === 0 || t.type === 1)
        t.gasPrice == null && (t.gasPrice = this.getGasPrice());
      else {
        const c = yield this.getFeeData();
        if (t.type == null)
          if (c.maxFeePerGas != null && c.maxPriorityFeePerGas != null)
            if (t.type = 2, t.gasPrice != null) {
              const a = t.gasPrice;
              delete t.gasPrice, t.maxFeePerGas = a, t.maxPriorityFeePerGas = a;
            } else
              t.maxFeePerGas == null && (t.maxFeePerGas = c.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = c.maxPriorityFeePerGas);
          else
            c.gasPrice != null ? (o && logger$2.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "populateTransaction"
            }), t.gasPrice == null && (t.gasPrice = c.gasPrice), t.type = 0) : logger$2.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
        else
          t.type === 2 && (t.maxFeePerGas == null && (t.maxFeePerGas = c.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = c.maxPriorityFeePerGas));
      }
      return t.nonce == null && (t.nonce = this.getTransactionCount("pending")), t.gasLimit == null && (t.gasLimit = this.estimateGas(t).catch((c) => {
        if (forwardErrors.indexOf(c.code) >= 0)
          throw c;
        return logger$2.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
          error: c,
          tx: t
        });
      })), t.chainId == null ? t.chainId = this.getChainId() : t.chainId = Promise.all([
        Promise.resolve(t.chainId),
        this.getChainId()
      ]).then((c) => (c[1] !== 0 && c[0] !== c[1] && logger$2.throwArgumentError("chainId address mismatch", "transaction", e), c[0])), yield resolveProperties(t);
    });
  }
  _checkProvider(e) {
    this.provider || logger$2.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: e || "_checkProvider"
    });
  }
  static isSigner(e) {
    return !!(e && e._isSigner);
  }
}
const version$1 = "wallet/5.7.0";
var __awaiter$2 = globalThis && globalThis.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
const logger$1 = new Logger(version$1);
function isAccount(n) {
  return n != null && isHexString(n.privateKey, 32) && n.address != null;
}
function hasMnemonic(n) {
  const e = n.mnemonic;
  return e && e.phrase;
}
class Wallet$1 extends Signer {
  constructor(e, t) {
    if (super(), isAccount(e)) {
      const o = new SigningKey(e.privateKey);
      if (defineReadOnly(this, "_signingKey", () => o), defineReadOnly(this, "address", computeAddress(this.publicKey)), this.address !== getAddress(e.address) && logger$1.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), hasMnemonic(e)) {
        const c = e.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: c.phrase,
          path: c.path || defaultPath,
          locale: c.locale || "en"
        }));
        const a = this.mnemonic, d = HDNode.fromMnemonic(a.phrase, null, a.locale).derivePath(a.path);
        computeAddress(d.privateKey) !== this.address && logger$1.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
      } else
        defineReadOnly(this, "_mnemonic", () => null);
    } else {
      if (SigningKey.isSigningKey(e))
        e.curve !== "secp256k1" && logger$1.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), defineReadOnly(this, "_signingKey", () => e);
      else {
        typeof e == "string" && e.match(/^[0-9a-f]*$/i) && e.length === 64 && (e = "0x" + e);
        const o = new SigningKey(e);
        defineReadOnly(this, "_signingKey", () => o);
      }
      defineReadOnly(this, "_mnemonic", () => null), defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    t && !Provider$1.isProvider(t) && logger$1.throwArgumentError("invalid provider", "provider", t), defineReadOnly(this, "provider", t || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(e) {
    return new Wallet$1(this, e);
  }
  signTransaction(e) {
    return resolveProperties(e).then((t) => {
      t.from != null && (getAddress(t.from) !== this.address && logger$1.throwArgumentError("transaction from address mismatch", "transaction.from", e.from), delete t.from);
      const o = this._signingKey().signDigest(keccak256$1(serialize(t)));
      return serialize(t, o);
    });
  }
  signMessage(e) {
    return __awaiter$2(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(e)));
    });
  }
  _signTypedData(e, t, o) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const c = yield TypedDataEncoder.resolveNames(e, t, o, (a) => (this.provider == null && logger$1.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName",
        value: a
      }), this.provider.resolveName(a)));
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(c.domain, t, c.value)));
    });
  }
  encrypt(e, t, o) {
    if (typeof t == "function" && !o && (o = t, t = {}), o && typeof o != "function")
      throw new Error("invalid callback");
    return t || (t = {}), encrypt(this, e, t, o);
  }
  static createRandom(e) {
    let t = randomBytes(16);
    e || (e = {}), e.extraEntropy && (t = arrayify(hexDataSlice(keccak256$1(concat([t, e.extraEntropy])), 0, 16)));
    const o = entropyToMnemonic(t, e.locale);
    return Wallet$1.fromMnemonic(o, e.path, e.locale);
  }
  static fromEncryptedJson(e, t, o) {
    return decryptJsonWallet(e, t, o).then((c) => new Wallet$1(c));
  }
  static fromEncryptedJsonSync(e, t) {
    return new Wallet$1(decryptJsonWalletSync(e, t));
  }
  static fromMnemonic(e, t, o) {
    return t || (t = defaultPath), new Wallet$1(HDNode.fromMnemonic(e, null, o).derivePath(t));
  }
}
function verifyMessage(n, e) {
  return recoverAddress(hashMessage(n), e);
}
function verifyTypedData(n, e, t, o) {
  return recoverAddress(TypedDataEncoder.hash(n, e, t), o);
}
const lib_esm$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Wallet: Wallet$1,
  verifyMessage,
  verifyTypedData
}, Symbol.toStringTag, { value: "Module" })), require$$19 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$1), version = "web/5.7.1";
var __awaiter$1 = globalThis && globalThis.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
function getUrl(n, e) {
  return __awaiter$1(this, void 0, void 0, function* () {
    e == null && (e = {});
    const t = {
      method: e.method || "GET",
      headers: e.headers || {},
      body: e.body || void 0
    };
    if (e.skipFetchSetup !== !0 && (t.mode = "cors", t.cache = "no-cache", t.credentials = "same-origin", t.redirect = "follow", t.referrer = "client"), e.fetchOptions != null) {
      const d = e.fetchOptions;
      d.mode && (t.mode = d.mode), d.cache && (t.cache = d.cache), d.credentials && (t.credentials = d.credentials), d.redirect && (t.redirect = d.redirect), d.referrer && (t.referrer = d.referrer);
    }
    const o = yield fetch(n, t), c = yield o.arrayBuffer(), a = {};
    return o.headers.forEach ? o.headers.forEach((d, p) => {
      a[p.toLowerCase()] = d;
    }) : o.headers.keys().forEach((d) => {
      a[d.toLowerCase()] = o.headers.get(d);
    }), {
      headers: a,
      statusCode: o.status,
      statusMessage: o.statusText,
      body: arrayify(new Uint8Array(c))
    };
  });
}
var __awaiter = globalThis && globalThis.__awaiter || function(n, e, t, o) {
  function c(a) {
    return a instanceof t ? a : new t(function(d) {
      d(a);
    });
  }
  return new (t || (t = Promise))(function(a, d) {
    function p(I) {
      try {
        M(o.next(I));
      } catch (B) {
        d(B);
      }
    }
    function w(I) {
      try {
        M(o.throw(I));
      } catch (B) {
        d(B);
      }
    }
    function M(I) {
      I.done ? a(I.value) : c(I.value).then(p, w);
    }
    M((o = o.apply(n, e || [])).next());
  });
};
const logger = new Logger(version);
function staller(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function bodyify(n, e) {
  if (n == null)
    return null;
  if (typeof n == "string")
    return n;
  if (isBytesLike(n)) {
    if (e && (e.split("/")[0] === "text" || e.split(";")[0].trim() === "application/json"))
      try {
        return toUtf8String(n);
      } catch {
      }
    return hexlify(n);
  }
  return n;
}
function unpercent(n) {
  return toUtf8Bytes(n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16))));
}
function _fetchData(n, e, t) {
  const o = typeof n == "object" && n.throttleLimit != null ? n.throttleLimit : 12;
  logger.assertArgument(o > 0 && o % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", o);
  const c = typeof n == "object" ? n.throttleCallback : null, a = typeof n == "object" && typeof n.throttleSlotInterval == "number" ? n.throttleSlotInterval : 100;
  logger.assertArgument(a > 0 && a % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", a);
  const d = typeof n == "object" ? !!n.errorPassThrough : !1, p = {};
  let w = null;
  const M = {
    method: "GET"
  };
  let I = !1, B = 2 * 60 * 1e3;
  if (typeof n == "string")
    w = n;
  else if (typeof n == "object") {
    if ((n == null || n.url == null) && logger.throwArgumentError("missing URL", "connection.url", n), w = n.url, typeof n.timeout == "number" && n.timeout > 0 && (B = n.timeout), n.headers)
      for (const U in n.headers)
        p[U.toLowerCase()] = { key: U, value: String(n.headers[U]) }, ["if-none-match", "if-modified-since"].indexOf(U.toLowerCase()) >= 0 && (I = !0);
    if (M.allowGzip = !!n.allowGzip, n.user != null && n.password != null) {
      w.substring(0, 6) !== "https:" && n.allowInsecureAuthentication !== !0 && logger.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url: w, user: n.user, password: "[REDACTED]" });
      const U = n.user + ":" + n.password;
      p.authorization = {
        key: "Authorization",
        value: "Basic " + encode(toUtf8Bytes(U))
      };
    }
    n.skipFetchSetup != null && (M.skipFetchSetup = !!n.skipFetchSetup), n.fetchOptions != null && (M.fetchOptions = shallowCopy(n.fetchOptions));
  }
  const H = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), L = w ? w.match(H) : null;
  if (L)
    try {
      const U = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": L[1] || "text/plain" },
        body: L[2] ? decode(L[3]) : unpercent(L[3])
      };
      let G = U.body;
      return t && (G = t(U.body, U)), Promise.resolve(G);
    } catch (U) {
      logger.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(L[1], L[2]),
        error: U,
        requestBody: null,
        requestMethod: "GET",
        url: w
      });
    }
  e && (M.method = "POST", M.body = e, p["content-type"] == null && (p["content-type"] = { key: "Content-Type", value: "application/octet-stream" }), p["content-length"] == null && (p["content-length"] = { key: "Content-Length", value: String(e.length) }));
  const W = {};
  Object.keys(p).forEach((U) => {
    const G = p[U];
    W[G.key] = G.value;
  }), M.headers = W;
  const $ = function() {
    let U = null;
    return { promise: new Promise(function(Z, J) {
      B && (U = setTimeout(() => {
        U != null && (U = null, J(logger.makeError("timeout", Logger.errors.TIMEOUT, {
          requestBody: bodyify(M.body, W["content-type"]),
          requestMethod: M.method,
          timeout: B,
          url: w
        })));
      }, B));
    }), cancel: function() {
      U != null && (clearTimeout(U), U = null);
    } };
  }(), P = function() {
    return __awaiter(this, void 0, void 0, function* () {
      for (let U = 0; U < o; U++) {
        let G = null;
        try {
          if (G = yield getUrl(w, M), U < o) {
            if (G.statusCode === 301 || G.statusCode === 302) {
              const Z = G.headers.location || "";
              if (M.method === "GET" && Z.match(/^https:/)) {
                w = G.headers.location;
                continue;
              }
            } else if (G.statusCode === 429) {
              let Z = !0;
              if (c && (Z = yield c(U, w)), Z) {
                let J = 0;
                const te = G.headers["retry-after"];
                typeof te == "string" && te.match(/^[1-9][0-9]*$/) ? J = parseInt(te) * 1e3 : J = a * parseInt(String(Math.random() * Math.pow(2, U))), yield staller(J);
                continue;
              }
            }
          }
        } catch (Z) {
          G = Z.response, G == null && ($.cancel(), logger.throwError("missing response", Logger.errors.SERVER_ERROR, {
            requestBody: bodyify(M.body, W["content-type"]),
            requestMethod: M.method,
            serverError: Z,
            url: w
          }));
        }
        let D = G.body;
        if (I && G.statusCode === 304 ? D = null : !d && (G.statusCode < 200 || G.statusCode >= 300) && ($.cancel(), logger.throwError("bad response", Logger.errors.SERVER_ERROR, {
          status: G.statusCode,
          headers: G.headers,
          body: bodyify(D, G.headers ? G.headers["content-type"] : null),
          requestBody: bodyify(M.body, W["content-type"]),
          requestMethod: M.method,
          url: w
        })), t)
          try {
            const Z = yield t(D, G);
            return $.cancel(), Z;
          } catch (Z) {
            if (Z.throttleRetry && U < o) {
              let J = !0;
              if (c && (J = yield c(U, w)), J) {
                const te = a * parseInt(String(Math.random() * Math.pow(2, U)));
                yield staller(te);
                continue;
              }
            }
            $.cancel(), logger.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(D, G.headers ? G.headers["content-type"] : null),
              error: Z,
              requestBody: bodyify(M.body, W["content-type"]),
              requestMethod: M.method,
              url: w
            });
          }
        return $.cancel(), D;
      }
      return logger.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(M.body, W["content-type"]),
        requestMethod: M.method,
        url: w
      });
    });
  }();
  return Promise.race([$.promise, P]);
}
function fetchJson(n, e, t) {
  let o = (a, d) => {
    let p = null;
    if (a != null)
      try {
        p = JSON.parse(toUtf8String(a));
      } catch (w) {
        logger.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: a,
          error: w
        });
      }
    return t && (p = t(p, d)), p;
  }, c = null;
  if (e != null) {
    c = toUtf8Bytes(e);
    const a = typeof n == "string" ? { url: n } : shallowCopy(n);
    a.headers ? Object.keys(a.headers).filter((p) => p.toLowerCase() === "content-type").length !== 0 || (a.headers = shallowCopy(a.headers), a.headers["content-type"] = "application/json") : a.headers = { "content-type": "application/json" }, n = a;
  }
  return _fetchData(n, c, o);
}
function poll(n, e) {
  return e || (e = {}), e = shallowCopy(e), e.floor == null && (e.floor = 0), e.ceiling == null && (e.ceiling = 1e4), e.interval == null && (e.interval = 250), new Promise(function(t, o) {
    let c = null, a = !1;
    const d = () => a ? !1 : (a = !0, c && clearTimeout(c), !0);
    e.timeout && (c = setTimeout(() => {
      d() && o(new Error("timeout"));
    }, e.timeout));
    const p = e.retryLimit;
    let w = 0;
    function M() {
      return n().then(function(I) {
        if (I !== void 0)
          d() && t(I);
        else if (e.oncePoll)
          e.oncePoll.once("poll", M);
        else if (e.onceBlock)
          e.onceBlock.once("block", M);
        else if (!a) {
          if (w++, w > p) {
            d() && o(new Error("retry limit reached"));
            return;
          }
          let B = e.interval * parseInt(String(Math.random() * Math.pow(2, w)));
          B < e.floor && (B = e.floor), B > e.ceiling && (B = e.ceiling), setTimeout(M, B);
        }
        return null;
      }, function(I) {
        d() && o(I);
      });
    }
    M();
  });
}
const lib_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _fetchData,
  fetchJson,
  poll
}, Symbol.toStringTag, { value: "Module" })), require$$20 = /* @__PURE__ */ getAugmentedNamespace(lib_esm);
(function(n) {
  var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(O, V, x, u) {
    u === void 0 && (u = x), Object.defineProperty(O, u, { enumerable: !0, get: function() {
      return V[x];
    } });
  } : function(O, V, x, u) {
    u === void 0 && (u = x), O[u] = V[x];
  }), t = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(O, V) {
    Object.defineProperty(O, "default", { enumerable: !0, value: V });
  } : function(O, V) {
    O.default = V;
  }), o = commonjsGlobal && commonjsGlobal.__importStar || function(O) {
    if (O && O.__esModule)
      return O;
    var V = {};
    if (O != null)
      for (var x in O)
        x !== "default" && Object.prototype.hasOwnProperty.call(O, x) && e(V, O, x);
    return t(V, O), V;
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), n.formatBytes32String = n.Utf8ErrorFuncs = n.toUtf8String = n.toUtf8CodePoints = n.toUtf8Bytes = n._toEscapedUtf8String = n.nameprep = n.hexDataSlice = n.hexDataLength = n.hexZeroPad = n.hexValue = n.hexStripZeros = n.hexConcat = n.isHexString = n.hexlify = n.base64 = n.base58 = n.TransactionDescription = n.LogDescription = n.Interface = n.SigningKey = n.HDNode = n.defaultPath = n.isBytesLike = n.isBytes = n.zeroPad = n.stripZeros = n.concat = n.arrayify = n.shallowCopy = n.resolveProperties = n.getStatic = n.defineReadOnly = n.deepCopy = n.checkProperties = n.poll = n.fetchJson = n._fetchData = n.RLP = n.Logger = n.checkResultErrors = n.FormatTypes = n.ParamType = n.FunctionFragment = n.EventFragment = n.ErrorFragment = n.ConstructorFragment = n.Fragment = n.defaultAbiCoder = n.AbiCoder = void 0, n.Indexed = n.Utf8ErrorReason = n.UnicodeNormalizationForm = n.SupportedAlgorithm = n.mnemonicToSeed = n.isValidMnemonic = n.entropyToMnemonic = n.mnemonicToEntropy = n.getAccountPath = n.verifyTypedData = n.verifyMessage = n.recoverPublicKey = n.computePublicKey = n.recoverAddress = n.computeAddress = n.getJsonWalletAddress = n.TransactionTypes = n.serializeTransaction = n.parseTransaction = n.accessListify = n.joinSignature = n.splitSignature = n.soliditySha256 = n.solidityKeccak256 = n.solidityPack = n.shuffled = n.randomBytes = n.sha512 = n.sha256 = n.ripemd160 = n.keccak256 = n.computeHmac = n.commify = n.parseUnits = n.formatUnits = n.parseEther = n.formatEther = n.isAddress = n.getCreate2Address = n.getContractAddress = n.getIcapAddress = n.getAddress = n._TypedDataEncoder = n.id = n.isValidName = n.namehash = n.hashMessage = n.dnsEncode = n.parseBytes32String = void 0;
  var c = require$$0;
  Object.defineProperty(n, "AbiCoder", { enumerable: !0, get: function() {
    return c.AbiCoder;
  } }), Object.defineProperty(n, "checkResultErrors", { enumerable: !0, get: function() {
    return c.checkResultErrors;
  } }), Object.defineProperty(n, "ConstructorFragment", { enumerable: !0, get: function() {
    return c.ConstructorFragment;
  } }), Object.defineProperty(n, "defaultAbiCoder", { enumerable: !0, get: function() {
    return c.defaultAbiCoder;
  } }), Object.defineProperty(n, "ErrorFragment", { enumerable: !0, get: function() {
    return c.ErrorFragment;
  } }), Object.defineProperty(n, "EventFragment", { enumerable: !0, get: function() {
    return c.EventFragment;
  } }), Object.defineProperty(n, "FormatTypes", { enumerable: !0, get: function() {
    return c.FormatTypes;
  } }), Object.defineProperty(n, "Fragment", { enumerable: !0, get: function() {
    return c.Fragment;
  } }), Object.defineProperty(n, "FunctionFragment", { enumerable: !0, get: function() {
    return c.FunctionFragment;
  } }), Object.defineProperty(n, "Indexed", { enumerable: !0, get: function() {
    return c.Indexed;
  } }), Object.defineProperty(n, "Interface", { enumerable: !0, get: function() {
    return c.Interface;
  } }), Object.defineProperty(n, "LogDescription", { enumerable: !0, get: function() {
    return c.LogDescription;
  } }), Object.defineProperty(n, "ParamType", { enumerable: !0, get: function() {
    return c.ParamType;
  } }), Object.defineProperty(n, "TransactionDescription", { enumerable: !0, get: function() {
    return c.TransactionDescription;
  } });
  var a = require$$1;
  Object.defineProperty(n, "getAddress", { enumerable: !0, get: function() {
    return a.getAddress;
  } }), Object.defineProperty(n, "getCreate2Address", { enumerable: !0, get: function() {
    return a.getCreate2Address;
  } }), Object.defineProperty(n, "getContractAddress", { enumerable: !0, get: function() {
    return a.getContractAddress;
  } }), Object.defineProperty(n, "getIcapAddress", { enumerable: !0, get: function() {
    return a.getIcapAddress;
  } }), Object.defineProperty(n, "isAddress", { enumerable: !0, get: function() {
    return a.isAddress;
  } });
  var d = o(require$$2);
  n.base64 = d;
  var p = require$$3;
  Object.defineProperty(n, "base58", { enumerable: !0, get: function() {
    return p.Base58;
  } });
  var w = require$$4;
  Object.defineProperty(n, "arrayify", { enumerable: !0, get: function() {
    return w.arrayify;
  } }), Object.defineProperty(n, "concat", { enumerable: !0, get: function() {
    return w.concat;
  } }), Object.defineProperty(n, "hexConcat", { enumerable: !0, get: function() {
    return w.hexConcat;
  } }), Object.defineProperty(n, "hexDataSlice", { enumerable: !0, get: function() {
    return w.hexDataSlice;
  } }), Object.defineProperty(n, "hexDataLength", { enumerable: !0, get: function() {
    return w.hexDataLength;
  } }), Object.defineProperty(n, "hexlify", { enumerable: !0, get: function() {
    return w.hexlify;
  } }), Object.defineProperty(n, "hexStripZeros", { enumerable: !0, get: function() {
    return w.hexStripZeros;
  } }), Object.defineProperty(n, "hexValue", { enumerable: !0, get: function() {
    return w.hexValue;
  } }), Object.defineProperty(n, "hexZeroPad", { enumerable: !0, get: function() {
    return w.hexZeroPad;
  } }), Object.defineProperty(n, "isBytes", { enumerable: !0, get: function() {
    return w.isBytes;
  } }), Object.defineProperty(n, "isBytesLike", { enumerable: !0, get: function() {
    return w.isBytesLike;
  } }), Object.defineProperty(n, "isHexString", { enumerable: !0, get: function() {
    return w.isHexString;
  } }), Object.defineProperty(n, "joinSignature", { enumerable: !0, get: function() {
    return w.joinSignature;
  } }), Object.defineProperty(n, "zeroPad", { enumerable: !0, get: function() {
    return w.zeroPad;
  } }), Object.defineProperty(n, "splitSignature", { enumerable: !0, get: function() {
    return w.splitSignature;
  } }), Object.defineProperty(n, "stripZeros", { enumerable: !0, get: function() {
    return w.stripZeros;
  } });
  var M = require$$5;
  Object.defineProperty(n, "_TypedDataEncoder", { enumerable: !0, get: function() {
    return M._TypedDataEncoder;
  } }), Object.defineProperty(n, "dnsEncode", { enumerable: !0, get: function() {
    return M.dnsEncode;
  } }), Object.defineProperty(n, "hashMessage", { enumerable: !0, get: function() {
    return M.hashMessage;
  } }), Object.defineProperty(n, "id", { enumerable: !0, get: function() {
    return M.id;
  } }), Object.defineProperty(n, "isValidName", { enumerable: !0, get: function() {
    return M.isValidName;
  } }), Object.defineProperty(n, "namehash", { enumerable: !0, get: function() {
    return M.namehash;
  } });
  var I = require$$6;
  Object.defineProperty(n, "defaultPath", { enumerable: !0, get: function() {
    return I.defaultPath;
  } }), Object.defineProperty(n, "entropyToMnemonic", { enumerable: !0, get: function() {
    return I.entropyToMnemonic;
  } }), Object.defineProperty(n, "getAccountPath", { enumerable: !0, get: function() {
    return I.getAccountPath;
  } }), Object.defineProperty(n, "HDNode", { enumerable: !0, get: function() {
    return I.HDNode;
  } }), Object.defineProperty(n, "isValidMnemonic", { enumerable: !0, get: function() {
    return I.isValidMnemonic;
  } }), Object.defineProperty(n, "mnemonicToEntropy", { enumerable: !0, get: function() {
    return I.mnemonicToEntropy;
  } }), Object.defineProperty(n, "mnemonicToSeed", { enumerable: !0, get: function() {
    return I.mnemonicToSeed;
  } });
  var B = require$$7;
  Object.defineProperty(n, "getJsonWalletAddress", { enumerable: !0, get: function() {
    return B.getJsonWalletAddress;
  } });
  var H = require$$8;
  Object.defineProperty(n, "keccak256", { enumerable: !0, get: function() {
    return H.keccak256;
  } });
  var L = require$$9;
  Object.defineProperty(n, "Logger", { enumerable: !0, get: function() {
    return L.Logger;
  } });
  var W = require$$10;
  Object.defineProperty(n, "computeHmac", { enumerable: !0, get: function() {
    return W.computeHmac;
  } }), Object.defineProperty(n, "ripemd160", { enumerable: !0, get: function() {
    return W.ripemd160;
  } }), Object.defineProperty(n, "sha256", { enumerable: !0, get: function() {
    return W.sha256;
  } }), Object.defineProperty(n, "sha512", { enumerable: !0, get: function() {
    return W.sha512;
  } });
  var $ = require$$11;
  Object.defineProperty(n, "solidityKeccak256", { enumerable: !0, get: function() {
    return $.keccak256;
  } }), Object.defineProperty(n, "solidityPack", { enumerable: !0, get: function() {
    return $.pack;
  } }), Object.defineProperty(n, "soliditySha256", { enumerable: !0, get: function() {
    return $.sha256;
  } });
  var P = require$$12;
  Object.defineProperty(n, "randomBytes", { enumerable: !0, get: function() {
    return P.randomBytes;
  } }), Object.defineProperty(n, "shuffled", { enumerable: !0, get: function() {
    return P.shuffled;
  } });
  var U = require$$13;
  Object.defineProperty(n, "checkProperties", { enumerable: !0, get: function() {
    return U.checkProperties;
  } }), Object.defineProperty(n, "deepCopy", { enumerable: !0, get: function() {
    return U.deepCopy;
  } }), Object.defineProperty(n, "defineReadOnly", { enumerable: !0, get: function() {
    return U.defineReadOnly;
  } }), Object.defineProperty(n, "getStatic", { enumerable: !0, get: function() {
    return U.getStatic;
  } }), Object.defineProperty(n, "resolveProperties", { enumerable: !0, get: function() {
    return U.resolveProperties;
  } }), Object.defineProperty(n, "shallowCopy", { enumerable: !0, get: function() {
    return U.shallowCopy;
  } });
  var G = o(require$$14);
  n.RLP = G;
  var D = require$$15;
  Object.defineProperty(n, "computePublicKey", { enumerable: !0, get: function() {
    return D.computePublicKey;
  } }), Object.defineProperty(n, "recoverPublicKey", { enumerable: !0, get: function() {
    return D.recoverPublicKey;
  } }), Object.defineProperty(n, "SigningKey", { enumerable: !0, get: function() {
    return D.SigningKey;
  } });
  var Z = require$$16;
  Object.defineProperty(n, "formatBytes32String", { enumerable: !0, get: function() {
    return Z.formatBytes32String;
  } }), Object.defineProperty(n, "nameprep", { enumerable: !0, get: function() {
    return Z.nameprep;
  } }), Object.defineProperty(n, "parseBytes32String", { enumerable: !0, get: function() {
    return Z.parseBytes32String;
  } }), Object.defineProperty(n, "_toEscapedUtf8String", { enumerable: !0, get: function() {
    return Z._toEscapedUtf8String;
  } }), Object.defineProperty(n, "toUtf8Bytes", { enumerable: !0, get: function() {
    return Z.toUtf8Bytes;
  } }), Object.defineProperty(n, "toUtf8CodePoints", { enumerable: !0, get: function() {
    return Z.toUtf8CodePoints;
  } }), Object.defineProperty(n, "toUtf8String", { enumerable: !0, get: function() {
    return Z.toUtf8String;
  } }), Object.defineProperty(n, "Utf8ErrorFuncs", { enumerable: !0, get: function() {
    return Z.Utf8ErrorFuncs;
  } });
  var J = require$$17;
  Object.defineProperty(n, "accessListify", { enumerable: !0, get: function() {
    return J.accessListify;
  } }), Object.defineProperty(n, "computeAddress", { enumerable: !0, get: function() {
    return J.computeAddress;
  } }), Object.defineProperty(n, "parseTransaction", { enumerable: !0, get: function() {
    return J.parse;
  } }), Object.defineProperty(n, "recoverAddress", { enumerable: !0, get: function() {
    return J.recoverAddress;
  } }), Object.defineProperty(n, "serializeTransaction", { enumerable: !0, get: function() {
    return J.serialize;
  } }), Object.defineProperty(n, "TransactionTypes", { enumerable: !0, get: function() {
    return J.TransactionTypes;
  } });
  var te = require$$18;
  Object.defineProperty(n, "commify", { enumerable: !0, get: function() {
    return te.commify;
  } }), Object.defineProperty(n, "formatEther", { enumerable: !0, get: function() {
    return te.formatEther;
  } }), Object.defineProperty(n, "parseEther", { enumerable: !0, get: function() {
    return te.parseEther;
  } }), Object.defineProperty(n, "formatUnits", { enumerable: !0, get: function() {
    return te.formatUnits;
  } }), Object.defineProperty(n, "parseUnits", { enumerable: !0, get: function() {
    return te.parseUnits;
  } });
  var ue = require$$19;
  Object.defineProperty(n, "verifyMessage", { enumerable: !0, get: function() {
    return ue.verifyMessage;
  } }), Object.defineProperty(n, "verifyTypedData", { enumerable: !0, get: function() {
    return ue.verifyTypedData;
  } });
  var he = require$$20;
  Object.defineProperty(n, "_fetchData", { enumerable: !0, get: function() {
    return he._fetchData;
  } }), Object.defineProperty(n, "fetchJson", { enumerable: !0, get: function() {
    return he.fetchJson;
  } }), Object.defineProperty(n, "poll", { enumerable: !0, get: function() {
    return he.poll;
  } });
  var Se = require$$10;
  Object.defineProperty(n, "SupportedAlgorithm", { enumerable: !0, get: function() {
    return Se.SupportedAlgorithm;
  } });
  var C = require$$16;
  Object.defineProperty(n, "UnicodeNormalizationForm", { enumerable: !0, get: function() {
    return C.UnicodeNormalizationForm;
  } }), Object.defineProperty(n, "Utf8ErrorReason", { enumerable: !0, get: function() {
    return C.Utf8ErrorReason;
  } });
})(utils$a);
Object.defineProperty(SolanaProvider$1, "__esModule", { value: !0 });
SolanaProvider$1.SolanaProvider = void 0;
const face_types_1$2 = dist, web3_js_1 = require$$1$1, utils_1 = utils$a;
class SolanaProvider {
  constructor(e) {
    this.internal = e;
  }
  async getPublicKeys() {
    return (await this.internal.getAddresses(face_types_1$2.Blockchain.SOLANA)).map((t) => new web3_js_1.PublicKey(utils_1.base58.decode(t)));
  }
  async signAndSendTransaction(e) {
    const t = {
      serializedHex: e.serialize({
        requireAllSignatures: !1,
        verifySignatures: !1
      }).toString("hex")
    };
    return await this.internal.sendRpc({
      method: "solana_sendTransaction",
      params: [t]
    });
  }
}
SolanaProvider$1.SolanaProvider = SolanaProvider;
Object.defineProperty(Solana$1, "__esModule", { value: !0 });
Solana$1.Solana = void 0;
const SolanaProvider_1 = SolanaProvider$1;
class Solana {
  constructor(e) {
    this.internal = e;
  }
  getProvider() {
    return new SolanaProvider_1.SolanaProvider(this.internal);
  }
}
Solana$1.Solana = Solana;
var internal = {}, iframe = {};
Object.defineProperty(iframe, "__esModule", { value: !0 });
iframe.Iframe = void 0;
const face_types_1$1 = dist, overlayStyles = {
  display: "none",
  position: "fixed",
  top: "0",
  right: "0",
  width: "100%",
  height: "100%",
  borderRadius: "0",
  border: "none",
  zIndex: "2147483647"
};
function applyOverlayStyles(n) {
  for (const [e, t] of Object.entries(overlayStyles))
    n.style[e] = t;
}
class Ready {
  constructor() {
    this._isCompleted = !1, this._eventListeners = Array(), this.complete = () => {
      this._isCompleted = !0, this._eventListeners.forEach((e) => e());
    }, this.add = (e) => {
      this._eventListeners.push(e);
    }, this.isCompleted = () => this._isCompleted;
  }
}
class Iframe {
  constructor(e, t, o, c) {
    this._ready = new Ready(), this.requestIndex = 0, this.activeElement = null, this._blockchain = t, this._env = o;
    const a = Math.random().toString();
    if (this.randomPrefix = a.substring(a.length - 6), document.getElementById("face-iframe"))
      throw new Error("Face is already initialized, Face can be initialized once.");
    window.addEventListener("message", async (d) => {
      d.origin === c && await this.processMessage(d.data);
    }), this._iframe = new Promise((d) => {
      const p = () => {
        if (!document.getElementById("face-iframe")) {
          const w = document.createElement("iframe");
          w.id = "face-iframe", w.title = "Secure Modal", w.src = new URL(`${c}?api_key=${e}&blockchain=${t}&env=${o}`).href, w.allow = "clipboard-read; clipboard-write", applyOverlayStyles(w), document.body.appendChild(w), d(w);
        }
      };
      ["loaded", "interactive", "complete"].includes(document.readyState) ? p() : window.addEventListener("load", p, !1);
    });
  }
  async sendChildMessage(e) {
    var t, o;
    await this.ready(), this.requestIndex += 1;
    const c = `${this.randomPrefix}-${this.requestIndex}`;
    return e.id = c, e.from = face_types_1$1.JsonRpcSource.FACE_SDK, (o = (t = await this._iframe) === null || t === void 0 ? void 0 : t.contentWindow) === null || o === void 0 || o.postMessage(e, "*"), c;
  }
  waitForResponse(e) {
    return new Promise((t, o) => {
      const c = (a) => {
        const d = a.data;
        e && d.id !== e || (window.removeEventListener("message", c), d.error && o(d.error), t(d.result));
      };
      window.addEventListener("message", c);
    });
  }
  async processMessage(e) {
    switch (e.method) {
      case face_types_1$1.JsonRpcMethod.face_ready:
        this._ready.complete();
        break;
      case face_types_1$1.JsonRpcMethod.face_openIframe:
        await this.showOverlay();
        break;
      case face_types_1$1.JsonRpcMethod.face_closeIframe:
        await this.hideOverlay();
        break;
    }
  }
  async ready() {
    return new Promise(async (e) => {
      if (this._ready.isCompleted()) {
        e();
        return;
      }
      this._ready.add(() => {
        e();
      });
    });
  }
  async showOverlay() {
    await this.ready();
    const e = await this._iframe;
    e.style.display = "block", this.activeElement = document.activeElement, e.focus();
  }
  async hideOverlay() {
    var e;
    await this.ready();
    const t = await this._iframe;
    t.style.display = "none", !((e = this.activeElement) === null || e === void 0) && e.focus && this.activeElement.focus(), this.activeElement = null;
  }
  setBlockchain(e) {
    this._blockchain = e;
  }
}
iframe.Iframe = Iframe;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal)
    return internal;
  hasRequiredInternal = 1, Object.defineProperty(internal, "__esModule", { value: !0 }), internal.Internal = void 0;
  const n = dist, e = require$$1$3, t = requireFace(), o = iframe, c = e.BigNumber.from(1e5).toHexString();
  class a {
    constructor({ apiKey: p, network: w, env: M, iframeUrl: I, face: B }) {
      const H = this.getBlockchainFromNetwork(w), L = M != null ? M : this.getDefaultEnv(w);
      this.iframe = new o.Iframe(p, H, L, this.getIframeUrl(L, I)), this.face = B;
    }
    async getAddresses(p) {
      const w = await this.iframe.sendChildMessage({
        method: n.JsonRpcMethod.face_accounts,
        params: [p]
      }), M = await this.iframe.waitForResponse(w);
      return M || Promise.reject(new Error("get address failed"));
    }
    async estimateGas(p) {
      return await Promise.all(p.params.map(async (w) => {
        if (w.from)
          if (w.data) {
            const M = [
              "function transfer(address to, uint256 value) public returns (bool success)"
            ], { name: I, args: B } = await this.decodeData(w.data, M).catch(() => ({}));
            if ((B == null ? void 0 : B.to) && (B == null ? void 0 : B.value)) {
              const H = await this.getBalance(w.from, w.to), L = { to: B.to, value: B.value };
              H.sub(L.value).lt(0) && (L.value = "0x0"), w.data = await this.encodeData(M, I, [L.to, L.value]);
            }
          } else
            (await this.getBalance(w.from)).sub(w.value).lt(0) && (w.value = "0x0");
      })), await this.sendRpc(p).catch(() => c);
    }
    async getBalance(p, w) {
      if (w) {
        const M = await this.encodeData(["function balanceOf(address owner) view returns (uint256)"], "balanceOf", [p]), I = await this.sendRpc({
          method: n.JsonRpcMethod.eth_call,
          params: [
            {
              to: w,
              data: M
            },
            "latest"
          ]
        });
        return e.BigNumber.from(I);
      }
      return e.BigNumber.from(await this.sendRpc({
        method: n.JsonRpcMethod.eth_getBalance,
        params: [p, "latest"]
      }));
    }
    async ownerOf(p, w) {
      const M = await this.encodeData(["function ownerOf(uint256 tokenId) view returns (address)"], "ownerOf", [w]), I = await this.sendRpc({
        method: n.JsonRpcMethod.eth_call,
        params: [
          {
            to: p,
            data: M
          },
          "latest"
        ]
      });
      return ("0x" + I.substring(26)).toLowerCase();
    }
    async logout() {
      const p = await this.iframe.sendChildMessage({
        method: n.JsonRpcMethod.face_logOut
      });
      await this.iframe.waitForResponse(p);
    }
    async getCurrentUser() {
      const p = await this.iframe.sendChildMessage({
        method: n.JsonRpcMethod.face_currentUser
      });
      return await this.iframe.waitForResponse(p);
    }
    async isLoggedIn() {
      await this.iframe.sendChildMessage({
        method: n.JsonRpcMethod.face_loggedIn
      });
      const p = await this.iframe.waitForResponse();
      return p || !1;
    }
    async ready() {
      return this.iframe.ready();
    }
    async loginWithCredential() {
      const p = await this.iframe.sendChildMessage({
        method: n.JsonRpcMethod.face_logInSignUp
      });
      return await this.iframe.waitForResponse(p);
    }
    async directSocialLogin(p) {
      const w = await this.iframe.sendChildMessage({
        method: n.JsonRpcMethod.face_directSocialLogin,
        params: [p]
      });
      return await this.iframe.waitForResponse(w);
    }
    async loginWithIdToken(p) {
      const w = await this.iframe.sendChildMessage({
        method: n.JsonRpcMethod.face_loginWithIdToken,
        params: [p]
      });
      return await this.iframe.waitForResponse(w);
    }
    async openWalletConnect(p, w) {
      await this.iframe.sendChildMessage({
        method: n.JsonRpcMethod.face_openWalletConnect,
        params: [p, w]
      });
    }
    async openHome() {
      await this.iframe.sendChildMessage({
        method: n.JsonRpcMethod.face_openHome
      });
    }
    async sendRpc(p) {
      const w = await this.iframe.sendChildMessage(p);
      return await this.iframe.waitForResponse(w);
    }
    getBlockchainFromNetwork(p) {
      switch (p) {
        case t.Network.ETHEREUM:
        case t.Network.GOERLI:
          return n.Blockchain.ETHEREUM;
        case t.Network.POLYGON:
        case t.Network.MUMBAI:
          return n.Blockchain.POLYGON;
        case t.Network.BNB_SMART_CHAIN:
        case t.Network.BNB_SMART_CHAIN_TESTNET:
          return n.Blockchain.BNB_SMART_CHAIN;
        case t.Network.KLAYTN:
        case t.Network.BAOBAB:
          return n.Blockchain.KLAYTN;
        case t.Network.SOLANA:
        case t.Network.SOLANA_DEVNET:
          return n.Blockchain.SOLANA;
        case t.Network.BORA:
        case t.Network.BORA_TESTNET:
          return n.Blockchain.BORA;
        case t.Network.NEAR:
        case t.Network.NEAR_TESTNET:
          return n.Blockchain.NEAR;
        default:
          return n.Blockchain.ETHEREUM;
      }
    }
    getIframeUrl(p, w) {
      if (w != null)
        return w;
      switch (p) {
        case n.Env.Local:
          return "http://localhost:3333";
        case n.Env.Dev:
          return "https://app.dev.facewallet.xyz";
        case n.Env.StageTest:
          return "https://app.stage-test.facewallet.xyz";
        case n.Env.ProdTest:
          return "https://app.test.facewallet.xyz";
        case n.Env.StageMainnet:
          return "https://app.stage.facewallet.xyz";
        case n.Env.ProdMainnet:
          return "https://app.facewallet.xyz";
        default:
          return "https://app.facewallet.xyz";
      }
    }
    getDefaultEnv(p) {
      return p && (p === t.Network.GOERLI || p === t.Network.MUMBAI || p === t.Network.BAOBAB || p === t.Network.BNB_SMART_CHAIN_TESTNET || p === t.Network.BORA_TESTNET || p === t.Network.SOLANA_DEVNET || p === t.Network.NEAR_TESTNET) ? n.Env.ProdTest : n.Env.ProdMainnet;
    }
    async decodeData(p, w) {
      const M = new e.ethers.utils.Interface(w), { name: I, args: B } = M.parseTransaction({ data: p });
      return { name: I, args: B };
    }
    async encodeData(p, w, M) {
      return new e.ethers.utils.Interface(p).encodeFunctionData(w, M);
    }
    async switchNetwork(p) {
      const w = this.getBlockchainFromNetwork(p), M = {
        method: n.JsonRpcMethod.face_switchNetwork,
        params: [{ blockchain: w }]
      }, I = await this.sendRpc(M);
      return this.face.setNetwork(p), this.iframe.setBlockchain(w), I;
    }
  }
  return internal.Internal = a, internal;
}
var provider = {};
Object.defineProperty(provider, "__esModule", { value: !0 });
provider.Provider = void 0;
const face_types_1 = dist;
class ProviderTemplate {
  constructor() {
    this.sendAsync = (e, t) => {
    };
  }
}
class Provider extends ProviderTemplate {
  constructor(e) {
    super(), this.internal = e;
  }
  async request(e) {
    if (Array.isArray(e))
      return Promise.all(e.map((t) => this.internal.sendRpc(t)));
    switch (e.method) {
      case face_types_1.JsonRpcMethod.wallet_switchEthereumChain:
        const t = face_types_1.NetworkChainIdMap[e.params[0].chainId];
        return this.internal.switchNetwork(t);
      case face_types_1.JsonRpcMethod.eth_estimateGas:
        return this.internal.estimateGas(e);
      case "personal_listAccounts":
      case "eth_accounts":
        return this.internal.getAddresses();
      default:
        return this.internal.sendRpc(e);
    }
  }
}
provider.Provider = Provider;
var wallet = {};
Object.defineProperty(wallet, "__esModule", { value: !0 });
wallet.Wallet = void 0;
class Wallet {
  constructor(e) {
    this.internal = e;
  }
  async home() {
    return this.internal.openHome();
  }
}
wallet.Wallet = Wallet;
var walletConnect = {};
Object.defineProperty(walletConnect, "__esModule", { value: !0 });
walletConnect.WalletConnect = void 0;
class WalletConnect {
  constructor(e) {
    this.internal = e;
  }
  async connectOpensea(e) {
    await this.connect("OpenSea", e ? "https://opensea.io/collection/" + e : "https://opensea.io");
  }
  async connect(e, t) {
    await this.internal.openWalletConnect(e, t);
  }
}
walletConnect.WalletConnect = WalletConnect;
var hasRequiredFace;
function requireFace() {
  return hasRequiredFace || (hasRequiredFace = 1, function(n) {
    var e = commonjsGlobal && commonjsGlobal.__rest || function(B, H) {
      var L = {};
      for (var W in B)
        Object.prototype.hasOwnProperty.call(B, W) && H.indexOf(W) < 0 && (L[W] = B[W]);
      if (B != null && typeof Object.getOwnPropertySymbols == "function")
        for (var $ = 0, W = Object.getOwnPropertySymbols(B); $ < W.length; $++)
          H.indexOf(W[$]) < 0 && Object.prototype.propertyIsEnumerable.call(B, W[$]) && (L[W[$]] = B[W[$]]);
      return L;
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), n.Face = n.Network = void 0;
    const t = dist;
    Object.defineProperty(n, "Network", { enumerable: !0, get: function() {
      return t.Network;
    } });
    const o = auth, c = Near$1, a = Solana$1, d = requireInternal(), p = provider, w = wallet, M = walletConnect;
    class I {
      constructor(H) {
        var { apiKey: L, network: W } = H, $ = e(H, ["apiKey", "network"]);
        if (this.getAddresses = async (P) => await this.internal.getAddresses(P), this.setNetwork = (P) => {
          this.network = P;
        }, this.getNetwork = () => this.network, this.getChainId = async () => Number(await this.internal.sendRpc({ method: "eth_chainId", params: [] })), W = W || t.Network.ETHEREUM, !(0, t.isSupportedNetwork)(W))
          throw (0, t.unsupportedChainError)();
        this.network = W, this.internal = new d.Internal({
          apiKey: L,
          network: W,
          env: $.env,
          iframeUrl: $.iframeUrl,
          face: this
        }), this.auth = new o.Auth(this.internal), this.wc = new M.WalletConnect(this.internal), this.solana = new a.Solana(this.internal), this.near = new c.Near(this.internal), this.wallet = new w.Wallet(this.internal);
      }
      async ready() {
        return this.internal.ready();
      }
      getEthLikeProvider() {
        return new p.Provider(this.internal);
      }
      async switchNetwork(H) {
        return this.internal.switchNetwork(H);
      }
    }
    n.Face = I;
  }(face)), face;
}
(function(n) {
  var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, c, a, d) {
    d === void 0 && (d = a);
    var p = Object.getOwnPropertyDescriptor(c, a);
    (!p || ("get" in p ? !c.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return c[a];
    } }), Object.defineProperty(o, d, p);
  } : function(o, c, a, d) {
    d === void 0 && (d = a), o[d] = c[a];
  }), t = commonjsGlobal && commonjsGlobal.__exportStar || function(o, c) {
    for (var a in o)
      a !== "default" && !Object.prototype.hasOwnProperty.call(c, a) && e(c, o, a);
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), t(requireFace(), n);
})(dist$1);
var jt = ((n) => (n.Undefined = "", n.Injected = "Injected", n.WalletConnect = "WalletConnect", n.FaceWallet = "FaceWallet", n))(jt || {}), Ue = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Jr(n) {
  var e = n.default;
  if (typeof e == "function") {
    var t = function() {
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(o) {
    var c = Object.getOwnPropertyDescriptor(n, o);
    Object.defineProperty(t, o, c.get ? c : { enumerable: !0, get: function() {
      return n[o];
    } });
  }), t;
}
var Vr = {}, ge = {};
Object.defineProperty(ge, "__esModule", { value: !0 });
var ni = ge.getLocalStorage = pi = ge.getLocalStorageOrThrow = di = ge.getCrypto = fi = ge.getCryptoOrThrow = li = ge.getLocation = ui = ge.getLocationOrThrow = hi = ge.getNavigator = ci = ge.getNavigatorOrThrow = si = ge.getDocument = ai = ge.getDocumentOrThrow = oi = ge.getFromWindowOrThrow = ii = ge.getFromWindow = void 0;
function Mt(n) {
  let e;
  return typeof window < "u" && typeof window[n] < "u" && (e = window[n]), e;
}
var ii = ge.getFromWindow = Mt;
function St(n) {
  const e = Mt(n);
  if (!e)
    throw new Error(`${n} is not defined in Window`);
  return e;
}
var oi = ge.getFromWindowOrThrow = St;
function as() {
  return St("document");
}
var ai = ge.getDocumentOrThrow = as;
function ss() {
  return Mt("document");
}
var si = ge.getDocument = ss;
function cs() {
  return St("navigator");
}
var ci = ge.getNavigatorOrThrow = cs;
function hs() {
  return Mt("navigator");
}
var hi = ge.getNavigator = hs;
function us() {
  return St("location");
}
var ui = ge.getLocationOrThrow = us;
function ls() {
  return Mt("location");
}
var li = ge.getLocation = ls;
function fs() {
  return St("crypto");
}
var fi = ge.getCryptoOrThrow = fs;
function ds() {
  return Mt("crypto");
}
var di = ge.getCrypto = ds;
function ps() {
  return St("localStorage");
}
var pi = ge.getLocalStorageOrThrow = ps;
function gs() {
  return Mt("localStorage");
}
ni = ge.getLocalStorage = gs, Object.defineProperty(Vr, "__esModule", { value: !0 });
var gi = Vr.getWindowMetadata = void 0;
const _i = ge;
function _s() {
  let n, e;
  try {
    n = _i.getDocumentOrThrow(), e = _i.getLocationOrThrow();
  } catch {
    return null;
  }
  function t() {
    const I = n.getElementsByTagName("link"), B = [];
    for (let H = 0; H < I.length; H++) {
      const L = I[H], W = L.getAttribute("rel");
      if (W && W.toLowerCase().indexOf("icon") > -1) {
        const $ = L.getAttribute("href");
        if ($)
          if ($.toLowerCase().indexOf("https:") === -1 && $.toLowerCase().indexOf("http:") === -1 && $.indexOf("//") !== 0) {
            let P = e.protocol + "//" + e.host;
            if ($.indexOf("/") === 0)
              P += $;
            else {
              const U = e.pathname.split("/");
              U.pop(), P += U.join("/") + "/" + $;
            }
            B.push(P);
          } else if ($.indexOf("//") === 0) {
            const P = e.protocol + $;
            B.push(P);
          } else
            B.push($);
      }
    }
    return B;
  }
  function o(...I) {
    const B = n.getElementsByTagName("meta");
    for (let H = 0; H < B.length; H++) {
      const L = B[H], W = ["itemprop", "property", "name"].map(($) => L.getAttribute($)).filter(($) => $ ? I.includes($) : !1);
      if (W.length && W) {
        const $ = L.getAttribute("content");
        if ($)
          return $;
      }
    }
    return "";
  }
  function c() {
    let I = o("name", "og:site_name", "og:title", "twitter:title");
    return I || (I = n.title), I;
  }
  function a() {
    return o("description", "og:description", "twitter:description", "keywords");
  }
  const d = c(), p = a(), w = e.origin, M = t();
  return { description: p, url: w, icons: M, name: d };
}
gi = Vr.getWindowMetadata = _s;
var ms = function() {
  for (var n = 0, e = 0, t = arguments.length; e < t; e++)
    n += arguments[e].length;
  for (var o = Array(n), c = 0, e = 0; e < t; e++)
    for (var a = arguments[e], d = 0, p = a.length; d < p; d++, c++)
      o[c] = a[d];
  return o;
}, vs = function() {
  function n(e, t, o) {
    this.name = e, this.version = t, this.os = o, this.type = "browser";
  }
  return n;
}(), ys = function() {
  function n(e) {
    this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
  }
  return n;
}(), ws = function() {
  function n(e, t, o, c) {
    this.name = e, this.version = t, this.os = o, this.bot = c, this.type = "bot-device";
  }
  return n;
}(), bs = function() {
  function n() {
    this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
  }
  return n;
}(), xs = function() {
  function n() {
    this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
  }
  return n;
}(), Ms = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, Es = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, mi = 3, Cs = [["aol", /AOLShield\/([0-9\._]+)/], ["edge", /Edge\/([0-9\._]+)/], ["edge-ios", /EdgiOS\/([0-9\._]+)/], ["yandexbrowser", /YaBrowser\/([0-9\._]+)/], ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/], ["samsung", /SamsungBrowser\/([0-9\.]+)/], ["silk", /\bSilk\/([0-9._-]+)\b/], ["miui", /MiuiBrowser\/([0-9\.]+)$/], ["beaker", /BeakerBrowser\/([0-9\.]+)/], ["edge-chromium", /EdgA?\/([0-9\.]+)/], ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/], ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/], ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/], ["fxios", /FxiOS\/([0-9\.]+)/], ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/], ["opera", /Opera\/([0-9\.]+)(?:\s|$)/], ["opera", /OPR\/([0-9\.]+)(:?\s|$)/], ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ["ie", /MSIE\s(7\.0)/], ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/], ["android", /Android\s([0-9\.]+)/], ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/], ["safari", /Version\/([0-9\._]+).*Safari/], ["facebook", /FBAV\/([0-9\.]+)/], ["instagram", /Instagram\s([0-9\.]+)/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ["searchbot", Ms]], vi = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
function Ss(n) {
  return n ? yi(n) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new xs() : typeof navigator < "u" ? yi(navigator.userAgent) : ks();
}
function As(n) {
  return n !== "" && Cs.reduce(function(e, t) {
    var o = t[0], c = t[1];
    if (e)
      return e;
    var a = c.exec(n);
    return !!a && [o, a];
  }, !1);
}
function yi(n) {
  var e = As(n);
  if (!e)
    return null;
  var t = e[0], o = e[1];
  if (t === "searchbot")
    return new bs();
  var c = o[1] && o[1].split(/[._]/).slice(0, 3);
  c ? c.length < mi && (c = ms(c, Is(mi - c.length))) : c = [];
  var a = c.join("."), d = Rs(n), p = Es.exec(n);
  return p && p[1] ? new ws(t, a, d, p[1]) : new vs(t, a, d);
}
function Rs(n) {
  for (var e = 0, t = vi.length; e < t; e++) {
    var o = vi[e], c = o[0], a = o[1], d = a.exec(n);
    if (d)
      return c;
  }
  return null;
}
function ks() {
  var n = typeof process < "u" && process.version;
  return n ? new ys(process.version.slice(1)) : null;
}
function Is(n) {
  for (var e = [], t = 0; t < n; t++)
    e.push("0");
  return e;
}
function sr(n) {
  return Ss(n);
}
function cr() {
  const n = sr();
  return n && n.os ? n.os : void 0;
}
function wi() {
  const n = cr();
  return n ? n.toLowerCase().includes("android") : !1;
}
function bi() {
  const n = cr();
  return n ? n.toLowerCase().includes("ios") || n.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : !1;
}
function xi() {
  return cr() ? wi() || bi() : !1;
}
function Mi() {
  const n = sr();
  return n && n.name ? n.name.toLowerCase() === "node" : !1;
}
function Ei() {
  return !Mi() && !!Si();
}
const Ci = ii, Ts = oi, Os = ai, Bs = si, Ns = ci, Si = hi, Ls = ui, Ai = li, Us = fi, Fs = di, Ps = pi, hr = ni;
function Yr() {
  return gi();
}
function qs(n) {
  if (typeof n != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof n}`);
  try {
    return JSON.parse(n);
  } catch {
    return n;
  }
}
function Ds(n) {
  return typeof n == "string" ? n : JSON.stringify(n);
}
const Ri = qs, ki = Ds;
function Gr(n, e) {
  const t = ki(e), o = hr();
  o && o.setItem(n, t);
}
function Qr(n) {
  let e = null, t = null;
  const o = hr();
  return o && (t = o.getItem(n)), e = t && Ri(t), e;
}
function Xr(n) {
  const e = hr();
  e && e.removeItem(n);
}
const ur = "WALLETCONNECT_DEEPLINK_CHOICE";
function Hs(n, e) {
  const t = encodeURIComponent(n);
  return e.universalLink ? `${e.universalLink}/wc?uri=${t}` : e.deepLink ? `${e.deepLink}${e.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${t}` : "";
}
function $s(n) {
  const e = n.href.split("?")[0];
  Gr(ur, Object.assign(Object.assign({}, n), { href: e }));
}
function Ii(n, e) {
  return n.filter((t) => t.name.toLowerCase().includes(e.toLowerCase()))[0];
}
function Ws(n, e) {
  let t = n;
  return e && (t = e.map((o) => Ii(n, o)).filter(Boolean)), t;
}
const Ti = "https://registry.walletconnect.com";
function js() {
  return Ti + "/api/v2/wallets";
}
function zs() {
  return Ti + "/api/v2/dapps";
}
function Oi(n, e = "mobile") {
  var t;
  return { name: n.name || "", shortName: n.metadata.shortName || "", color: n.metadata.colors.primary || "", logo: (t = n.image_url.sm) !== null && t !== void 0 ? t : "", universalLink: n[e].universal || "", deepLink: n[e].native || "" };
}
function Ks(n, e = "mobile") {
  return Object.values(n).filter((t) => !!t[e].universal || !!t[e].native).map((t) => Oi(t, e));
}
var Js = Object.freeze({ __proto__: null, detectEnv: sr, detectOS: cr, isAndroid: wi, isIOS: bi, isMobile: xi, isNode: Mi, isBrowser: Ei, getFromWindow: Ci, getFromWindowOrThrow: Ts, getDocumentOrThrow: Os, getDocument: Bs, getNavigatorOrThrow: Ns, getNavigator: Si, getLocationOrThrow: Ls, getLocation: Ai, getCryptoOrThrow: Us, getCrypto: Fs, getLocalStorageOrThrow: Ps, getLocalStorage: hr, getClientMeta: Yr, safeJsonParse: Ri, safeJsonStringify: ki, setLocal: Gr, getLocal: Qr, removeLocal: Xr, mobileLinkChoiceKey: ur, formatIOSMobile: Hs, saveMobileLinkInfo: $s, getMobileRegistryEntry: Ii, getMobileLinkRegistry: Ws, getWalletRegistryUrl: js, getDappRegistryUrl: zs, formatMobileRegistryEntry: Oi, formatMobileRegistry: Ks }), Bi = { exports: {} }, Gs = {}, Qs = Object.freeze({ __proto__: null, default: Gs }), Xs = Jr(Qs);
(function(n) {
  (function(e, t) {
    function o(C, O) {
      if (!C)
        throw new Error(O || "Assertion failed");
    }
    function c(C, O) {
      C.super_ = O;
      var V = function() {
      };
      V.prototype = O.prototype, C.prototype = new V(), C.prototype.constructor = C;
    }
    function a(C, O, V) {
      if (a.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((O === "le" || O === "be") && (V = O, O = 10), this._init(C || 0, O || 10, V || "be"));
    }
    typeof e == "object" ? e.exports = a : t.BN = a, a.BN = a, a.wordSize = 26;
    var d;
    try {
      d = Xs.Buffer;
    } catch {
    }
    a.isBN = function(C) {
      return C instanceof a ? !0 : C !== null && typeof C == "object" && C.constructor.wordSize === a.wordSize && Array.isArray(C.words);
    }, a.max = function(C, O) {
      return C.cmp(O) > 0 ? C : O;
    }, a.min = function(C, O) {
      return C.cmp(O) < 0 ? C : O;
    }, a.prototype._init = function(C, O, V) {
      if (typeof C == "number")
        return this._initNumber(C, O, V);
      if (typeof C == "object")
        return this._initArray(C, O, V);
      O === "hex" && (O = 16), o(O === (O | 0) && O >= 2 && O <= 36), C = C.toString().replace(/\s+/g, "");
      var x = 0;
      C[0] === "-" && x++, O === 16 ? this._parseHex(C, x) : this._parseBase(C, O, x), C[0] === "-" && (this.negative = 1), this.strip(), V === "le" && this._initArray(this.toArray(), O, V);
    }, a.prototype._initNumber = function(C, O, V) {
      C < 0 && (this.negative = 1, C = -C), C < 67108864 ? (this.words = [C & 67108863], this.length = 1) : C < 4503599627370496 ? (this.words = [C & 67108863, C / 67108864 & 67108863], this.length = 2) : (o(C < 9007199254740992), this.words = [C & 67108863, C / 67108864 & 67108863, 1], this.length = 3), V === "le" && this._initArray(this.toArray(), O, V);
    }, a.prototype._initArray = function(C, O, V) {
      if (o(typeof C.length == "number"), C.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(C.length / 3), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var u, h, g = 0;
      if (V === "be")
        for (x = C.length - 1, u = 0; x >= 0; x -= 3)
          h = C[x] | C[x - 1] << 8 | C[x - 2] << 16, this.words[u] |= h << g & 67108863, this.words[u + 1] = h >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, u++);
      else if (V === "le")
        for (x = 0, u = 0; x < C.length; x += 3)
          h = C[x] | C[x + 1] << 8 | C[x + 2] << 16, this.words[u] |= h << g & 67108863, this.words[u + 1] = h >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, u++);
      return this.strip();
    };
    function p(C, O, V) {
      for (var x = 0, u = Math.min(C.length, V), h = O; h < u; h++) {
        var g = C.charCodeAt(h) - 48;
        x <<= 4, g >= 49 && g <= 54 ? x |= g - 49 + 10 : g >= 17 && g <= 22 ? x |= g - 17 + 10 : x |= g & 15;
      }
      return x;
    }
    a.prototype._parseHex = function(C, O) {
      this.length = Math.ceil((C.length - O) / 6), this.words = new Array(this.length);
      for (var V = 0; V < this.length; V++)
        this.words[V] = 0;
      var x, u, h = 0;
      for (V = C.length - 6, x = 0; V >= O; V -= 6)
        u = p(C, V, V + 6), this.words[x] |= u << h & 67108863, this.words[x + 1] |= u >>> 26 - h & 4194303, h += 24, h >= 26 && (h -= 26, x++);
      V + 6 !== O && (u = p(C, O, V + 6), this.words[x] |= u << h & 67108863, this.words[x + 1] |= u >>> 26 - h & 4194303), this.strip();
    };
    function w(C, O, V, x) {
      for (var u = 0, h = Math.min(C.length, V), g = O; g < h; g++) {
        var y = C.charCodeAt(g) - 48;
        u *= x, y >= 49 ? u += y - 49 + 10 : y >= 17 ? u += y - 17 + 10 : u += y;
      }
      return u;
    }
    a.prototype._parseBase = function(C, O, V) {
      this.words = [0], this.length = 1;
      for (var x = 0, u = 1; u <= 67108863; u *= O)
        x++;
      x--, u = u / O | 0;
      for (var h = C.length - V, g = h % x, y = Math.min(h, h - g) + V, m = 0, _ = V; _ < y; _ += x)
        m = w(C, _, _ + x, O), this.imuln(u), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
      if (g !== 0) {
        var R = 1;
        for (m = w(C, _, C.length, O), _ = 0; _ < g; _++)
          R *= O;
        this.imuln(R), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
      }
    }, a.prototype.copy = function(C) {
      C.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        C.words[O] = this.words[O];
      C.length = this.length, C.negative = this.negative, C.red = this.red;
    }, a.prototype.clone = function() {
      var C = new a(null);
      return this.copy(C), C;
    }, a.prototype._expand = function(C) {
      for (; this.length < C; )
        this.words[this.length++] = 0;
      return this;
    }, a.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, a.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, a.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var M = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], I = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], B = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    a.prototype.toString = function(C, O) {
      C = C || 10, O = O | 0 || 1;
      var V;
      if (C === 16 || C === "hex") {
        V = "";
        for (var x = 0, u = 0, h = 0; h < this.length; h++) {
          var g = this.words[h], y = ((g << x | u) & 16777215).toString(16);
          u = g >>> 24 - x & 16777215, u !== 0 || h !== this.length - 1 ? V = M[6 - y.length] + y + V : V = y + V, x += 2, x >= 26 && (x -= 26, h--);
        }
        for (u !== 0 && (V = u.toString(16) + V); V.length % O !== 0; )
          V = "0" + V;
        return this.negative !== 0 && (V = "-" + V), V;
      }
      if (C === (C | 0) && C >= 2 && C <= 36) {
        var m = I[C], _ = B[C];
        V = "";
        var R = this.clone();
        for (R.negative = 0; !R.isZero(); ) {
          var b = R.modn(_).toString(C);
          R = R.idivn(_), R.isZero() ? V = b + V : V = M[m - b.length] + b + V;
        }
        for (this.isZero() && (V = "0" + V); V.length % O !== 0; )
          V = "0" + V;
        return this.negative !== 0 && (V = "-" + V), V;
      }
      o(!1, "Base should be between 2 and 36");
    }, a.prototype.toNumber = function() {
      var C = this.words[0];
      return this.length === 2 ? C += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? C += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -C : C;
    }, a.prototype.toJSON = function() {
      return this.toString(16);
    }, a.prototype.toBuffer = function(C, O) {
      return o(typeof d < "u"), this.toArrayLike(d, C, O);
    }, a.prototype.toArray = function(C, O) {
      return this.toArrayLike(Array, C, O);
    }, a.prototype.toArrayLike = function(C, O, V) {
      var x = this.byteLength(), u = V || Math.max(1, x);
      o(x <= u, "byte array longer than desired length"), o(u > 0, "Requested array length <= 0"), this.strip();
      var h = O === "le", g = new C(u), y, m, _ = this.clone();
      if (h) {
        for (m = 0; !_.isZero(); m++)
          y = _.andln(255), _.iushrn(8), g[m] = y;
        for (; m < u; m++)
          g[m] = 0;
      } else {
        for (m = 0; m < u - x; m++)
          g[m] = 0;
        for (m = 0; !_.isZero(); m++)
          y = _.andln(255), _.iushrn(8), g[u - m - 1] = y;
      }
      return g;
    }, Math.clz32 ? a.prototype._countBits = function(C) {
      return 32 - Math.clz32(C);
    } : a.prototype._countBits = function(C) {
      var O = C, V = 0;
      return O >= 4096 && (V += 13, O >>>= 13), O >= 64 && (V += 7, O >>>= 7), O >= 8 && (V += 4, O >>>= 4), O >= 2 && (V += 2, O >>>= 2), V + O;
    }, a.prototype._zeroBits = function(C) {
      if (C === 0)
        return 26;
      var O = C, V = 0;
      return (O & 8191) === 0 && (V += 13, O >>>= 13), (O & 127) === 0 && (V += 7, O >>>= 7), (O & 15) === 0 && (V += 4, O >>>= 4), (O & 3) === 0 && (V += 2, O >>>= 2), (O & 1) === 0 && V++, V;
    }, a.prototype.bitLength = function() {
      var C = this.words[this.length - 1], O = this._countBits(C);
      return (this.length - 1) * 26 + O;
    };
    function H(C) {
      for (var O = new Array(C.bitLength()), V = 0; V < O.length; V++) {
        var x = V / 26 | 0, u = V % 26;
        O[V] = (C.words[x] & 1 << u) >>> u;
      }
      return O;
    }
    a.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var C = 0, O = 0; O < this.length; O++) {
        var V = this._zeroBits(this.words[O]);
        if (C += V, V !== 26)
          break;
      }
      return C;
    }, a.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, a.prototype.toTwos = function(C) {
      return this.negative !== 0 ? this.abs().inotn(C).iaddn(1) : this.clone();
    }, a.prototype.fromTwos = function(C) {
      return this.testn(C - 1) ? this.notn(C).iaddn(1).ineg() : this.clone();
    }, a.prototype.isNeg = function() {
      return this.negative !== 0;
    }, a.prototype.neg = function() {
      return this.clone().ineg();
    }, a.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, a.prototype.iuor = function(C) {
      for (; this.length < C.length; )
        this.words[this.length++] = 0;
      for (var O = 0; O < C.length; O++)
        this.words[O] = this.words[O] | C.words[O];
      return this.strip();
    }, a.prototype.ior = function(C) {
      return o((this.negative | C.negative) === 0), this.iuor(C);
    }, a.prototype.or = function(C) {
      return this.length > C.length ? this.clone().ior(C) : C.clone().ior(this);
    }, a.prototype.uor = function(C) {
      return this.length > C.length ? this.clone().iuor(C) : C.clone().iuor(this);
    }, a.prototype.iuand = function(C) {
      var O;
      this.length > C.length ? O = C : O = this;
      for (var V = 0; V < O.length; V++)
        this.words[V] = this.words[V] & C.words[V];
      return this.length = O.length, this.strip();
    }, a.prototype.iand = function(C) {
      return o((this.negative | C.negative) === 0), this.iuand(C);
    }, a.prototype.and = function(C) {
      return this.length > C.length ? this.clone().iand(C) : C.clone().iand(this);
    }, a.prototype.uand = function(C) {
      return this.length > C.length ? this.clone().iuand(C) : C.clone().iuand(this);
    }, a.prototype.iuxor = function(C) {
      var O, V;
      this.length > C.length ? (O = this, V = C) : (O = C, V = this);
      for (var x = 0; x < V.length; x++)
        this.words[x] = O.words[x] ^ V.words[x];
      if (this !== O)
        for (; x < O.length; x++)
          this.words[x] = O.words[x];
      return this.length = O.length, this.strip();
    }, a.prototype.ixor = function(C) {
      return o((this.negative | C.negative) === 0), this.iuxor(C);
    }, a.prototype.xor = function(C) {
      return this.length > C.length ? this.clone().ixor(C) : C.clone().ixor(this);
    }, a.prototype.uxor = function(C) {
      return this.length > C.length ? this.clone().iuxor(C) : C.clone().iuxor(this);
    }, a.prototype.inotn = function(C) {
      o(typeof C == "number" && C >= 0);
      var O = Math.ceil(C / 26) | 0, V = C % 26;
      this._expand(O), V > 0 && O--;
      for (var x = 0; x < O; x++)
        this.words[x] = ~this.words[x] & 67108863;
      return V > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - V), this.strip();
    }, a.prototype.notn = function(C) {
      return this.clone().inotn(C);
    }, a.prototype.setn = function(C, O) {
      o(typeof C == "number" && C >= 0);
      var V = C / 26 | 0, x = C % 26;
      return this._expand(V + 1), O ? this.words[V] = this.words[V] | 1 << x : this.words[V] = this.words[V] & ~(1 << x), this.strip();
    }, a.prototype.iadd = function(C) {
      var O;
      if (this.negative !== 0 && C.negative === 0)
        return this.negative = 0, O = this.isub(C), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && C.negative !== 0)
        return C.negative = 0, O = this.isub(C), C.negative = 1, O._normSign();
      var V, x;
      this.length > C.length ? (V = this, x = C) : (V = C, x = this);
      for (var u = 0, h = 0; h < x.length; h++)
        O = (V.words[h] | 0) + (x.words[h] | 0) + u, this.words[h] = O & 67108863, u = O >>> 26;
      for (; u !== 0 && h < V.length; h++)
        O = (V.words[h] | 0) + u, this.words[h] = O & 67108863, u = O >>> 26;
      if (this.length = V.length, u !== 0)
        this.words[this.length] = u, this.length++;
      else if (V !== this)
        for (; h < V.length; h++)
          this.words[h] = V.words[h];
      return this;
    }, a.prototype.add = function(C) {
      var O;
      return C.negative !== 0 && this.negative === 0 ? (C.negative = 0, O = this.sub(C), C.negative ^= 1, O) : C.negative === 0 && this.negative !== 0 ? (this.negative = 0, O = C.sub(this), this.negative = 1, O) : this.length > C.length ? this.clone().iadd(C) : C.clone().iadd(this);
    }, a.prototype.isub = function(C) {
      if (C.negative !== 0) {
        C.negative = 0;
        var O = this.iadd(C);
        return C.negative = 1, O._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(C), this.negative = 1, this._normSign();
      var V = this.cmp(C);
      if (V === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var x, u;
      V > 0 ? (x = this, u = C) : (x = C, u = this);
      for (var h = 0, g = 0; g < u.length; g++)
        O = (x.words[g] | 0) - (u.words[g] | 0) + h, h = O >> 26, this.words[g] = O & 67108863;
      for (; h !== 0 && g < x.length; g++)
        O = (x.words[g] | 0) + h, h = O >> 26, this.words[g] = O & 67108863;
      if (h === 0 && g < x.length && x !== this)
        for (; g < x.length; g++)
          this.words[g] = x.words[g];
      return this.length = Math.max(this.length, g), x !== this && (this.negative = 1), this.strip();
    }, a.prototype.sub = function(C) {
      return this.clone().isub(C);
    };
    function L(C, O, V) {
      V.negative = O.negative ^ C.negative;
      var x = C.length + O.length | 0;
      V.length = x, x = x - 1 | 0;
      var u = C.words[0] | 0, h = O.words[0] | 0, g = u * h, y = g & 67108863, m = g / 67108864 | 0;
      V.words[0] = y;
      for (var _ = 1; _ < x; _++) {
        for (var R = m >>> 26, b = m & 67108863, l = Math.min(_, O.length - 1), v = Math.max(0, _ - C.length + 1); v <= l; v++) {
          var X = _ - v | 0;
          u = C.words[X] | 0, h = O.words[v] | 0, g = u * h + b, R += g / 67108864 | 0, b = g & 67108863;
        }
        V.words[_] = b | 0, m = R | 0;
      }
      return m !== 0 ? V.words[_] = m | 0 : V.length--, V.strip();
    }
    var W = function(C, O, V) {
      var x = C.words, u = O.words, h = V.words, g = 0, y, m, _, R = x[0] | 0, b = R & 8191, l = R >>> 13, v = x[1] | 0, X = v & 8191, S = v >>> 13, Y = x[2] | 0, fe = Y & 8191, oe = Y >>> 13, de = x[3] | 0, Ie = de & 8191, ye = de >>> 13, be = x[4] | 0, rt = be & 8191, xe = be >>> 13, Ne = x[5] | 0, j = Ne & 8191, z = Ne >>> 13, ee = x[6] | 0, ve = ee & 8191, me = ee >>> 13, Ae = x[7] | 0, it = Ae & 8191, ke = Ae >>> 13, qe = x[8] | 0, or = qe & 8191, Oe = qe >>> 13, T = x[9] | 0, A = T & 8191, E = T >>> 13, F = u[0] | 0, ie = F & 8191, ne = F >>> 13, ce = u[1] | 0, nt = ce & 8191, Be = ce >>> 13, Ce = u[2] | 0, _t = Ce & 8191, Me = Ce >>> 13, pt = u[3] | 0, qr = pt & 8191, Xe = pt >>> 13, yt = u[4] | 0, Zr = yt & 8191, He = yt >>> 13, dt = u[5] | 0, Hr = dt & 8191, Ze = dt >>> 13, mt = u[6] | 0, zr = mt & 8191, Qe = mt >>> 13, tt = u[7] | 0, Wr = tt & 8191, q = tt >>> 13, Q = u[8] | 0, ae = Q & 8191, k = Q >>> 13, re = u[9] | 0, Ee = re & 8191, pe = re >>> 13;
      V.negative = C.negative ^ O.negative, V.length = 19, y = Math.imul(b, ie), m = Math.imul(b, ne), m = m + Math.imul(l, ie) | 0, _ = Math.imul(l, ne);
      var _e = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, y = Math.imul(X, ie), m = Math.imul(X, ne), m = m + Math.imul(S, ie) | 0, _ = Math.imul(S, ne), y = y + Math.imul(b, nt) | 0, m = m + Math.imul(b, Be) | 0, m = m + Math.imul(l, nt) | 0, _ = _ + Math.imul(l, Be) | 0;
      var bt = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, y = Math.imul(fe, ie), m = Math.imul(fe, ne), m = m + Math.imul(oe, ie) | 0, _ = Math.imul(oe, ne), y = y + Math.imul(X, nt) | 0, m = m + Math.imul(X, Be) | 0, m = m + Math.imul(S, nt) | 0, _ = _ + Math.imul(S, Be) | 0, y = y + Math.imul(b, _t) | 0, m = m + Math.imul(b, Me) | 0, m = m + Math.imul(l, _t) | 0, _ = _ + Math.imul(l, Me) | 0;
      var Te = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, y = Math.imul(Ie, ie), m = Math.imul(Ie, ne), m = m + Math.imul(ye, ie) | 0, _ = Math.imul(ye, ne), y = y + Math.imul(fe, nt) | 0, m = m + Math.imul(fe, Be) | 0, m = m + Math.imul(oe, nt) | 0, _ = _ + Math.imul(oe, Be) | 0, y = y + Math.imul(X, _t) | 0, m = m + Math.imul(X, Me) | 0, m = m + Math.imul(S, _t) | 0, _ = _ + Math.imul(S, Me) | 0, y = y + Math.imul(b, qr) | 0, m = m + Math.imul(b, Xe) | 0, m = m + Math.imul(l, qr) | 0, _ = _ + Math.imul(l, Xe) | 0;
      var Re = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, y = Math.imul(rt, ie), m = Math.imul(rt, ne), m = m + Math.imul(xe, ie) | 0, _ = Math.imul(xe, ne), y = y + Math.imul(Ie, nt) | 0, m = m + Math.imul(Ie, Be) | 0, m = m + Math.imul(ye, nt) | 0, _ = _ + Math.imul(ye, Be) | 0, y = y + Math.imul(fe, _t) | 0, m = m + Math.imul(fe, Me) | 0, m = m + Math.imul(oe, _t) | 0, _ = _ + Math.imul(oe, Me) | 0, y = y + Math.imul(X, qr) | 0, m = m + Math.imul(X, Xe) | 0, m = m + Math.imul(S, qr) | 0, _ = _ + Math.imul(S, Xe) | 0, y = y + Math.imul(b, Zr) | 0, m = m + Math.imul(b, He) | 0, m = m + Math.imul(l, Zr) | 0, _ = _ + Math.imul(l, He) | 0;
      var Dr = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, y = Math.imul(j, ie), m = Math.imul(j, ne), m = m + Math.imul(z, ie) | 0, _ = Math.imul(z, ne), y = y + Math.imul(rt, nt) | 0, m = m + Math.imul(rt, Be) | 0, m = m + Math.imul(xe, nt) | 0, _ = _ + Math.imul(xe, Be) | 0, y = y + Math.imul(Ie, _t) | 0, m = m + Math.imul(Ie, Me) | 0, m = m + Math.imul(ye, _t) | 0, _ = _ + Math.imul(ye, Me) | 0, y = y + Math.imul(fe, qr) | 0, m = m + Math.imul(fe, Xe) | 0, m = m + Math.imul(oe, qr) | 0, _ = _ + Math.imul(oe, Xe) | 0, y = y + Math.imul(X, Zr) | 0, m = m + Math.imul(X, He) | 0, m = m + Math.imul(S, Zr) | 0, _ = _ + Math.imul(S, He) | 0, y = y + Math.imul(b, Hr) | 0, m = m + Math.imul(b, Ze) | 0, m = m + Math.imul(l, Hr) | 0, _ = _ + Math.imul(l, Ze) | 0;
      var vt = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, y = Math.imul(ve, ie), m = Math.imul(ve, ne), m = m + Math.imul(me, ie) | 0, _ = Math.imul(me, ne), y = y + Math.imul(j, nt) | 0, m = m + Math.imul(j, Be) | 0, m = m + Math.imul(z, nt) | 0, _ = _ + Math.imul(z, Be) | 0, y = y + Math.imul(rt, _t) | 0, m = m + Math.imul(rt, Me) | 0, m = m + Math.imul(xe, _t) | 0, _ = _ + Math.imul(xe, Me) | 0, y = y + Math.imul(Ie, qr) | 0, m = m + Math.imul(Ie, Xe) | 0, m = m + Math.imul(ye, qr) | 0, _ = _ + Math.imul(ye, Xe) | 0, y = y + Math.imul(fe, Zr) | 0, m = m + Math.imul(fe, He) | 0, m = m + Math.imul(oe, Zr) | 0, _ = _ + Math.imul(oe, He) | 0, y = y + Math.imul(X, Hr) | 0, m = m + Math.imul(X, Ze) | 0, m = m + Math.imul(S, Hr) | 0, _ = _ + Math.imul(S, Ze) | 0, y = y + Math.imul(b, zr) | 0, m = m + Math.imul(b, Qe) | 0, m = m + Math.imul(l, zr) | 0, _ = _ + Math.imul(l, Qe) | 0;
      var pr = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, y = Math.imul(it, ie), m = Math.imul(it, ne), m = m + Math.imul(ke, ie) | 0, _ = Math.imul(ke, ne), y = y + Math.imul(ve, nt) | 0, m = m + Math.imul(ve, Be) | 0, m = m + Math.imul(me, nt) | 0, _ = _ + Math.imul(me, Be) | 0, y = y + Math.imul(j, _t) | 0, m = m + Math.imul(j, Me) | 0, m = m + Math.imul(z, _t) | 0, _ = _ + Math.imul(z, Me) | 0, y = y + Math.imul(rt, qr) | 0, m = m + Math.imul(rt, Xe) | 0, m = m + Math.imul(xe, qr) | 0, _ = _ + Math.imul(xe, Xe) | 0, y = y + Math.imul(Ie, Zr) | 0, m = m + Math.imul(Ie, He) | 0, m = m + Math.imul(ye, Zr) | 0, _ = _ + Math.imul(ye, He) | 0, y = y + Math.imul(fe, Hr) | 0, m = m + Math.imul(fe, Ze) | 0, m = m + Math.imul(oe, Hr) | 0, _ = _ + Math.imul(oe, Ze) | 0, y = y + Math.imul(X, zr) | 0, m = m + Math.imul(X, Qe) | 0, m = m + Math.imul(S, zr) | 0, _ = _ + Math.imul(S, Qe) | 0, y = y + Math.imul(b, Wr) | 0, m = m + Math.imul(b, q) | 0, m = m + Math.imul(l, Wr) | 0, _ = _ + Math.imul(l, q) | 0;
      var Pr = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, y = Math.imul(or, ie), m = Math.imul(or, ne), m = m + Math.imul(Oe, ie) | 0, _ = Math.imul(Oe, ne), y = y + Math.imul(it, nt) | 0, m = m + Math.imul(it, Be) | 0, m = m + Math.imul(ke, nt) | 0, _ = _ + Math.imul(ke, Be) | 0, y = y + Math.imul(ve, _t) | 0, m = m + Math.imul(ve, Me) | 0, m = m + Math.imul(me, _t) | 0, _ = _ + Math.imul(me, Me) | 0, y = y + Math.imul(j, qr) | 0, m = m + Math.imul(j, Xe) | 0, m = m + Math.imul(z, qr) | 0, _ = _ + Math.imul(z, Xe) | 0, y = y + Math.imul(rt, Zr) | 0, m = m + Math.imul(rt, He) | 0, m = m + Math.imul(xe, Zr) | 0, _ = _ + Math.imul(xe, He) | 0, y = y + Math.imul(Ie, Hr) | 0, m = m + Math.imul(Ie, Ze) | 0, m = m + Math.imul(ye, Hr) | 0, _ = _ + Math.imul(ye, Ze) | 0, y = y + Math.imul(fe, zr) | 0, m = m + Math.imul(fe, Qe) | 0, m = m + Math.imul(oe, zr) | 0, _ = _ + Math.imul(oe, Qe) | 0, y = y + Math.imul(X, Wr) | 0, m = m + Math.imul(X, q) | 0, m = m + Math.imul(S, Wr) | 0, _ = _ + Math.imul(S, q) | 0, y = y + Math.imul(b, ae) | 0, m = m + Math.imul(b, k) | 0, m = m + Math.imul(l, ae) | 0, _ = _ + Math.imul(l, k) | 0;
      var Lr = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, y = Math.imul(A, ie), m = Math.imul(A, ne), m = m + Math.imul(E, ie) | 0, _ = Math.imul(E, ne), y = y + Math.imul(or, nt) | 0, m = m + Math.imul(or, Be) | 0, m = m + Math.imul(Oe, nt) | 0, _ = _ + Math.imul(Oe, Be) | 0, y = y + Math.imul(it, _t) | 0, m = m + Math.imul(it, Me) | 0, m = m + Math.imul(ke, _t) | 0, _ = _ + Math.imul(ke, Me) | 0, y = y + Math.imul(ve, qr) | 0, m = m + Math.imul(ve, Xe) | 0, m = m + Math.imul(me, qr) | 0, _ = _ + Math.imul(me, Xe) | 0, y = y + Math.imul(j, Zr) | 0, m = m + Math.imul(j, He) | 0, m = m + Math.imul(z, Zr) | 0, _ = _ + Math.imul(z, He) | 0, y = y + Math.imul(rt, Hr) | 0, m = m + Math.imul(rt, Ze) | 0, m = m + Math.imul(xe, Hr) | 0, _ = _ + Math.imul(xe, Ze) | 0, y = y + Math.imul(Ie, zr) | 0, m = m + Math.imul(Ie, Qe) | 0, m = m + Math.imul(ye, zr) | 0, _ = _ + Math.imul(ye, Qe) | 0, y = y + Math.imul(fe, Wr) | 0, m = m + Math.imul(fe, q) | 0, m = m + Math.imul(oe, Wr) | 0, _ = _ + Math.imul(oe, q) | 0, y = y + Math.imul(X, ae) | 0, m = m + Math.imul(X, k) | 0, m = m + Math.imul(S, ae) | 0, _ = _ + Math.imul(S, k) | 0, y = y + Math.imul(b, Ee) | 0, m = m + Math.imul(b, pe) | 0, m = m + Math.imul(l, Ee) | 0, _ = _ + Math.imul(l, pe) | 0;
      var Kr = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (Kr >>> 26) | 0, Kr &= 67108863, y = Math.imul(A, nt), m = Math.imul(A, Be), m = m + Math.imul(E, nt) | 0, _ = Math.imul(E, Be), y = y + Math.imul(or, _t) | 0, m = m + Math.imul(or, Me) | 0, m = m + Math.imul(Oe, _t) | 0, _ = _ + Math.imul(Oe, Me) | 0, y = y + Math.imul(it, qr) | 0, m = m + Math.imul(it, Xe) | 0, m = m + Math.imul(ke, qr) | 0, _ = _ + Math.imul(ke, Xe) | 0, y = y + Math.imul(ve, Zr) | 0, m = m + Math.imul(ve, He) | 0, m = m + Math.imul(me, Zr) | 0, _ = _ + Math.imul(me, He) | 0, y = y + Math.imul(j, Hr) | 0, m = m + Math.imul(j, Ze) | 0, m = m + Math.imul(z, Hr) | 0, _ = _ + Math.imul(z, Ze) | 0, y = y + Math.imul(rt, zr) | 0, m = m + Math.imul(rt, Qe) | 0, m = m + Math.imul(xe, zr) | 0, _ = _ + Math.imul(xe, Qe) | 0, y = y + Math.imul(Ie, Wr) | 0, m = m + Math.imul(Ie, q) | 0, m = m + Math.imul(ye, Wr) | 0, _ = _ + Math.imul(ye, q) | 0, y = y + Math.imul(fe, ae) | 0, m = m + Math.imul(fe, k) | 0, m = m + Math.imul(oe, ae) | 0, _ = _ + Math.imul(oe, k) | 0, y = y + Math.imul(X, Ee) | 0, m = m + Math.imul(X, pe) | 0, m = m + Math.imul(S, Ee) | 0, _ = _ + Math.imul(S, pe) | 0;
      var $r = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, y = Math.imul(A, _t), m = Math.imul(A, Me), m = m + Math.imul(E, _t) | 0, _ = Math.imul(E, Me), y = y + Math.imul(or, qr) | 0, m = m + Math.imul(or, Xe) | 0, m = m + Math.imul(Oe, qr) | 0, _ = _ + Math.imul(Oe, Xe) | 0, y = y + Math.imul(it, Zr) | 0, m = m + Math.imul(it, He) | 0, m = m + Math.imul(ke, Zr) | 0, _ = _ + Math.imul(ke, He) | 0, y = y + Math.imul(ve, Hr) | 0, m = m + Math.imul(ve, Ze) | 0, m = m + Math.imul(me, Hr) | 0, _ = _ + Math.imul(me, Ze) | 0, y = y + Math.imul(j, zr) | 0, m = m + Math.imul(j, Qe) | 0, m = m + Math.imul(z, zr) | 0, _ = _ + Math.imul(z, Qe) | 0, y = y + Math.imul(rt, Wr) | 0, m = m + Math.imul(rt, q) | 0, m = m + Math.imul(xe, Wr) | 0, _ = _ + Math.imul(xe, q) | 0, y = y + Math.imul(Ie, ae) | 0, m = m + Math.imul(Ie, k) | 0, m = m + Math.imul(ye, ae) | 0, _ = _ + Math.imul(ye, k) | 0, y = y + Math.imul(fe, Ee) | 0, m = m + Math.imul(fe, pe) | 0, m = m + Math.imul(oe, Ee) | 0, _ = _ + Math.imul(oe, pe) | 0;
      var Fr = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, y = Math.imul(A, qr), m = Math.imul(A, Xe), m = m + Math.imul(E, qr) | 0, _ = Math.imul(E, Xe), y = y + Math.imul(or, Zr) | 0, m = m + Math.imul(or, He) | 0, m = m + Math.imul(Oe, Zr) | 0, _ = _ + Math.imul(Oe, He) | 0, y = y + Math.imul(it, Hr) | 0, m = m + Math.imul(it, Ze) | 0, m = m + Math.imul(ke, Hr) | 0, _ = _ + Math.imul(ke, Ze) | 0, y = y + Math.imul(ve, zr) | 0, m = m + Math.imul(ve, Qe) | 0, m = m + Math.imul(me, zr) | 0, _ = _ + Math.imul(me, Qe) | 0, y = y + Math.imul(j, Wr) | 0, m = m + Math.imul(j, q) | 0, m = m + Math.imul(z, Wr) | 0, _ = _ + Math.imul(z, q) | 0, y = y + Math.imul(rt, ae) | 0, m = m + Math.imul(rt, k) | 0, m = m + Math.imul(xe, ae) | 0, _ = _ + Math.imul(xe, k) | 0, y = y + Math.imul(Ie, Ee) | 0, m = m + Math.imul(Ie, pe) | 0, m = m + Math.imul(ye, Ee) | 0, _ = _ + Math.imul(ye, pe) | 0;
      var Ur = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, y = Math.imul(A, Zr), m = Math.imul(A, He), m = m + Math.imul(E, Zr) | 0, _ = Math.imul(E, He), y = y + Math.imul(or, Hr) | 0, m = m + Math.imul(or, Ze) | 0, m = m + Math.imul(Oe, Hr) | 0, _ = _ + Math.imul(Oe, Ze) | 0, y = y + Math.imul(it, zr) | 0, m = m + Math.imul(it, Qe) | 0, m = m + Math.imul(ke, zr) | 0, _ = _ + Math.imul(ke, Qe) | 0, y = y + Math.imul(ve, Wr) | 0, m = m + Math.imul(ve, q) | 0, m = m + Math.imul(me, Wr) | 0, _ = _ + Math.imul(me, q) | 0, y = y + Math.imul(j, ae) | 0, m = m + Math.imul(j, k) | 0, m = m + Math.imul(z, ae) | 0, _ = _ + Math.imul(z, k) | 0, y = y + Math.imul(rt, Ee) | 0, m = m + Math.imul(rt, pe) | 0, m = m + Math.imul(xe, Ee) | 0, _ = _ + Math.imul(xe, pe) | 0;
      var ar = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, y = Math.imul(A, Hr), m = Math.imul(A, Ze), m = m + Math.imul(E, Hr) | 0, _ = Math.imul(E, Ze), y = y + Math.imul(or, zr) | 0, m = m + Math.imul(or, Qe) | 0, m = m + Math.imul(Oe, zr) | 0, _ = _ + Math.imul(Oe, Qe) | 0, y = y + Math.imul(it, Wr) | 0, m = m + Math.imul(it, q) | 0, m = m + Math.imul(ke, Wr) | 0, _ = _ + Math.imul(ke, q) | 0, y = y + Math.imul(ve, ae) | 0, m = m + Math.imul(ve, k) | 0, m = m + Math.imul(me, ae) | 0, _ = _ + Math.imul(me, k) | 0, y = y + Math.imul(j, Ee) | 0, m = m + Math.imul(j, pe) | 0, m = m + Math.imul(z, Ee) | 0, _ = _ + Math.imul(z, pe) | 0;
      var gr = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, y = Math.imul(A, zr), m = Math.imul(A, Qe), m = m + Math.imul(E, zr) | 0, _ = Math.imul(E, Qe), y = y + Math.imul(or, Wr) | 0, m = m + Math.imul(or, q) | 0, m = m + Math.imul(Oe, Wr) | 0, _ = _ + Math.imul(Oe, q) | 0, y = y + Math.imul(it, ae) | 0, m = m + Math.imul(it, k) | 0, m = m + Math.imul(ke, ae) | 0, _ = _ + Math.imul(ke, k) | 0, y = y + Math.imul(ve, Ee) | 0, m = m + Math.imul(ve, pe) | 0, m = m + Math.imul(me, Ee) | 0, _ = _ + Math.imul(me, pe) | 0;
      var zt = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, y = Math.imul(A, Wr), m = Math.imul(A, q), m = m + Math.imul(E, Wr) | 0, _ = Math.imul(E, q), y = y + Math.imul(or, ae) | 0, m = m + Math.imul(or, k) | 0, m = m + Math.imul(Oe, ae) | 0, _ = _ + Math.imul(Oe, k) | 0, y = y + Math.imul(it, Ee) | 0, m = m + Math.imul(it, pe) | 0, m = m + Math.imul(ke, Ee) | 0, _ = _ + Math.imul(ke, pe) | 0;
      var lr = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, y = Math.imul(A, ae), m = Math.imul(A, k), m = m + Math.imul(E, ae) | 0, _ = Math.imul(E, k), y = y + Math.imul(or, Ee) | 0, m = m + Math.imul(or, pe) | 0, m = m + Math.imul(Oe, Ee) | 0, _ = _ + Math.imul(Oe, pe) | 0;
      var dr = (g + y | 0) + ((m & 8191) << 13) | 0;
      g = (_ + (m >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, y = Math.imul(A, Ee), m = Math.imul(A, pe), m = m + Math.imul(E, Ee) | 0, _ = Math.imul(E, pe);
      var wt = (g + y | 0) + ((m & 8191) << 13) | 0;
      return g = (_ + (m >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, h[0] = _e, h[1] = bt, h[2] = Te, h[3] = Re, h[4] = Dr, h[5] = vt, h[6] = pr, h[7] = Pr, h[8] = Lr, h[9] = Kr, h[10] = $r, h[11] = Fr, h[12] = Ur, h[13] = ar, h[14] = gr, h[15] = zt, h[16] = lr, h[17] = dr, h[18] = wt, g !== 0 && (h[19] = g, V.length++), V;
    };
    Math.imul || (W = L);
    function $(C, O, V) {
      V.negative = O.negative ^ C.negative, V.length = C.length + O.length;
      for (var x = 0, u = 0, h = 0; h < V.length - 1; h++) {
        var g = u;
        u = 0;
        for (var y = x & 67108863, m = Math.min(h, O.length - 1), _ = Math.max(0, h - C.length + 1); _ <= m; _++) {
          var R = h - _, b = C.words[R] | 0, l = O.words[_] | 0, v = b * l, X = v & 67108863;
          g = g + (v / 67108864 | 0) | 0, X = X + y | 0, y = X & 67108863, g = g + (X >>> 26) | 0, u += g >>> 26, g &= 67108863;
        }
        V.words[h] = y, x = g, g = u;
      }
      return x !== 0 ? V.words[h] = x : V.length--, V.strip();
    }
    function P(C, O, V) {
      var x = new U();
      return x.mulp(C, O, V);
    }
    a.prototype.mulTo = function(C, O) {
      var V, x = this.length + C.length;
      return this.length === 10 && C.length === 10 ? V = W(this, C, O) : x < 63 ? V = L(this, C, O) : x < 1024 ? V = $(this, C, O) : V = P(this, C, O), V;
    };
    function U(C, O) {
      this.x = C, this.y = O;
    }
    U.prototype.makeRBT = function(C) {
      for (var O = new Array(C), V = a.prototype._countBits(C) - 1, x = 0; x < C; x++)
        O[x] = this.revBin(x, V, C);
      return O;
    }, U.prototype.revBin = function(C, O, V) {
      if (C === 0 || C === V - 1)
        return C;
      for (var x = 0, u = 0; u < O; u++)
        x |= (C & 1) << O - u - 1, C >>= 1;
      return x;
    }, U.prototype.permute = function(C, O, V, x, u, h) {
      for (var g = 0; g < h; g++)
        x[g] = O[C[g]], u[g] = V[C[g]];
    }, U.prototype.transform = function(C, O, V, x, u, h) {
      this.permute(h, C, O, V, x, u);
      for (var g = 1; g < u; g <<= 1)
        for (var y = g << 1, m = Math.cos(2 * Math.PI / y), _ = Math.sin(2 * Math.PI / y), R = 0; R < u; R += y)
          for (var b = m, l = _, v = 0; v < g; v++) {
            var X = V[R + v], S = x[R + v], Y = V[R + v + g], fe = x[R + v + g], oe = b * Y - l * fe;
            fe = b * fe + l * Y, Y = oe, V[R + v] = X + Y, x[R + v] = S + fe, V[R + v + g] = X - Y, x[R + v + g] = S - fe, v !== y && (oe = m * b - _ * l, l = m * l + _ * b, b = oe);
          }
    }, U.prototype.guessLen13b = function(C, O) {
      var V = Math.max(O, C) | 1, x = V & 1, u = 0;
      for (V = V / 2 | 0; V; V = V >>> 1)
        u++;
      return 1 << u + 1 + x;
    }, U.prototype.conjugate = function(C, O, V) {
      if (!(V <= 1))
        for (var x = 0; x < V / 2; x++) {
          var u = C[x];
          C[x] = C[V - x - 1], C[V - x - 1] = u, u = O[x], O[x] = -O[V - x - 1], O[V - x - 1] = -u;
        }
    }, U.prototype.normalize13b = function(C, O) {
      for (var V = 0, x = 0; x < O / 2; x++) {
        var u = Math.round(C[2 * x + 1] / O) * 8192 + Math.round(C[2 * x] / O) + V;
        C[x] = u & 67108863, u < 67108864 ? V = 0 : V = u / 67108864 | 0;
      }
      return C;
    }, U.prototype.convert13b = function(C, O, V, x) {
      for (var u = 0, h = 0; h < O; h++)
        u = u + (C[h] | 0), V[2 * h] = u & 8191, u = u >>> 13, V[2 * h + 1] = u & 8191, u = u >>> 13;
      for (h = 2 * O; h < x; ++h)
        V[h] = 0;
      o(u === 0), o((u & -8192) === 0);
    }, U.prototype.stub = function(C) {
      for (var O = new Array(C), V = 0; V < C; V++)
        O[V] = 0;
      return O;
    }, U.prototype.mulp = function(C, O, V) {
      var x = 2 * this.guessLen13b(C.length, O.length), u = this.makeRBT(x), h = this.stub(x), g = new Array(x), y = new Array(x), m = new Array(x), _ = new Array(x), R = new Array(x), b = new Array(x), l = V.words;
      l.length = x, this.convert13b(C.words, C.length, g, x), this.convert13b(O.words, O.length, _, x), this.transform(g, h, y, m, x, u), this.transform(_, h, R, b, x, u);
      for (var v = 0; v < x; v++) {
        var X = y[v] * R[v] - m[v] * b[v];
        m[v] = y[v] * b[v] + m[v] * R[v], y[v] = X;
      }
      return this.conjugate(y, m, x), this.transform(y, m, l, h, x, u), this.conjugate(l, h, x), this.normalize13b(l, x), V.negative = C.negative ^ O.negative, V.length = C.length + O.length, V.strip();
    }, a.prototype.mul = function(C) {
      var O = new a(null);
      return O.words = new Array(this.length + C.length), this.mulTo(C, O);
    }, a.prototype.mulf = function(C) {
      var O = new a(null);
      return O.words = new Array(this.length + C.length), P(this, C, O);
    }, a.prototype.imul = function(C) {
      return this.clone().mulTo(C, this);
    }, a.prototype.imuln = function(C) {
      o(typeof C == "number"), o(C < 67108864);
      for (var O = 0, V = 0; V < this.length; V++) {
        var x = (this.words[V] | 0) * C, u = (x & 67108863) + (O & 67108863);
        O >>= 26, O += x / 67108864 | 0, O += u >>> 26, this.words[V] = u & 67108863;
      }
      return O !== 0 && (this.words[V] = O, this.length++), this;
    }, a.prototype.muln = function(C) {
      return this.clone().imuln(C);
    }, a.prototype.sqr = function() {
      return this.mul(this);
    }, a.prototype.isqr = function() {
      return this.imul(this.clone());
    }, a.prototype.pow = function(C) {
      var O = H(C);
      if (O.length === 0)
        return new a(1);
      for (var V = this, x = 0; x < O.length && O[x] === 0; x++, V = V.sqr())
        ;
      if (++x < O.length)
        for (var u = V.sqr(); x < O.length; x++, u = u.sqr())
          O[x] !== 0 && (V = V.mul(u));
      return V;
    }, a.prototype.iushln = function(C) {
      o(typeof C == "number" && C >= 0);
      var O = C % 26, V = (C - O) / 26, x = 67108863 >>> 26 - O << 26 - O, u;
      if (O !== 0) {
        var h = 0;
        for (u = 0; u < this.length; u++) {
          var g = this.words[u] & x, y = (this.words[u] | 0) - g << O;
          this.words[u] = y | h, h = g >>> 26 - O;
        }
        h && (this.words[u] = h, this.length++);
      }
      if (V !== 0) {
        for (u = this.length - 1; u >= 0; u--)
          this.words[u + V] = this.words[u];
        for (u = 0; u < V; u++)
          this.words[u] = 0;
        this.length += V;
      }
      return this.strip();
    }, a.prototype.ishln = function(C) {
      return o(this.negative === 0), this.iushln(C);
    }, a.prototype.iushrn = function(C, O, V) {
      o(typeof C == "number" && C >= 0);
      var x;
      O ? x = (O - O % 26) / 26 : x = 0;
      var u = C % 26, h = Math.min((C - u) / 26, this.length), g = 67108863 ^ 67108863 >>> u << u, y = V;
      if (x -= h, x = Math.max(0, x), y) {
        for (var m = 0; m < h; m++)
          y.words[m] = this.words[m];
        y.length = h;
      }
      if (h !== 0)
        if (this.length > h)
          for (this.length -= h, m = 0; m < this.length; m++)
            this.words[m] = this.words[m + h];
        else
          this.words[0] = 0, this.length = 1;
      var _ = 0;
      for (m = this.length - 1; m >= 0 && (_ !== 0 || m >= x); m--) {
        var R = this.words[m] | 0;
        this.words[m] = _ << 26 - u | R >>> u, _ = R & g;
      }
      return y && _ !== 0 && (y.words[y.length++] = _), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, a.prototype.ishrn = function(C, O, V) {
      return o(this.negative === 0), this.iushrn(C, O, V);
    }, a.prototype.shln = function(C) {
      return this.clone().ishln(C);
    }, a.prototype.ushln = function(C) {
      return this.clone().iushln(C);
    }, a.prototype.shrn = function(C) {
      return this.clone().ishrn(C);
    }, a.prototype.ushrn = function(C) {
      return this.clone().iushrn(C);
    }, a.prototype.testn = function(C) {
      o(typeof C == "number" && C >= 0);
      var O = C % 26, V = (C - O) / 26, x = 1 << O;
      if (this.length <= V)
        return !1;
      var u = this.words[V];
      return !!(u & x);
    }, a.prototype.imaskn = function(C) {
      o(typeof C == "number" && C >= 0);
      var O = C % 26, V = (C - O) / 26;
      if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= V)
        return this;
      if (O !== 0 && V++, this.length = Math.min(V, this.length), O !== 0) {
        var x = 67108863 ^ 67108863 >>> O << O;
        this.words[this.length - 1] &= x;
      }
      return this.strip();
    }, a.prototype.maskn = function(C) {
      return this.clone().imaskn(C);
    }, a.prototype.iaddn = function(C) {
      return o(typeof C == "number"), o(C < 67108864), C < 0 ? this.isubn(-C) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < C ? (this.words[0] = C - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(C), this.negative = 1, this) : this._iaddn(C);
    }, a.prototype._iaddn = function(C) {
      this.words[0] += C;
      for (var O = 0; O < this.length && this.words[O] >= 67108864; O++)
        this.words[O] -= 67108864, O === this.length - 1 ? this.words[O + 1] = 1 : this.words[O + 1]++;
      return this.length = Math.max(this.length, O + 1), this;
    }, a.prototype.isubn = function(C) {
      if (o(typeof C == "number"), o(C < 67108864), C < 0)
        return this.iaddn(-C);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(C), this.negative = 1, this;
      if (this.words[0] -= C, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var O = 0; O < this.length && this.words[O] < 0; O++)
          this.words[O] += 67108864, this.words[O + 1] -= 1;
      return this.strip();
    }, a.prototype.addn = function(C) {
      return this.clone().iaddn(C);
    }, a.prototype.subn = function(C) {
      return this.clone().isubn(C);
    }, a.prototype.iabs = function() {
      return this.negative = 0, this;
    }, a.prototype.abs = function() {
      return this.clone().iabs();
    }, a.prototype._ishlnsubmul = function(C, O, V) {
      var x = C.length + V, u;
      this._expand(x);
      var h, g = 0;
      for (u = 0; u < C.length; u++) {
        h = (this.words[u + V] | 0) + g;
        var y = (C.words[u] | 0) * O;
        h -= y & 67108863, g = (h >> 26) - (y / 67108864 | 0), this.words[u + V] = h & 67108863;
      }
      for (; u < this.length - V; u++)
        h = (this.words[u + V] | 0) + g, g = h >> 26, this.words[u + V] = h & 67108863;
      if (g === 0)
        return this.strip();
      for (o(g === -1), g = 0, u = 0; u < this.length; u++)
        h = -(this.words[u] | 0) + g, g = h >> 26, this.words[u] = h & 67108863;
      return this.negative = 1, this.strip();
    }, a.prototype._wordDiv = function(C, O) {
      var V = this.length - C.length, x = this.clone(), u = C, h = u.words[u.length - 1] | 0, g = this._countBits(h);
      V = 26 - g, V !== 0 && (u = u.ushln(V), x.iushln(V), h = u.words[u.length - 1] | 0);
      var y = x.length - u.length, m;
      if (O !== "mod") {
        m = new a(null), m.length = y + 1, m.words = new Array(m.length);
        for (var _ = 0; _ < m.length; _++)
          m.words[_] = 0;
      }
      var R = x.clone()._ishlnsubmul(u, 1, y);
      R.negative === 0 && (x = R, m && (m.words[y] = 1));
      for (var b = y - 1; b >= 0; b--) {
        var l = (x.words[u.length + b] | 0) * 67108864 + (x.words[u.length + b - 1] | 0);
        for (l = Math.min(l / h | 0, 67108863), x._ishlnsubmul(u, l, b); x.negative !== 0; )
          l--, x.negative = 0, x._ishlnsubmul(u, 1, b), x.isZero() || (x.negative ^= 1);
        m && (m.words[b] = l);
      }
      return m && m.strip(), x.strip(), O !== "div" && V !== 0 && x.iushrn(V), { div: m || null, mod: x };
    }, a.prototype.divmod = function(C, O, V) {
      if (o(!C.isZero()), this.isZero())
        return { div: new a(0), mod: new a(0) };
      var x, u, h;
      return this.negative !== 0 && C.negative === 0 ? (h = this.neg().divmod(C, O), O !== "mod" && (x = h.div.neg()), O !== "div" && (u = h.mod.neg(), V && u.negative !== 0 && u.iadd(C)), { div: x, mod: u }) : this.negative === 0 && C.negative !== 0 ? (h = this.divmod(C.neg(), O), O !== "mod" && (x = h.div.neg()), { div: x, mod: h.mod }) : (this.negative & C.negative) !== 0 ? (h = this.neg().divmod(C.neg(), O), O !== "div" && (u = h.mod.neg(), V && u.negative !== 0 && u.isub(C)), { div: h.div, mod: u }) : C.length > this.length || this.cmp(C) < 0 ? { div: new a(0), mod: this } : C.length === 1 ? O === "div" ? { div: this.divn(C.words[0]), mod: null } : O === "mod" ? { div: null, mod: new a(this.modn(C.words[0])) } : { div: this.divn(C.words[0]), mod: new a(this.modn(C.words[0])) } : this._wordDiv(C, O);
    }, a.prototype.div = function(C) {
      return this.divmod(C, "div", !1).div;
    }, a.prototype.mod = function(C) {
      return this.divmod(C, "mod", !1).mod;
    }, a.prototype.umod = function(C) {
      return this.divmod(C, "mod", !0).mod;
    }, a.prototype.divRound = function(C) {
      var O = this.divmod(C);
      if (O.mod.isZero())
        return O.div;
      var V = O.div.negative !== 0 ? O.mod.isub(C) : O.mod, x = C.ushrn(1), u = C.andln(1), h = V.cmp(x);
      return h < 0 || u === 1 && h === 0 ? O.div : O.div.negative !== 0 ? O.div.isubn(1) : O.div.iaddn(1);
    }, a.prototype.modn = function(C) {
      o(C <= 67108863);
      for (var O = (1 << 26) % C, V = 0, x = this.length - 1; x >= 0; x--)
        V = (O * V + (this.words[x] | 0)) % C;
      return V;
    }, a.prototype.idivn = function(C) {
      o(C <= 67108863);
      for (var O = 0, V = this.length - 1; V >= 0; V--) {
        var x = (this.words[V] | 0) + O * 67108864;
        this.words[V] = x / C | 0, O = x % C;
      }
      return this.strip();
    }, a.prototype.divn = function(C) {
      return this.clone().idivn(C);
    }, a.prototype.egcd = function(C) {
      o(C.negative === 0), o(!C.isZero());
      var O = this, V = C.clone();
      O.negative !== 0 ? O = O.umod(C) : O = O.clone();
      for (var x = new a(1), u = new a(0), h = new a(0), g = new a(1), y = 0; O.isEven() && V.isEven(); )
        O.iushrn(1), V.iushrn(1), ++y;
      for (var m = V.clone(), _ = O.clone(); !O.isZero(); ) {
        for (var R = 0, b = 1; (O.words[0] & b) === 0 && R < 26; ++R, b <<= 1)
          ;
        if (R > 0)
          for (O.iushrn(R); R-- > 0; )
            (x.isOdd() || u.isOdd()) && (x.iadd(m), u.isub(_)), x.iushrn(1), u.iushrn(1);
        for (var l = 0, v = 1; (V.words[0] & v) === 0 && l < 26; ++l, v <<= 1)
          ;
        if (l > 0)
          for (V.iushrn(l); l-- > 0; )
            (h.isOdd() || g.isOdd()) && (h.iadd(m), g.isub(_)), h.iushrn(1), g.iushrn(1);
        O.cmp(V) >= 0 ? (O.isub(V), x.isub(h), u.isub(g)) : (V.isub(O), h.isub(x), g.isub(u));
      }
      return { a: h, b: g, gcd: V.iushln(y) };
    }, a.prototype._invmp = function(C) {
      o(C.negative === 0), o(!C.isZero());
      var O = this, V = C.clone();
      O.negative !== 0 ? O = O.umod(C) : O = O.clone();
      for (var x = new a(1), u = new a(0), h = V.clone(); O.cmpn(1) > 0 && V.cmpn(1) > 0; ) {
        for (var g = 0, y = 1; (O.words[0] & y) === 0 && g < 26; ++g, y <<= 1)
          ;
        if (g > 0)
          for (O.iushrn(g); g-- > 0; )
            x.isOdd() && x.iadd(h), x.iushrn(1);
        for (var m = 0, _ = 1; (V.words[0] & _) === 0 && m < 26; ++m, _ <<= 1)
          ;
        if (m > 0)
          for (V.iushrn(m); m-- > 0; )
            u.isOdd() && u.iadd(h), u.iushrn(1);
        O.cmp(V) >= 0 ? (O.isub(V), x.isub(u)) : (V.isub(O), u.isub(x));
      }
      var R;
      return O.cmpn(1) === 0 ? R = x : R = u, R.cmpn(0) < 0 && R.iadd(C), R;
    }, a.prototype.gcd = function(C) {
      if (this.isZero())
        return C.abs();
      if (C.isZero())
        return this.abs();
      var O = this.clone(), V = C.clone();
      O.negative = 0, V.negative = 0;
      for (var x = 0; O.isEven() && V.isEven(); x++)
        O.iushrn(1), V.iushrn(1);
      do {
        for (; O.isEven(); )
          O.iushrn(1);
        for (; V.isEven(); )
          V.iushrn(1);
        var u = O.cmp(V);
        if (u < 0) {
          var h = O;
          O = V, V = h;
        } else if (u === 0 || V.cmpn(1) === 0)
          break;
        O.isub(V);
      } while (!0);
      return V.iushln(x);
    }, a.prototype.invm = function(C) {
      return this.egcd(C).a.umod(C);
    }, a.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, a.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, a.prototype.andln = function(C) {
      return this.words[0] & C;
    }, a.prototype.bincn = function(C) {
      o(typeof C == "number");
      var O = C % 26, V = (C - O) / 26, x = 1 << O;
      if (this.length <= V)
        return this._expand(V + 1), this.words[V] |= x, this;
      for (var u = x, h = V; u !== 0 && h < this.length; h++) {
        var g = this.words[h] | 0;
        g += u, u = g >>> 26, g &= 67108863, this.words[h] = g;
      }
      return u !== 0 && (this.words[h] = u, this.length++), this;
    }, a.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, a.prototype.cmpn = function(C) {
      var O = C < 0;
      if (this.negative !== 0 && !O)
        return -1;
      if (this.negative === 0 && O)
        return 1;
      this.strip();
      var V;
      if (this.length > 1)
        V = 1;
      else {
        O && (C = -C), o(C <= 67108863, "Number is too big");
        var x = this.words[0] | 0;
        V = x === C ? 0 : x < C ? -1 : 1;
      }
      return this.negative !== 0 ? -V | 0 : V;
    }, a.prototype.cmp = function(C) {
      if (this.negative !== 0 && C.negative === 0)
        return -1;
      if (this.negative === 0 && C.negative !== 0)
        return 1;
      var O = this.ucmp(C);
      return this.negative !== 0 ? -O | 0 : O;
    }, a.prototype.ucmp = function(C) {
      if (this.length > C.length)
        return 1;
      if (this.length < C.length)
        return -1;
      for (var O = 0, V = this.length - 1; V >= 0; V--) {
        var x = this.words[V] | 0, u = C.words[V] | 0;
        if (x !== u) {
          x < u ? O = -1 : x > u && (O = 1);
          break;
        }
      }
      return O;
    }, a.prototype.gtn = function(C) {
      return this.cmpn(C) === 1;
    }, a.prototype.gt = function(C) {
      return this.cmp(C) === 1;
    }, a.prototype.gten = function(C) {
      return this.cmpn(C) >= 0;
    }, a.prototype.gte = function(C) {
      return this.cmp(C) >= 0;
    }, a.prototype.ltn = function(C) {
      return this.cmpn(C) === -1;
    }, a.prototype.lt = function(C) {
      return this.cmp(C) === -1;
    }, a.prototype.lten = function(C) {
      return this.cmpn(C) <= 0;
    }, a.prototype.lte = function(C) {
      return this.cmp(C) <= 0;
    }, a.prototype.eqn = function(C) {
      return this.cmpn(C) === 0;
    }, a.prototype.eq = function(C) {
      return this.cmp(C) === 0;
    }, a.red = function(C) {
      return new he(C);
    }, a.prototype.toRed = function(C) {
      return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), C.convertTo(this)._forceRed(C);
    }, a.prototype.fromRed = function() {
      return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, a.prototype._forceRed = function(C) {
      return this.red = C, this;
    }, a.prototype.forceRed = function(C) {
      return o(!this.red, "Already a number in reduction context"), this._forceRed(C);
    }, a.prototype.redAdd = function(C) {
      return o(this.red, "redAdd works only with red numbers"), this.red.add(this, C);
    }, a.prototype.redIAdd = function(C) {
      return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, C);
    }, a.prototype.redSub = function(C) {
      return o(this.red, "redSub works only with red numbers"), this.red.sub(this, C);
    }, a.prototype.redISub = function(C) {
      return o(this.red, "redISub works only with red numbers"), this.red.isub(this, C);
    }, a.prototype.redShl = function(C) {
      return o(this.red, "redShl works only with red numbers"), this.red.shl(this, C);
    }, a.prototype.redMul = function(C) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, C), this.red.mul(this, C);
    }, a.prototype.redIMul = function(C) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, C), this.red.imul(this, C);
    }, a.prototype.redSqr = function() {
      return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, a.prototype.redISqr = function() {
      return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, a.prototype.redSqrt = function() {
      return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, a.prototype.redInvm = function() {
      return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, a.prototype.redNeg = function() {
      return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, a.prototype.redPow = function(C) {
      return o(this.red && !C.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, C);
    };
    var G = { k256: null, p224: null, p192: null, p25519: null };
    function D(C, O) {
      this.name = C, this.p = new a(O, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    D.prototype._tmp = function() {
      var C = new a(null);
      return C.words = new Array(Math.ceil(this.n / 13)), C;
    }, D.prototype.ireduce = function(C) {
      var O = C, V;
      do
        this.split(O, this.tmp), O = this.imulK(O), O = O.iadd(this.tmp), V = O.bitLength();
      while (V > this.n);
      var x = V < this.n ? -1 : O.ucmp(this.p);
      return x === 0 ? (O.words[0] = 0, O.length = 1) : x > 0 ? O.isub(this.p) : O.strip(), O;
    }, D.prototype.split = function(C, O) {
      C.iushrn(this.n, 0, O);
    }, D.prototype.imulK = function(C) {
      return C.imul(this.k);
    };
    function Z() {
      D.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    c(Z, D), Z.prototype.split = function(C, O) {
      for (var V = 4194303, x = Math.min(C.length, 9), u = 0; u < x; u++)
        O.words[u] = C.words[u];
      if (O.length = x, C.length <= 9) {
        C.words[0] = 0, C.length = 1;
        return;
      }
      var h = C.words[9];
      for (O.words[O.length++] = h & V, u = 10; u < C.length; u++) {
        var g = C.words[u] | 0;
        C.words[u - 10] = (g & V) << 4 | h >>> 22, h = g;
      }
      h >>>= 22, C.words[u - 10] = h, h === 0 && C.length > 10 ? C.length -= 10 : C.length -= 9;
    }, Z.prototype.imulK = function(C) {
      C.words[C.length] = 0, C.words[C.length + 1] = 0, C.length += 2;
      for (var O = 0, V = 0; V < C.length; V++) {
        var x = C.words[V] | 0;
        O += x * 977, C.words[V] = O & 67108863, O = x * 64 + (O / 67108864 | 0);
      }
      return C.words[C.length - 1] === 0 && (C.length--, C.words[C.length - 1] === 0 && C.length--), C;
    };
    function J() {
      D.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    c(J, D);
    function te() {
      D.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    c(te, D);
    function ue() {
      D.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    c(ue, D), ue.prototype.imulK = function(C) {
      for (var O = 0, V = 0; V < C.length; V++) {
        var x = (C.words[V] | 0) * 19 + O, u = x & 67108863;
        x >>>= 26, C.words[V] = u, O = x;
      }
      return O !== 0 && (C.words[C.length++] = O), C;
    }, a._prime = function(C) {
      if (G[C])
        return G[C];
      var O;
      if (C === "k256")
        O = new Z();
      else if (C === "p224")
        O = new J();
      else if (C === "p192")
        O = new te();
      else if (C === "p25519")
        O = new ue();
      else
        throw new Error("Unknown prime " + C);
      return G[C] = O, O;
    };
    function he(C) {
      if (typeof C == "string") {
        var O = a._prime(C);
        this.m = O.p, this.prime = O;
      } else
        o(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    he.prototype._verify1 = function(C) {
      o(C.negative === 0, "red works only with positives"), o(C.red, "red works only with red numbers");
    }, he.prototype._verify2 = function(C, O) {
      o((C.negative | O.negative) === 0, "red works only with positives"), o(C.red && C.red === O.red, "red works only with red numbers");
    }, he.prototype.imod = function(C) {
      return this.prime ? this.prime.ireduce(C)._forceRed(this) : C.umod(this.m)._forceRed(this);
    }, he.prototype.neg = function(C) {
      return C.isZero() ? C.clone() : this.m.sub(C)._forceRed(this);
    }, he.prototype.add = function(C, O) {
      this._verify2(C, O);
      var V = C.add(O);
      return V.cmp(this.m) >= 0 && V.isub(this.m), V._forceRed(this);
    }, he.prototype.iadd = function(C, O) {
      this._verify2(C, O);
      var V = C.iadd(O);
      return V.cmp(this.m) >= 0 && V.isub(this.m), V;
    }, he.prototype.sub = function(C, O) {
      this._verify2(C, O);
      var V = C.sub(O);
      return V.cmpn(0) < 0 && V.iadd(this.m), V._forceRed(this);
    }, he.prototype.isub = function(C, O) {
      this._verify2(C, O);
      var V = C.isub(O);
      return V.cmpn(0) < 0 && V.iadd(this.m), V;
    }, he.prototype.shl = function(C, O) {
      return this._verify1(C), this.imod(C.ushln(O));
    }, he.prototype.imul = function(C, O) {
      return this._verify2(C, O), this.imod(C.imul(O));
    }, he.prototype.mul = function(C, O) {
      return this._verify2(C, O), this.imod(C.mul(O));
    }, he.prototype.isqr = function(C) {
      return this.imul(C, C.clone());
    }, he.prototype.sqr = function(C) {
      return this.mul(C, C);
    }, he.prototype.sqrt = function(C) {
      if (C.isZero())
        return C.clone();
      var O = this.m.andln(3);
      if (o(O % 2 === 1), O === 3) {
        var V = this.m.add(new a(1)).iushrn(2);
        return this.pow(C, V);
      }
      for (var x = this.m.subn(1), u = 0; !x.isZero() && x.andln(1) === 0; )
        u++, x.iushrn(1);
      o(!x.isZero());
      var h = new a(1).toRed(this), g = h.redNeg(), y = this.m.subn(1).iushrn(1), m = this.m.bitLength();
      for (m = new a(2 * m * m).toRed(this); this.pow(m, y).cmp(g) !== 0; )
        m.redIAdd(g);
      for (var _ = this.pow(m, x), R = this.pow(C, x.addn(1).iushrn(1)), b = this.pow(C, x), l = u; b.cmp(h) !== 0; ) {
        for (var v = b, X = 0; v.cmp(h) !== 0; X++)
          v = v.redSqr();
        o(X < l);
        var S = this.pow(_, new a(1).iushln(l - X - 1));
        R = R.redMul(S), _ = S.redSqr(), b = b.redMul(_), l = X;
      }
      return R;
    }, he.prototype.invm = function(C) {
      var O = C._invmp(this.m);
      return O.negative !== 0 ? (O.negative = 0, this.imod(O).redNeg()) : this.imod(O);
    }, he.prototype.pow = function(C, O) {
      if (O.isZero())
        return new a(1).toRed(this);
      if (O.cmpn(1) === 0)
        return C.clone();
      var V = 4, x = new Array(1 << V);
      x[0] = new a(1).toRed(this), x[1] = C;
      for (var u = 2; u < x.length; u++)
        x[u] = this.mul(x[u - 1], C);
      var h = x[0], g = 0, y = 0, m = O.bitLength() % 26;
      for (m === 0 && (m = 26), u = O.length - 1; u >= 0; u--) {
        for (var _ = O.words[u], R = m - 1; R >= 0; R--) {
          var b = _ >> R & 1;
          if (h !== x[0] && (h = this.sqr(h)), b === 0 && g === 0) {
            y = 0;
            continue;
          }
          g <<= 1, g |= b, y++, !(y !== V && (u !== 0 || R !== 0)) && (h = this.mul(h, x[g]), y = 0, g = 0);
        }
        m = 26;
      }
      return h;
    }, he.prototype.convertTo = function(C) {
      var O = C.umod(this.m);
      return O === C ? O.clone() : O;
    }, he.prototype.convertFrom = function(C) {
      var O = C.clone();
      return O.red = null, O;
    }, a.mont = function(C) {
      return new Se(C);
    };
    function Se(C) {
      he.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    c(Se, he), Se.prototype.convertTo = function(C) {
      return this.imod(C.ushln(this.shift));
    }, Se.prototype.convertFrom = function(C) {
      var O = this.imod(C.mul(this.rinv));
      return O.red = null, O;
    }, Se.prototype.imul = function(C, O) {
      if (C.isZero() || O.isZero())
        return C.words[0] = 0, C.length = 1, C;
      var V = C.imul(O), x = V.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = V.isub(x).iushrn(this.shift), h = u;
      return u.cmp(this.m) >= 0 ? h = u.isub(this.m) : u.cmpn(0) < 0 && (h = u.iadd(this.m)), h._forceRed(this);
    }, Se.prototype.mul = function(C, O) {
      if (C.isZero() || O.isZero())
        return new a(0)._forceRed(this);
      var V = C.mul(O), x = V.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = V.isub(x).iushrn(this.shift), h = u;
      return u.cmp(this.m) >= 0 ? h = u.isub(this.m) : u.cmpn(0) < 0 && (h = u.iadd(this.m)), h._forceRed(this);
    }, Se.prototype.invm = function(C) {
      var O = this.imod(C._invmp(this.m).mul(this.r2));
      return O._forceRed(this);
    };
  })(n, Ue);
})(Bi);
Bi.exports;
var ec = en;
en.strict = Ni, en.loose = Li;
var tc = Object.prototype.toString, rc = { "[object Int8Array]": !0, "[object Int16Array]": !0, "[object Int32Array]": !0, "[object Uint8Array]": !0, "[object Uint8ClampedArray]": !0, "[object Uint16Array]": !0, "[object Uint32Array]": !0, "[object Float32Array]": !0, "[object Float64Array]": !0 };
function en(n) {
  return Ni(n) || Li(n);
}
function Ni(n) {
  return n instanceof Int8Array || n instanceof Int16Array || n instanceof Int32Array || n instanceof Uint8Array || n instanceof Uint8ClampedArray || n instanceof Uint16Array || n instanceof Uint32Array || n instanceof Float32Array || n instanceof Float64Array;
}
function Li(n) {
  return rc[tc.call(n)];
}
var nc = ec.strict, ic = function(n) {
  if (nc(n)) {
    var e = Buffer.from(n.buffer);
    return n.byteLength !== n.buffer.byteLength && (e = e.slice(n.byteOffset, n.byteOffset + n.byteLength)), e;
  } else
    return Buffer.from(n);
};
const Ui = "hex", Fi = "utf8";
function At(n) {
  return new Uint8Array(n);
}
function Pi(n, e = !1) {
  const t = n.toString(Ui);
  return e ? It(t) : t;
}
function oc(n) {
  return n.toString(Fi);
}
function fr(n) {
  return ic(n);
}
function Rt(n, e = !1) {
  return Pi(fr(n), e);
}
function ac(n) {
  return oc(fr(n));
}
function sc(n) {
  return Buffer.from(ot(n), Ui);
}
function kt(n) {
  return At(sc(n));
}
function tn(n) {
  return Buffer.from(n, Fi);
}
function cc(n) {
  return At(tn(n));
}
function qi(...n) {
  let e = [];
  return n.forEach((t) => e = e.concat(Array.from(t))), new Uint8Array([...e]);
}
function ot(n) {
  return n.replace(/^0x/, "");
}
function It(n) {
  return n.startsWith("0x") ? n : `0x${n}`;
}
function rn(n) {
  return fr(new Uint8Array(n));
}
function mc(n) {
  return At(n).buffer;
}
var $i = { exports: {} };
/**
* [js-sha3]{@link https://github.com/emn178/js-sha3}
*
* @version 0.8.0
* @author Chen, Yi-Cyuan [emn178@gmail.com]
* @copyright Chen, Yi-Cyuan 2015-2018
* @license MIT
*/
(function(n) {
  (function() {
    var e = "input is invalid type", t = "finalize already called", o = typeof window == "object", c = o ? window : {};
    c.JS_SHA3_NO_WINDOW && (o = !1);
    var a = !o && typeof self == "object", d = !c.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    d ? c = Ue : a && (c = self);
    var p = !c.JS_SHA3_NO_COMMON_JS && !0 && n.exports, w = !c.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", M = "0123456789abcdef".split(""), I = [31, 7936, 2031616, 520093696], B = [4, 1024, 262144, 67108864], H = [1, 256, 65536, 16777216], L = [6, 1536, 393216, 100663296], W = [0, 8, 16, 24], $ = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], P = [224, 256, 384, 512], U = [128, 256], G = ["hex", "buffer", "arrayBuffer", "array", "digest"], D = { 128: 168, 256: 136 };
    (c.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(S) {
      return Object.prototype.toString.call(S) === "[object Array]";
    }), w && (c.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(S) {
      return typeof S == "object" && S.buffer && S.buffer.constructor === ArrayBuffer;
    });
    for (var Z = function(S, Y, fe) {
      return function(oe) {
        return new l(S, Y, S).update(oe)[fe]();
      };
    }, J = function(S, Y, fe) {
      return function(oe, de) {
        return new l(S, Y, de).update(oe)[fe]();
      };
    }, te = function(S, Y, fe) {
      return function(oe, de, Ie, ye) {
        return u["cshake" + S].update(oe, de, Ie, ye)[fe]();
      };
    }, ue = function(S, Y, fe) {
      return function(oe, de, Ie, ye) {
        return u["kmac" + S].update(oe, de, Ie, ye)[fe]();
      };
    }, he = function(S, Y, fe, oe) {
      for (var de = 0; de < G.length; ++de) {
        var Ie = G[de];
        S[Ie] = Y(fe, oe, Ie);
      }
      return S;
    }, Se = function(S, Y) {
      var fe = Z(S, Y, "hex");
      return fe.create = function() {
        return new l(S, Y, S);
      }, fe.update = function(oe) {
        return fe.create().update(oe);
      }, he(fe, Z, S, Y);
    }, C = function(S, Y) {
      var fe = J(S, Y, "hex");
      return fe.create = function(oe) {
        return new l(S, Y, oe);
      }, fe.update = function(oe, de) {
        return fe.create(de).update(oe);
      }, he(fe, J, S, Y);
    }, O = function(S, Y) {
      var fe = D[S], oe = te(S, Y, "hex");
      return oe.create = function(de, Ie, ye) {
        return !Ie && !ye ? u["shake" + S].create(de) : new l(S, Y, de).bytepad([Ie, ye], fe);
      }, oe.update = function(de, Ie, ye, be) {
        return oe.create(Ie, ye, be).update(de);
      }, he(oe, te, S, Y);
    }, V = function(S, Y) {
      var fe = D[S], oe = ue(S, Y, "hex");
      return oe.create = function(de, Ie, ye) {
        return new v(S, Y, Ie).bytepad(["KMAC", ye], fe).bytepad([de], fe);
      }, oe.update = function(de, Ie, ye, be) {
        return oe.create(de, ye, be).update(Ie);
      }, he(oe, ue, S, Y);
    }, x = [{ name: "keccak", padding: H, bits: P, createMethod: Se }, { name: "sha3", padding: L, bits: P, createMethod: Se }, { name: "shake", padding: I, bits: U, createMethod: C }, { name: "cshake", padding: B, bits: U, createMethod: O }, { name: "kmac", padding: B, bits: U, createMethod: V }], u = {}, h = [], g = 0; g < x.length; ++g)
      for (var y = x[g], m = y.bits, _ = 0; _ < m.length; ++_) {
        var R = y.name + "_" + m[_];
        if (h.push(R), u[R] = y.createMethod(m[_], y.padding), y.name !== "sha3") {
          var b = y.name + m[_];
          h.push(b), u[b] = u[R];
        }
      }
    function l(S, Y, fe) {
      this.blocks = [], this.s = [], this.padding = Y, this.outputBits = fe, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (S << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = fe >> 5, this.extraBytes = (fe & 31) >> 3;
      for (var oe = 0; oe < 50; ++oe)
        this.s[oe] = 0;
    }
    l.prototype.update = function(S) {
      if (this.finalized)
        throw new Error(t);
      var Y, fe = typeof S;
      if (fe !== "string") {
        if (fe === "object") {
          if (S === null)
            throw new Error(e);
          if (w && S.constructor === ArrayBuffer)
            S = new Uint8Array(S);
          else if (!Array.isArray(S) && (!w || !ArrayBuffer.isView(S)))
            throw new Error(e);
        } else
          throw new Error(e);
        Y = !0;
      }
      for (var oe = this.blocks, de = this.byteCount, Ie = S.length, ye = this.blockCount, be = 0, rt = this.s, xe, Ne; be < Ie; ) {
        if (this.reset)
          for (this.reset = !1, oe[0] = this.block, xe = 1; xe < ye + 1; ++xe)
            oe[xe] = 0;
        if (Y)
          for (xe = this.start; be < Ie && xe < de; ++be)
            oe[xe >> 2] |= S[be] << W[xe++ & 3];
        else
          for (xe = this.start; be < Ie && xe < de; ++be)
            Ne = S.charCodeAt(be), Ne < 128 ? oe[xe >> 2] |= Ne << W[xe++ & 3] : Ne < 2048 ? (oe[xe >> 2] |= (192 | Ne >> 6) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne & 63) << W[xe++ & 3]) : Ne < 55296 || Ne >= 57344 ? (oe[xe >> 2] |= (224 | Ne >> 12) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne >> 6 & 63) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne & 63) << W[xe++ & 3]) : (Ne = 65536 + ((Ne & 1023) << 10 | S.charCodeAt(++be) & 1023), oe[xe >> 2] |= (240 | Ne >> 18) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne >> 12 & 63) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne >> 6 & 63) << W[xe++ & 3], oe[xe >> 2] |= (128 | Ne & 63) << W[xe++ & 3]);
        if (this.lastByteIndex = xe, xe >= de) {
          for (this.start = xe - de, this.block = oe[ye], xe = 0; xe < ye; ++xe)
            rt[xe] ^= oe[xe];
          X(rt), this.reset = !0;
        } else
          this.start = xe;
      }
      return this;
    }, l.prototype.encode = function(S, Y) {
      var fe = S & 255, oe = 1, de = [fe];
      for (S = S >> 8, fe = S & 255; fe > 0; )
        de.unshift(fe), S = S >> 8, fe = S & 255, ++oe;
      return Y ? de.push(oe) : de.unshift(oe), this.update(de), de.length;
    }, l.prototype.encodeString = function(S) {
      var Y, fe = typeof S;
      if (fe !== "string") {
        if (fe === "object") {
          if (S === null)
            throw new Error(e);
          if (w && S.constructor === ArrayBuffer)
            S = new Uint8Array(S);
          else if (!Array.isArray(S) && (!w || !ArrayBuffer.isView(S)))
            throw new Error(e);
        } else
          throw new Error(e);
        Y = !0;
      }
      var oe = 0, de = S.length;
      if (Y)
        oe = de;
      else
        for (var Ie = 0; Ie < S.length; ++Ie) {
          var ye = S.charCodeAt(Ie);
          ye < 128 ? oe += 1 : ye < 2048 ? oe += 2 : ye < 55296 || ye >= 57344 ? oe += 3 : (ye = 65536 + ((ye & 1023) << 10 | S.charCodeAt(++Ie) & 1023), oe += 4);
        }
      return oe += this.encode(oe * 8), this.update(S), oe;
    }, l.prototype.bytepad = function(S, Y) {
      for (var fe = this.encode(Y), oe = 0; oe < S.length; ++oe)
        fe += this.encodeString(S[oe]);
      var de = Y - fe % Y, Ie = [];
      return Ie.length = de, this.update(Ie), this;
    }, l.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var S = this.blocks, Y = this.lastByteIndex, fe = this.blockCount, oe = this.s;
        if (S[Y >> 2] |= this.padding[Y & 3], this.lastByteIndex === this.byteCount)
          for (S[0] = S[fe], Y = 1; Y < fe + 1; ++Y)
            S[Y] = 0;
        for (S[fe - 1] |= 2147483648, Y = 0; Y < fe; ++Y)
          oe[Y] ^= S[Y];
        X(oe);
      }
    }, l.prototype.toString = l.prototype.hex = function() {
      this.finalize();
      for (var S = this.blockCount, Y = this.s, fe = this.outputBlocks, oe = this.extraBytes, de = 0, Ie = 0, ye = "", be; Ie < fe; ) {
        for (de = 0; de < S && Ie < fe; ++de, ++Ie)
          be = Y[de], ye += M[be >> 4 & 15] + M[be & 15] + M[be >> 12 & 15] + M[be >> 8 & 15] + M[be >> 20 & 15] + M[be >> 16 & 15] + M[be >> 28 & 15] + M[be >> 24 & 15];
        Ie % S === 0 && (X(Y), de = 0);
      }
      return oe && (be = Y[de], ye += M[be >> 4 & 15] + M[be & 15], oe > 1 && (ye += M[be >> 12 & 15] + M[be >> 8 & 15]), oe > 2 && (ye += M[be >> 20 & 15] + M[be >> 16 & 15])), ye;
    }, l.prototype.arrayBuffer = function() {
      this.finalize();
      var S = this.blockCount, Y = this.s, fe = this.outputBlocks, oe = this.extraBytes, de = 0, Ie = 0, ye = this.outputBits >> 3, be;
      oe ? be = new ArrayBuffer(fe + 1 << 2) : be = new ArrayBuffer(ye);
      for (var rt = new Uint32Array(be); Ie < fe; ) {
        for (de = 0; de < S && Ie < fe; ++de, ++Ie)
          rt[Ie] = Y[de];
        Ie % S === 0 && X(Y);
      }
      return oe && (rt[de] = Y[de], be = be.slice(0, ye)), be;
    }, l.prototype.buffer = l.prototype.arrayBuffer, l.prototype.digest = l.prototype.array = function() {
      this.finalize();
      for (var S = this.blockCount, Y = this.s, fe = this.outputBlocks, oe = this.extraBytes, de = 0, Ie = 0, ye = [], be, rt; Ie < fe; ) {
        for (de = 0; de < S && Ie < fe; ++de, ++Ie)
          be = Ie << 2, rt = Y[de], ye[be] = rt & 255, ye[be + 1] = rt >> 8 & 255, ye[be + 2] = rt >> 16 & 255, ye[be + 3] = rt >> 24 & 255;
        Ie % S === 0 && X(Y);
      }
      return oe && (be = Ie << 2, rt = Y[de], ye[be] = rt & 255, oe > 1 && (ye[be + 1] = rt >> 8 & 255), oe > 2 && (ye[be + 2] = rt >> 16 & 255)), ye;
    };
    function v(S, Y, fe) {
      l.call(this, S, Y, fe);
    }
    v.prototype = new l(), v.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), l.prototype.finalize.call(this);
    };
    var X = function(S) {
      var Y, fe, oe, de, Ie, ye, be, rt, xe, Ne, j, z, ee, ve, me, Ae, it, ke, qe, or, Oe, T, A, E, F, ie, ne, ce, nt, Be, Ce, _t, Me, pt, qr, Xe, yt, Zr, He, dt, Hr, Ze, mt, zr, Qe, tt, Wr, q, Q, ae, k, re, Ee, pe, _e, bt, Te, Re, Dr, vt, pr, Pr, Lr;
      for (oe = 0; oe < 48; oe += 2)
        de = S[0] ^ S[10] ^ S[20] ^ S[30] ^ S[40], Ie = S[1] ^ S[11] ^ S[21] ^ S[31] ^ S[41], ye = S[2] ^ S[12] ^ S[22] ^ S[32] ^ S[42], be = S[3] ^ S[13] ^ S[23] ^ S[33] ^ S[43], rt = S[4] ^ S[14] ^ S[24] ^ S[34] ^ S[44], xe = S[5] ^ S[15] ^ S[25] ^ S[35] ^ S[45], Ne = S[6] ^ S[16] ^ S[26] ^ S[36] ^ S[46], j = S[7] ^ S[17] ^ S[27] ^ S[37] ^ S[47], z = S[8] ^ S[18] ^ S[28] ^ S[38] ^ S[48], ee = S[9] ^ S[19] ^ S[29] ^ S[39] ^ S[49], Y = z ^ (ye << 1 | be >>> 31), fe = ee ^ (be << 1 | ye >>> 31), S[0] ^= Y, S[1] ^= fe, S[10] ^= Y, S[11] ^= fe, S[20] ^= Y, S[21] ^= fe, S[30] ^= Y, S[31] ^= fe, S[40] ^= Y, S[41] ^= fe, Y = de ^ (rt << 1 | xe >>> 31), fe = Ie ^ (xe << 1 | rt >>> 31), S[2] ^= Y, S[3] ^= fe, S[12] ^= Y, S[13] ^= fe, S[22] ^= Y, S[23] ^= fe, S[32] ^= Y, S[33] ^= fe, S[42] ^= Y, S[43] ^= fe, Y = ye ^ (Ne << 1 | j >>> 31), fe = be ^ (j << 1 | Ne >>> 31), S[4] ^= Y, S[5] ^= fe, S[14] ^= Y, S[15] ^= fe, S[24] ^= Y, S[25] ^= fe, S[34] ^= Y, S[35] ^= fe, S[44] ^= Y, S[45] ^= fe, Y = rt ^ (z << 1 | ee >>> 31), fe = xe ^ (ee << 1 | z >>> 31), S[6] ^= Y, S[7] ^= fe, S[16] ^= Y, S[17] ^= fe, S[26] ^= Y, S[27] ^= fe, S[36] ^= Y, S[37] ^= fe, S[46] ^= Y, S[47] ^= fe, Y = Ne ^ (de << 1 | Ie >>> 31), fe = j ^ (Ie << 1 | de >>> 31), S[8] ^= Y, S[9] ^= fe, S[18] ^= Y, S[19] ^= fe, S[28] ^= Y, S[29] ^= fe, S[38] ^= Y, S[39] ^= fe, S[48] ^= Y, S[49] ^= fe, ve = S[0], me = S[1], tt = S[11] << 4 | S[10] >>> 28, Wr = S[10] << 4 | S[11] >>> 28, ce = S[20] << 3 | S[21] >>> 29, nt = S[21] << 3 | S[20] >>> 29, vt = S[31] << 9 | S[30] >>> 23, pr = S[30] << 9 | S[31] >>> 23, Ze = S[40] << 18 | S[41] >>> 14, mt = S[41] << 18 | S[40] >>> 14, pt = S[2] << 1 | S[3] >>> 31, qr = S[3] << 1 | S[2] >>> 31, Ae = S[13] << 12 | S[12] >>> 20, it = S[12] << 12 | S[13] >>> 20, q = S[22] << 10 | S[23] >>> 22, Q = S[23] << 10 | S[22] >>> 22, Be = S[33] << 13 | S[32] >>> 19, Ce = S[32] << 13 | S[33] >>> 19, Pr = S[42] << 2 | S[43] >>> 30, Lr = S[43] << 2 | S[42] >>> 30, pe = S[5] << 30 | S[4] >>> 2, _e = S[4] << 30 | S[5] >>> 2, Xe = S[14] << 6 | S[15] >>> 26, yt = S[15] << 6 | S[14] >>> 26, ke = S[25] << 11 | S[24] >>> 21, qe = S[24] << 11 | S[25] >>> 21, ae = S[34] << 15 | S[35] >>> 17, k = S[35] << 15 | S[34] >>> 17, _t = S[45] << 29 | S[44] >>> 3, Me = S[44] << 29 | S[45] >>> 3, E = S[6] << 28 | S[7] >>> 4, F = S[7] << 28 | S[6] >>> 4, bt = S[17] << 23 | S[16] >>> 9, Te = S[16] << 23 | S[17] >>> 9, Zr = S[26] << 25 | S[27] >>> 7, He = S[27] << 25 | S[26] >>> 7, or = S[36] << 21 | S[37] >>> 11, Oe = S[37] << 21 | S[36] >>> 11, re = S[47] << 24 | S[46] >>> 8, Ee = S[46] << 24 | S[47] >>> 8, zr = S[8] << 27 | S[9] >>> 5, Qe = S[9] << 27 | S[8] >>> 5, ie = S[18] << 20 | S[19] >>> 12, ne = S[19] << 20 | S[18] >>> 12, Re = S[29] << 7 | S[28] >>> 25, Dr = S[28] << 7 | S[29] >>> 25, dt = S[38] << 8 | S[39] >>> 24, Hr = S[39] << 8 | S[38] >>> 24, T = S[48] << 14 | S[49] >>> 18, A = S[49] << 14 | S[48] >>> 18, S[0] = ve ^ ~Ae & ke, S[1] = me ^ ~it & qe, S[10] = E ^ ~ie & ce, S[11] = F ^ ~ne & nt, S[20] = pt ^ ~Xe & Zr, S[21] = qr ^ ~yt & He, S[30] = zr ^ ~tt & q, S[31] = Qe ^ ~Wr & Q, S[40] = pe ^ ~bt & Re, S[41] = _e ^ ~Te & Dr, S[2] = Ae ^ ~ke & or, S[3] = it ^ ~qe & Oe, S[12] = ie ^ ~ce & Be, S[13] = ne ^ ~nt & Ce, S[22] = Xe ^ ~Zr & dt, S[23] = yt ^ ~He & Hr, S[32] = tt ^ ~q & ae, S[33] = Wr ^ ~Q & k, S[42] = bt ^ ~Re & vt, S[43] = Te ^ ~Dr & pr, S[4] = ke ^ ~or & T, S[5] = qe ^ ~Oe & A, S[14] = ce ^ ~Be & _t, S[15] = nt ^ ~Ce & Me, S[24] = Zr ^ ~dt & Ze, S[25] = He ^ ~Hr & mt, S[34] = q ^ ~ae & re, S[35] = Q ^ ~k & Ee, S[44] = Re ^ ~vt & Pr, S[45] = Dr ^ ~pr & Lr, S[6] = or ^ ~T & ve, S[7] = Oe ^ ~A & me, S[16] = Be ^ ~_t & E, S[17] = Ce ^ ~Me & F, S[26] = dt ^ ~Ze & pt, S[27] = Hr ^ ~mt & qr, S[36] = ae ^ ~re & zr, S[37] = k ^ ~Ee & Qe, S[46] = vt ^ ~Pr & pe, S[47] = pr ^ ~Lr & _e, S[8] = T ^ ~ve & Ae, S[9] = A ^ ~me & it, S[18] = _t ^ ~E & ie, S[19] = Me ^ ~F & ne, S[28] = Ze ^ ~pt & Xe, S[29] = mt ^ ~qr & yt, S[38] = re ^ ~zr & tt, S[39] = Ee ^ ~Qe & Wr, S[48] = Pr ^ ~pe & bt, S[49] = Lr ^ ~_e & Te, S[0] ^= $[oe], S[1] ^= $[oe + 1];
    };
    if (p)
      n.exports = u;
    else
      for (g = 0; g < h.length; ++g)
        c[h[g]] = u[h[g]];
  })();
})($i);
var Tt = {}, at = {};
Object.defineProperty(at, "__esModule", { value: !0 }), at.isBrowserCryptoAvailable = at.getSubtleCrypto = at.getBrowerCrypto = void 0;
function nn() {
  return (Ue == null ? void 0 : Ue.crypto) || (Ue == null ? void 0 : Ue.msCrypto) || {};
}
at.getBrowerCrypto = nn;
function Wi() {
  const n = nn();
  return n.subtle || n.webkitSubtle;
}
at.getSubtleCrypto = Wi;
function bc() {
  return !!nn() && !!Wi();
}
at.isBrowserCryptoAvailable = bc;
var st = {};
Object.defineProperty(st, "__esModule", { value: !0 }), st.isBrowser = st.isNode = st.isReactNative = void 0;
function ji() {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
}
st.isReactNative = ji;
function zi() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
st.isNode = zi;
function xc() {
  return !ji() && !zi();
}
st.isBrowser = xc, function(n) {
  var e = Ue && Ue.__createBinding || (Object.create ? function(o, c, a, d) {
    d === void 0 && (d = a), Object.defineProperty(o, d, { enumerable: !0, get: function() {
      return c[a];
    } });
  } : function(o, c, a, d) {
    d === void 0 && (d = a), o[d] = c[a];
  }), t = Ue && Ue.__exportStar || function(o, c) {
    for (var a in o)
      a !== "default" && !c.hasOwnProperty(a) && e(c, o, a);
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), t(at, n), t(st, n);
}(Tt);
var cn = {}, Lc = (n) => encodeURIComponent(n).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), Vi = "%[a-f0-9]{2}", Yi = new RegExp(Vi, "gi"), Gi = new RegExp("(" + Vi + ")+", "gi");
function hn(n, e) {
  try {
    return decodeURIComponent(n.join(""));
  } catch {
  }
  if (n.length === 1)
    return n;
  e = e || 1;
  var t = n.slice(0, e), o = n.slice(e);
  return Array.prototype.concat.call([], hn(t), hn(o));
}
function Uc(n) {
  try {
    return decodeURIComponent(n);
  } catch {
    for (var e = n.match(Yi), t = 1; t < e.length; t++)
      n = hn(e, t).join(""), e = n.match(Yi);
    return n;
  }
}
function Fc(n) {
  for (var e = { "%FE%FF": "\uFFFD\uFFFD", "%FF%FE": "\uFFFD\uFFFD" }, t = Gi.exec(n); t; ) {
    try {
      e[t[0]] = decodeURIComponent(t[0]);
    } catch {
      var o = Uc(t[0]);
      o !== t[0] && (e[t[0]] = o);
    }
    t = Gi.exec(n);
  }
  e["%C2"] = "\uFFFD";
  for (var c = Object.keys(e), a = 0; a < c.length; a++) {
    var d = c[a];
    n = n.replace(new RegExp(d, "g"), e[d]);
  }
  return n;
}
var Pc = function(n) {
  if (typeof n != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof n + "`");
  try {
    return n = n.replace(/\+/g, " "), decodeURIComponent(n);
  } catch {
    return Fc(n);
  }
}, qc = (n, e) => {
  if (!(typeof n == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [n];
  const t = n.indexOf(e);
  return t === -1 ? [n] : [n.slice(0, t), n.slice(t + e.length)];
};
(function(n) {
  const e = Lc, t = Pc, o = qc, c = (P) => P == null;
  function a(P) {
    switch (P.arrayFormat) {
      case "index":
        return (U) => (G, D) => {
          const Z = G.length;
          return D === void 0 || P.skipNull && D === null || P.skipEmptyString && D === "" ? G : D === null ? [...G, [w(U, P), "[", Z, "]"].join("")] : [...G, [w(U, P), "[", w(Z, P), "]=", w(D, P)].join("")];
        };
      case "bracket":
        return (U) => (G, D) => D === void 0 || P.skipNull && D === null || P.skipEmptyString && D === "" ? G : D === null ? [...G, [w(U, P), "[]"].join("")] : [...G, [w(U, P), "[]=", w(D, P)].join("")];
      case "comma":
      case "separator":
        return (U) => (G, D) => D == null || D.length === 0 ? G : G.length === 0 ? [[w(U, P), "=", w(D, P)].join("")] : [[G, w(D, P)].join(P.arrayFormatSeparator)];
      default:
        return (U) => (G, D) => D === void 0 || P.skipNull && D === null || P.skipEmptyString && D === "" ? G : D === null ? [...G, w(U, P)] : [...G, [w(U, P), "=", w(D, P)].join("")];
    }
  }
  function d(P) {
    let U;
    switch (P.arrayFormat) {
      case "index":
        return (G, D, Z) => {
          if (U = /\[(\d*)\]$/.exec(G), G = G.replace(/\[\d*\]$/, ""), !U) {
            Z[G] = D;
            return;
          }
          Z[G] === void 0 && (Z[G] = {}), Z[G][U[1]] = D;
        };
      case "bracket":
        return (G, D, Z) => {
          if (U = /(\[\])$/.exec(G), G = G.replace(/\[\]$/, ""), !U) {
            Z[G] = D;
            return;
          }
          if (Z[G] === void 0) {
            Z[G] = [D];
            return;
          }
          Z[G] = [].concat(Z[G], D);
        };
      case "comma":
      case "separator":
        return (G, D, Z) => {
          const J = typeof D == "string" && D.split("").indexOf(P.arrayFormatSeparator) > -1 ? D.split(P.arrayFormatSeparator).map((te) => M(te, P)) : D === null ? D : M(D, P);
          Z[G] = J;
        };
      default:
        return (G, D, Z) => {
          if (Z[G] === void 0) {
            Z[G] = D;
            return;
          }
          Z[G] = [].concat(Z[G], D);
        };
    }
  }
  function p(P) {
    if (typeof P != "string" || P.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function w(P, U) {
    return U.encode ? U.strict ? e(P) : encodeURIComponent(P) : P;
  }
  function M(P, U) {
    return U.decode ? t(P) : P;
  }
  function I(P) {
    return Array.isArray(P) ? P.sort() : typeof P == "object" ? I(Object.keys(P)).sort((U, G) => Number(U) - Number(G)).map((U) => P[U]) : P;
  }
  function B(P) {
    const U = P.indexOf("#");
    return U !== -1 && (P = P.slice(0, U)), P;
  }
  function H(P) {
    let U = "";
    const G = P.indexOf("#");
    return G !== -1 && (U = P.slice(G)), U;
  }
  function L(P) {
    P = B(P);
    const U = P.indexOf("?");
    return U === -1 ? "" : P.slice(U + 1);
  }
  function W(P, U) {
    return U.parseNumbers && !Number.isNaN(Number(P)) && typeof P == "string" && P.trim() !== "" ? P = Number(P) : U.parseBooleans && P !== null && (P.toLowerCase() === "true" || P.toLowerCase() === "false") && (P = P.toLowerCase() === "true"), P;
  }
  function $(P, U) {
    U = Object.assign({ decode: !0, sort: !0, arrayFormat: "none", arrayFormatSeparator: ",", parseNumbers: !1, parseBooleans: !1 }, U), p(U.arrayFormatSeparator);
    const G = d(U), D = /* @__PURE__ */ Object.create(null);
    if (typeof P != "string" || (P = P.trim().replace(/^[?#&]/, ""), !P))
      return D;
    for (const Z of P.split("&")) {
      let [J, te] = o(U.decode ? Z.replace(/\+/g, " ") : Z, "=");
      te = te === void 0 ? null : ["comma", "separator"].includes(U.arrayFormat) ? te : M(te, U), G(M(J, U), te, D);
    }
    for (const Z of Object.keys(D)) {
      const J = D[Z];
      if (typeof J == "object" && J !== null)
        for (const te of Object.keys(J))
          J[te] = W(J[te], U);
      else
        D[Z] = W(J, U);
    }
    return U.sort === !1 ? D : (U.sort === !0 ? Object.keys(D).sort() : Object.keys(D).sort(U.sort)).reduce((Z, J) => {
      const te = D[J];
      return Boolean(te) && typeof te == "object" && !Array.isArray(te) ? Z[J] = I(te) : Z[J] = te, Z;
    }, /* @__PURE__ */ Object.create(null));
  }
  n.extract = L, n.parse = $, n.stringify = (P, U) => {
    if (!P)
      return "";
    U = Object.assign({ encode: !0, strict: !0, arrayFormat: "none", arrayFormatSeparator: "," }, U), p(U.arrayFormatSeparator);
    const G = (te) => U.skipNull && c(P[te]) || U.skipEmptyString && P[te] === "", D = a(U), Z = {};
    for (const te of Object.keys(P))
      G(te) || (Z[te] = P[te]);
    const J = Object.keys(Z);
    return U.sort !== !1 && J.sort(U.sort), J.map((te) => {
      const ue = P[te];
      return ue === void 0 ? "" : ue === null ? w(te, U) : Array.isArray(ue) ? ue.reduce(D(te), []).join("&") : w(te, U) + "=" + w(ue, U);
    }).filter((te) => te.length > 0).join("&");
  }, n.parseUrl = (P, U) => {
    U = Object.assign({ decode: !0 }, U);
    const [G, D] = o(P, "#");
    return Object.assign({ url: G.split("?")[0] || "", query: $(L(P), U) }, U && U.parseFragmentIdentifier && D ? { fragmentIdentifier: M(D, U) } : {});
  }, n.stringifyUrl = (P, U) => {
    U = Object.assign({ encode: !0, strict: !0 }, U);
    const G = B(P.url).split("?")[0] || "", D = n.extract(P.url), Z = n.parse(D, { sort: !1 }), J = Object.assign(Z, P.query);
    let te = n.stringify(J, U);
    te && (te = `?${te}`);
    let ue = H(P.url);
    return P.fragmentIdentifier && (ue = `#${w(P.fragmentIdentifier, U)}`), `${G}${te}${ue}`;
  };
})(cn);
typeof global.WebSocket < "u" ? global.WebSocket : require("ws");
const sh = "abcdefghijklmnopqrstuvwxyz0123456789";
sh.split("").map((n) => `https://${n}.bridge.walletconnect.org`);
function gh(n) {
  return Tt.getBrowerCrypto().getRandomValues(new Uint8Array(n));
}
const to = 256, ro = to, _h = to, ct = "AES-CBC", mh = `SHA-${ro}`, ln = "HMAC", vh = "encrypt", yh = "decrypt", wh = "sign", bh = "verify";
function xh(n) {
  return n === ct ? { length: ro, name: ct } : { hash: { name: mh }, name: ln };
}
function Mh(n) {
  return n === ct ? [vh, yh] : [wh, bh];
}
async function fn(n, e = ct) {
  return Tt.getSubtleCrypto().importKey("raw", n, xh(e), !0, Mh(e));
}
async function Eh(n, e, t) {
  const o = Tt.getSubtleCrypto(), c = await fn(e, ct), a = await o.encrypt({ iv: n, name: ct }, c, t);
  return new Uint8Array(a);
}
async function Ch(n, e, t) {
  const o = Tt.getSubtleCrypto(), c = await fn(e, ct), a = await o.decrypt({ iv: n, name: ct }, c, t);
  return new Uint8Array(a);
}
async function Sh(n, e) {
  const t = Tt.getSubtleCrypto(), o = await fn(n, ln), c = await t.sign({ length: _h, name: ln }, o, e);
  return new Uint8Array(c);
}
function Ah(n, e, t) {
  return Eh(n, e, t);
}
function Rh(n, e, t) {
  return Ch(n, e, t);
}
async function no(n, e) {
  return await Sh(n, e);
}
async function io(n) {
  const e = (n || 256) / 8, t = gh(e);
  return mc(fr(t));
}
async function oo(n, e) {
  const t = kt(n.data), o = kt(n.iv), c = kt(n.hmac), a = Rt(c, !1), d = qi(t, o), p = await no(e, d), w = Rt(p, !1);
  return ot(a) === ot(w);
}
async function kh(n, e, t) {
  const o = At(rn(e)), c = t || await io(128), a = At(rn(c)), d = Rt(a, !1), p = JSON.stringify(n), w = cc(p), M = await Ah(a, o, w), I = Rt(M, !1), B = qi(M, a), H = await no(o, B), L = Rt(H, !1);
  return { data: I, hmac: L, iv: d };
}
async function Ih(n, e) {
  const t = At(rn(e));
  if (!t)
    throw new Error("Missing key: required for decryption");
  if (!await oo(n, t))
    return null;
  const o = kt(n.data), c = kt(n.iv), a = await Rh(c, t, o), d = ac(a);
  let p;
  try {
    p = JSON.parse(d);
  } catch {
    return null;
  }
  return p;
}
Object.freeze({ __proto__: null, generateKey: io, verifyHmac: oo, encrypt: kh, decrypt: Ih });
Jr(Js);
var Kt = {}, Nh = function() {
  return typeof Promise == "function" && Promise.prototype && Promise.prototype.then;
}, ao = {}, ht = {}, Lh = {}.toString, dn = Array.isArray || function(n) {
  return Lh.call(n) == "[object Array]";
}, Uh = dn;
function Fh() {
  try {
    var n = new Uint8Array(1);
    return n.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
      return 42;
    } }, n.foo() === 42;
  } catch {
    return !1;
  }
}
le.TYPED_ARRAY_SUPPORT = Fh();
var so = le.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
function le(n, e, t) {
  return !le.TYPED_ARRAY_SUPPORT && !(this instanceof le) ? new le(n, e, t) : typeof n == "number" ? co(this, n) : jh(this, n, e, t);
}
le.TYPED_ARRAY_SUPPORT && (le.prototype.__proto__ = Uint8Array.prototype, le.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && le[Symbol.species] === le && Object.defineProperty(le, Symbol.species, { value: null, configurable: !0, enumerable: !1, writable: !1 }));
function pn(n) {
  if (n >= so)
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + so.toString(16) + " bytes");
  return n | 0;
}
function Ph(n) {
  return n !== n;
}
function Ot(n, e) {
  var t;
  return le.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e), t.__proto__ = le.prototype) : (t = n, t === null && (t = new le(e)), t.length = e), t;
}
function co(n, e) {
  var t = Ot(n, e < 0 ? 0 : pn(e) | 0);
  if (!le.TYPED_ARRAY_SUPPORT)
    for (var o = 0; o < e; ++o)
      t[o] = 0;
  return t;
}
function qh(n, e) {
  var t = uo(e) | 0, o = Ot(n, t), c = o.write(e);
  return c !== t && (o = o.slice(0, c)), o;
}
function gn(n, e) {
  for (var t = e.length < 0 ? 0 : pn(e.length) | 0, o = Ot(n, t), c = 0; c < t; c += 1)
    o[c] = e[c] & 255;
  return o;
}
function Dh(n, e, t, o) {
  if (t < 0 || e.byteLength < t)
    throw new RangeError("'offset' is out of bounds");
  if (e.byteLength < t + (o || 0))
    throw new RangeError("'length' is out of bounds");
  var c;
  return t === void 0 && o === void 0 ? c = new Uint8Array(e) : o === void 0 ? c = new Uint8Array(e, t) : c = new Uint8Array(e, t, o), le.TYPED_ARRAY_SUPPORT ? c.__proto__ = le.prototype : c = gn(n, c), c;
}
function Hh(n, e) {
  if (le.isBuffer(e)) {
    var t = pn(e.length) | 0, o = Ot(n, t);
    return o.length === 0 || e.copy(o, 0, 0, t), o;
  }
  if (e) {
    if (typeof ArrayBuffer < "u" && e.buffer instanceof ArrayBuffer || "length" in e)
      return typeof e.length != "number" || Ph(e.length) ? Ot(n, 0) : gn(n, e);
    if (e.type === "Buffer" && Array.isArray(e.data))
      return gn(n, e.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function ho(n, e) {
  e = e || 1 / 0;
  for (var t, o = n.length, c = null, a = [], d = 0; d < o; ++d) {
    if (t = n.charCodeAt(d), t > 55295 && t < 57344) {
      if (!c) {
        if (t > 56319) {
          (e -= 3) > -1 && a.push(239, 191, 189);
          continue;
        } else if (d + 1 === o) {
          (e -= 3) > -1 && a.push(239, 191, 189);
          continue;
        }
        c = t;
        continue;
      }
      if (t < 56320) {
        (e -= 3) > -1 && a.push(239, 191, 189), c = t;
        continue;
      }
      t = (c - 55296 << 10 | t - 56320) + 65536;
    } else
      c && (e -= 3) > -1 && a.push(239, 191, 189);
    if (c = null, t < 128) {
      if ((e -= 1) < 0)
        break;
      a.push(t);
    } else if (t < 2048) {
      if ((e -= 2) < 0)
        break;
      a.push(t >> 6 | 192, t & 63 | 128);
    } else if (t < 65536) {
      if ((e -= 3) < 0)
        break;
      a.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
    } else if (t < 1114112) {
      if ((e -= 4) < 0)
        break;
      a.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
    } else
      throw new Error("Invalid code point");
  }
  return a;
}
function uo(n) {
  if (le.isBuffer(n))
    return n.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(n) || n instanceof ArrayBuffer))
    return n.byteLength;
  typeof n != "string" && (n = "" + n);
  var e = n.length;
  return e === 0 ? 0 : ho(n).length;
}
function $h(n, e, t, o) {
  for (var c = 0; c < o && !(c + t >= e.length || c >= n.length); ++c)
    e[c + t] = n[c];
  return c;
}
function Wh(n, e, t, o) {
  return $h(ho(e, n.length - t), n, t, o);
}
function jh(n, e, t, o) {
  if (typeof e == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer ? Dh(n, e, t, o) : typeof e == "string" ? qh(n, e) : Hh(n, e);
}
le.prototype.write = function(n, e, t) {
  e === void 0 ? (t = this.length, e = 0) : t === void 0 && typeof e == "string" ? (t = this.length, e = 0) : isFinite(e) && (e = e | 0, isFinite(t) ? t = t | 0 : t = void 0);
  var o = this.length - e;
  if ((t === void 0 || t > o) && (t = o), n.length > 0 && (t < 0 || e < 0) || e > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  return Wh(this, n, e, t);
}, le.prototype.slice = function(n, e) {
  var t = this.length;
  n = ~~n, e = e === void 0 ? t : ~~e, n < 0 ? (n += t, n < 0 && (n = 0)) : n > t && (n = t), e < 0 ? (e += t, e < 0 && (e = 0)) : e > t && (e = t), e < n && (e = n);
  var o;
  if (le.TYPED_ARRAY_SUPPORT)
    o = this.subarray(n, e), o.__proto__ = le.prototype;
  else {
    var c = e - n;
    o = new le(c, void 0);
    for (var a = 0; a < c; ++a)
      o[a] = this[a + n];
  }
  return o;
}, le.prototype.copy = function(n, e, t, o) {
  if (t || (t = 0), !o && o !== 0 && (o = this.length), e >= n.length && (e = n.length), e || (e = 0), o > 0 && o < t && (o = t), o === t || n.length === 0 || this.length === 0)
    return 0;
  if (e < 0)
    throw new RangeError("targetStart out of bounds");
  if (t < 0 || t >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (o < 0)
    throw new RangeError("sourceEnd out of bounds");
  o > this.length && (o = this.length), n.length - e < o - t && (o = n.length - e + t);
  var c = o - t, a;
  if (this === n && t < e && e < o)
    for (a = c - 1; a >= 0; --a)
      n[a + e] = this[a + t];
  else if (c < 1e3 || !le.TYPED_ARRAY_SUPPORT)
    for (a = 0; a < c; ++a)
      n[a + e] = this[a + t];
  else
    Uint8Array.prototype.set.call(n, this.subarray(t, t + c), e);
  return c;
}, le.prototype.fill = function(n, e, t) {
  if (typeof n == "string") {
    if (typeof e == "string" ? (e = 0, t = this.length) : typeof t == "string" && (t = this.length), n.length === 1) {
      var o = n.charCodeAt(0);
      o < 256 && (n = o);
    }
  } else
    typeof n == "number" && (n = n & 255);
  if (e < 0 || this.length < e || this.length < t)
    throw new RangeError("Out of range index");
  if (t <= e)
    return this;
  e = e >>> 0, t = t === void 0 ? this.length : t >>> 0, n || (n = 0);
  var c;
  if (typeof n == "number")
    for (c = e; c < t; ++c)
      this[c] = n;
  else {
    var a = le.isBuffer(n) ? n : new le(n), d = a.length;
    for (c = 0; c < t - e; ++c)
      this[c + e] = a[c % d];
  }
  return this;
}, le.concat = function(n, e) {
  if (!Uh(n))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (n.length === 0)
    return Ot(null, 0);
  var t;
  if (e === void 0)
    for (e = 0, t = 0; t < n.length; ++t)
      e += n[t].length;
  var o = co(null, e), c = 0;
  for (t = 0; t < n.length; ++t) {
    var a = n[t];
    if (!le.isBuffer(a))
      throw new TypeError('"list" argument must be an Array of Buffers');
    a.copy(o, c), c += a.length;
  }
  return o;
}, le.byteLength = uo, le.prototype._isBuffer = !0, le.isBuffer = function(n) {
  return !!(n != null && n._isBuffer);
}, ht.alloc = function(n) {
  var e = new le(n);
  return e.fill(0), e;
}, ht.from = function(n) {
  return new le(n);
};
var De = {}, _n, zh = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
De.getSymbolSize = function(n) {
  if (!n)
    throw new Error('"version" cannot be null or undefined');
  if (n < 1 || n > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return n * 4 + 17;
}, De.getSymbolTotalCodewords = function(n) {
  return zh[n];
}, De.getBCHDigit = function(n) {
  for (var e = 0; n !== 0; )
    e++, n >>>= 1;
  return e;
}, De.setToSJISFunction = function(n) {
  if (typeof n != "function")
    throw new Error('"toSJISFunc" is not a valid function.');
  _n = n;
}, De.isKanjiModeEnabled = function() {
  return typeof _n < "u";
}, De.toSJIS = function(n) {
  return _n(n);
};
var _r = {};
(function(n) {
  n.L = { bit: 1 }, n.M = { bit: 0 }, n.Q = { bit: 3 }, n.H = { bit: 2 };
  function e(t) {
    if (typeof t != "string")
      throw new Error("Param is not a string");
    var o = t.toLowerCase();
    switch (o) {
      case "l":
      case "low":
        return n.L;
      case "m":
      case "medium":
        return n.M;
      case "q":
      case "quartile":
        return n.Q;
      case "h":
      case "high":
        return n.H;
      default:
        throw new Error("Unknown EC Level: " + t);
    }
  }
  n.isValid = function(t) {
    return t && typeof t.bit < "u" && t.bit >= 0 && t.bit < 4;
  }, n.from = function(t, o) {
    if (n.isValid(t))
      return t;
    try {
      return e(t);
    } catch {
      return o;
    }
  };
})(_r);
function lo() {
  this.buffer = [], this.length = 0;
}
lo.prototype = { get: function(n) {
  var e = Math.floor(n / 8);
  return (this.buffer[e] >>> 7 - n % 8 & 1) === 1;
}, put: function(n, e) {
  for (var t = 0; t < e; t++)
    this.putBit((n >>> e - t - 1 & 1) === 1);
}, getLengthInBits: function() {
  return this.length;
}, putBit: function(n) {
  var e = Math.floor(this.length / 8);
  this.buffer.length <= e && this.buffer.push(0), n && (this.buffer[e] |= 128 >>> this.length % 8), this.length++;
} };
var Kh = lo, fo = ht;
function Jt(n) {
  if (!n || n < 1)
    throw new Error("BitMatrix size must be defined and greater than 0");
  this.size = n, this.data = fo.alloc(n * n), this.reservedBit = fo.alloc(n * n);
}
Jt.prototype.set = function(n, e, t, o) {
  var c = n * this.size + e;
  this.data[c] = t, o && (this.reservedBit[c] = !0);
}, Jt.prototype.get = function(n, e) {
  return this.data[n * this.size + e];
}, Jt.prototype.xor = function(n, e, t) {
  this.data[n * this.size + e] ^= t;
}, Jt.prototype.isReserved = function(n, e) {
  return this.reservedBit[n * this.size + e];
};
var Jh = Jt, po = {};
(function(n) {
  var e = De.getSymbolSize;
  n.getRowColCoords = function(t) {
    if (t === 1)
      return [];
    for (var o = Math.floor(t / 7) + 2, c = e(t), a = c === 145 ? 26 : Math.ceil((c - 13) / (2 * o - 2)) * 2, d = [c - 7], p = 1; p < o - 1; p++)
      d[p] = d[p - 1] - a;
    return d.push(6), d.reverse();
  }, n.getPositions = function(t) {
    for (var o = [], c = n.getRowColCoords(t), a = c.length, d = 0; d < a; d++)
      for (var p = 0; p < a; p++)
        d === 0 && p === 0 || d === 0 && p === a - 1 || d === a - 1 && p === 0 || o.push([c[d], c[p]]);
    return o;
  };
})(po);
var go = {}, Vh = De.getSymbolSize, _o = 7;
go.getPositions = function(n) {
  var e = Vh(n);
  return [[0, 0], [e - _o, 0], [0, e - _o]];
};
var mo = {};
(function(n) {
  n.Patterns = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
  var e = { N1: 3, N2: 3, N3: 40, N4: 10 };
  n.isValid = function(o) {
    return o != null && o !== "" && !isNaN(o) && o >= 0 && o <= 7;
  }, n.from = function(o) {
    return n.isValid(o) ? parseInt(o, 10) : void 0;
  }, n.getPenaltyN1 = function(o) {
    for (var c = o.size, a = 0, d = 0, p = 0, w = null, M = null, I = 0; I < c; I++) {
      d = p = 0, w = M = null;
      for (var B = 0; B < c; B++) {
        var H = o.get(I, B);
        H === w ? d++ : (d >= 5 && (a += e.N1 + (d - 5)), w = H, d = 1), H = o.get(B, I), H === M ? p++ : (p >= 5 && (a += e.N1 + (p - 5)), M = H, p = 1);
      }
      d >= 5 && (a += e.N1 + (d - 5)), p >= 5 && (a += e.N1 + (p - 5));
    }
    return a;
  }, n.getPenaltyN2 = function(o) {
    for (var c = o.size, a = 0, d = 0; d < c - 1; d++)
      for (var p = 0; p < c - 1; p++) {
        var w = o.get(d, p) + o.get(d, p + 1) + o.get(d + 1, p) + o.get(d + 1, p + 1);
        (w === 4 || w === 0) && a++;
      }
    return a * e.N2;
  }, n.getPenaltyN3 = function(o) {
    for (var c = o.size, a = 0, d = 0, p = 0, w = 0; w < c; w++) {
      d = p = 0;
      for (var M = 0; M < c; M++)
        d = d << 1 & 2047 | o.get(w, M), M >= 10 && (d === 1488 || d === 93) && a++, p = p << 1 & 2047 | o.get(M, w), M >= 10 && (p === 1488 || p === 93) && a++;
    }
    return a * e.N3;
  }, n.getPenaltyN4 = function(o) {
    for (var c = 0, a = o.data.length, d = 0; d < a; d++)
      c += o.data[d];
    var p = Math.abs(Math.ceil(c * 100 / a / 5) - 10);
    return p * e.N4;
  };
  function t(o, c, a) {
    switch (o) {
      case n.Patterns.PATTERN000:
        return (c + a) % 2 === 0;
      case n.Patterns.PATTERN001:
        return c % 2 === 0;
      case n.Patterns.PATTERN010:
        return a % 3 === 0;
      case n.Patterns.PATTERN011:
        return (c + a) % 3 === 0;
      case n.Patterns.PATTERN100:
        return (Math.floor(c / 2) + Math.floor(a / 3)) % 2 === 0;
      case n.Patterns.PATTERN101:
        return c * a % 2 + c * a % 3 === 0;
      case n.Patterns.PATTERN110:
        return (c * a % 2 + c * a % 3) % 2 === 0;
      case n.Patterns.PATTERN111:
        return (c * a % 3 + (c + a) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + o);
    }
  }
  n.applyMask = function(o, c) {
    for (var a = c.size, d = 0; d < a; d++)
      for (var p = 0; p < a; p++)
        c.isReserved(p, d) || c.xor(p, d, t(o, p, d));
  }, n.getBestMask = function(o, c) {
    for (var a = Object.keys(n.Patterns).length, d = 0, p = 1 / 0, w = 0; w < a; w++) {
      c(w), n.applyMask(w, o);
      var M = n.getPenaltyN1(o) + n.getPenaltyN2(o) + n.getPenaltyN3(o) + n.getPenaltyN4(o);
      n.applyMask(w, o), M < p && (p = M, d = w);
    }
    return d;
  };
})(mo);
var mr = {}, ut = _r, vr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81], yr = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
mr.getBlocksCount = function(n, e) {
  switch (e) {
    case ut.L:
      return vr[(n - 1) * 4 + 0];
    case ut.M:
      return vr[(n - 1) * 4 + 1];
    case ut.Q:
      return vr[(n - 1) * 4 + 2];
    case ut.H:
      return vr[(n - 1) * 4 + 3];
    default:
      return;
  }
}, mr.getTotalCodewordsCount = function(n, e) {
  switch (e) {
    case ut.L:
      return yr[(n - 1) * 4 + 0];
    case ut.M:
      return yr[(n - 1) * 4 + 1];
    case ut.Q:
      return yr[(n - 1) * 4 + 2];
    case ut.H:
      return yr[(n - 1) * 4 + 3];
    default:
      return;
  }
};
var vo = {}, wr = {}, yo = ht, Vt = yo.alloc(512), br = yo.alloc(256);
(function() {
  for (var n = 1, e = 0; e < 255; e++)
    Vt[e] = n, br[n] = e, n <<= 1, n & 256 && (n ^= 285);
  for (e = 255; e < 512; e++)
    Vt[e] = Vt[e - 255];
})(), wr.log = function(n) {
  if (n < 1)
    throw new Error("log(" + n + ")");
  return br[n];
}, wr.exp = function(n) {
  return Vt[n];
}, wr.mul = function(n, e) {
  return n === 0 || e === 0 ? 0 : Vt[br[n] + br[e]];
}, function(n) {
  var e = ht, t = wr;
  n.mul = function(o, c) {
    for (var a = e.alloc(o.length + c.length - 1), d = 0; d < o.length; d++)
      for (var p = 0; p < c.length; p++)
        a[d + p] ^= t.mul(o[d], c[p]);
    return a;
  }, n.mod = function(o, c) {
    for (var a = e.from(o); a.length - c.length >= 0; ) {
      for (var d = a[0], p = 0; p < c.length; p++)
        a[p] ^= t.mul(c[p], d);
      for (var w = 0; w < a.length && a[w] === 0; )
        w++;
      a = a.slice(w);
    }
    return a;
  }, n.generateECPolynomial = function(o) {
    for (var c = e.from([1]), a = 0; a < o; a++)
      c = n.mul(c, [1, t.exp(a)]);
    return c;
  };
}(vo);
var wo = {}, xr = {};
xr.byteLength = Qh, xr.toByteArray = Zh, xr.fromByteArray = ru;
for (var ze = [], $e = [], Yh = typeof Uint8Array < "u" ? Uint8Array : Array, mn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Bt = 0, Gh = mn.length; Bt < Gh; ++Bt)
  ze[Bt] = mn[Bt], $e[mn.charCodeAt(Bt)] = Bt;
$e["-".charCodeAt(0)] = 62, $e["_".charCodeAt(0)] = 63;
function bo(n) {
  var e = n.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var t = n.indexOf("=");
  t === -1 && (t = e);
  var o = t === e ? 0 : 4 - t % 4;
  return [t, o];
}
function Qh(n) {
  var e = bo(n), t = e[0], o = e[1];
  return (t + o) * 3 / 4 - o;
}
function Xh(n, e, t) {
  return (e + t) * 3 / 4 - t;
}
function Zh(n) {
  var e, t = bo(n), o = t[0], c = t[1], a = new Yh(Xh(n, o, c)), d = 0, p = c > 0 ? o - 4 : o, w;
  for (w = 0; w < p; w += 4)
    e = $e[n.charCodeAt(w)] << 18 | $e[n.charCodeAt(w + 1)] << 12 | $e[n.charCodeAt(w + 2)] << 6 | $e[n.charCodeAt(w + 3)], a[d++] = e >> 16 & 255, a[d++] = e >> 8 & 255, a[d++] = e & 255;
  return c === 2 && (e = $e[n.charCodeAt(w)] << 2 | $e[n.charCodeAt(w + 1)] >> 4, a[d++] = e & 255), c === 1 && (e = $e[n.charCodeAt(w)] << 10 | $e[n.charCodeAt(w + 1)] << 4 | $e[n.charCodeAt(w + 2)] >> 2, a[d++] = e >> 8 & 255, a[d++] = e & 255), a;
}
function eu(n) {
  return ze[n >> 18 & 63] + ze[n >> 12 & 63] + ze[n >> 6 & 63] + ze[n & 63];
}
function tu(n, e, t) {
  for (var o, c = [], a = e; a < t; a += 3)
    o = (n[a] << 16 & 16711680) + (n[a + 1] << 8 & 65280) + (n[a + 2] & 255), c.push(eu(o));
  return c.join("");
}
function ru(n) {
  for (var e, t = n.length, o = t % 3, c = [], a = 16383, d = 0, p = t - o; d < p; d += a)
    c.push(tu(n, d, d + a > p ? p : d + a));
  return o === 1 ? (e = n[t - 1], c.push(ze[e >> 2] + ze[e << 4 & 63] + "==")) : o === 2 && (e = (n[t - 2] << 8) + n[t - 1], c.push(ze[e >> 10] + ze[e >> 4 & 63] + ze[e << 2 & 63] + "=")), c.join("");
}
var vn = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
vn.read = function(n, e, t, o, c) {
  var a, d, p = c * 8 - o - 1, w = (1 << p) - 1, M = w >> 1, I = -7, B = t ? c - 1 : 0, H = t ? -1 : 1, L = n[e + B];
  for (B += H, a = L & (1 << -I) - 1, L >>= -I, I += p; I > 0; a = a * 256 + n[e + B], B += H, I -= 8)
    ;
  for (d = a & (1 << -I) - 1, a >>= -I, I += o; I > 0; d = d * 256 + n[e + B], B += H, I -= 8)
    ;
  if (a === 0)
    a = 1 - M;
  else {
    if (a === w)
      return d ? NaN : (L ? -1 : 1) * (1 / 0);
    d = d + Math.pow(2, o), a = a - M;
  }
  return (L ? -1 : 1) * d * Math.pow(2, a - o);
}, vn.write = function(n, e, t, o, c, a) {
  var d, p, w, M = a * 8 - c - 1, I = (1 << M) - 1, B = I >> 1, H = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, L = o ? 0 : a - 1, W = o ? 1 : -1, $ = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (p = isNaN(e) ? 1 : 0, d = I) : (d = Math.floor(Math.log(e) / Math.LN2), e * (w = Math.pow(2, -d)) < 1 && (d--, w *= 2), d + B >= 1 ? e += H / w : e += H * Math.pow(2, 1 - B), e * w >= 2 && (d++, w /= 2), d + B >= I ? (p = 0, d = I) : d + B >= 1 ? (p = (e * w - 1) * Math.pow(2, c), d = d + B) : (p = e * Math.pow(2, B - 1) * Math.pow(2, c), d = 0)); c >= 8; n[t + L] = p & 255, L += W, p /= 256, c -= 8)
    ;
  for (d = d << c | p, M += c; M > 0; n[t + L] = d & 255, L += W, d /= 256, M -= 8)
    ;
  n[t + L - W] |= $ * 128;
};
/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <https://feross.org>
* @license  MIT
*/
(function(n) {
  var e = xr, t = vn, o = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  n.Buffer = p, n.SlowBuffer = G, n.INSPECT_MAX_BYTES = 50;
  var c = 2147483647;
  n.kMaxLength = c, p.TYPED_ARRAY_SUPPORT = a(), !p.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function a() {
    try {
      var j = new Uint8Array(1), z = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(z, Uint8Array.prototype), Object.setPrototypeOf(j, z), j.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(p.prototype, "parent", { enumerable: !0, get: function() {
    if (p.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(p.prototype, "offset", { enumerable: !0, get: function() {
    if (p.isBuffer(this))
      return this.byteOffset;
  } });
  function d(j) {
    if (j > c)
      throw new RangeError('The value "' + j + '" is invalid for option "size"');
    var z = new Uint8Array(j);
    return Object.setPrototypeOf(z, p.prototype), z;
  }
  function p(j, z, ee) {
    if (typeof j == "number") {
      if (typeof z == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return B(j);
    }
    return w(j, z, ee);
  }
  p.poolSize = 8192;
  function w(j, z, ee) {
    if (typeof j == "string")
      return H(j, z);
    if (ArrayBuffer.isView(j))
      return W(j);
    if (j == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof j);
    if (rt(j, ArrayBuffer) || j && rt(j.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (rt(j, SharedArrayBuffer) || j && rt(j.buffer, SharedArrayBuffer)))
      return $(j, z, ee);
    if (typeof j == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    var ve = j.valueOf && j.valueOf();
    if (ve != null && ve !== j)
      return p.from(ve, z, ee);
    var me = P(j);
    if (me)
      return me;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof j[Symbol.toPrimitive] == "function")
      return p.from(j[Symbol.toPrimitive]("string"), z, ee);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof j);
  }
  p.from = function(j, z, ee) {
    return w(j, z, ee);
  }, Object.setPrototypeOf(p.prototype, Uint8Array.prototype), Object.setPrototypeOf(p, Uint8Array);
  function M(j) {
    if (typeof j != "number")
      throw new TypeError('"size" argument must be of type number');
    if (j < 0)
      throw new RangeError('The value "' + j + '" is invalid for option "size"');
  }
  function I(j, z, ee) {
    return M(j), j <= 0 ? d(j) : z !== void 0 ? typeof ee == "string" ? d(j).fill(z, ee) : d(j).fill(z) : d(j);
  }
  p.alloc = function(j, z, ee) {
    return I(j, z, ee);
  };
  function B(j) {
    return M(j), d(j < 0 ? 0 : U(j) | 0);
  }
  p.allocUnsafe = function(j) {
    return B(j);
  }, p.allocUnsafeSlow = function(j) {
    return B(j);
  };
  function H(j, z) {
    if ((typeof z != "string" || z === "") && (z = "utf8"), !p.isEncoding(z))
      throw new TypeError("Unknown encoding: " + z);
    var ee = D(j, z) | 0, ve = d(ee), me = ve.write(j, z);
    return me !== ee && (ve = ve.slice(0, me)), ve;
  }
  function L(j) {
    for (var z = j.length < 0 ? 0 : U(j.length) | 0, ee = d(z), ve = 0; ve < z; ve += 1)
      ee[ve] = j[ve] & 255;
    return ee;
  }
  function W(j) {
    if (rt(j, Uint8Array)) {
      var z = new Uint8Array(j);
      return $(z.buffer, z.byteOffset, z.byteLength);
    }
    return L(j);
  }
  function $(j, z, ee) {
    if (z < 0 || j.byteLength < z)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (j.byteLength < z + (ee || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var ve;
    return z === void 0 && ee === void 0 ? ve = new Uint8Array(j) : ee === void 0 ? ve = new Uint8Array(j, z) : ve = new Uint8Array(j, z, ee), Object.setPrototypeOf(ve, p.prototype), ve;
  }
  function P(j) {
    if (p.isBuffer(j)) {
      var z = U(j.length) | 0, ee = d(z);
      return ee.length === 0 || j.copy(ee, 0, 0, z), ee;
    }
    if (j.length !== void 0)
      return typeof j.length != "number" || xe(j.length) ? d(0) : L(j);
    if (j.type === "Buffer" && Array.isArray(j.data))
      return L(j.data);
  }
  function U(j) {
    if (j >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return j | 0;
  }
  function G(j) {
    return +j != j && (j = 0), p.alloc(+j);
  }
  p.isBuffer = function(j) {
    return j != null && j._isBuffer === !0 && j !== p.prototype;
  }, p.compare = function(j, z) {
    if (rt(j, Uint8Array) && (j = p.from(j, j.offset, j.byteLength)), rt(z, Uint8Array) && (z = p.from(z, z.offset, z.byteLength)), !p.isBuffer(j) || !p.isBuffer(z))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (j === z)
      return 0;
    for (var ee = j.length, ve = z.length, me = 0, Ae = Math.min(ee, ve); me < Ae; ++me)
      if (j[me] !== z[me]) {
        ee = j[me], ve = z[me];
        break;
      }
    return ee < ve ? -1 : ve < ee ? 1 : 0;
  }, p.isEncoding = function(j) {
    switch (String(j).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, p.concat = function(j, z) {
    if (!Array.isArray(j))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (j.length === 0)
      return p.alloc(0);
    var ee;
    if (z === void 0)
      for (z = 0, ee = 0; ee < j.length; ++ee)
        z += j[ee].length;
    var ve = p.allocUnsafe(z), me = 0;
    for (ee = 0; ee < j.length; ++ee) {
      var Ae = j[ee];
      if (rt(Ae, Uint8Array))
        me + Ae.length > ve.length ? p.from(Ae).copy(ve, me) : Uint8Array.prototype.set.call(ve, Ae, me);
      else if (p.isBuffer(Ae))
        Ae.copy(ve, me);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      me += Ae.length;
    }
    return ve;
  };
  function D(j, z) {
    if (p.isBuffer(j))
      return j.length;
    if (ArrayBuffer.isView(j) || rt(j, ArrayBuffer))
      return j.byteLength;
    if (typeof j != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof j);
    var ee = j.length, ve = arguments.length > 2 && arguments[2] === !0;
    if (!ve && ee === 0)
      return 0;
    for (var me = !1; ; )
      switch (z) {
        case "ascii":
        case "latin1":
        case "binary":
          return ee;
        case "utf8":
        case "utf-8":
          return oe(j).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ee * 2;
        case "hex":
          return ee >>> 1;
        case "base64":
          return ye(j).length;
        default:
          if (me)
            return ve ? -1 : oe(j).length;
          z = ("" + z).toLowerCase(), me = !0;
      }
  }
  p.byteLength = D;
  function Z(j, z, ee) {
    var ve = !1;
    if ((z === void 0 || z < 0) && (z = 0), z > this.length || ((ee === void 0 || ee > this.length) && (ee = this.length), ee <= 0) || (ee >>>= 0, z >>>= 0, ee <= z))
      return "";
    for (j || (j = "utf8"); ; )
      switch (j) {
        case "hex":
          return _(this, z, ee);
        case "utf8":
        case "utf-8":
          return u(this, z, ee);
        case "ascii":
          return y(this, z, ee);
        case "latin1":
        case "binary":
          return m(this, z, ee);
        case "base64":
          return x(this, z, ee);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return R(this, z, ee);
        default:
          if (ve)
            throw new TypeError("Unknown encoding: " + j);
          j = (j + "").toLowerCase(), ve = !0;
      }
  }
  p.prototype._isBuffer = !0;
  function J(j, z, ee) {
    var ve = j[z];
    j[z] = j[ee], j[ee] = ve;
  }
  p.prototype.swap16 = function() {
    var j = this.length;
    if (j % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var z = 0; z < j; z += 2)
      J(this, z, z + 1);
    return this;
  }, p.prototype.swap32 = function() {
    var j = this.length;
    if (j % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var z = 0; z < j; z += 4)
      J(this, z, z + 3), J(this, z + 1, z + 2);
    return this;
  }, p.prototype.swap64 = function() {
    var j = this.length;
    if (j % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var z = 0; z < j; z += 8)
      J(this, z, z + 7), J(this, z + 1, z + 6), J(this, z + 2, z + 5), J(this, z + 3, z + 4);
    return this;
  }, p.prototype.toString = function() {
    var j = this.length;
    return j === 0 ? "" : arguments.length === 0 ? u(this, 0, j) : Z.apply(this, arguments);
  }, p.prototype.toLocaleString = p.prototype.toString, p.prototype.equals = function(j) {
    if (!p.isBuffer(j))
      throw new TypeError("Argument must be a Buffer");
    return this === j ? !0 : p.compare(this, j) === 0;
  }, p.prototype.inspect = function() {
    var j = "", z = n.INSPECT_MAX_BYTES;
    return j = this.toString("hex", 0, z).replace(/(.{2})/g, "$1 ").trim(), this.length > z && (j += " ... "), "<Buffer " + j + ">";
  }, o && (p.prototype[o] = p.prototype.inspect), p.prototype.compare = function(j, z, ee, ve, me) {
    if (rt(j, Uint8Array) && (j = p.from(j, j.offset, j.byteLength)), !p.isBuffer(j))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof j);
    if (z === void 0 && (z = 0), ee === void 0 && (ee = j ? j.length : 0), ve === void 0 && (ve = 0), me === void 0 && (me = this.length), z < 0 || ee > j.length || ve < 0 || me > this.length)
      throw new RangeError("out of range index");
    if (ve >= me && z >= ee)
      return 0;
    if (ve >= me)
      return -1;
    if (z >= ee)
      return 1;
    if (z >>>= 0, ee >>>= 0, ve >>>= 0, me >>>= 0, this === j)
      return 0;
    for (var Ae = me - ve, it = ee - z, ke = Math.min(Ae, it), qe = this.slice(ve, me), or = j.slice(z, ee), Oe = 0; Oe < ke; ++Oe)
      if (qe[Oe] !== or[Oe]) {
        Ae = qe[Oe], it = or[Oe];
        break;
      }
    return Ae < it ? -1 : it < Ae ? 1 : 0;
  };
  function te(j, z, ee, ve, me) {
    if (j.length === 0)
      return -1;
    if (typeof ee == "string" ? (ve = ee, ee = 0) : ee > 2147483647 ? ee = 2147483647 : ee < -2147483648 && (ee = -2147483648), ee = +ee, xe(ee) && (ee = me ? 0 : j.length - 1), ee < 0 && (ee = j.length + ee), ee >= j.length) {
      if (me)
        return -1;
      ee = j.length - 1;
    } else if (ee < 0)
      if (me)
        ee = 0;
      else
        return -1;
    if (typeof z == "string" && (z = p.from(z, ve)), p.isBuffer(z))
      return z.length === 0 ? -1 : ue(j, z, ee, ve, me);
    if (typeof z == "number")
      return z = z & 255, typeof Uint8Array.prototype.indexOf == "function" ? me ? Uint8Array.prototype.indexOf.call(j, z, ee) : Uint8Array.prototype.lastIndexOf.call(j, z, ee) : ue(j, [z], ee, ve, me);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ue(j, z, ee, ve, me) {
    var Ae = 1, it = j.length, ke = z.length;
    if (ve !== void 0 && (ve = String(ve).toLowerCase(), ve === "ucs2" || ve === "ucs-2" || ve === "utf16le" || ve === "utf-16le")) {
      if (j.length < 2 || z.length < 2)
        return -1;
      Ae = 2, it /= 2, ke /= 2, ee /= 2;
    }
    function qe(E, F) {
      return Ae === 1 ? E[F] : E.readUInt16BE(F * Ae);
    }
    var or;
    if (me) {
      var Oe = -1;
      for (or = ee; or < it; or++)
        if (qe(j, or) === qe(z, Oe === -1 ? 0 : or - Oe)) {
          if (Oe === -1 && (Oe = or), or - Oe + 1 === ke)
            return Oe * Ae;
        } else
          Oe !== -1 && (or -= or - Oe), Oe = -1;
    } else
      for (ee + ke > it && (ee = it - ke), or = ee; or >= 0; or--) {
        for (var T = !0, A = 0; A < ke; A++)
          if (qe(j, or + A) !== qe(z, A)) {
            T = !1;
            break;
          }
        if (T)
          return or;
      }
    return -1;
  }
  p.prototype.includes = function(j, z, ee) {
    return this.indexOf(j, z, ee) !== -1;
  }, p.prototype.indexOf = function(j, z, ee) {
    return te(this, j, z, ee, !0);
  }, p.prototype.lastIndexOf = function(j, z, ee) {
    return te(this, j, z, ee, !1);
  };
  function he(j, z, ee, ve) {
    ee = Number(ee) || 0;
    var me = j.length - ee;
    ve ? (ve = Number(ve), ve > me && (ve = me)) : ve = me;
    var Ae = z.length;
    ve > Ae / 2 && (ve = Ae / 2);
    for (var it = 0; it < ve; ++it) {
      var ke = parseInt(z.substr(it * 2, 2), 16);
      if (xe(ke))
        return it;
      j[ee + it] = ke;
    }
    return it;
  }
  function Se(j, z, ee, ve) {
    return be(oe(z, j.length - ee), j, ee, ve);
  }
  function C(j, z, ee, ve) {
    return be(de(z), j, ee, ve);
  }
  function O(j, z, ee, ve) {
    return be(ye(z), j, ee, ve);
  }
  function V(j, z, ee, ve) {
    return be(Ie(z, j.length - ee), j, ee, ve);
  }
  p.prototype.write = function(j, z, ee, ve) {
    if (z === void 0)
      ve = "utf8", ee = this.length, z = 0;
    else if (ee === void 0 && typeof z == "string")
      ve = z, ee = this.length, z = 0;
    else if (isFinite(z))
      z = z >>> 0, isFinite(ee) ? (ee = ee >>> 0, ve === void 0 && (ve = "utf8")) : (ve = ee, ee = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var me = this.length - z;
    if ((ee === void 0 || ee > me) && (ee = me), j.length > 0 && (ee < 0 || z < 0) || z > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ve || (ve = "utf8");
    for (var Ae = !1; ; )
      switch (ve) {
        case "hex":
          return he(this, j, z, ee);
        case "utf8":
        case "utf-8":
          return Se(this, j, z, ee);
        case "ascii":
        case "latin1":
        case "binary":
          return C(this, j, z, ee);
        case "base64":
          return O(this, j, z, ee);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return V(this, j, z, ee);
        default:
          if (Ae)
            throw new TypeError("Unknown encoding: " + ve);
          ve = ("" + ve).toLowerCase(), Ae = !0;
      }
  }, p.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function x(j, z, ee) {
    return z === 0 && ee === j.length ? e.fromByteArray(j) : e.fromByteArray(j.slice(z, ee));
  }
  function u(j, z, ee) {
    ee = Math.min(j.length, ee);
    for (var ve = [], me = z; me < ee; ) {
      var Ae = j[me], it = null, ke = Ae > 239 ? 4 : Ae > 223 ? 3 : Ae > 191 ? 2 : 1;
      if (me + ke <= ee) {
        var qe, or, Oe, T;
        switch (ke) {
          case 1:
            Ae < 128 && (it = Ae);
            break;
          case 2:
            qe = j[me + 1], (qe & 192) === 128 && (T = (Ae & 31) << 6 | qe & 63, T > 127 && (it = T));
            break;
          case 3:
            qe = j[me + 1], or = j[me + 2], (qe & 192) === 128 && (or & 192) === 128 && (T = (Ae & 15) << 12 | (qe & 63) << 6 | or & 63, T > 2047 && (T < 55296 || T > 57343) && (it = T));
            break;
          case 4:
            qe = j[me + 1], or = j[me + 2], Oe = j[me + 3], (qe & 192) === 128 && (or & 192) === 128 && (Oe & 192) === 128 && (T = (Ae & 15) << 18 | (qe & 63) << 12 | (or & 63) << 6 | Oe & 63, T > 65535 && T < 1114112 && (it = T));
        }
      }
      it === null ? (it = 65533, ke = 1) : it > 65535 && (it -= 65536, ve.push(it >>> 10 & 1023 | 55296), it = 56320 | it & 1023), ve.push(it), me += ke;
    }
    return g(ve);
  }
  var h = 4096;
  function g(j) {
    var z = j.length;
    if (z <= h)
      return String.fromCharCode.apply(String, j);
    for (var ee = "", ve = 0; ve < z; )
      ee += String.fromCharCode.apply(String, j.slice(ve, ve += h));
    return ee;
  }
  function y(j, z, ee) {
    var ve = "";
    ee = Math.min(j.length, ee);
    for (var me = z; me < ee; ++me)
      ve += String.fromCharCode(j[me] & 127);
    return ve;
  }
  function m(j, z, ee) {
    var ve = "";
    ee = Math.min(j.length, ee);
    for (var me = z; me < ee; ++me)
      ve += String.fromCharCode(j[me]);
    return ve;
  }
  function _(j, z, ee) {
    var ve = j.length;
    (!z || z < 0) && (z = 0), (!ee || ee < 0 || ee > ve) && (ee = ve);
    for (var me = "", Ae = z; Ae < ee; ++Ae)
      me += Ne[j[Ae]];
    return me;
  }
  function R(j, z, ee) {
    for (var ve = j.slice(z, ee), me = "", Ae = 0; Ae < ve.length - 1; Ae += 2)
      me += String.fromCharCode(ve[Ae] + ve[Ae + 1] * 256);
    return me;
  }
  p.prototype.slice = function(j, z) {
    var ee = this.length;
    j = ~~j, z = z === void 0 ? ee : ~~z, j < 0 ? (j += ee, j < 0 && (j = 0)) : j > ee && (j = ee), z < 0 ? (z += ee, z < 0 && (z = 0)) : z > ee && (z = ee), z < j && (z = j);
    var ve = this.subarray(j, z);
    return Object.setPrototypeOf(ve, p.prototype), ve;
  };
  function b(j, z, ee) {
    if (j % 1 !== 0 || j < 0)
      throw new RangeError("offset is not uint");
    if (j + z > ee)
      throw new RangeError("Trying to access beyond buffer length");
  }
  p.prototype.readUintLE = p.prototype.readUIntLE = function(j, z, ee) {
    j = j >>> 0, z = z >>> 0, ee || b(j, z, this.length);
    for (var ve = this[j], me = 1, Ae = 0; ++Ae < z && (me *= 256); )
      ve += this[j + Ae] * me;
    return ve;
  }, p.prototype.readUintBE = p.prototype.readUIntBE = function(j, z, ee) {
    j = j >>> 0, z = z >>> 0, ee || b(j, z, this.length);
    for (var ve = this[j + --z], me = 1; z > 0 && (me *= 256); )
      ve += this[j + --z] * me;
    return ve;
  }, p.prototype.readUint8 = p.prototype.readUInt8 = function(j, z) {
    return j = j >>> 0, z || b(j, 1, this.length), this[j];
  }, p.prototype.readUint16LE = p.prototype.readUInt16LE = function(j, z) {
    return j = j >>> 0, z || b(j, 2, this.length), this[j] | this[j + 1] << 8;
  }, p.prototype.readUint16BE = p.prototype.readUInt16BE = function(j, z) {
    return j = j >>> 0, z || b(j, 2, this.length), this[j] << 8 | this[j + 1];
  }, p.prototype.readUint32LE = p.prototype.readUInt32LE = function(j, z) {
    return j = j >>> 0, z || b(j, 4, this.length), (this[j] | this[j + 1] << 8 | this[j + 2] << 16) + this[j + 3] * 16777216;
  }, p.prototype.readUint32BE = p.prototype.readUInt32BE = function(j, z) {
    return j = j >>> 0, z || b(j, 4, this.length), this[j] * 16777216 + (this[j + 1] << 16 | this[j + 2] << 8 | this[j + 3]);
  }, p.prototype.readIntLE = function(j, z, ee) {
    j = j >>> 0, z = z >>> 0, ee || b(j, z, this.length);
    for (var ve = this[j], me = 1, Ae = 0; ++Ae < z && (me *= 256); )
      ve += this[j + Ae] * me;
    return me *= 128, ve >= me && (ve -= Math.pow(2, 8 * z)), ve;
  }, p.prototype.readIntBE = function(j, z, ee) {
    j = j >>> 0, z = z >>> 0, ee || b(j, z, this.length);
    for (var ve = z, me = 1, Ae = this[j + --ve]; ve > 0 && (me *= 256); )
      Ae += this[j + --ve] * me;
    return me *= 128, Ae >= me && (Ae -= Math.pow(2, 8 * z)), Ae;
  }, p.prototype.readInt8 = function(j, z) {
    return j = j >>> 0, z || b(j, 1, this.length), this[j] & 128 ? (255 - this[j] + 1) * -1 : this[j];
  }, p.prototype.readInt16LE = function(j, z) {
    j = j >>> 0, z || b(j, 2, this.length);
    var ee = this[j] | this[j + 1] << 8;
    return ee & 32768 ? ee | 4294901760 : ee;
  }, p.prototype.readInt16BE = function(j, z) {
    j = j >>> 0, z || b(j, 2, this.length);
    var ee = this[j + 1] | this[j] << 8;
    return ee & 32768 ? ee | 4294901760 : ee;
  }, p.prototype.readInt32LE = function(j, z) {
    return j = j >>> 0, z || b(j, 4, this.length), this[j] | this[j + 1] << 8 | this[j + 2] << 16 | this[j + 3] << 24;
  }, p.prototype.readInt32BE = function(j, z) {
    return j = j >>> 0, z || b(j, 4, this.length), this[j] << 24 | this[j + 1] << 16 | this[j + 2] << 8 | this[j + 3];
  }, p.prototype.readFloatLE = function(j, z) {
    return j = j >>> 0, z || b(j, 4, this.length), t.read(this, j, !0, 23, 4);
  }, p.prototype.readFloatBE = function(j, z) {
    return j = j >>> 0, z || b(j, 4, this.length), t.read(this, j, !1, 23, 4);
  }, p.prototype.readDoubleLE = function(j, z) {
    return j = j >>> 0, z || b(j, 8, this.length), t.read(this, j, !0, 52, 8);
  }, p.prototype.readDoubleBE = function(j, z) {
    return j = j >>> 0, z || b(j, 8, this.length), t.read(this, j, !1, 52, 8);
  };
  function l(j, z, ee, ve, me, Ae) {
    if (!p.isBuffer(j))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (z > me || z < Ae)
      throw new RangeError('"value" argument is out of bounds');
    if (ee + ve > j.length)
      throw new RangeError("Index out of range");
  }
  p.prototype.writeUintLE = p.prototype.writeUIntLE = function(j, z, ee, ve) {
    if (j = +j, z = z >>> 0, ee = ee >>> 0, !ve) {
      var me = Math.pow(2, 8 * ee) - 1;
      l(this, j, z, ee, me, 0);
    }
    var Ae = 1, it = 0;
    for (this[z] = j & 255; ++it < ee && (Ae *= 256); )
      this[z + it] = j / Ae & 255;
    return z + ee;
  }, p.prototype.writeUintBE = p.prototype.writeUIntBE = function(j, z, ee, ve) {
    if (j = +j, z = z >>> 0, ee = ee >>> 0, !ve) {
      var me = Math.pow(2, 8 * ee) - 1;
      l(this, j, z, ee, me, 0);
    }
    var Ae = ee - 1, it = 1;
    for (this[z + Ae] = j & 255; --Ae >= 0 && (it *= 256); )
      this[z + Ae] = j / it & 255;
    return z + ee;
  }, p.prototype.writeUint8 = p.prototype.writeUInt8 = function(j, z, ee) {
    return j = +j, z = z >>> 0, ee || l(this, j, z, 1, 255, 0), this[z] = j & 255, z + 1;
  }, p.prototype.writeUint16LE = p.prototype.writeUInt16LE = function(j, z, ee) {
    return j = +j, z = z >>> 0, ee || l(this, j, z, 2, 65535, 0), this[z] = j & 255, this[z + 1] = j >>> 8, z + 2;
  }, p.prototype.writeUint16BE = p.prototype.writeUInt16BE = function(j, z, ee) {
    return j = +j, z = z >>> 0, ee || l(this, j, z, 2, 65535, 0), this[z] = j >>> 8, this[z + 1] = j & 255, z + 2;
  }, p.prototype.writeUint32LE = p.prototype.writeUInt32LE = function(j, z, ee) {
    return j = +j, z = z >>> 0, ee || l(this, j, z, 4, 4294967295, 0), this[z + 3] = j >>> 24, this[z + 2] = j >>> 16, this[z + 1] = j >>> 8, this[z] = j & 255, z + 4;
  }, p.prototype.writeUint32BE = p.prototype.writeUInt32BE = function(j, z, ee) {
    return j = +j, z = z >>> 0, ee || l(this, j, z, 4, 4294967295, 0), this[z] = j >>> 24, this[z + 1] = j >>> 16, this[z + 2] = j >>> 8, this[z + 3] = j & 255, z + 4;
  }, p.prototype.writeIntLE = function(j, z, ee, ve) {
    if (j = +j, z = z >>> 0, !ve) {
      var me = Math.pow(2, 8 * ee - 1);
      l(this, j, z, ee, me - 1, -me);
    }
    var Ae = 0, it = 1, ke = 0;
    for (this[z] = j & 255; ++Ae < ee && (it *= 256); )
      j < 0 && ke === 0 && this[z + Ae - 1] !== 0 && (ke = 1), this[z + Ae] = (j / it >> 0) - ke & 255;
    return z + ee;
  }, p.prototype.writeIntBE = function(j, z, ee, ve) {
    if (j = +j, z = z >>> 0, !ve) {
      var me = Math.pow(2, 8 * ee - 1);
      l(this, j, z, ee, me - 1, -me);
    }
    var Ae = ee - 1, it = 1, ke = 0;
    for (this[z + Ae] = j & 255; --Ae >= 0 && (it *= 256); )
      j < 0 && ke === 0 && this[z + Ae + 1] !== 0 && (ke = 1), this[z + Ae] = (j / it >> 0) - ke & 255;
    return z + ee;
  }, p.prototype.writeInt8 = function(j, z, ee) {
    return j = +j, z = z >>> 0, ee || l(this, j, z, 1, 127, -128), j < 0 && (j = 255 + j + 1), this[z] = j & 255, z + 1;
  }, p.prototype.writeInt16LE = function(j, z, ee) {
    return j = +j, z = z >>> 0, ee || l(this, j, z, 2, 32767, -32768), this[z] = j & 255, this[z + 1] = j >>> 8, z + 2;
  }, p.prototype.writeInt16BE = function(j, z, ee) {
    return j = +j, z = z >>> 0, ee || l(this, j, z, 2, 32767, -32768), this[z] = j >>> 8, this[z + 1] = j & 255, z + 2;
  }, p.prototype.writeInt32LE = function(j, z, ee) {
    return j = +j, z = z >>> 0, ee || l(this, j, z, 4, 2147483647, -2147483648), this[z] = j & 255, this[z + 1] = j >>> 8, this[z + 2] = j >>> 16, this[z + 3] = j >>> 24, z + 4;
  }, p.prototype.writeInt32BE = function(j, z, ee) {
    return j = +j, z = z >>> 0, ee || l(this, j, z, 4, 2147483647, -2147483648), j < 0 && (j = 4294967295 + j + 1), this[z] = j >>> 24, this[z + 1] = j >>> 16, this[z + 2] = j >>> 8, this[z + 3] = j & 255, z + 4;
  };
  function v(j, z, ee, ve, me, Ae) {
    if (ee + ve > j.length)
      throw new RangeError("Index out of range");
    if (ee < 0)
      throw new RangeError("Index out of range");
  }
  function X(j, z, ee, ve, me) {
    return z = +z, ee = ee >>> 0, me || v(j, z, ee, 4), t.write(j, z, ee, ve, 23, 4), ee + 4;
  }
  p.prototype.writeFloatLE = function(j, z, ee) {
    return X(this, j, z, !0, ee);
  }, p.prototype.writeFloatBE = function(j, z, ee) {
    return X(this, j, z, !1, ee);
  };
  function S(j, z, ee, ve, me) {
    return z = +z, ee = ee >>> 0, me || v(j, z, ee, 8), t.write(j, z, ee, ve, 52, 8), ee + 8;
  }
  p.prototype.writeDoubleLE = function(j, z, ee) {
    return S(this, j, z, !0, ee);
  }, p.prototype.writeDoubleBE = function(j, z, ee) {
    return S(this, j, z, !1, ee);
  }, p.prototype.copy = function(j, z, ee, ve) {
    if (!p.isBuffer(j))
      throw new TypeError("argument should be a Buffer");
    if (ee || (ee = 0), !ve && ve !== 0 && (ve = this.length), z >= j.length && (z = j.length), z || (z = 0), ve > 0 && ve < ee && (ve = ee), ve === ee || j.length === 0 || this.length === 0)
      return 0;
    if (z < 0)
      throw new RangeError("targetStart out of bounds");
    if (ee < 0 || ee >= this.length)
      throw new RangeError("Index out of range");
    if (ve < 0)
      throw new RangeError("sourceEnd out of bounds");
    ve > this.length && (ve = this.length), j.length - z < ve - ee && (ve = j.length - z + ee);
    var me = ve - ee;
    return this === j && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(z, ee, ve) : Uint8Array.prototype.set.call(j, this.subarray(ee, ve), z), me;
  }, p.prototype.fill = function(j, z, ee, ve) {
    if (typeof j == "string") {
      if (typeof z == "string" ? (ve = z, z = 0, ee = this.length) : typeof ee == "string" && (ve = ee, ee = this.length), ve !== void 0 && typeof ve != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ve == "string" && !p.isEncoding(ve))
        throw new TypeError("Unknown encoding: " + ve);
      if (j.length === 1) {
        var me = j.charCodeAt(0);
        (ve === "utf8" && me < 128 || ve === "latin1") && (j = me);
      }
    } else
      typeof j == "number" ? j = j & 255 : typeof j == "boolean" && (j = Number(j));
    if (z < 0 || this.length < z || this.length < ee)
      throw new RangeError("Out of range index");
    if (ee <= z)
      return this;
    z = z >>> 0, ee = ee === void 0 ? this.length : ee >>> 0, j || (j = 0);
    var Ae;
    if (typeof j == "number")
      for (Ae = z; Ae < ee; ++Ae)
        this[Ae] = j;
    else {
      var it = p.isBuffer(j) ? j : p.from(j, ve), ke = it.length;
      if (ke === 0)
        throw new TypeError('The value "' + j + '" is invalid for argument "value"');
      for (Ae = 0; Ae < ee - z; ++Ae)
        this[Ae + z] = it[Ae % ke];
    }
    return this;
  };
  var Y = /[^+/0-9A-Za-z-_]/g;
  function fe(j) {
    if (j = j.split("=")[0], j = j.trim().replace(Y, ""), j.length < 2)
      return "";
    for (; j.length % 4 !== 0; )
      j = j + "=";
    return j;
  }
  function oe(j, z) {
    z = z || 1 / 0;
    for (var ee, ve = j.length, me = null, Ae = [], it = 0; it < ve; ++it) {
      if (ee = j.charCodeAt(it), ee > 55295 && ee < 57344) {
        if (!me) {
          if (ee > 56319) {
            (z -= 3) > -1 && Ae.push(239, 191, 189);
            continue;
          } else if (it + 1 === ve) {
            (z -= 3) > -1 && Ae.push(239, 191, 189);
            continue;
          }
          me = ee;
          continue;
        }
        if (ee < 56320) {
          (z -= 3) > -1 && Ae.push(239, 191, 189), me = ee;
          continue;
        }
        ee = (me - 55296 << 10 | ee - 56320) + 65536;
      } else
        me && (z -= 3) > -1 && Ae.push(239, 191, 189);
      if (me = null, ee < 128) {
        if ((z -= 1) < 0)
          break;
        Ae.push(ee);
      } else if (ee < 2048) {
        if ((z -= 2) < 0)
          break;
        Ae.push(ee >> 6 | 192, ee & 63 | 128);
      } else if (ee < 65536) {
        if ((z -= 3) < 0)
          break;
        Ae.push(ee >> 12 | 224, ee >> 6 & 63 | 128, ee & 63 | 128);
      } else if (ee < 1114112) {
        if ((z -= 4) < 0)
          break;
        Ae.push(ee >> 18 | 240, ee >> 12 & 63 | 128, ee >> 6 & 63 | 128, ee & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return Ae;
  }
  function de(j) {
    for (var z = [], ee = 0; ee < j.length; ++ee)
      z.push(j.charCodeAt(ee) & 255);
    return z;
  }
  function Ie(j, z) {
    for (var ee, ve, me, Ae = [], it = 0; it < j.length && !((z -= 2) < 0); ++it)
      ee = j.charCodeAt(it), ve = ee >> 8, me = ee % 256, Ae.push(me), Ae.push(ve);
    return Ae;
  }
  function ye(j) {
    return e.toByteArray(fe(j));
  }
  function be(j, z, ee, ve) {
    for (var me = 0; me < ve && !(me + ee >= z.length || me >= j.length); ++me)
      z[me + ee] = j[me];
    return me;
  }
  function rt(j, z) {
    return j instanceof z || j != null && j.constructor != null && j.constructor.name != null && j.constructor.name === z.name;
  }
  function xe(j) {
    return j !== j;
  }
  var Ne = function() {
    for (var j = "0123456789abcdef", z = new Array(256), ee = 0; ee < 16; ++ee)
      for (var ve = ee * 16, me = 0; me < 16; ++me)
        z[ve + me] = j[ee] + j[me];
    return z;
  }();
})(wo);
var xo = ht, Mo = vo, nu = wo.Buffer;
function yn(n) {
  this.genPoly = void 0, this.degree = n, this.degree && this.initialize(this.degree);
}
yn.prototype.initialize = function(n) {
  this.degree = n, this.genPoly = Mo.generateECPolynomial(this.degree);
}, yn.prototype.encode = function(n) {
  if (!this.genPoly)
    throw new Error("Encoder not initialized");
  var e = xo.alloc(this.degree), t = nu.concat([n, e], n.length + this.degree), o = Mo.mod(t, this.genPoly), c = this.degree - o.length;
  if (c > 0) {
    var a = xo.alloc(this.degree);
    return o.copy(a, c), a;
  }
  return o;
};
var iu = yn, Eo = {}, lt = {}, wn = {};
wn.isValid = function(n) {
  return !isNaN(n) && n >= 1 && n <= 40;
};
var Ke = {}, Co = "[0-9]+", ou = "[A-Z $%*+\\-./:]+", Yt = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
Yt = Yt.replace(/u/g, "\\u");
var au = "(?:(?![A-Z0-9 $%*+\\-./:]|" + Yt + `)(?:.|[\r
]))+`;
Ke.KANJI = new RegExp(Yt, "g"), Ke.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g"), Ke.BYTE = new RegExp(au, "g"), Ke.NUMERIC = new RegExp(Co, "g"), Ke.ALPHANUMERIC = new RegExp(ou, "g");
var su = new RegExp("^" + Yt + "$"), cu = new RegExp("^" + Co + "$"), hu = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
Ke.testKanji = function(n) {
  return su.test(n);
}, Ke.testNumeric = function(n) {
  return cu.test(n);
}, Ke.testAlphanumeric = function(n) {
  return hu.test(n);
}, function(n) {
  var e = wn, t = Ke;
  n.NUMERIC = { id: "Numeric", bit: 1 << 0, ccBits: [10, 12, 14] }, n.ALPHANUMERIC = { id: "Alphanumeric", bit: 1 << 1, ccBits: [9, 11, 13] }, n.BYTE = { id: "Byte", bit: 1 << 2, ccBits: [8, 16, 16] }, n.KANJI = { id: "Kanji", bit: 1 << 3, ccBits: [8, 10, 12] }, n.MIXED = { bit: -1 }, n.getCharCountIndicator = function(c, a) {
    if (!c.ccBits)
      throw new Error("Invalid mode: " + c);
    if (!e.isValid(a))
      throw new Error("Invalid version: " + a);
    return a >= 1 && a < 10 ? c.ccBits[0] : a < 27 ? c.ccBits[1] : c.ccBits[2];
  }, n.getBestModeForData = function(c) {
    return t.testNumeric(c) ? n.NUMERIC : t.testAlphanumeric(c) ? n.ALPHANUMERIC : t.testKanji(c) ? n.KANJI : n.BYTE;
  }, n.toString = function(c) {
    if (c && c.id)
      return c.id;
    throw new Error("Invalid mode");
  }, n.isValid = function(c) {
    return c && c.bit && c.ccBits;
  };
  function o(c) {
    if (typeof c != "string")
      throw new Error("Param is not a string");
    var a = c.toLowerCase();
    switch (a) {
      case "numeric":
        return n.NUMERIC;
      case "alphanumeric":
        return n.ALPHANUMERIC;
      case "kanji":
        return n.KANJI;
      case "byte":
        return n.BYTE;
      default:
        throw new Error("Unknown mode: " + c);
    }
  }
  n.from = function(c, a) {
    if (n.isValid(c))
      return c;
    try {
      return o(c);
    } catch {
      return a;
    }
  };
}(lt), function(n) {
  var e = De, t = mr, o = _r, c = lt, a = wn, d = dn, p = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0, w = e.getBCHDigit(p);
  function M(L, W, $) {
    for (var P = 1; P <= 40; P++)
      if (W <= n.getCapacity(P, $, L))
        return P;
  }
  function I(L, W) {
    return c.getCharCountIndicator(L, W) + 4;
  }
  function B(L, W) {
    var $ = 0;
    return L.forEach(function(P) {
      var U = I(P.mode, W);
      $ += U + P.getBitsLength();
    }), $;
  }
  function H(L, W) {
    for (var $ = 1; $ <= 40; $++) {
      var P = B(L, $);
      if (P <= n.getCapacity($, W, c.MIXED))
        return $;
    }
  }
  n.from = function(L, W) {
    return a.isValid(L) ? parseInt(L, 10) : W;
  }, n.getCapacity = function(L, W, $) {
    if (!a.isValid(L))
      throw new Error("Invalid QR Code version");
    typeof $ > "u" && ($ = c.BYTE);
    var P = e.getSymbolTotalCodewords(L), U = t.getTotalCodewordsCount(L, W), G = (P - U) * 8;
    if ($ === c.MIXED)
      return G;
    var D = G - I($, L);
    switch ($) {
      case c.NUMERIC:
        return Math.floor(D / 10 * 3);
      case c.ALPHANUMERIC:
        return Math.floor(D / 11 * 2);
      case c.KANJI:
        return Math.floor(D / 13);
      case c.BYTE:
      default:
        return Math.floor(D / 8);
    }
  }, n.getBestVersionForData = function(L, W) {
    var $, P = o.from(W, o.M);
    if (d(L)) {
      if (L.length > 1)
        return H(L, P);
      if (L.length === 0)
        return 1;
      $ = L[0];
    } else
      $ = L;
    return M($.mode, $.getLength(), P);
  }, n.getEncodedBits = function(L) {
    if (!a.isValid(L) || L < 7)
      throw new Error("Invalid QR Code version");
    for (var W = L << 12; e.getBCHDigit(W) - w >= 0; )
      W ^= p << e.getBCHDigit(W) - w;
    return L << 12 | W;
  };
}(Eo);
var So = {}, bn = De, Ao = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0, uu = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1, Ro = bn.getBCHDigit(Ao);
So.getEncodedBits = function(n, e) {
  for (var t = n.bit << 3 | e, o = t << 10; bn.getBCHDigit(o) - Ro >= 0; )
    o ^= Ao << bn.getBCHDigit(o) - Ro;
  return (t << 10 | o) ^ uu;
};
var ko = {}, lu = lt;
function Nt(n) {
  this.mode = lu.NUMERIC, this.data = n.toString();
}
Nt.getBitsLength = function(n) {
  return 10 * Math.floor(n / 3) + (n % 3 ? n % 3 * 3 + 1 : 0);
}, Nt.prototype.getLength = function() {
  return this.data.length;
}, Nt.prototype.getBitsLength = function() {
  return Nt.getBitsLength(this.data.length);
}, Nt.prototype.write = function(n) {
  var e, t, o;
  for (e = 0; e + 3 <= this.data.length; e += 3)
    t = this.data.substr(e, 3), o = parseInt(t, 10), n.put(o, 10);
  var c = this.data.length - e;
  c > 0 && (t = this.data.substr(e), o = parseInt(t, 10), n.put(o, c * 3 + 1));
};
var fu = Nt, du = lt, xn = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
function Lt(n) {
  this.mode = du.ALPHANUMERIC, this.data = n;
}
Lt.getBitsLength = function(n) {
  return 11 * Math.floor(n / 2) + 6 * (n % 2);
}, Lt.prototype.getLength = function() {
  return this.data.length;
}, Lt.prototype.getBitsLength = function() {
  return Lt.getBitsLength(this.data.length);
}, Lt.prototype.write = function(n) {
  var e;
  for (e = 0; e + 2 <= this.data.length; e += 2) {
    var t = xn.indexOf(this.data[e]) * 45;
    t += xn.indexOf(this.data[e + 1]), n.put(t, 11);
  }
  this.data.length % 2 && n.put(xn.indexOf(this.data[e]), 6);
};
var pu = Lt, gu = ht, _u = lt;
function Ut(n) {
  this.mode = _u.BYTE, this.data = gu.from(n);
}
Ut.getBitsLength = function(n) {
  return n * 8;
}, Ut.prototype.getLength = function() {
  return this.data.length;
}, Ut.prototype.getBitsLength = function() {
  return Ut.getBitsLength(this.data.length);
}, Ut.prototype.write = function(n) {
  for (var e = 0, t = this.data.length; e < t; e++)
    n.put(this.data[e], 8);
};
var mu = Ut, vu = lt, yu = De;
function Ft(n) {
  this.mode = vu.KANJI, this.data = n;
}
Ft.getBitsLength = function(n) {
  return n * 13;
}, Ft.prototype.getLength = function() {
  return this.data.length;
}, Ft.prototype.getBitsLength = function() {
  return Ft.getBitsLength(this.data.length);
}, Ft.prototype.write = function(n) {
  var e;
  for (e = 0; e < this.data.length; e++) {
    var t = yu.toSJIS(this.data[e]);
    if (t >= 33088 && t <= 40956)
      t -= 33088;
    else if (t >= 57408 && t <= 60351)
      t -= 49472;
    else
      throw new Error("Invalid SJIS character: " + this.data[e] + `
Make sure your charset is UTF-8`);
    t = (t >>> 8 & 255) * 192 + (t & 255), n.put(t, 13);
  }
};
var wu = Ft, Io = { exports: {} };
(function(n) {
  var e = { single_source_shortest_paths: function(t, o, c) {
    var a = {}, d = {};
    d[o] = 0;
    var p = e.PriorityQueue.make();
    p.push(o, 0);
    for (var w, M, I, B, H, L, W, $, P; !p.empty(); ) {
      w = p.pop(), M = w.value, B = w.cost, H = t[M] || {};
      for (I in H)
        H.hasOwnProperty(I) && (L = H[I], W = B + L, $ = d[I], P = typeof d[I] > "u", (P || $ > W) && (d[I] = W, p.push(I, W), a[I] = M));
    }
    if (typeof c < "u" && typeof d[c] > "u") {
      var U = ["Could not find a path from ", o, " to ", c, "."].join("");
      throw new Error(U);
    }
    return a;
  }, extract_shortest_path_from_predecessor_list: function(t, o) {
    for (var c = [], a = o; a; )
      c.push(a), t[a], a = t[a];
    return c.reverse(), c;
  }, find_path: function(t, o, c) {
    var a = e.single_source_shortest_paths(t, o, c);
    return e.extract_shortest_path_from_predecessor_list(a, c);
  }, PriorityQueue: { make: function(t) {
    var o = e.PriorityQueue, c = {}, a;
    t = t || {};
    for (a in o)
      o.hasOwnProperty(a) && (c[a] = o[a]);
    return c.queue = [], c.sorter = t.sorter || o.default_sorter, c;
  }, default_sorter: function(t, o) {
    return t.cost - o.cost;
  }, push: function(t, o) {
    var c = { value: t, cost: o };
    this.queue.push(c), this.queue.sort(this.sorter);
  }, pop: function() {
    return this.queue.shift();
  }, empty: function() {
    return this.queue.length === 0;
  } } };
  n.exports = e;
})(Io), function(n) {
  var e = lt, t = fu, o = pu, c = mu, a = wu, d = Ke, p = De, w = Io.exports;
  function M(U) {
    return unescape(encodeURIComponent(U)).length;
  }
  function I(U, G, D) {
    for (var Z = [], J; (J = U.exec(D)) !== null; )
      Z.push({ data: J[0], index: J.index, mode: G, length: J[0].length });
    return Z;
  }
  function B(U) {
    var G = I(d.NUMERIC, e.NUMERIC, U), D = I(d.ALPHANUMERIC, e.ALPHANUMERIC, U), Z, J;
    p.isKanjiModeEnabled() ? (Z = I(d.BYTE, e.BYTE, U), J = I(d.KANJI, e.KANJI, U)) : (Z = I(d.BYTE_KANJI, e.BYTE, U), J = []);
    var te = G.concat(D, Z, J);
    return te.sort(function(ue, he) {
      return ue.index - he.index;
    }).map(function(ue) {
      return { data: ue.data, mode: ue.mode, length: ue.length };
    });
  }
  function H(U, G) {
    switch (G) {
      case e.NUMERIC:
        return t.getBitsLength(U);
      case e.ALPHANUMERIC:
        return o.getBitsLength(U);
      case e.KANJI:
        return a.getBitsLength(U);
      case e.BYTE:
        return c.getBitsLength(U);
    }
  }
  function L(U) {
    return U.reduce(function(G, D) {
      var Z = G.length - 1 >= 0 ? G[G.length - 1] : null;
      return Z && Z.mode === D.mode ? (G[G.length - 1].data += D.data, G) : (G.push(D), G);
    }, []);
  }
  function W(U) {
    for (var G = [], D = 0; D < U.length; D++) {
      var Z = U[D];
      switch (Z.mode) {
        case e.NUMERIC:
          G.push([Z, { data: Z.data, mode: e.ALPHANUMERIC, length: Z.length }, { data: Z.data, mode: e.BYTE, length: Z.length }]);
          break;
        case e.ALPHANUMERIC:
          G.push([Z, { data: Z.data, mode: e.BYTE, length: Z.length }]);
          break;
        case e.KANJI:
          G.push([Z, { data: Z.data, mode: e.BYTE, length: M(Z.data) }]);
          break;
        case e.BYTE:
          G.push([{ data: Z.data, mode: e.BYTE, length: M(Z.data) }]);
      }
    }
    return G;
  }
  function $(U, G) {
    for (var D = {}, Z = { start: {} }, J = ["start"], te = 0; te < U.length; te++) {
      for (var ue = U[te], he = [], Se = 0; Se < ue.length; Se++) {
        var C = ue[Se], O = "" + te + Se;
        he.push(O), D[O] = { node: C, lastCount: 0 }, Z[O] = {};
        for (var V = 0; V < J.length; V++) {
          var x = J[V];
          D[x] && D[x].node.mode === C.mode ? (Z[x][O] = H(D[x].lastCount + C.length, C.mode) - H(D[x].lastCount, C.mode), D[x].lastCount += C.length) : (D[x] && (D[x].lastCount = C.length), Z[x][O] = H(C.length, C.mode) + 4 + e.getCharCountIndicator(C.mode, G));
        }
      }
      J = he;
    }
    for (V = 0; V < J.length; V++)
      Z[J[V]].end = 0;
    return { map: Z, table: D };
  }
  function P(U, G) {
    var D, Z = e.getBestModeForData(U);
    if (D = e.from(G, Z), D !== e.BYTE && D.bit < Z.bit)
      throw new Error('"' + U + '" cannot be encoded with mode ' + e.toString(D) + `.
 Suggested mode is: ` + e.toString(Z));
    switch (D === e.KANJI && !p.isKanjiModeEnabled() && (D = e.BYTE), D) {
      case e.NUMERIC:
        return new t(U);
      case e.ALPHANUMERIC:
        return new o(U);
      case e.KANJI:
        return new a(U);
      case e.BYTE:
        return new c(U);
    }
  }
  n.fromArray = function(U) {
    return U.reduce(function(G, D) {
      return typeof D == "string" ? G.push(P(D, null)) : D.data && G.push(P(D.data, D.mode)), G;
    }, []);
  }, n.fromString = function(U, G) {
    for (var D = B(U, p.isKanjiModeEnabled()), Z = W(D), J = $(Z, G), te = w.find_path(J.map, "start", "end"), ue = [], he = 1; he < te.length - 1; he++)
      ue.push(J.table[te[he]].node);
    return n.fromArray(L(ue));
  }, n.rawSplit = function(U) {
    return n.fromArray(B(U, p.isKanjiModeEnabled()));
  };
}(ko);
var To = ht, Mr = De, Mn = _r, bu = Kh, xu = Jh, Mu = po, Eu = go, En = mo, Cn = mr, Cu = iu, Er = Eo, Su = So, Au = lt, Sn = ko, Ru = dn;
function ku(n, e) {
  for (var t = n.size, o = Eu.getPositions(e), c = 0; c < o.length; c++)
    for (var a = o[c][0], d = o[c][1], p = -1; p <= 7; p++)
      if (!(a + p <= -1 || t <= a + p))
        for (var w = -1; w <= 7; w++)
          d + w <= -1 || t <= d + w || (p >= 0 && p <= 6 && (w === 0 || w === 6) || w >= 0 && w <= 6 && (p === 0 || p === 6) || p >= 2 && p <= 4 && w >= 2 && w <= 4 ? n.set(a + p, d + w, !0, !0) : n.set(a + p, d + w, !1, !0));
}
function Iu(n) {
  for (var e = n.size, t = 8; t < e - 8; t++) {
    var o = t % 2 === 0;
    n.set(t, 6, o, !0), n.set(6, t, o, !0);
  }
}
function Tu(n, e) {
  for (var t = Mu.getPositions(e), o = 0; o < t.length; o++)
    for (var c = t[o][0], a = t[o][1], d = -2; d <= 2; d++)
      for (var p = -2; p <= 2; p++)
        d === -2 || d === 2 || p === -2 || p === 2 || d === 0 && p === 0 ? n.set(c + d, a + p, !0, !0) : n.set(c + d, a + p, !1, !0);
}
function Ou(n, e) {
  for (var t = n.size, o = Er.getEncodedBits(e), c, a, d, p = 0; p < 18; p++)
    c = Math.floor(p / 3), a = p % 3 + t - 8 - 3, d = (o >> p & 1) === 1, n.set(c, a, d, !0), n.set(a, c, d, !0);
}
function An(n, e, t) {
  var o = n.size, c = Su.getEncodedBits(e, t), a, d;
  for (a = 0; a < 15; a++)
    d = (c >> a & 1) === 1, a < 6 ? n.set(a, 8, d, !0) : a < 8 ? n.set(a + 1, 8, d, !0) : n.set(o - 15 + a, 8, d, !0), a < 8 ? n.set(8, o - a - 1, d, !0) : a < 9 ? n.set(8, 15 - a - 1 + 1, d, !0) : n.set(8, 15 - a - 1, d, !0);
  n.set(o - 8, 8, 1, !0);
}
function Bu(n, e) {
  for (var t = n.size, o = -1, c = t - 1, a = 7, d = 0, p = t - 1; p > 0; p -= 2)
    for (p === 6 && p--; ; ) {
      for (var w = 0; w < 2; w++)
        if (!n.isReserved(c, p - w)) {
          var M = !1;
          d < e.length && (M = (e[d] >>> a & 1) === 1), n.set(c, p - w, M), a--, a === -1 && (d++, a = 7);
        }
      if (c += o, c < 0 || t <= c) {
        c -= o, o = -o;
        break;
      }
    }
}
function Nu(n, e, t) {
  var o = new bu();
  t.forEach(function(M) {
    o.put(M.mode.bit, 4), o.put(M.getLength(), Au.getCharCountIndicator(M.mode, n)), M.write(o);
  });
  var c = Mr.getSymbolTotalCodewords(n), a = Cn.getTotalCodewordsCount(n, e), d = (c - a) * 8;
  for (o.getLengthInBits() + 4 <= d && o.put(0, 4); o.getLengthInBits() % 8 !== 0; )
    o.putBit(0);
  for (var p = (d - o.getLengthInBits()) / 8, w = 0; w < p; w++)
    o.put(w % 2 ? 17 : 236, 8);
  return Lu(o, n, e);
}
function Lu(n, e, t) {
  for (var o = Mr.getSymbolTotalCodewords(e), c = Cn.getTotalCodewordsCount(e, t), a = o - c, d = Cn.getBlocksCount(e, t), p = o % d, w = d - p, M = Math.floor(o / d), I = Math.floor(a / d), B = I + 1, H = M - I, L = new Cu(H), W = 0, $ = new Array(d), P = new Array(d), U = 0, G = To.from(n.buffer), D = 0; D < d; D++) {
    var Z = D < w ? I : B;
    $[D] = G.slice(W, W + Z), P[D] = L.encode($[D]), W += Z, U = Math.max(U, Z);
  }
  var J = To.alloc(o), te = 0, ue, he;
  for (ue = 0; ue < U; ue++)
    for (he = 0; he < d; he++)
      ue < $[he].length && (J[te++] = $[he][ue]);
  for (ue = 0; ue < H; ue++)
    for (he = 0; he < d; he++)
      J[te++] = P[he][ue];
  return J;
}
function Uu(n, e, t, o) {
  var c;
  if (Ru(n))
    c = Sn.fromArray(n);
  else if (typeof n == "string") {
    var a = e;
    if (!a) {
      var d = Sn.rawSplit(n);
      a = Er.getBestVersionForData(d, t);
    }
    c = Sn.fromString(n, a || 40);
  } else
    throw new Error("Invalid data");
  var p = Er.getBestVersionForData(c, t);
  if (!p)
    throw new Error("The amount of data is too big to be stored in a QR Code");
  if (!e)
    e = p;
  else if (e < p)
    throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + p + `.
`);
  var w = Nu(e, t, c), M = Mr.getSymbolSize(e), I = new xu(M);
  return ku(I, e), Iu(I), Tu(I, e), An(I, t, 0), e >= 7 && Ou(I, e), Bu(I, w), isNaN(o) && (o = En.getBestMask(I, An.bind(null, I, t))), En.applyMask(o, I), An(I, t, o), { modules: I, version: e, errorCorrectionLevel: t, maskPattern: o, segments: c };
}
ao.create = function(n, e) {
  if (typeof n > "u" || n === "")
    throw new Error("No input text");
  var t = Mn.M, o, c;
  return typeof e < "u" && (t = Mn.from(e.errorCorrectionLevel, Mn.M), o = Er.from(e.version), c = En.from(e.maskPattern), e.toSJISFunc && Mr.setToSJISFunction(e.toSJISFunc)), Uu(n, o, t, c);
};
var Oo = {}, Rn = {};
(function(n) {
  function e(t) {
    if (typeof t == "number" && (t = t.toString()), typeof t != "string")
      throw new Error("Color should be defined as hex string");
    var o = t.slice().replace("#", "").split("");
    if (o.length < 3 || o.length === 5 || o.length > 8)
      throw new Error("Invalid hex color: " + t);
    (o.length === 3 || o.length === 4) && (o = Array.prototype.concat.apply([], o.map(function(a) {
      return [a, a];
    }))), o.length === 6 && o.push("F", "F");
    var c = parseInt(o.join(""), 16);
    return { r: c >> 24 & 255, g: c >> 16 & 255, b: c >> 8 & 255, a: c & 255, hex: "#" + o.slice(0, 6).join("") };
  }
  n.getOptions = function(t) {
    t || (t = {}), t.color || (t.color = {});
    var o = typeof t.margin > "u" || t.margin === null || t.margin < 0 ? 4 : t.margin, c = t.width && t.width >= 21 ? t.width : void 0, a = t.scale || 4;
    return { width: c, scale: c ? 4 : a, margin: o, color: { dark: e(t.color.dark || "#000000ff"), light: e(t.color.light || "#ffffffff") }, type: t.type, rendererOpts: t.rendererOpts || {} };
  }, n.getScale = function(t, o) {
    return o.width && o.width >= t + o.margin * 2 ? o.width / (t + o.margin * 2) : o.scale;
  }, n.getImageWidth = function(t, o) {
    var c = n.getScale(t, o);
    return Math.floor((t + o.margin * 2) * c);
  }, n.qrToImageData = function(t, o, c) {
    for (var a = o.modules.size, d = o.modules.data, p = n.getScale(a, c), w = Math.floor((a + c.margin * 2) * p), M = c.margin * p, I = [c.color.light, c.color.dark], B = 0; B < w; B++)
      for (var H = 0; H < w; H++) {
        var L = (B * w + H) * 4, W = c.color.light;
        if (B >= M && H >= M && B < w - M && H < w - M) {
          var $ = Math.floor((B - M) / p), P = Math.floor((H - M) / p);
          W = I[d[$ * a + P] ? 1 : 0];
        }
        t[L++] = W.r, t[L++] = W.g, t[L++] = W.b, t[L] = W.a;
      }
  };
})(Rn), function(n) {
  var e = Rn;
  function t(c, a, d) {
    c.clearRect(0, 0, a.width, a.height), a.style || (a.style = {}), a.height = d, a.width = d, a.style.height = d + "px", a.style.width = d + "px";
  }
  function o() {
    try {
      return document.createElement("canvas");
    } catch {
      throw new Error("You need to specify a canvas element");
    }
  }
  n.render = function(c, a, d) {
    var p = d, w = a;
    typeof p > "u" && (!a || !a.getContext) && (p = a, a = void 0), a || (w = o()), p = e.getOptions(p);
    var M = e.getImageWidth(c.modules.size, p), I = w.getContext("2d"), B = I.createImageData(M, M);
    return e.qrToImageData(B.data, c, p), t(I, w, M), I.putImageData(B, 0, 0), w;
  }, n.renderToDataURL = function(c, a, d) {
    var p = d;
    typeof p > "u" && (!a || !a.getContext) && (p = a, a = void 0), p || (p = {});
    var w = n.render(c, a, p), M = p.type || "image/png", I = p.rendererOpts || {};
    return w.toDataURL(M, I.quality);
  };
}(Oo);
var Bo = {}, Fu = Rn;
function No(n, e) {
  var t = n.a / 255, o = e + '="' + n.hex + '"';
  return t < 1 ? o + " " + e + '-opacity="' + t.toFixed(2).slice(1) + '"' : o;
}
function kn(n, e, t) {
  var o = n + e;
  return typeof t < "u" && (o += " " + t), o;
}
function Pu(n, e, t) {
  for (var o = "", c = 0, a = !1, d = 0, p = 0; p < n.length; p++) {
    var w = Math.floor(p % e), M = Math.floor(p / e);
    !w && !a && (a = !0), n[p] ? (d++, p > 0 && w > 0 && n[p - 1] || (o += a ? kn("M", w + t, 0.5 + M + t) : kn("m", c, 0), c = 0, a = !1), w + 1 < e && n[p + 1] || (o += kn("h", d), d = 0)) : c++;
  }
  return o;
}
Bo.render = function(n, e, t) {
  var o = Fu.getOptions(e), c = n.modules.size, a = n.modules.data, d = c + o.margin * 2, p = o.color.light.a ? "<path " + No(o.color.light, "fill") + ' d="M0 0h' + d + "v" + d + 'H0z"/>' : "", w = "<path " + No(o.color.dark, "stroke") + ' d="' + Pu(a, c, o.margin) + '"/>', M = 'viewBox="0 0 ' + d + " " + d + '"', I = o.width ? 'width="' + o.width + '" height="' + o.width + '" ' : "", B = '<svg xmlns="http://www.w3.org/2000/svg" ' + I + M + ' shape-rendering="crispEdges">' + p + w + `</svg>
`;
  return typeof t == "function" && t(null, B), B;
};
var qu = Nh, In = ao, Lo = Oo, Du = Bo;
function Tn(n, e, t, o, c) {
  var a = [].slice.call(arguments, 1), d = a.length, p = typeof a[d - 1] == "function";
  if (!p && !qu())
    throw new Error("Callback required as last argument");
  if (p) {
    if (d < 2)
      throw new Error("Too few arguments provided");
    d === 2 ? (c = t, t = e, e = o = void 0) : d === 3 && (e.getContext && typeof c > "u" ? (c = o, o = void 0) : (c = o, o = t, t = e, e = void 0));
  } else {
    if (d < 1)
      throw new Error("Too few arguments provided");
    return d === 1 ? (t = e, e = o = void 0) : d === 2 && !e.getContext && (o = t, t = e, e = void 0), new Promise(function(M, I) {
      try {
        var B = In.create(t, o);
        M(n(B, e, o));
      } catch (H) {
        I(H);
      }
    });
  }
  try {
    var w = In.create(t, o);
    c(null, n(w, e, o));
  } catch (M) {
    c(M);
  }
}
Kt.create = In.create, Kt.toCanvas = Tn.bind(null, Lo.render), Kt.toDataURL = Tn.bind(null, Lo.renderToDataURL), Kt.toString = Tn.bind(null, function(n, e, t) {
  return Du.render(n, t);
});
var Hu = function() {
  var n = document.getSelection();
  if (!n.rangeCount)
    return function() {
    };
  for (var e = document.activeElement, t = [], o = 0; o < n.rangeCount; o++)
    t.push(n.getRangeAt(o));
  switch (e.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      e.blur();
      break;
    default:
      e = null;
      break;
  }
  return n.removeAllRanges(), function() {
    n.type === "Caret" && n.removeAllRanges(), n.rangeCount || t.forEach(function(c) {
      n.addRange(c);
    }), e && e.focus();
  };
}, $u = Hu, Uo = { "text/plain": "Text", "text/html": "Url", default: "Text" }, Wu = "Copy to clipboard: #{key}, Enter";
function ju(n) {
  var e = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return n.replace(/#{\s*key\s*}/g, e);
}
function zu(n, e) {
  var t, o, c, a, d, p, w = !1;
  e || (e = {}), t = e.debug || !1;
  try {
    c = $u(), a = document.createRange(), d = document.getSelection(), p = document.createElement("span"), p.textContent = n, p.ariaHidden = "true", p.style.all = "unset", p.style.position = "fixed", p.style.top = 0, p.style.clip = "rect(0, 0, 0, 0)", p.style.whiteSpace = "pre", p.style.webkitUserSelect = "text", p.style.MozUserSelect = "text", p.style.msUserSelect = "text", p.style.userSelect = "text", p.addEventListener("copy", function(I) {
      if (I.stopPropagation(), e.format)
        if (I.preventDefault(), typeof I.clipboardData > "u") {
          t && console.warn("unable to use e.clipboardData"), t && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var B = Uo[e.format] || Uo.default;
          window.clipboardData.setData(B, n);
        } else
          I.clipboardData.clearData(), I.clipboardData.setData(e.format, n);
      e.onCopy && (I.preventDefault(), e.onCopy(I.clipboardData));
    }), document.body.appendChild(p), a.selectNodeContents(p), d.addRange(a);
    var M = document.execCommand("copy");
    if (!M)
      throw new Error("copy command was unsuccessful");
    w = !0;
  } catch (I) {
    t && console.error("unable to copy using execCommand: ", I), t && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(e.format || "text", n), e.onCopy && e.onCopy(window.clipboardData), w = !0;
    } catch (B) {
      t && console.error("unable to copy using clipboardData: ", B), t && console.error("falling back to prompt"), o = ju("message" in e ? e.message : Wu), window.prompt(o, n);
    }
  } finally {
    d && (typeof d.removeRange == "function" ? d.removeRange(a) : d.removeAllRanges()), p && document.body.removeChild(p), c();
  }
  return w;
}
var Ku = zu, se, Gt, On, Fo, Po, Bn, qo, Ve = {}, Cr = [], Ju = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function Ye(n, e) {
  for (var t in e)
    n[t] = e[t];
  return n;
}
function Do(n) {
  var e = n.parentNode;
  e && e.removeChild(n);
}
function Ge(n, e, t) {
  var o, c = arguments, a = {};
  for (o in e)
    o !== "key" && o !== "ref" && (a[o] = e[o]);
  if (arguments.length > 3)
    for (t = [t], o = 3; o < arguments.length; o++)
      t.push(c[o]);
  if (t != null && (a.children = t), typeof n == "function" && n.defaultProps != null)
    for (o in n.defaultProps)
      a[o] === void 0 && (a[o] = n.defaultProps[o]);
  return Sr(n, a, e && e.key, e && e.ref, null);
}
function Sr(n, e, t, o, c) {
  var a = { type: n, props: e, key: t, ref: o, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: c };
  return c == null && (a.__v = a), se.vnode && se.vnode(a), a;
}
function Ho() {
  return {};
}
function Qt(n) {
  return n.children;
}
function je(n, e) {
  this.props = n, this.context = e;
}
function Xt(n, e) {
  if (e == null)
    return n.__ ? Xt(n.__, n.__.__k.indexOf(n) + 1) : null;
  for (var t; e < n.__k.length; e++)
    if ((t = n.__k[e]) != null && t.__e != null)
      return t.__e;
  return typeof n.type == "function" ? Xt(n) : null;
}
function $o(n) {
  var e, t;
  if ((n = n.__) != null && n.__c != null) {
    for (n.__e = n.__c.base = null, e = 0; e < n.__k.length; e++)
      if ((t = n.__k[e]) != null && t.__e != null) {
        n.__e = n.__c.base = t.__e;
        break;
      }
    return $o(n);
  }
}
function Ar(n) {
  (!n.__d && (n.__d = !0) && Gt.push(n) && !On++ || Po !== se.debounceRendering) && ((Po = se.debounceRendering) || Fo)(Vu);
}
function Vu() {
  for (var n; On = Gt.length; )
    n = Gt.sort(function(e, t) {
      return e.__v.__b - t.__v.__b;
    }), Gt = [], n.some(function(e) {
      var t, o, c, a, d, p, w;
      e.__d && (p = (d = (t = e).__v).__e, (w = t.__P) && (o = [], (c = Ye({}, d)).__v = c, a = Nn(w, d, c, t.__n, w.ownerSVGElement !== void 0, null, o, p != null ? p : Xt(d)), Ko(o, d), a != p && $o(d)));
    });
}
function Wo(n, e, t, o, c, a, d, p, w) {
  var M, I, B, H, L, W, $, P = t && t.__k || Cr, U = P.length;
  if (p == Ve && (p = a != null ? a[0] : U ? Xt(t, 0) : null), M = 0, e.__k = ft(e.__k, function(G) {
    if (G != null) {
      if (G.__ = e, G.__b = e.__b + 1, (B = P[M]) === null || B && G.key == B.key && G.type === B.type)
        P[M] = void 0;
      else
        for (I = 0; I < U; I++) {
          if ((B = P[I]) && G.key == B.key && G.type === B.type) {
            P[I] = void 0;
            break;
          }
          B = null;
        }
      if (H = Nn(n, G, B = B || Ve, o, c, a, d, p, w), (I = G.ref) && B.ref != I && ($ || ($ = []), B.ref && $.push(B.ref, null, G), $.push(I, G.__c || H, G)), H != null) {
        var D;
        if (W == null && (W = H), G.__d !== void 0)
          D = G.__d, G.__d = void 0;
        else if (a == B || H != p || H.parentNode == null) {
          e:
            if (p == null || p.parentNode !== n)
              n.appendChild(H), D = null;
            else {
              for (L = p, I = 0; (L = L.nextSibling) && I < U; I += 2)
                if (L == H)
                  break e;
              n.insertBefore(H, p), D = p;
            }
          e.type == "option" && (n.value = "");
        }
        p = D !== void 0 ? D : H.nextSibling, typeof e.type == "function" && (e.__d = p);
      } else
        p && B.__e == p && p.parentNode != n && (p = Xt(B));
    }
    return M++, G;
  }), e.__e = W, a != null && typeof e.type != "function")
    for (M = a.length; M--; )
      a[M] != null && Do(a[M]);
  for (M = U; M--; )
    P[M] != null && Zt(P[M], P[M]);
  if ($)
    for (M = 0; M < $.length; M++)
      Jo($[M], $[++M], $[++M]);
}
function ft(n, e, t) {
  if (t == null && (t = []), n == null || typeof n == "boolean")
    e && t.push(e(null));
  else if (Array.isArray(n))
    for (var o = 0; o < n.length; o++)
      ft(n[o], e, t);
  else
    t.push(e ? e(typeof n == "string" || typeof n == "number" ? Sr(null, n, null, null, n) : n.__e != null || n.__c != null ? Sr(n.type, n.props, n.key, null, n.__v) : n) : n);
  return t;
}
function Yu(n, e, t, o, c) {
  var a;
  for (a in t)
    a === "children" || a === "key" || a in e || Rr(n, a, null, t[a], o);
  for (a in e)
    c && typeof e[a] != "function" || a === "children" || a === "key" || a === "value" || a === "checked" || t[a] === e[a] || Rr(n, a, e[a], t[a], o);
}
function jo(n, e, t) {
  e[0] === "-" ? n.setProperty(e, t) : n[e] = typeof t == "number" && Ju.test(e) === !1 ? t + "px" : t != null ? t : "";
}
function Rr(n, e, t, o, c) {
  var a, d, p, w, M;
  if (c ? e === "className" && (e = "class") : e === "class" && (e = "className"), e === "style")
    if (a = n.style, typeof t == "string")
      a.cssText = t;
    else {
      if (typeof o == "string" && (a.cssText = "", o = null), o)
        for (w in o)
          t && w in t || jo(a, w, "");
      if (t)
        for (M in t)
          o && t[M] === o[M] || jo(a, M, t[M]);
    }
  else
    e[0] === "o" && e[1] === "n" ? (d = e !== (e = e.replace(/Capture$/, "")), p = e.toLowerCase(), e = (p in n ? p : e).slice(2), t ? (o || n.addEventListener(e, zo, d), (n.l || (n.l = {}))[e] = t) : n.removeEventListener(e, zo, d)) : e !== "list" && e !== "tagName" && e !== "form" && e !== "type" && e !== "size" && !c && e in n ? n[e] = t != null ? t : "" : typeof t != "function" && e !== "dangerouslySetInnerHTML" && (e !== (e = e.replace(/^xlink:?/, "")) ? t == null || t === !1 ? n.removeAttributeNS("http://www.w3.org/1999/xlink", e.toLowerCase()) : n.setAttributeNS("http://www.w3.org/1999/xlink", e.toLowerCase(), t) : t == null || t === !1 && !/^ar/.test(e) ? n.removeAttribute(e) : n.setAttribute(e, t));
}
function zo(n) {
  this.l[n.type](se.event ? se.event(n) : n);
}
function Nn(n, e, t, o, c, a, d, p, w) {
  var M, I, B, H, L, W, $, P, U, G, D = e.type;
  if (e.constructor !== void 0)
    return null;
  (M = se.__b) && M(e);
  try {
    e:
      if (typeof D == "function") {
        if (P = e.props, U = (M = D.contextType) && o[M.__c], G = M ? U ? U.props.value : M.__ : o, t.__c ? $ = (I = e.__c = t.__c).__ = I.__E : ("prototype" in D && D.prototype.render ? e.__c = I = new D(P, G) : (e.__c = I = new je(P, G), I.constructor = D, I.render = Qu), U && U.sub(I), I.props = P, I.state || (I.state = {}), I.context = G, I.__n = o, B = I.__d = !0, I.__h = []), I.__s == null && (I.__s = I.state), D.getDerivedStateFromProps != null && (I.__s == I.state && (I.__s = Ye({}, I.__s)), Ye(I.__s, D.getDerivedStateFromProps(P, I.__s))), H = I.props, L = I.state, B)
          D.getDerivedStateFromProps == null && I.componentWillMount != null && I.componentWillMount(), I.componentDidMount != null && I.__h.push(I.componentDidMount);
        else {
          if (D.getDerivedStateFromProps == null && P !== H && I.componentWillReceiveProps != null && I.componentWillReceiveProps(P, G), !I.__e && I.shouldComponentUpdate != null && I.shouldComponentUpdate(P, I.__s, G) === !1 || e.__v === t.__v && !I.__) {
            for (I.props = P, I.state = I.__s, e.__v !== t.__v && (I.__d = !1), I.__v = e, e.__e = t.__e, e.__k = t.__k, I.__h.length && d.push(I), M = 0; M < e.__k.length; M++)
              e.__k[M] && (e.__k[M].__ = e);
            break e;
          }
          I.componentWillUpdate != null && I.componentWillUpdate(P, I.__s, G), I.componentDidUpdate != null && I.__h.push(function() {
            I.componentDidUpdate(H, L, W);
          });
        }
        I.context = G, I.props = P, I.state = I.__s, (M = se.__r) && M(e), I.__d = !1, I.__v = e, I.__P = n, M = I.render(I.props, I.state, I.context), e.__k = M != null && M.type == Qt && M.key == null ? M.props.children : Array.isArray(M) ? M : [M], I.getChildContext != null && (o = Ye(Ye({}, o), I.getChildContext())), B || I.getSnapshotBeforeUpdate == null || (W = I.getSnapshotBeforeUpdate(H, L)), Wo(n, e, t, o, c, a, d, p, w), I.base = e.__e, I.__h.length && d.push(I), $ && (I.__E = I.__ = null), I.__e = !1;
      } else
        a == null && e.__v === t.__v ? (e.__k = t.__k, e.__e = t.__e) : e.__e = Gu(t.__e, e, t, o, c, a, d, w);
    (M = se.diffed) && M(e);
  } catch (Z) {
    e.__v = null, se.__e(Z, e, t);
  }
  return e.__e;
}
function Ko(n, e) {
  se.__c && se.__c(e, n), n.some(function(t) {
    try {
      n = t.__h, t.__h = [], n.some(function(o) {
        o.call(t);
      });
    } catch (o) {
      se.__e(o, t.__v);
    }
  });
}
function Gu(n, e, t, o, c, a, d, p) {
  var w, M, I, B, H, L = t.props, W = e.props;
  if (c = e.type === "svg" || c, a != null) {
    for (w = 0; w < a.length; w++)
      if ((M = a[w]) != null && ((e.type === null ? M.nodeType === 3 : M.localName === e.type) || n == M)) {
        n = M, a[w] = null;
        break;
      }
  }
  if (n == null) {
    if (e.type === null)
      return document.createTextNode(W);
    n = c ? document.createElementNS("http://www.w3.org/2000/svg", e.type) : document.createElement(e.type, W.is && { is: W.is }), a = null, p = !1;
  }
  if (e.type === null)
    L !== W && n.data != W && (n.data = W);
  else {
    if (a != null && (a = Cr.slice.call(n.childNodes)), I = (L = t.props || Ve).dangerouslySetInnerHTML, B = W.dangerouslySetInnerHTML, !p) {
      if (L === Ve)
        for (L = {}, H = 0; H < n.attributes.length; H++)
          L[n.attributes[H].name] = n.attributes[H].value;
      (B || I) && (B && I && B.__html == I.__html || (n.innerHTML = B && B.__html || ""));
    }
    Yu(n, W, L, c, p), B ? e.__k = [] : (e.__k = e.props.children, Wo(n, e, t, o, e.type !== "foreignObject" && c, a, d, Ve, p)), p || ("value" in W && (w = W.value) !== void 0 && w !== n.value && Rr(n, "value", w, L.value, !1), "checked" in W && (w = W.checked) !== void 0 && w !== n.checked && Rr(n, "checked", w, L.checked, !1));
  }
  return n;
}
function Jo(n, e, t) {
  try {
    typeof n == "function" ? n(e) : n.current = e;
  } catch (o) {
    se.__e(o, t);
  }
}
function Zt(n, e, t) {
  var o, c, a;
  if (se.unmount && se.unmount(n), (o = n.ref) && (o.current && o.current !== n.__e || Jo(o, null, e)), t || typeof n.type == "function" || (t = (c = n.__e) != null), n.__e = n.__d = void 0, (o = n.__c) != null) {
    if (o.componentWillUnmount)
      try {
        o.componentWillUnmount();
      } catch (d) {
        se.__e(d, e);
      }
    o.base = o.__P = null;
  }
  if (o = n.__k)
    for (a = 0; a < o.length; a++)
      o[a] && Zt(o[a], e, t);
  c != null && Do(c);
}
function Qu(n, e, t) {
  return this.constructor(n, t);
}
function er(n, e, t) {
  var o, c, a;
  se.__ && se.__(n, e), c = (o = t === Bn) ? null : t && t.__k || e.__k, n = Ge(Qt, null, [n]), a = [], Nn(e, (o ? e : t || e).__k = n, c || Ve, Ve, e.ownerSVGElement !== void 0, t && !o ? [t] : c ? null : Cr.slice.call(e.childNodes), a, t || Ve, o), Ko(a, n);
}
function Vo(n, e) {
  er(n, e, Bn);
}
function Xu(n, e) {
  var t, o;
  for (o in e = Ye(Ye({}, n.props), e), arguments.length > 2 && (e.children = Cr.slice.call(arguments, 2)), t = {}, e)
    o !== "key" && o !== "ref" && (t[o] = e[o]);
  return Sr(n.type, t, e.key || n.key, e.ref || n.ref, null);
}
function Yo(n) {
  var e = {}, t = { __c: "__cC" + qo++, __: n, Consumer: function(o, c) {
    return o.children(c);
  }, Provider: function(o) {
    var c, a = this;
    return this.getChildContext || (c = [], this.getChildContext = function() {
      return e[t.__c] = a, e;
    }, this.shouldComponentUpdate = function(d) {
      a.props.value !== d.value && c.some(function(p) {
        p.context = d.value, Ar(p);
      });
    }, this.sub = function(d) {
      c.push(d);
      var p = d.componentWillUnmount;
      d.componentWillUnmount = function() {
        c.splice(c.indexOf(d), 1), p && p.call(d);
      };
    }), o.children;
  } };
  return t.Consumer.contextType = t, t.Provider.__ = t, t;
}
se = { __e: function(n, e) {
  for (var t, o; e = e.__; )
    if ((t = e.__c) && !t.__)
      try {
        if (t.constructor && t.constructor.getDerivedStateFromError != null && (o = !0, t.setState(t.constructor.getDerivedStateFromError(n))), t.componentDidCatch != null && (o = !0, t.componentDidCatch(n)), o)
          return Ar(t.__E = t);
      } catch (c) {
        n = c;
      }
  throw n;
} }, je.prototype.setState = function(n, e) {
  var t;
  t = this.__s !== this.state ? this.__s : this.__s = Ye({}, this.state), typeof n == "function" && (n = n(t, this.props)), n && Ye(t, n), n != null && this.__v && (e && this.__h.push(e), Ar(this));
}, je.prototype.forceUpdate = function(n) {
  this.__v && (this.__e = !0, n && this.__h.push(n), Ar(this));
}, je.prototype.render = Qt, Gt = [], On = 0, Fo = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, Bn = Ve, qo = 0;
var Ct, Pe, Go, Pt = 0, Ln = [], Qo = se.__r, Xo = se.diffed, Zo = se.__c, ea = se.unmount;
function qt(n, e) {
  se.__h && se.__h(Pe, n, Pt || e), Pt = 0;
  var t = Pe.__H || (Pe.__H = { __: [], __h: [] });
  return n >= t.__.length && t.__.push({}), t.__[n];
}
function Un(n) {
  return Pt = 1, Fn(sa, n);
}
function Fn(n, e, t) {
  var o = qt(Ct++, 2);
  return o.__c || (o.__c = Pe, o.__ = [t ? t(e) : sa(void 0, e), function(c) {
    var a = n(o.__[0], c);
    o.__[0] !== a && (o.__[0] = a, o.__c.setState({}));
  }]), o.__;
}
function ta(n, e) {
  var t = qt(Ct++, 3);
  !se.__s && Hn(t.__H, e) && (t.__ = n, t.__H = e, Pe.__H.__h.push(t));
}
function Pn(n, e) {
  var t = qt(Ct++, 4);
  !se.__s && Hn(t.__H, e) && (t.__ = n, t.__H = e, Pe.__h.push(t));
}
function ra(n) {
  return Pt = 5, kr(function() {
    return { current: n };
  }, []);
}
function na(n, e, t) {
  Pt = 6, Pn(function() {
    typeof n == "function" ? n(e()) : n && (n.current = e());
  }, t == null ? t : t.concat(n));
}
function kr(n, e) {
  var t = qt(Ct++, 7);
  return Hn(t.__H, e) ? (t.__H = e, t.__h = n, t.__ = n()) : t.__;
}
function ia(n, e) {
  return Pt = 8, kr(function() {
    return n;
  }, e);
}
function oa(n) {
  var e = Pe.context[n.__c], t = qt(Ct++, 9);
  return t.__c = n, e ? (t.__ == null && (t.__ = !0, e.sub(Pe)), e.props.value) : n.__;
}
function aa(n, e) {
  se.useDebugValue && se.useDebugValue(e ? e(n) : n);
}
function Zu(n) {
  var e = qt(Ct++, 10), t = Un();
  return e.__ = n, Pe.componentDidCatch || (Pe.componentDidCatch = function(o) {
    e.__ && e.__(o), t[1](o);
  }), [t[0], function() {
    t[1](void 0);
  }];
}
function el() {
  Ln.some(function(n) {
    if (n.__P)
      try {
        n.__H.__h.forEach(qn), n.__H.__h.forEach(Dn), n.__H.__h = [];
      } catch (e) {
        return n.__H.__h = [], se.__e(e, n.__v), !0;
      }
  }), Ln = [];
}
function qn(n) {
  n.t && n.t();
}
function Dn(n) {
  var e = n.__();
  typeof e == "function" && (n.t = e);
}
function Hn(n, e) {
  return !n || e.some(function(t, o) {
    return t !== n[o];
  });
}
function sa(n, e) {
  return typeof e == "function" ? e(n) : e;
}
se.__r = function(n) {
  Qo && Qo(n), Ct = 0, (Pe = n.__c).__H && (Pe.__H.__h.forEach(qn), Pe.__H.__h.forEach(Dn), Pe.__H.__h = []);
}, se.diffed = function(n) {
  Xo && Xo(n);
  var e = n.__c;
  if (e) {
    var t = e.__H;
    t && t.__h.length && (Ln.push(e) !== 1 && Go === se.requestAnimationFrame || ((Go = se.requestAnimationFrame) || function(o) {
      var c, a = function() {
        clearTimeout(d), cancelAnimationFrame(c), setTimeout(o);
      }, d = setTimeout(a, 100);
      typeof window < "u" && (c = requestAnimationFrame(a));
    })(el));
  }
}, se.__c = function(n, e) {
  e.some(function(t) {
    try {
      t.__h.forEach(qn), t.__h = t.__h.filter(function(o) {
        return !o.__ || Dn(o);
      });
    } catch (o) {
      e.some(function(c) {
        c.__h && (c.__h = []);
      }), e = [], se.__e(o, t.__v);
    }
  }), Zo && Zo(n, e);
}, se.unmount = function(n) {
  ea && ea(n);
  var e = n.__c;
  if (e) {
    var t = e.__H;
    if (t)
      try {
        t.__.forEach(function(o) {
          return o.t && o.t();
        });
      } catch (o) {
        se.__e(o, e.__v);
      }
  }
};
function $n(n, e) {
  for (var t in e)
    n[t] = e[t];
  return n;
}
function Wn(n, e) {
  for (var t in n)
    if (t !== "__source" && !(t in e))
      return !0;
  for (var o in e)
    if (o !== "__source" && n[o] !== e[o])
      return !0;
  return !1;
}
var ca = function(n) {
  var e, t;
  function o(c) {
    var a;
    return (a = n.call(this, c) || this).isPureReactComponent = !0, a;
  }
  return t = n, (e = o).prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t, o.prototype.shouldComponentUpdate = function(c, a) {
    return Wn(this.props, c) || Wn(this.state, a);
  }, o;
}(je);
function ha(n, e) {
  function t(c) {
    var a = this.props.ref, d = a == c.ref;
    return !d && a && (a.call ? a(null) : a.current = null), e ? !e(this.props, c) || !d : Wn(this.props, c);
  }
  function o(c) {
    return this.shouldComponentUpdate = t, Ge(n, $n({}, c));
  }
  return o.prototype.isReactComponent = !0, o.displayName = "Memo(" + (n.displayName || n.name) + ")", o.t = !0, o;
}
var ua = se.__b;
function la(n) {
  function e(t) {
    var o = $n({}, t);
    return delete o.ref, n(o, t.ref);
  }
  return e.prototype.isReactComponent = e.t = !0, e.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", e;
}
se.__b = function(n) {
  n.type && n.type.t && n.ref && (n.props.ref = n.ref, n.ref = null), ua && ua(n);
};
var fa = function(n, e) {
  return n ? ft(n).reduce(function(t, o, c) {
    return t.concat(e(o, c));
  }, []) : null;
}, da = { map: fa, forEach: fa, count: function(n) {
  return n ? ft(n).length : 0;
}, only: function(n) {
  if ((n = ft(n)).length !== 1)
    throw new Error("Children.only() expects only one child.");
  return n[0];
}, toArray: ft }, tl = se.__e;
function pa(n) {
  return n && ((n = $n({}, n)).__c = null, n.__k = n.__k && n.__k.map(pa)), n;
}
function Ir() {
  this.__u = 0, this.o = null, this.__b = null;
}
function ga(n) {
  var e = n.__.__c;
  return e && e.u && e.u(n);
}
function _a(n) {
  var e, t, o;
  function c(a) {
    if (e || (e = n()).then(function(d) {
      t = d.default || d;
    }, function(d) {
      o = d;
    }), o)
      throw o;
    if (!t)
      throw e;
    return Ge(t, a);
  }
  return c.displayName = "Lazy", c.t = !0, c;
}
function Dt() {
  this.i = null, this.l = null;
}
se.__e = function(n, e, t) {
  if (n.then) {
    for (var o, c = e; c = c.__; )
      if ((o = c.__c) && o.__c)
        return o.__c(n, e.__c);
  }
  tl(n, e, t);
}, (Ir.prototype = new je()).__c = function(n, e) {
  var t = this;
  t.o == null && (t.o = []), t.o.push(e);
  var o = ga(t.__v), c = !1, a = function() {
    c || (c = !0, o ? o(d) : d());
  };
  e.__c = e.componentWillUnmount, e.componentWillUnmount = function() {
    a(), e.__c && e.__c();
  };
  var d = function() {
    var p;
    if (!--t.__u)
      for (t.__v.__k[0] = t.state.u, t.setState({ u: t.__b = null }); p = t.o.pop(); )
        p.forceUpdate();
  };
  t.__u++ || t.setState({ u: t.__b = t.__v.__k[0] }), n.then(a, a);
}, Ir.prototype.render = function(n, e) {
  return this.__b && (this.__v.__k[0] = pa(this.__b), this.__b = null), [Ge(je, null, e.u ? null : n.children), e.u && n.fallback];
};
var ma = function(n, e, t) {
  if (++t[1] === t[0] && n.l.delete(e), n.props.revealOrder && (n.props.revealOrder[0] !== "t" || !n.l.size))
    for (t = n.i; t; ) {
      for (; t.length > 3; )
        t.pop()();
      if (t[1] < t[0])
        break;
      n.i = t = t[2];
    }
};
(Dt.prototype = new je()).u = function(n) {
  var e = this, t = ga(e.__v), o = e.l.get(n);
  return o[0]++, function(c) {
    var a = function() {
      e.props.revealOrder ? (o.push(c), ma(e, n, o)) : c();
    };
    t ? t(a) : a();
  };
}, Dt.prototype.render = function(n) {
  this.i = null, this.l = /* @__PURE__ */ new Map();
  var e = ft(n.children);
  n.revealOrder && n.revealOrder[0] === "b" && e.reverse();
  for (var t = e.length; t--; )
    this.l.set(e[t], this.i = [1, 0, this.i]);
  return n.children;
}, Dt.prototype.componentDidUpdate = Dt.prototype.componentDidMount = function() {
  var n = this;
  n.l.forEach(function(e, t) {
    ma(n, t, e);
  });
};
var rl = function() {
  function n() {
  }
  var e = n.prototype;
  return e.getChildContext = function() {
    return this.props.context;
  }, e.render = function(t) {
    return t.children;
  }, n;
}();
function nl(n) {
  var e = this, t = n.container, o = Ge(rl, { context: e.context }, n.vnode);
  return e.s && e.s !== t && (e.v.parentNode && e.s.removeChild(e.v), Zt(e.h), e.p = !1), n.vnode ? e.p ? (t.__k = e.__k, er(o, t), e.__k = t.__k) : (e.v = document.createTextNode(""), Vo("", t), t.appendChild(e.v), e.p = !0, e.s = t, er(o, t, e.v), e.__k = e.v.__k) : e.p && (e.v.parentNode && e.s.removeChild(e.v), Zt(e.h)), e.h = o, e.componentWillUnmount = function() {
    e.v.parentNode && e.s.removeChild(e.v), Zt(e.h);
  }, null;
}
function va(n, e) {
  return Ge(nl, { vnode: n, container: e });
}
var ya = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
je.prototype.isReactComponent = {};
var wa = typeof Symbol < "u" && Symbol.for && Symbol.for("react.element") || 60103;
function jn(n, e, t) {
  if (e.__k == null)
    for (; e.firstChild; )
      e.removeChild(e.firstChild);
  return er(n, e), typeof t == "function" && t(), n ? n.__c : null;
}
function il(n, e, t) {
  return Vo(n, e), typeof t == "function" && t(), n ? n.__c : null;
}
var ba = se.event;
function zn(n, e) {
  n["UNSAFE_" + e] && !n[e] && Object.defineProperty(n, e, { configurable: !1, get: function() {
    return this["UNSAFE_" + e];
  }, set: function(t) {
    this["UNSAFE_" + e] = t;
  } });
}
se.event = function(n) {
  ba && (n = ba(n)), n.persist = function() {
  };
  var e = !1, t = !1, o = n.stopPropagation;
  n.stopPropagation = function() {
    o.call(n), e = !0;
  };
  var c = n.preventDefault;
  return n.preventDefault = function() {
    c.call(n), t = !0;
  }, n.isPropagationStopped = function() {
    return e;
  }, n.isDefaultPrevented = function() {
    return t;
  }, n.nativeEvent = n;
};
var xa = { configurable: !0, get: function() {
  return this.class;
} }, Ma = se.vnode;
se.vnode = function(n) {
  n.$$typeof = wa;
  var e = n.type, t = n.props;
  if (e) {
    if (t.class != t.className && (xa.enumerable = "className" in t, t.className != null && (t.class = t.className), Object.defineProperty(t, "className", xa)), typeof e != "function") {
      var o, c, a;
      for (a in t.defaultValue && t.value !== void 0 && (t.value || t.value === 0 || (t.value = t.defaultValue), delete t.defaultValue), Array.isArray(t.value) && t.multiple && e === "select" && (ft(t.children).forEach(function(d) {
        t.value.indexOf(d.props.value) != -1 && (d.props.selected = !0);
      }), delete t.value), t)
        if (o = ya.test(a))
          break;
      if (o)
        for (a in c = n.props = {}, t)
          c[ya.test(a) ? a.replace(/[A-Z0-9]/, "-$&").toLowerCase() : a] = t[a];
    }
    (function(d) {
      var p = n.type, w = n.props;
      if (w && typeof p == "string") {
        var M = {};
        for (var I in w)
          /^on(Ani|Tra|Tou)/.test(I) && (w[I.toLowerCase()] = w[I], delete w[I]), M[I.toLowerCase()] = I;
        if (M.ondoubleclick && (w.ondblclick = w[M.ondoubleclick], delete w[M.ondoubleclick]), M.onbeforeinput && (w.onbeforeinput = w[M.onbeforeinput], delete w[M.onbeforeinput]), M.onchange && (p === "textarea" || p.toLowerCase() === "input" && !/^fil|che|ra/i.test(w.type))) {
          var B = M.oninput || "oninput";
          w[B] || (w[B] = w[M.onchange], delete w[M.onchange]);
        }
      }
    })(), typeof e == "function" && !e.m && e.prototype && (zn(e.prototype, "componentWillMount"), zn(e.prototype, "componentWillReceiveProps"), zn(e.prototype, "componentWillUpdate"), e.m = !0);
  }
  Ma && Ma(n);
};
var ol = "16.8.0";
function Ea(n) {
  return Ge.bind(null, n);
}
function Kn(n) {
  return !!n && n.$$typeof === wa;
}
function Ca(n) {
  return Kn(n) ? Xu.apply(null, arguments) : n;
}
function Sa(n) {
  return !!n.__k && (er(null, n), !0);
}
function Aa(n) {
  return n && (n.base || n.nodeType === 1 && n) || null;
}
var Ra = function(n, e) {
  return n(e);
}, al = { useState: Un, useReducer: Fn, useEffect: ta, useLayoutEffect: Pn, useRef: ra, useImperativeHandle: na, useMemo: kr, useCallback: ia, useContext: oa, useDebugValue: aa, version: "16.8.0", Children: da, render: jn, hydrate: jn, unmountComponentAtNode: Sa, createPortal: va, createElement: Ge, createContext: Yo, createFactory: Ea, cloneElement: Ca, createRef: Ho, Fragment: Qt, isValidElement: Kn, findDOMNode: Aa, Component: je, PureComponent: ca, memo: ha, forwardRef: la, unstable_batchedUpdates: Ra, Suspense: Ir, SuspenseList: Dt, lazy: _a }, sl = Object.freeze({ __proto__: null, default: al, version: ol, Children: da, render: jn, hydrate: il, unmountComponentAtNode: Sa, createPortal: va, createFactory: Ea, cloneElement: Ca, isValidElement: Kn, findDOMNode: Aa, PureComponent: ca, memo: ha, forwardRef: la, unstable_batchedUpdates: Ra, Suspense: Ir, SuspenseList: Dt, lazy: _a, createElement: Ge, createContext: Yo, createRef: Ho, Fragment: Qt, Component: je, useState: Un, useReducer: Fn, useEffect: ta, useLayoutEffect: Pn, useRef: ra, useImperativeHandle: na, useMemo: kr, useCallback: ia, useContext: oa, useDebugValue: aa, useErrorBoundary: Zu });
Jr(sl);
function ka(n) {
  return n && typeof n == "object" && "default" in n ? n.default : n;
}
ka(Kt);
ka(Ku);
typeof Symbol < "u" && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))), typeof Symbol < "u" && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
var Pa = { exports: {} };
(function(n) {
  var e = Object.prototype.hasOwnProperty, t = "~";
  function o() {
  }
  Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (t = !1));
  function c(w, M, I) {
    this.fn = w, this.context = M, this.once = I || !1;
  }
  function a(w, M, I, B, H) {
    if (typeof I != "function")
      throw new TypeError("The listener must be a function");
    var L = new c(I, B || w, H), W = t ? t + M : M;
    return w._events[W] ? w._events[W].fn ? w._events[W] = [w._events[W], L] : w._events[W].push(L) : (w._events[W] = L, w._eventsCount++), w;
  }
  function d(w, M) {
    --w._eventsCount === 0 ? w._events = new o() : delete w._events[M];
  }
  function p() {
    this._events = new o(), this._eventsCount = 0;
  }
  p.prototype.eventNames = function() {
    var w = [], M, I;
    if (this._eventsCount === 0)
      return w;
    for (I in M = this._events)
      e.call(M, I) && w.push(t ? I.slice(1) : I);
    return Object.getOwnPropertySymbols ? w.concat(Object.getOwnPropertySymbols(M)) : w;
  }, p.prototype.listeners = function(w) {
    var M = t ? t + w : w, I = this._events[M];
    if (!I)
      return [];
    if (I.fn)
      return [I.fn];
    for (var B = 0, H = I.length, L = new Array(H); B < H; B++)
      L[B] = I[B].fn;
    return L;
  }, p.prototype.listenerCount = function(w) {
    var M = t ? t + w : w, I = this._events[M];
    return I ? I.fn ? 1 : I.length : 0;
  }, p.prototype.emit = function(w, M, I, B, H, L) {
    var W = t ? t + w : w;
    if (!this._events[W])
      return !1;
    var $ = this._events[W], P = arguments.length, U, G;
    if ($.fn) {
      switch ($.once && this.removeListener(w, $.fn, void 0, !0), P) {
        case 1:
          return $.fn.call($.context), !0;
        case 2:
          return $.fn.call($.context, M), !0;
        case 3:
          return $.fn.call($.context, M, I), !0;
        case 4:
          return $.fn.call($.context, M, I, B), !0;
        case 5:
          return $.fn.call($.context, M, I, B, H), !0;
        case 6:
          return $.fn.call($.context, M, I, B, H, L), !0;
      }
      for (G = 1, U = new Array(P - 1); G < P; G++)
        U[G - 1] = arguments[G];
      $.fn.apply($.context, U);
    } else {
      var D = $.length, Z;
      for (G = 0; G < D; G++)
        switch ($[G].once && this.removeListener(w, $[G].fn, void 0, !0), P) {
          case 1:
            $[G].fn.call($[G].context);
            break;
          case 2:
            $[G].fn.call($[G].context, M);
            break;
          case 3:
            $[G].fn.call($[G].context, M, I);
            break;
          case 4:
            $[G].fn.call($[G].context, M, I, B);
            break;
          default:
            if (!U)
              for (Z = 1, U = new Array(P - 1); Z < P; Z++)
                U[Z - 1] = arguments[Z];
            $[G].fn.apply($[G].context, U);
        }
    }
    return !0;
  }, p.prototype.on = function(w, M, I) {
    return a(this, w, M, I, !1);
  }, p.prototype.once = function(w, M, I) {
    return a(this, w, M, I, !0);
  }, p.prototype.removeListener = function(w, M, I, B) {
    var H = t ? t + w : w;
    if (!this._events[H])
      return this;
    if (!M)
      return d(this, H), this;
    var L = this._events[H];
    if (L.fn)
      L.fn === M && (!B || L.once) && (!I || L.context === I) && d(this, H);
    else {
      for (var W = 0, $ = [], P = L.length; W < P; W++)
        (L[W].fn !== M || B && !L[W].once || I && L[W].context !== I) && $.push(L[W]);
      $.length ? this._events[H] = $.length === 1 ? $[0] : $ : d(this, H);
    }
    return this;
  }, p.prototype.removeAllListeners = function(w) {
    var M;
    return w ? (M = t ? t + w : w, this._events[M] && d(this, M)) : (this._events = new o(), this._eventsCount = 0), this;
  }, p.prototype.off = p.prototype.removeListener, p.prototype.addListener = p.prototype.on, p.prefixed = t, p.EventEmitter = p, n.exports = p;
})(Pa);
Pa.exports;
var qa = {}, Vn = {}, Ht = {}, Yn = { exports: {} };
/*! https://mths.be/punycode v1.3.2 by @mathias */
(function(n, e) {
  (function(t) {
    var o = e && !e.nodeType && e, c = n && !n.nodeType && n, a = typeof Ue == "object" && Ue;
    (a.global === a || a.window === a || a.self === a) && (t = a);
    var d, p = 2147483647, w = 36, M = 1, I = 26, B = 38, H = 700, L = 72, W = 128, $ = "-", P = /^xn--/, U = /[^\x20-\x7E]/, G = /[\x2E\u3002\uFF0E\uFF61]/g, D = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, Z = w - M, J = Math.floor, te = String.fromCharCode, ue;
    function he(R) {
      throw RangeError(D[R]);
    }
    function Se(R, b) {
      for (var l = R.length, v = []; l--; )
        v[l] = b(R[l]);
      return v;
    }
    function C(R, b) {
      var l = R.split("@"), v = "";
      l.length > 1 && (v = l[0] + "@", R = l[1]), R = R.replace(G, ".");
      var X = R.split("."), S = Se(X, b).join(".");
      return v + S;
    }
    function O(R) {
      for (var b = [], l = 0, v = R.length, X, S; l < v; )
        X = R.charCodeAt(l++), X >= 55296 && X <= 56319 && l < v ? (S = R.charCodeAt(l++), (S & 64512) == 56320 ? b.push(((X & 1023) << 10) + (S & 1023) + 65536) : (b.push(X), l--)) : b.push(X);
      return b;
    }
    function V(R) {
      return Se(R, function(b) {
        var l = "";
        return b > 65535 && (b -= 65536, l += te(b >>> 10 & 1023 | 55296), b = 56320 | b & 1023), l += te(b), l;
      }).join("");
    }
    function x(R) {
      return R - 48 < 10 ? R - 22 : R - 65 < 26 ? R - 65 : R - 97 < 26 ? R - 97 : w;
    }
    function u(R, b) {
      return R + 22 + 75 * (R < 26) - ((b != 0) << 5);
    }
    function h(R, b, l) {
      var v = 0;
      for (R = l ? J(R / H) : R >> 1, R += J(R / b); R > Z * I >> 1; v += w)
        R = J(R / Z);
      return J(v + (Z + 1) * R / (R + B));
    }
    function g(R) {
      var b = [], l = R.length, v, X = 0, S = W, Y = L, fe, oe, de, Ie, ye, be, rt, xe, Ne;
      for (fe = R.lastIndexOf($), fe < 0 && (fe = 0), oe = 0; oe < fe; ++oe)
        R.charCodeAt(oe) >= 128 && he("not-basic"), b.push(R.charCodeAt(oe));
      for (de = fe > 0 ? fe + 1 : 0; de < l; ) {
        for (Ie = X, ye = 1, be = w; de >= l && he("invalid-input"), rt = x(R.charCodeAt(de++)), (rt >= w || rt > J((p - X) / ye)) && he("overflow"), X += rt * ye, xe = be <= Y ? M : be >= Y + I ? I : be - Y, !(rt < xe); be += w)
          Ne = w - xe, ye > J(p / Ne) && he("overflow"), ye *= Ne;
        v = b.length + 1, Y = h(X - Ie, v, Ie == 0), J(X / v) > p - S && he("overflow"), S += J(X / v), X %= v, b.splice(X++, 0, S);
      }
      return V(b);
    }
    function y(R) {
      var b, l, v, X, S, Y, fe, oe, de, Ie, ye, be = [], rt, xe, Ne, j;
      for (R = O(R), rt = R.length, b = W, l = 0, S = L, Y = 0; Y < rt; ++Y)
        ye = R[Y], ye < 128 && be.push(te(ye));
      for (v = X = be.length, X && be.push($); v < rt; ) {
        for (fe = p, Y = 0; Y < rt; ++Y)
          ye = R[Y], ye >= b && ye < fe && (fe = ye);
        for (xe = v + 1, fe - b > J((p - l) / xe) && he("overflow"), l += (fe - b) * xe, b = fe, Y = 0; Y < rt; ++Y)
          if (ye = R[Y], ye < b && ++l > p && he("overflow"), ye == b) {
            for (oe = l, de = w; Ie = de <= S ? M : de >= S + I ? I : de - S, !(oe < Ie); de += w)
              j = oe - Ie, Ne = w - Ie, be.push(te(u(Ie + j % Ne, 0))), oe = J(j / Ne);
            be.push(te(u(oe, 0))), S = h(l, xe, v == X), l = 0, ++v;
          }
        ++l, ++b;
      }
      return be.join("");
    }
    function m(R) {
      return C(R, function(b) {
        return P.test(b) ? g(b.slice(4).toLowerCase()) : b;
      });
    }
    function _(R) {
      return C(R, function(b) {
        return U.test(b) ? "xn--" + y(b) : b;
      });
    }
    if (d = { version: "1.3.2", ucs2: { decode: O, encode: V }, decode: g, encode: y, toASCII: _, toUnicode: m }, o && c)
      if (n.exports == o)
        c.exports = d;
      else
        for (ue in d)
          d.hasOwnProperty(ue) && (o[ue] = d[ue]);
    else
      t.punycode = d;
  })(Ue);
})(Yn, Yn.exports);
var Yl = { isString: function(n) {
  return typeof n == "string";
}, isObject: function(n) {
  return typeof n == "object" && n !== null;
}, isNull: function(n) {
  return n === null;
}, isNullOrUndefined: function(n) {
  return n == null;
} }, tr = {};
function Gl(n, e) {
  return Object.prototype.hasOwnProperty.call(n, e);
}
var Ql = function(n, e, t, o) {
  e = e || "&", t = t || "=";
  var c = {};
  if (typeof n != "string" || n.length === 0)
    return c;
  var a = /\+/g;
  n = n.split(e);
  var d = 1e3;
  o && typeof o.maxKeys == "number" && (d = o.maxKeys);
  var p = n.length;
  d > 0 && p > d && (p = d);
  for (var w = 0; w < p; ++w) {
    var M = n[w].replace(a, "%20"), I = M.indexOf(t), B, H, L, W;
    I >= 0 ? (B = M.substr(0, I), H = M.substr(I + 1)) : (B = M, H = ""), L = decodeURIComponent(B), W = decodeURIComponent(H), Gl(c, L) ? Array.isArray(c[L]) ? c[L].push(W) : c[L] = [c[L], W] : c[L] = W;
  }
  return c;
}, rr = function(n) {
  switch (typeof n) {
    case "string":
      return n;
    case "boolean":
      return n ? "true" : "false";
    case "number":
      return isFinite(n) ? n : "";
    default:
      return "";
  }
}, Xl = function(n, e, t, o) {
  return e = e || "&", t = t || "=", n === null && (n = void 0), typeof n == "object" ? Object.keys(n).map(function(c) {
    var a = encodeURIComponent(rr(c)) + t;
    return Array.isArray(n[c]) ? n[c].map(function(d) {
      return a + encodeURIComponent(rr(d));
    }).join(e) : a + encodeURIComponent(rr(n[c]));
  }).join(e) : o ? encodeURIComponent(rr(o)) + t + encodeURIComponent(rr(n)) : "";
};
tr.decode = tr.parse = Ql, tr.encode = tr.stringify = Xl;
var Zl = Yn.exports, Je = Yl;
Ht.parse = nr, Ht.resolve = uf, Ht.resolveObject = lf, Ht.format = hf, Ht.Url = We;
function We() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var ef = /^([a-z0-9.+-]+:)/i, tf = /:[0-9]*$/, rf = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, nf = ["<", ">", '"', "`", " ", "\r", `
`, "	"], of = ["{", "}", "|", "\\", "^", "`"].concat(nf), Gn = ["'"].concat(of), Da = ["%", "/", "?", ";", "#"].concat(Gn), Ha = ["/", "?", "#"], af = 255, $a = /^[+a-z0-9A-Z_-]{0,63}$/, sf = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, cf = { javascript: !0, "javascript:": !0 }, Qn = { javascript: !0, "javascript:": !0 }, $t = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 }, Xn = tr;
function nr(n, e, t) {
  if (n && Je.isObject(n) && n instanceof We)
    return n;
  var o = new We();
  return o.parse(n, e, t), o;
}
We.prototype.parse = function(n, e, t) {
  if (!Je.isString(n))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof n);
  var o = n.indexOf("?"), c = o !== -1 && o < n.indexOf("#") ? "?" : "#", a = n.split(c), d = /\\/g;
  a[0] = a[0].replace(d, "/"), n = a.join(c);
  var p = n;
  if (p = p.trim(), !t && n.split("#").length === 1) {
    var w = rf.exec(p);
    if (w)
      return this.path = p, this.href = p, this.pathname = w[1], w[2] ? (this.search = w[2], e ? this.query = Xn.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : e && (this.search = "", this.query = {}), this;
  }
  var M = ef.exec(p);
  if (M) {
    M = M[0];
    var I = M.toLowerCase();
    this.protocol = I, p = p.substr(M.length);
  }
  if (t || M || p.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var B = p.substr(0, 2) === "//";
    B && !(M && Qn[M]) && (p = p.substr(2), this.slashes = !0);
  }
  if (!Qn[M] && (B || M && !$t[M])) {
    for (var H = -1, L = 0; L < Ha.length; L++) {
      var W = p.indexOf(Ha[L]);
      W !== -1 && (H === -1 || W < H) && (H = W);
    }
    var $, P;
    H === -1 ? P = p.lastIndexOf("@") : P = p.lastIndexOf("@", H), P !== -1 && ($ = p.slice(0, P), p = p.slice(P + 1), this.auth = decodeURIComponent($)), H = -1;
    for (var L = 0; L < Da.length; L++) {
      var W = p.indexOf(Da[L]);
      W !== -1 && (H === -1 || W < H) && (H = W);
    }
    H === -1 && (H = p.length), this.host = p.slice(0, H), p = p.slice(H), this.parseHost(), this.hostname = this.hostname || "";
    var U = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!U)
      for (var G = this.hostname.split(/\./), L = 0, D = G.length; L < D; L++) {
        var Z = G[L];
        if (!!Z && !Z.match($a)) {
          for (var J = "", te = 0, ue = Z.length; te < ue; te++)
            Z.charCodeAt(te) > 127 ? J += "x" : J += Z[te];
          if (!J.match($a)) {
            var he = G.slice(0, L), Se = G.slice(L + 1), C = Z.match(sf);
            C && (he.push(C[1]), Se.unshift(C[2])), Se.length && (p = "/" + Se.join(".") + p), this.hostname = he.join(".");
            break;
          }
        }
      }
    this.hostname.length > af ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U || (this.hostname = Zl.toASCII(this.hostname));
    var O = this.port ? ":" + this.port : "", V = this.hostname || "";
    this.host = V + O, this.href += this.host, U && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), p[0] !== "/" && (p = "/" + p));
  }
  if (!cf[I])
    for (var L = 0, D = Gn.length; L < D; L++) {
      var x = Gn[L];
      if (p.indexOf(x) !== -1) {
        var u = encodeURIComponent(x);
        u === x && (u = escape(x)), p = p.split(x).join(u);
      }
    }
  var h = p.indexOf("#");
  h !== -1 && (this.hash = p.substr(h), p = p.slice(0, h));
  var g = p.indexOf("?");
  if (g !== -1 ? (this.search = p.substr(g), this.query = p.substr(g + 1), e && (this.query = Xn.parse(this.query)), p = p.slice(0, g)) : e && (this.search = "", this.query = {}), p && (this.pathname = p), $t[I] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var O = this.pathname || "", y = this.search || "";
    this.path = O + y;
  }
  return this.href = this.format(), this;
};
function hf(n) {
  return Je.isString(n) && (n = nr(n)), n instanceof We ? n.format() : We.prototype.format.call(n);
}
We.prototype.format = function() {
  var n = this.auth || "";
  n && (n = encodeURIComponent(n), n = n.replace(/%3A/i, ":"), n += "@");
  var e = this.protocol || "", t = this.pathname || "", o = this.hash || "", c = !1, a = "";
  this.host ? c = n + this.host : this.hostname && (c = n + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (c += ":" + this.port)), this.query && Je.isObject(this.query) && Object.keys(this.query).length && (a = Xn.stringify(this.query));
  var d = this.search || a && "?" + a || "";
  return e && e.substr(-1) !== ":" && (e += ":"), this.slashes || (!e || $t[e]) && c !== !1 ? (c = "//" + (c || ""), t && t.charAt(0) !== "/" && (t = "/" + t)) : c || (c = ""), o && o.charAt(0) !== "#" && (o = "#" + o), d && d.charAt(0) !== "?" && (d = "?" + d), t = t.replace(/[?#]/g, function(p) {
    return encodeURIComponent(p);
  }), d = d.replace("#", "%23"), e + c + t + d + o;
};
function uf(n, e) {
  return nr(n, !1, !0).resolve(e);
}
We.prototype.resolve = function(n) {
  return this.resolveObject(nr(n, !1, !0)).format();
};
function lf(n, e) {
  return n ? nr(n, !1, !0).resolveObject(e) : e;
}
We.prototype.resolveObject = function(n) {
  if (Je.isString(n)) {
    var e = new We();
    e.parse(n, !1, !0), n = e;
  }
  for (var t = new We(), o = Object.keys(this), c = 0; c < o.length; c++) {
    var a = o[c];
    t[a] = this[a];
  }
  if (t.hash = n.hash, n.href === "")
    return t.href = t.format(), t;
  if (n.slashes && !n.protocol) {
    for (var d = Object.keys(n), p = 0; p < d.length; p++) {
      var w = d[p];
      w !== "protocol" && (t[w] = n[w]);
    }
    return $t[t.protocol] && t.hostname && !t.pathname && (t.path = t.pathname = "/"), t.href = t.format(), t;
  }
  if (n.protocol && n.protocol !== t.protocol) {
    if (!$t[n.protocol]) {
      for (var M = Object.keys(n), I = 0; I < M.length; I++) {
        var B = M[I];
        t[B] = n[B];
      }
      return t.href = t.format(), t;
    }
    if (t.protocol = n.protocol, !n.host && !Qn[n.protocol]) {
      for (var D = (n.pathname || "").split("/"); D.length && !(n.host = D.shift()); )
        ;
      n.host || (n.host = ""), n.hostname || (n.hostname = ""), D[0] !== "" && D.unshift(""), D.length < 2 && D.unshift(""), t.pathname = D.join("/");
    } else
      t.pathname = n.pathname;
    if (t.search = n.search, t.query = n.query, t.host = n.host || "", t.auth = n.auth, t.hostname = n.hostname || n.host, t.port = n.port, t.pathname || t.search) {
      var H = t.pathname || "", L = t.search || "";
      t.path = H + L;
    }
    return t.slashes = t.slashes || n.slashes, t.href = t.format(), t;
  }
  var W = t.pathname && t.pathname.charAt(0) === "/", $ = n.host || n.pathname && n.pathname.charAt(0) === "/", P = $ || W || t.host && n.pathname, U = P, G = t.pathname && t.pathname.split("/") || [], D = n.pathname && n.pathname.split("/") || [], Z = t.protocol && !$t[t.protocol];
  if (Z && (t.hostname = "", t.port = null, t.host && (G[0] === "" ? G[0] = t.host : G.unshift(t.host)), t.host = "", n.protocol && (n.hostname = null, n.port = null, n.host && (D[0] === "" ? D[0] = n.host : D.unshift(n.host)), n.host = null), P = P && (D[0] === "" || G[0] === "")), $)
    t.host = n.host || n.host === "" ? n.host : t.host, t.hostname = n.hostname || n.hostname === "" ? n.hostname : t.hostname, t.search = n.search, t.query = n.query, G = D;
  else if (D.length)
    G || (G = []), G.pop(), G = G.concat(D), t.search = n.search, t.query = n.query;
  else if (!Je.isNullOrUndefined(n.search)) {
    if (Z) {
      t.hostname = t.host = G.shift();
      var J = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1;
      J && (t.auth = J.shift(), t.host = t.hostname = J.shift());
    }
    return t.search = n.search, t.query = n.query, (!Je.isNull(t.pathname) || !Je.isNull(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.href = t.format(), t;
  }
  if (!G.length)
    return t.pathname = null, t.search ? t.path = "/" + t.search : t.path = null, t.href = t.format(), t;
  for (var te = G.slice(-1)[0], ue = (t.host || n.host || G.length > 1) && (te === "." || te === "..") || te === "", he = 0, Se = G.length; Se >= 0; Se--)
    te = G[Se], te === "." ? G.splice(Se, 1) : te === ".." ? (G.splice(Se, 1), he++) : he && (G.splice(Se, 1), he--);
  if (!P && !U)
    for (; he--; he)
      G.unshift("..");
  P && G[0] !== "" && (!G[0] || G[0].charAt(0) !== "/") && G.unshift(""), ue && G.join("/").substr(-1) !== "/" && G.push("");
  var C = G[0] === "" || G[0] && G[0].charAt(0) === "/";
  if (Z) {
    t.hostname = t.host = C ? "" : G.length ? G.shift() : "";
    var J = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1;
    J && (t.auth = J.shift(), t.host = t.hostname = J.shift());
  }
  return P = P || t.host && G.length, P && !C && G.unshift(""), G.length ? t.pathname = G.join("/") : (t.pathname = null, t.path = null), (!Je.isNull(t.pathname) || !Je.isNull(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.auth = n.auth || t.auth, t.slashes = t.slashes || n.slashes, t.href = t.format(), t;
}, We.prototype.parseHost = function() {
  var n = this.host, e = tf.exec(n);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), n = n.substr(0, n.length - e.length)), n && (this.hostname = n);
};
var Zn = {};
Object.defineProperty(Zn, "__esModule", { value: !0 });
var ff = function() {
  function n(e) {
    this.type = e, this.bubbles = !1, this.cancelable = !1, this.loaded = 0, this.lengthComputable = !1, this.total = 0;
  }
  return n;
}();
Zn.ProgressEvent = ff;
var Wt = {}, Tr = Ue && Ue.__extends || function() {
  var n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, t) {
    e.__proto__ = t;
  } || function(e, t) {
    for (var o in t)
      t.hasOwnProperty(o) && (e[o] = t[o]);
  };
  return function(e, t) {
    n(e, t);
    function o() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (o.prototype = t.prototype, new o());
  };
}();
Object.defineProperty(Wt, "__esModule", { value: !0 });
var df = function(n) {
  Tr(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e;
}(Error);
Wt.SecurityError = df;
var pf = function(n) {
  Tr(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e;
}(Error);
Wt.InvalidStateError = pf;
var gf = function(n) {
  Tr(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e;
}(Error);
Wt.NetworkError = gf;
var _f = function(n) {
  Tr(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e;
}(Error);
Wt.SyntaxError = _f;
var ir = {};
Object.defineProperty(ir, "__esModule", { value: !0 });
var mf = function() {
  function n() {
    this.listeners = {};
  }
  return n.prototype.addEventListener = function(e, t) {
    e = e.toLowerCase(), this.listeners[e] = this.listeners[e] || [], this.listeners[e].push(t.handleEvent || t);
  }, n.prototype.removeEventListener = function(e, t) {
    if (e = e.toLowerCase(), !!this.listeners[e]) {
      var o = this.listeners[e].indexOf(t.handleEvent || t);
      o < 0 || this.listeners[e].splice(o, 1);
    }
  }, n.prototype.dispatchEvent = function(e) {
    var t = e.type.toLowerCase();
    if (e.target = this, this.listeners[t])
      for (var o = 0, c = this.listeners[t]; o < c.length; o++) {
        var a = c[o];
        a.call(this, e);
      }
    var d = this["on" + t];
    return d && d.call(this, e), !0;
  }, n;
}();
ir.XMLHttpRequestEventTarget = mf;
var ei = {}, vf = Ue && Ue.__extends || function() {
  var n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, t) {
    e.__proto__ = t;
  } || function(e, t) {
    for (var o in t)
      t.hasOwnProperty(o) && (e[o] = t[o]);
  };
  return function(e, t) {
    n(e, t);
    function o() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (o.prototype = t.prototype, new o());
  };
}();
Object.defineProperty(ei, "__esModule", { value: !0 });
var yf = ir, wf = function(n) {
  vf(e, n);
  function e() {
    var t = n.call(this) || this;
    return t._contentType = null, t._body = null, t._reset(), t;
  }
  return e.prototype._reset = function() {
    this._contentType = null, this._body = null;
  }, e.prototype._setData = function(t) {
    if (t != null)
      if (typeof t == "string")
        t.length !== 0 && (this._contentType = "text/plain;charset=UTF-8"), this._body = new Buffer(t, "utf-8");
      else if (Buffer.isBuffer(t))
        this._body = t;
      else if (t instanceof ArrayBuffer) {
        for (var o = new Buffer(t.byteLength), c = new Uint8Array(t), a = 0; a < t.byteLength; a++)
          o[a] = c[a];
        this._body = o;
      } else if (t.buffer && t.buffer instanceof ArrayBuffer) {
        for (var o = new Buffer(t.byteLength), d = t.byteOffset, c = new Uint8Array(t.buffer), a = 0; a < t.byteLength; a++)
          o[a] = c[a + d];
        this._body = o;
      } else
        throw new Error("Unsupported send() data " + t);
  }, e.prototype._finalizeHeaders = function(t, o) {
    this._contentType && !o["content-type"] && (t["Content-Type"] = this._contentType), this._body && (t["Content-Length"] = this._body.length.toString());
  }, e.prototype._startUpload = function(t) {
    this._body && t.write(this._body), t.end();
  }, e;
}(yf.XMLHttpRequestEventTarget);
ei.XMLHttpRequestUpload = wf;
var Or = {};
(function() {
  function n(c, a, d, p) {
    return this instanceof n ? (this.domain = c || void 0, this.path = a || "/", this.secure = !!d, this.script = !!p, this) : new n(c, a, d, p);
  }
  n.All = Object.freeze(/* @__PURE__ */ Object.create(null)), Or.CookieAccessInfo = n;
  function e(c, a, d) {
    return c instanceof e ? c : this instanceof e ? (this.name = null, this.value = null, this.expiration_date = 1 / 0, this.path = String(d || "/"), this.explicit_path = !1, this.domain = a || null, this.explicit_domain = !1, this.secure = !1, this.noscript = !1, c && this.parse(c, a, d), this) : new e(c, a, d);
  }
  Or.Cookie = e, e.prototype.toString = function() {
    var c = [this.name + "=" + this.value];
    return this.expiration_date !== 1 / 0 && c.push("expires=" + new Date(this.expiration_date).toGMTString()), this.domain && c.push("domain=" + this.domain), this.path && c.push("path=" + this.path), this.secure && c.push("secure"), this.noscript && c.push("httponly"), c.join("; ");
  }, e.prototype.toValueString = function() {
    return this.name + "=" + this.value;
  };
  var t = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
  e.prototype.parse = function(c, a, d) {
    if (this instanceof e) {
      var p = c.split(";").filter(function(H) {
        return !!H;
      }), w, M = p[0].match(/([^=]+)=([\s\S]*)/);
      if (!M) {
        console.warn("Invalid cookie header encountered. Header: '" + c + "'");
        return;
      }
      var I = M[1], B = M[2];
      if (typeof I != "string" || I.length === 0 || typeof B != "string") {
        console.warn("Unable to extract values from cookie header. Cookie: '" + c + "'");
        return;
      }
      for (this.name = I, this.value = B, w = 1; w < p.length; w += 1)
        switch (M = p[w].match(/([^=]+)(?:=([\s\S]*))?/), I = M[1].trim().toLowerCase(), B = M[2], I) {
          case "httponly":
            this.noscript = !0;
            break;
          case "expires":
            this.expiration_date = B ? Number(Date.parse(B)) : 1 / 0;
            break;
          case "path":
            this.path = B ? B.trim() : "", this.explicit_path = !0;
            break;
          case "domain":
            this.domain = B ? B.trim() : "", this.explicit_domain = !!this.domain;
            break;
          case "secure":
            this.secure = !0;
            break;
        }
      return this.explicit_path || (this.path = d || "/"), this.explicit_domain || (this.domain = a), this;
    }
    return new e().parse(c, a, d);
  }, e.prototype.matches = function(c) {
    return c === n.All ? !0 : !(this.noscript && c.script || this.secure && !c.secure || !this.collidesWith(c));
  }, e.prototype.collidesWith = function(c) {
    if (this.path && !c.path || this.domain && !c.domain || this.path && c.path.indexOf(this.path) !== 0 || this.explicit_path && c.path.indexOf(this.path) !== 0)
      return !1;
    var a = c.domain && c.domain.replace(/^[\.]/, ""), d = this.domain && this.domain.replace(/^[\.]/, "");
    if (d === a)
      return !0;
    if (d) {
      if (!this.explicit_domain)
        return !1;
      var p = a.indexOf(d);
      return !(p === -1 || p !== a.length - d.length);
    }
    return !0;
  };
  function o() {
    var c, a, d;
    return this instanceof o ? (c = /* @__PURE__ */ Object.create(null), this.setCookie = function(p, w, M) {
      var I, B;
      if (p = new e(p, w, M), I = p.expiration_date <= Date.now(), c[p.name] !== void 0) {
        for (a = c[p.name], B = 0; B < a.length; B += 1)
          if (d = a[B], d.collidesWith(p))
            return I ? (a.splice(B, 1), a.length === 0 && delete c[p.name], !1) : (a[B] = p, p);
        return I ? !1 : (a.push(p), p);
      }
      return I ? !1 : (c[p.name] = [p], c[p.name]);
    }, this.getCookie = function(p, w) {
      var M, I;
      if (a = c[p], !!a)
        for (I = 0; I < a.length; I += 1) {
          if (M = a[I], M.expiration_date <= Date.now()) {
            a.length === 0 && delete c[M.name];
            continue;
          }
          if (M.matches(w))
            return M;
        }
    }, this.getCookies = function(p) {
      var w = [], M, I;
      for (M in c)
        I = this.getCookie(M, p), I && w.push(I);
      return w.toString = function() {
        return w.join(":");
      }, w.toValueString = function() {
        return w.map(function(B) {
          return B.toValueString();
        }).join("; ");
      }, w;
    }, this) : new o();
  }
  Or.CookieJar = o, o.prototype.setCookies = function(c, a, d) {
    c = Array.isArray(c) ? c : c.split(t);
    var p = [], w, M;
    for (c = c.map(function(I) {
      return new e(I, a, d);
    }), w = 0; w < c.length; w += 1)
      M = c[w], this.setCookie(M, a, d) && p.push(M);
    return p;
  };
})();
var bf = Ue && Ue.__extends || function() {
  var n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, t) {
    e.__proto__ = t;
  } || function(e, t) {
    for (var o in t)
      t.hasOwnProperty(o) && (e[o] = t[o]);
  };
  return function(e, t) {
    n(e, t);
    function o() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (o.prototype = t.prototype, new o());
  };
}(), xf = Ue && Ue.__assign || Object.assign || function(n) {
  for (var e, t = 1, o = arguments.length; t < o; t++) {
    e = arguments[t];
    for (var c in e)
      Object.prototype.hasOwnProperty.call(e, c) && (n[c] = e[c]);
  }
  return n;
};
Object.defineProperty(Vn, "__esModule", { value: !0 });
var ti = Za, Wa = Za, ja = Za, ri = Ht, za = Zn, Br = Wt, Mf = ir, Ka = ei, Ja = Or, Nr = function(n) {
  bf(e, n);
  function e(t) {
    t === void 0 && (t = {});
    var o = n.call(this) || this;
    return o.UNSENT = e.UNSENT, o.OPENED = e.OPENED, o.HEADERS_RECEIVED = e.HEADERS_RECEIVED, o.LOADING = e.LOADING, o.DONE = e.DONE, o.onreadystatechange = null, o.readyState = e.UNSENT, o.response = null, o.responseText = "", o.responseType = "", o.status = 0, o.statusText = "", o.timeout = 0, o.upload = new Ka.XMLHttpRequestUpload(), o.responseUrl = "", o.withCredentials = !1, o._method = null, o._url = null, o._sync = !1, o._headers = {}, o._loweredHeaders = {}, o._mimeOverride = null, o._request = null, o._response = null, o._responseParts = null, o._responseHeaders = null, o._aborting = null, o._error = null, o._loadedBytes = 0, o._totalBytes = 0, o._lengthComputable = !1, o._restrictedMethods = { CONNECT: !0, TRACE: !0, TRACK: !0 }, o._restrictedHeaders = { "accept-charset": !0, "accept-encoding": !0, "access-control-request-headers": !0, "access-control-request-method": !0, connection: !0, "content-length": !0, cookie: !0, cookie2: !0, date: !0, dnt: !0, expect: !0, host: !0, "keep-alive": !0, origin: !0, referer: !0, te: !0, trailer: !0, "transfer-encoding": !0, upgrade: !0, "user-agent": !0, via: !0 }, o._privateHeaders = { "set-cookie": !0, "set-cookie2": !0 }, o._userAgent = "Mozilla/5.0 (" + ja.type() + " " + ja.arch() + ") node.js/" + process.versions.node + " v8/" + process.versions.v8, o._anonymous = t.anon || !1, o;
  }
  return e.prototype.open = function(t, o, c, a, d) {
    if (c === void 0 && (c = !0), t = t.toUpperCase(), this._restrictedMethods[t])
      throw new e.SecurityError("HTTP method " + t + " is not allowed in XHR");
    var p = this._parseUrl(o, a, d);
    this.readyState === e.HEADERS_RECEIVED || (this.readyState, e.LOADING), this._method = t, this._url = p, this._sync = !c, this._headers = {}, this._loweredHeaders = {}, this._mimeOverride = null, this._setReadyState(e.OPENED), this._request = null, this._response = null, this.status = 0, this.statusText = "", this._responseParts = [], this._responseHeaders = null, this._loadedBytes = 0, this._totalBytes = 0, this._lengthComputable = !1;
  }, e.prototype.setRequestHeader = function(t, o) {
    if (this.readyState !== e.OPENED)
      throw new e.InvalidStateError("XHR readyState must be OPENED");
    var c = t.toLowerCase();
    if (this._restrictedHeaders[c] || /^sec-/.test(c) || /^proxy-/.test(c)) {
      console.warn('Refused to set unsafe header "' + t + '"');
      return;
    }
    o = o.toString(), this._loweredHeaders[c] != null ? (t = this._loweredHeaders[c], this._headers[t] = this._headers[t] + ", " + o) : (this._loweredHeaders[c] = t, this._headers[t] = o);
  }, e.prototype.send = function(t) {
    if (this.readyState !== e.OPENED)
      throw new e.InvalidStateError("XHR readyState must be OPENED");
    if (this._request)
      throw new e.InvalidStateError("send() already called");
    switch (this._url.protocol) {
      case "file:":
        return this._sendFile(t);
      case "http:":
      case "https:":
        return this._sendHttp(t);
      default:
        throw new e.NetworkError("Unsupported protocol " + this._url.protocol);
    }
  }, e.prototype.abort = function() {
    this._request != null && (this._request.abort(), this._setError(), this._dispatchProgress("abort"), this._dispatchProgress("loadend"));
  }, e.prototype.getResponseHeader = function(t) {
    if (this._responseHeaders == null || t == null)
      return null;
    var o = t.toLowerCase();
    return this._responseHeaders.hasOwnProperty(o) ? this._responseHeaders[t.toLowerCase()] : null;
  }, e.prototype.getAllResponseHeaders = function() {
    var t = this;
    return this._responseHeaders == null ? "" : Object.keys(this._responseHeaders).map(function(o) {
      return o + ": " + t._responseHeaders[o];
    }).join(`\r
`);
  }, e.prototype.overrideMimeType = function(t) {
    if (this.readyState === e.LOADING || this.readyState === e.DONE)
      throw new e.InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
    this._mimeOverride = t.toLowerCase();
  }, e.prototype.nodejsSet = function(t) {
    if (this.nodejsHttpAgent = t.httpAgent || this.nodejsHttpAgent, this.nodejsHttpsAgent = t.httpsAgent || this.nodejsHttpsAgent, t.hasOwnProperty("baseUrl")) {
      if (t.baseUrl != null) {
        var o = ri.parse(t.baseUrl, !1, !0);
        if (!o.protocol)
          throw new e.SyntaxError("baseUrl must be an absolute URL");
      }
      this.nodejsBaseUrl = t.baseUrl;
    }
  }, e.nodejsSet = function(t) {
    e.prototype.nodejsSet(t);
  }, e.prototype._setReadyState = function(t) {
    this.readyState = t, this.dispatchEvent(new za.ProgressEvent("readystatechange"));
  }, e.prototype._sendFile = function(t) {
    throw new Error("Protocol file: not implemented");
  }, e.prototype._sendHttp = function(t) {
    if (this._sync)
      throw new Error("Synchronous XHR processing not implemented");
    t && (this._method === "GET" || this._method === "HEAD") ? (console.warn("Discarding entity body for " + this._method + " requests"), t = null) : t = t || "", this.upload._setData(t), this._finalizeHeaders(), this._sendHxxpRequest();
  }, e.prototype._sendHxxpRequest = function() {
    var t = this;
    if (this.withCredentials) {
      var o = e.cookieJar.getCookies(Ja.CookieAccessInfo(this._url.hostname, this._url.pathname, this._url.protocol === "https:")).toValueString();
      this._headers.cookie = this._headers.cookie2 = o;
    }
    var c = this._url.protocol === "http:" ? [ti, this.nodejsHttpAgent] : [Wa, this.nodejsHttpsAgent], a = c[0], d = c[1], p = a.request.bind(a), w = p({ hostname: this._url.hostname, port: +this._url.port, path: this._url.path, auth: this._url.auth, method: this._method, headers: this._headers, agent: d });
    this._request = w, this.timeout && w.setTimeout(this.timeout, function() {
      return t._onHttpTimeout(w);
    }), w.on("response", function(M) {
      return t._onHttpResponse(w, M);
    }), w.on("error", function(M) {
      return t._onHttpRequestError(w, M);
    }), this.upload._startUpload(w), this._request === w && this._dispatchProgress("loadstart");
  }, e.prototype._finalizeHeaders = function() {
    this._headers = xf({}, this._headers, { Connection: "keep-alive", Host: this._url.host, "User-Agent": this._userAgent }, this._anonymous ? { Referer: "about:blank" } : {}), this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
  }, e.prototype._onHttpResponse = function(t, o) {
    var c = this;
    if (this._request === t) {
      if (this.withCredentials && (o.headers["set-cookie"] || o.headers["set-cookie2"]) && e.cookieJar.setCookies(o.headers["set-cookie"] || o.headers["set-cookie2"]), [301, 302, 303, 307, 308].indexOf(o.statusCode) >= 0) {
        this._url = this._parseUrl(o.headers.location), this._method = "GET", this._loweredHeaders["content-type"] && (delete this._headers[this._loweredHeaders["content-type"]], delete this._loweredHeaders["content-type"]), this._headers["Content-Type"] != null && delete this._headers["Content-Type"], delete this._headers["Content-Length"], this.upload._reset(), this._finalizeHeaders(), this._sendHxxpRequest();
        return;
      }
      this._response = o, this._response.on("data", function(d) {
        return c._onHttpResponseData(o, d);
      }), this._response.on("end", function() {
        return c._onHttpResponseEnd(o);
      }), this._response.on("close", function() {
        return c._onHttpResponseClose(o);
      }), this.responseUrl = this._url.href.split("#")[0], this.status = o.statusCode, this.statusText = ti.STATUS_CODES[this.status], this._parseResponseHeaders(o);
      var a = this._responseHeaders["content-length"] || "";
      this._totalBytes = +a, this._lengthComputable = !!a, this._setReadyState(e.HEADERS_RECEIVED);
    }
  }, e.prototype._onHttpResponseData = function(t, o) {
    this._response === t && (this._responseParts.push(new Buffer(o)), this._loadedBytes += o.length, this.readyState !== e.LOADING && this._setReadyState(e.LOADING), this._dispatchProgress("progress"));
  }, e.prototype._onHttpResponseEnd = function(t) {
    this._response === t && (this._parseResponse(), this._request = null, this._response = null, this._setReadyState(e.DONE), this._dispatchProgress("load"), this._dispatchProgress("loadend"));
  }, e.prototype._onHttpResponseClose = function(t) {
    if (this._response === t) {
      var o = this._request;
      this._setError(), o.abort(), this._setReadyState(e.DONE), this._dispatchProgress("error"), this._dispatchProgress("loadend");
    }
  }, e.prototype._onHttpTimeout = function(t) {
    this._request === t && (this._setError(), t.abort(), this._setReadyState(e.DONE), this._dispatchProgress("timeout"), this._dispatchProgress("loadend"));
  }, e.prototype._onHttpRequestError = function(t, o) {
    this._request === t && (this._setError(), t.abort(), this._setReadyState(e.DONE), this._dispatchProgress("error"), this._dispatchProgress("loadend"));
  }, e.prototype._dispatchProgress = function(t) {
    var o = new e.ProgressEvent(t);
    o.lengthComputable = this._lengthComputable, o.loaded = this._loadedBytes, o.total = this._totalBytes, this.dispatchEvent(o);
  }, e.prototype._setError = function() {
    this._request = null, this._response = null, this._responseHeaders = null, this._responseParts = null;
  }, e.prototype._parseUrl = function(t, o, c) {
    var a = this.nodejsBaseUrl == null ? t : ri.resolve(this.nodejsBaseUrl, t), d = ri.parse(a, !1, !0);
    d.hash = null;
    var p = (d.auth || "").split(":"), w = p[0], M = p[1];
    return (w || M || o || c) && (d.auth = (o || w || "") + ":" + (c || M || "")), d;
  }, e.prototype._parseResponseHeaders = function(t) {
    this._responseHeaders = {};
    for (var o in t.headers) {
      var c = o.toLowerCase();
      this._privateHeaders[c] || (this._responseHeaders[c] = t.headers[o]);
    }
    this._mimeOverride != null && (this._responseHeaders["content-type"] = this._mimeOverride);
  }, e.prototype._parseResponse = function() {
    var t = Buffer.concat(this._responseParts);
    switch (this._responseParts = null, this.responseType) {
      case "json":
        this.responseText = null;
        try {
          this.response = JSON.parse(t.toString("utf-8"));
        } catch {
          this.response = null;
        }
        return;
      case "buffer":
        this.responseText = null, this.response = t;
        return;
      case "arraybuffer":
        this.responseText = null;
        for (var o = new ArrayBuffer(t.length), c = new Uint8Array(o), a = 0; a < t.length; a++)
          c[a] = t[a];
        this.response = o;
        return;
      case "text":
      default:
        try {
          this.responseText = t.toString(this._parseResponseEncoding());
        } catch {
          this.responseText = t.toString("binary");
        }
        this.response = this.responseText;
    }
  }, e.prototype._parseResponseEncoding = function() {
    return /;\s*charset=(.*)$/.exec(this._responseHeaders["content-type"] || "")[1] || "utf-8";
  }, e.ProgressEvent = za.ProgressEvent, e.InvalidStateError = Br.InvalidStateError, e.NetworkError = Br.NetworkError, e.SecurityError = Br.SecurityError, e.SyntaxError = Br.SyntaxError, e.XMLHttpRequestUpload = Ka.XMLHttpRequestUpload, e.UNSENT = 0, e.OPENED = 1, e.HEADERS_RECEIVED = 2, e.LOADING = 3, e.DONE = 4, e.cookieJar = Ja.CookieJar(), e;
}(Mf.XMLHttpRequestEventTarget);
Vn.XMLHttpRequest = Nr, Nr.prototype.nodejsHttpAgent = ti.globalAgent, Nr.prototype.nodejsHttpsAgent = Wa.globalAgent, Nr.prototype.nodejsBaseUrl = null, function(n) {
  function e(o) {
    for (var c in o)
      n.hasOwnProperty(c) || (n[c] = o[c]);
  }
  Object.defineProperty(n, "__esModule", { value: !0 }), e(Vn);
  var t = ir;
  n.XMLHttpRequestEventTarget = t.XMLHttpRequestEventTarget;
}(qa);
Ci("XMLHttpRequest") || qa.XMLHttpRequest;
require("web3-provider-engine");
require("web3-provider-engine/subproviders/cache");
require("web3-provider-engine/subproviders/fixture");
require("web3-provider-engine/subproviders/filters");
require("web3-provider-engine/subproviders/hooked-wallet");
require("web3-provider-engine/subproviders/nonce-tracker");
require("web3-provider-engine/subproviders/subscriptions");
const btn = "_btn_1ij5m_5", active$1 = "_active_1ij5m_19", can_not_switch = "_can_not_switch_1ij5m_36", styles$3 = {
  btn,
  active: active$1,
  can_not_switch
}, ChainButton = ({
  chain: n,
  loading: e,
  disabled: t,
  isActive: o,
  canSwitchChain: c,
  onClick: a
}) => {
  const {
    name: d,
    chainId: p
  } = n;
  let w = o ? styles$3.active : styles$3.btn;
  const M = c && !o;
  let I;
  return M ? I = () => a() : (w = `${w} ${styles$3.can_not_switch}`, I = () => {
  }), /* @__PURE__ */ jsx(Button, {
    block: !0,
    className: w,
    disabled: e || t,
    icon: getChainIconOld(p, 23, 23),
    onClick: I,
    children: d
  });
}, ChainButtonWithLogic = ({
  chain: n,
  loading: e,
  connectedChainId: t,
  expectedChainId: o,
  canSwitchChain: c,
  onClick: a
}) => {
  const {
    chainId: d
  } = n, p = d === t;
  let w;
  return !p && o && (w = d !== o), /* @__PURE__ */ jsx(ChainButton, {
    onClick: a,
    loading: e,
    disabled: w,
    isActive: p,
    canSwitchChain: c,
    chain: n
  });
}, button = "_button_1evvb_5", wallet_name = "_wallet_name_1evvb_18", acc = "_acc_1evvb_27", cnn = "_cnn_1evvb_37", active = "_active_1evvb_47", disabled = "_disabled_1evvb_55", loading = "_loading_1evvb_58", spinner$1 = "_spinner_1evvb_66", styles$2 = {
  button,
  wallet_name,
  acc,
  cnn,
  active,
  disabled,
  loading,
  spinner: spinner$1
}, spinner = /* @__PURE__ */ jsx(Spin, {
  className: styles$2.spinner,
  indicator: /* @__PURE__ */ jsx(LoadingOutlined$1, {
    style: {
      fontSize: 24
    },
    spin: !0
  })
}), ConnectButton = ({
  account: n,
  onClick: e,
  walletIcon: t,
  walletName: o,
  labelText: c,
  loading: a,
  disabled: d
}) => {
  let p, w = styles$2.button;
  n ? (p = /* @__PURE__ */ jsx("span", {
    className: styles$2.acc,
    children: toMasskedAddress(n)
  }), w = `${w} ${styles$2.active}`) : a ? (p = spinner, w = `${w} ${styles$2.loading}`) : d ? (p = /* @__PURE__ */ jsx("span", {
    className: styles$2.cnn,
    children: c
  }), w = `${w} ${styles$2.disabled}`) : p = /* @__PURE__ */ jsx("span", {
    className: styles$2.cnn,
    children: c
  });
  let M = e;
  return (n || a || d) && (M = void 0), /* @__PURE__ */ jsxs("div", {
    onClick: M,
    className: w,
    children: [t, /* @__PURE__ */ jsx("span", {
      className: styles$2.wallet_name,
      children: o
    }), p]
  });
}, Svg$1 = () => /* @__PURE__ */ jsxs("svg", {
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: [/* @__PURE__ */ jsx("path", {
    d: "M29.5057 2.09412L17.7998 10.7882L19.9645 5.65882L29.5057 2.09412Z",
    fill: "#E2761B",
    stroke: "#E2761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M2.48242 2.09412L14.0942 10.8706L12.0354 5.65882L2.48242 2.09412Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M25.2944 22.2471L22.1768 27.0235L28.8473 28.8588L30.765 22.353L25.2944 22.2471Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M1.24707 22.353L3.15295 28.8588L9.82354 27.0235L6.70589 22.2471L1.24707 22.353Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M9.44671 14.1764L7.58789 16.9882L14.2114 17.2823L13.9761 10.1647L9.44671 14.1764Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M22.541 14.1765L17.9527 10.0823L17.7998 17.2823L24.4116 16.9882L22.541 14.1765Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M9.82324 27.0236L13.7997 25.0824L10.3644 22.4L9.82324 27.0236Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M18.1885 25.0824L22.1767 27.0236L21.6238 22.4L18.1885 25.0824Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M22.1767 27.0236L18.1885 25.0824L18.5061 27.6824L18.4708 28.7765L22.1767 27.0236Z",
    fill: "#D7C1B3",
    stroke: "#D7C1B3",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M9.82422 27.0236L13.5301 28.7765L13.5066 27.6824L13.8007 25.0824L9.82422 27.0236Z",
    fill: "#D7C1B3",
    stroke: "#D7C1B3",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M13.5882 20.6824L10.2705 19.7059L12.6117 18.6353L13.5882 20.6824Z",
    fill: "#233447",
    stroke: "#233447",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M18.4004 20.6824L19.3769 18.6353L21.7298 19.7059L18.4004 20.6824Z",
    fill: "#233447",
    stroke: "#233447",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M9.8237 27.0235L10.3884 22.2471L6.70605 22.353L9.8237 27.0235Z",
    fill: "#CD6116",
    stroke: "#CD6116",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M21.6123 22.2471L22.177 27.0235L25.2947 22.353L21.6123 22.2471Z",
    fill: "#CD6116",
    stroke: "#CD6116",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M24.4116 16.9882L17.7998 17.2823L18.4116 20.6823L19.388 18.6353L21.741 19.7059L24.4116 16.9882Z",
    fill: "#CD6116",
    stroke: "#CD6116",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M10.2702 19.7059L12.6232 18.6353L13.5879 20.6823L14.2114 17.2823L7.58789 16.9882L10.2702 19.7059Z",
    fill: "#CD6116",
    stroke: "#CD6116",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M7.58887 16.9883L10.3653 22.4L10.2712 19.7059L7.58887 16.9883Z",
    fill: "#E4751F",
    stroke: "#E4751F",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M21.7417 19.7059L21.624 22.4L24.4123 16.9883L21.7417 19.7059Z",
    fill: "#E4751F",
    stroke: "#E4751F",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M14.2124 17.2824L13.5889 20.6824L14.3653 24.6942L14.5418 19.4118L14.2124 17.2824Z",
    fill: "#E4751F",
    stroke: "#E4751F",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M17.801 17.2824L17.4834 19.4001L17.6246 24.6942L18.4128 20.6824L17.801 17.2824Z",
    fill: "#E4751F",
    stroke: "#E4751F",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M18.4123 20.6823L17.624 24.6941L18.1887 25.0823L21.624 22.4L21.7417 19.7059L18.4123 20.6823Z",
    fill: "#F6851B",
    stroke: "#F6851B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M10.2705 19.7059L10.3646 22.4L13.7999 25.0823L14.3646 24.6941L13.5882 20.6823L10.2705 19.7059Z",
    fill: "#F6851B",
    stroke: "#F6851B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M18.4703 28.7765L18.5056 27.6824L18.2115 27.4236H13.7762L13.5056 27.6824L13.5291 28.7765L9.82324 27.0236L11.1174 28.0824L13.7409 29.9059H18.2468L20.8821 28.0824L22.1762 27.0236L18.4703 28.7765Z",
    fill: "#C0AD9E",
    stroke: "#C0AD9E",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M18.1882 25.0823L17.6235 24.6941H14.3647L13.8 25.0823L13.5059 27.6823L13.7764 27.4235H18.2117L18.5059 27.6823L18.1882 25.0823Z",
    fill: "#161616",
    stroke: "#161616",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M30.0002 11.3529L31.0002 6.55294L29.5061 2.09412L18.1885 10.4941L22.5414 14.1765L28.6944 15.9765L30.0591 14.3882L29.4708 13.9647L30.412 13.1059L29.6826 12.5412L30.6238 11.8235L30.0002 11.3529Z",
    fill: "#763D16",
    stroke: "#763D16",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M1 6.55294L2 11.3529L1.36471 11.8235L2.30588 12.5412L1.58824 13.1059L2.52941 13.9647L1.94118 14.3882L3.29412 15.9765L9.44706 14.1765L13.8 10.4941L2.48235 2.09412L1 6.55294Z",
    fill: "#763D16",
    stroke: "#763D16",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M28.6946 15.9765L22.5417 14.1765L24.4123 16.9882L21.624 22.4L25.2946 22.3529H30.7652L28.6946 15.9765Z",
    fill: "#F6851B",
    stroke: "#F6851B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M9.44707 14.1765L3.29413 15.9765L1.24707 22.3529H6.70589L10.3647 22.4L7.58825 16.9882L9.44707 14.1765Z",
    fill: "#F6851B",
    stroke: "#F6851B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M17.7999 17.2823L18.1881 10.4941L19.9763 5.65881H12.0352L13.7999 10.4941L14.2116 17.2823L14.3528 19.4235L14.3646 24.6941H17.6234L17.6469 19.4235L17.7999 17.2823Z",
    fill: "#F6851B",
    stroke: "#F6851B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })]
}), MetamaskIcon = /* @__PURE__ */ jsx(Icon, {
  component: Svg$1
}), Svg = () => /* @__PURE__ */ jsx("svg", {
  width: "42",
  height: "32",
  viewBox: "0 0 30 20",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: /* @__PURE__ */ jsx("path", {
    d: "M6.14162 4.39898C11.034 -0.391048 18.9661 -0.391048 23.8584 4.39898L24.4472 4.97546C24.6918 5.21496 24.6918 5.60327 24.4472 5.84277L22.433 7.81482C22.3107 7.93457 22.1124 7.93457 21.9901 7.81482L21.1799 7.02151C17.7668 3.67986 12.2332 3.67986 8.82018 7.02151L7.95246 7.87108C7.83015 7.99083 7.63184 7.99083 7.50953 7.87108L5.49536 5.89903C5.25074 5.65953 5.25074 5.27122 5.49536 5.03172L6.14162 4.39898ZM28.0239 8.47738L29.8165 10.2325C30.0612 10.472 30.0612 10.8603 29.8165 11.0998L21.7335 19.0139C21.4889 19.2534 21.0923 19.2534 20.8476 19.0139C20.8476 19.0139 20.8476 19.0139 20.8476 19.0139L15.1108 13.3971C15.0496 13.3372 14.9505 13.3372 14.8893 13.3971C14.8893 13.3971 14.8893 13.3971 14.8893 13.3971L9.15259 19.0139C8.90797 19.2534 8.51137 19.2534 8.26675 19.0139C8.26674 19.0139 8.26674 19.0139 8.26674 19.0139L0.183463 11.0997C-0.0611544 10.8602 -0.0611544 10.4719 0.183463 10.2324L1.97609 8.47728C2.22071 8.23778 2.61731 8.23778 2.86193 8.47728L8.59887 14.0942C8.66002 14.1541 8.75918 14.1541 8.82033 14.0942C8.82033 14.0942 8.82033 14.0942 8.82033 14.0942L14.557 8.47728C14.8016 8.23777 15.1982 8.23776 15.4428 8.47726C15.4428 8.47726 15.4428 8.47726 15.4428 8.47727L21.1798 14.0942C21.2409 14.1541 21.3401 14.1541 21.4012 14.0942L27.1381 8.47738C27.3827 8.23788 27.7793 8.23788 28.0239 8.47738Z",
    fill: "#3B99FC"
  })
}), WalletConnectIcon = /* @__PURE__ */ jsx(Icon, {
  component: Svg
}), chain_name = "_chain_name_8kdgo_1", styles$1 = {
  chain_name
}, bold = "_bold_5fnjw_5", styles = {
  bold
}, Bold = ({
  className: n,
  children: e
}) => {
  const t = n ? `${n} ${styles.bold}` : styles.bold;
  return /* @__PURE__ */ jsx("span", {
    className: t,
    children: e
  });
}, ChainName = ({
  children: n
}) => /* @__PURE__ */ jsx(Bold, {
  className: styles$1.chain_name,
  children: n
}), Alert = ({
  account: n,
  chain: e,
  supportedChains: t,
  expectedChainId: o
}) => n ? o ? /* @__PURE__ */ jsxs(Fragment$1, {
  children: ["You connected to ", /* @__PURE__ */ jsxs(ChainName, {
    children: [e.name, "."]
  }), /* @__PURE__ */ jsxs("div", {
    children: ["Please connect to ", /* @__PURE__ */ jsx(ChainName, {
      children: getChainName(o)
    }), " network."]
  })]
}) : t.some((c) => c.name === e.name) ? /* @__PURE__ */ jsxs(Fragment$1, {
  children: ["You are currently using ", /* @__PURE__ */ jsx(Bold, {
    children: "Oort Digital"
  }), " on the ", /* @__PURE__ */ jsx(ChainName, {
    children: e.name
  }), " network"]
}) : /* @__PURE__ */ jsxs(Fragment$1, {
  children: ["You connected to ", /* @__PURE__ */ jsxs(ChainName, {
    children: [e.name, "."]
  }), /* @__PURE__ */ jsxs("div", {
    children: ["Please connect to the appropriate network. ", /* @__PURE__ */ jsx(ChainName, {
      children: t.map((c) => c.name).join(", ")
    })]
  })]
}) : null, style = {
  height: "32px",
  width: "32px"
}, FaceWalletIcon = /* @__PURE__ */ jsx("img", {
  style,
  src: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCACQAJADAREAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD+ZGv+28/zgCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP3d/4Iw/8ABG3Uv+CkmveJvif8U/EWu+Af2Yvhrrtv4c1vU/DcUEfi74k+MzZ22qXPgnwhqGoWl7pei2ui6Xe6ZqPi3xHd2WpT2UWr6Lpek6Vc3Wq3Wq+Hv4A+m99NjC/Riy/K+FeE8ty/iHxU4owFTMsDhcznUlk3DGSKvUwlLPc5w2GrUMXjquOxdDFYbJ8so18LCvPB47F4vF0qOEpYTMv1Tw38OZ8Z1a+Ox1arhMkwVVUas6KSxGNxPLGpLDYec4yp040qcoTxFaUZuKqUoU6cpVJTpf2PeGv+CFn/AASn8L6PbaPbfsh+ENWS3Hz6j4l8W/EvxFrF1IVVXmudR1XxpcTkvsDeTD5NrGxYwW8W9gf8Us0+n39LnNcbVxtXxlznBuq9MNleT8L5bgqMbtxhSw2EyOnTSje3PPnrSSXtKk7Jn9F0fC3gOhTjTXD2Hqcv262IxtapJ23lOeJb1tsrRT2SN/8A4cm/8Erv+jMfhl/4MPHH/wA1led/xPT9LX/o93FP/hNkP/znNv8AiGfAn/RN4L/wPFf/ADQH/Dk3/gld/wBGY/DL/wAGHjj/AOayj/ien6Wv/R7uKf8AwmyH/wCc4f8AEM+BP+ibwX/geK/+aA/4cm/8Erv+jMfhl/4MPHH/AM1lH/E9P0tf+j3cU/8AhNkP/wA5w/4hnwJ/0TeC/wDA8V/80B/w5N/4JXf9GY/DL/wYeOP/AJrKP+J6fpa/9Hu4p/8ACbIf/nOH/EM+BP8Aom8F/wCB4r/5oD/hyb/wSu/6Mx+GX/gw8cf/ADWUf8T0/S1/6PdxT/4TZD/85w/4hnwJ/wBE3gv/AAPFf/NAf8OTf+CV3/RmPwy/8GHjj/5rKP8Aien6Wv8A0e7in/wmyH/5zh/xDPgT/om8F/4Hiv8A5oKt7/wRC/4JU39rPZz/ALGnw7jiuEMcj2Wu/ETTbpVJBzBfad4ztb22fjiW2uIpAMgOASDtQ+nf9LjD1qdan428SSnTlzRjXy/hrFUW/wDp5h8TkdWhVj/dq05x620RMvDHgOcXF8OYNJqz5auMhL5ShiYyi/NNM/mS/wCCzf8AwQJ8Nfsl/DXXf2r/ANj/AFHxNqfwf8M3VrJ8VfhD4nvm8Q618ONI1K9jsLbxh4N8STBNX1/wZZXt1YWOu6Prw1XxL4ejnPiOXxBrGhDVR4a/1N+hF+0OzTxh4oy/wh8Z8NlWF40zWlWjwlxllWHWW4HibGYWhLEVclzvLIOWDy7PK9CliMRl+Ny/6pleZSp/2ZDLsFmH1T+1PxPxI8J6OQYKrn/Ds688uoSi8fl9eftquDpzkoRxGGrO1SthoylCNWnV9pXop+2dapS9p7H+Vyv9aj8ICgAoAKACgAoAKACgD/Tl/wCCCnhzRvDv/BKD9k7+x7GKzbXdH+IniPV5E3NJf6zqnxb8eG7vriRyzPK0cNvbR5O2G1tra2jCxQoo/wCV/wDaEZnjsy+l74v/AF2vOusBjeGsswcZWUcPgcJwdw/7GhTiklGClOpVl1nWq1asm5zk3/bfhTRp0eAcg9nFR9rTxlao1vOpPMMXzSb6uyUV2jFJaJH7A1/GB+iBQAUAFABQAUAFABQB5L8fPCWj+PfgX8Z/A/iK1hvtB8Y/Cn4h+F9as7mLzoLnS9e8Javpd/BLFuTzEktrqRWUOhOfldDhh9h4eZxjeHuPuB8+y2tUw+YZLxfw3muBr0p8lSli8vznB4vD1ITtLllGrSi0+WSXWLWj8/NsPTxWV5lha0VKliMBjKFSMldShVw9SE01pdOMn1Xqj/Hzr/s/P88AoAKACgAoAKACgAoA/wBQD/ghf/yih/Y4/wCxL8Z/+rZ+IFf8qH0+f+UvPGv/ALHmR/8ArH8On9weFv8AyQXDn/YNif8A1YYs/Wav4/PvwoAKACgAoAKACgAoA4z4j/8AJPPHn/YmeKP/AEx31e5wz/yUnD3/AGPMp/8AU/DnNjf9zxf/AGDV/wD01M/xzK/7Uz/OkKACgAoAKACgAoAKAP8AUA/4IX/8oof2OP8AsS/Gf/q2fiBX/Kh9Pn/lLzxr/wCx5kf/AKx/Dp/cHhb/AMkFw5/2DYn/ANWGLP1mr+Pz78KAP5hPiF/wcU6B+yz+3X+0r+y7+1L8IdSvfhZ8OPiRceHfAXxP+E0aXXi3SNKj0jTbqO18a+C/EOq2dn4jinurx518QeHtb0e7sbIJAPDGuzOLpP8AVXhv9mtmPiz4A+F/iv4T8ZYahxZxNwxSzLiHhXjCUqWT4zFyxmKpSq5HnmXYOtXyydOlRjTeXZlgMbRxFfmqPNcBCPsZfiGM8YaWRcU51kee5fOWBweNdHCY7AJSxFOmqcJKOJw1apGNZOUm/bUatOUY2XsKr94/V74Uf8Fd/wDgmj8ZtMttS8JftnfAzSTcohGmfEvxfa/B/XY5WQM1s+i/FVfB2oyTRnKN9mt54XZSYJZo9rt/IfF/0NfpRcE4qrhc48EOPsZ7KTTxXC+S1eNMBKCk0qscdwi86w0aclaS9rUpzimlUhCV4r73AeIPBWZQjPD8SZXT5l8GNxEcuqp9vZY/6tNtf3U0+ja1Oq8e/wDBUf8A4Jy/DXTZNV8Uftt/s0vDH96z8K/Frwj8QddxsLhl8NeANS8TeIXRlB2OmlsjthEZnIU+Tw99E/6THFGKjhMp8CvFGM5bV834PznhzAX5lFp5pxFhcqy2Mk370ZYtSiveklFNm+L454OwUPaV+JslaX2aGYYfF1dr/wAHCTr1rdnyWey1Pw6/ao/4OfPhDaeI9A+Gn7D/AMO9V+Kmta74o0HRLv4t/E3S9U8I+B7GwvtdtLK6l8LeCJfsnjbxJfXmnyTLZT+JI/BUOk3c1rdT6Vr0cU+mt/efhJ+yq4yrZZmHFHjxxJhOEsDl+VZhjqPB3C2LwmcZ9XxGHy+tXowzbPoe2yLLMPQxMYOvTyuWezxlGFWlTxmXynTxS/MM+8b8vjWpYLhjBzx9SrXpUpZhjYVMPhYwlVjGToYV8uKrTlBvldZYZU5OMnTqpOB/VxX+RJ+9BQBxnxH/AOSeePP+xM8Uf+mO+r3OGf8AkpOHv+x5lP8A6n4c5sb/ALni/wDsGr/+mpn+OZX/AGpn+dIUAFABQAUAFABQAUAf6gH/AAQv/wCUUP7HH/Yl+M//AFbPxAr/AJUPp8/8peeNf/Y8yP8A9Y/h0/uDwt/5ILhz/sGxP/qwxZ+s1fx+ffhQB/AL/wAHNn7Ffiv4UftbWv7YGiaPNcfCj9pLTPDul69rVrG7Wnh34xeCvDVr4cvNC1EJvisf+Eo8G+HtG8SaLNI0R1m/tPGPlwmTSLmab/oi/ZZeOWUcX+DtXwYx2NhT4v8ADHFZlisvwNWUVWzLgvPM0q5nQx+GbtOv/ZOd5ljssx0IqawOHrZJzTUcbSpw/k3xt4ar4DiCPEVKm3gM5hRhVqRXu0cxw1GNGVKdtI+3w1GlWpt29pOOJsr05N/zJ1/qafiQUAfrv/wRJ/Ys8Sftk/t6fCSH+yJrj4U/A7xN4e+NHxg1mS3eXSrbRfBuqJrXhrwpdvmOOS6+IPinS7Dw1HZLPHdnRZPEOr2ySx6JcqP42+nX445Z4J/R84xn9dp0+LuPcqzLgfgvAxqqGLq47O8JLA5pm9GPvSjS4cynF4jNJV3TlRWOjluCquEsfSZ+heGXDVbiPivL17NvAZXXo5lmNRq9ONLDVFVo0JbJyxdeEKCjdS9m61RXVKR/p31/ysn9uhQBxnxH/wCSeePP+xM8Uf8Apjvq9zhn/kpOHv8AseZT/wCp+HObG/7ni/8AsGr/APpqZ/jmV/2pn+dIUAFABQAUAFABQAUAf6gH/BC//lFD+xx/2JfjP/1bPxAr/lQ+nz/yl541/wDY8yP/ANY/h0/uDwt/5ILhz/sGxP8A6sMWfrNX8fn34UAeVfG34I/Cv9oz4X+Lvgz8avBej+P/AIb+ONNbTPEPhrWoWe3uI1kSe0vbO5heK80vWNLvIoNR0bWtMuLTVdH1O2ttQ067tru3imT67gTjvi3wz4ryfjfgbPMbw7xPkOJWKy3NMDNRqU5OMqdahXpTU6GLwWLoTqYbHYHFU62ExuFq1cNiaNWjUnB8GZ5ZgM5wOIy3MsNTxeCxUOStRqq6aveMoyVpU6lOSU6dWDjUpzjGcJRkkz+O/wDaf/4NSfiDB4j1XWf2Pf2hvB2q+E7u4nutO8CfHyDW/D/iDQbdpVMelxePPBOg+J9O8UskZk8m8vPCHhJlCxW9x9ocyX7f7SeFX7XThyplmEwPjR4b53g84o06dLE5/wCHtTA5lluYVFFqWLnw/nuYZVicpTko89ChnOcJtzqUvZx5cOv52zzwGxarVKnDub4aph5Nyhhc2VWjWpK+lNYrDUq8K9le0pYfD9FK+szzP4H/APBqT+07rfiKwl/aH/aE+C/w+8GLLbzahB8K18YfEnxpcW6sr3NhDD4j8MfD7w5pVxMmYIdT/tXX4bWVjcNpd9HEIJ/quPP2unhXgMtxEPDfw4444jztwqQw1Ti15LwxkdOo040sRUqZZmvEeZ4unCVqk8L9Ty+daK9msXh5TdSnxZX4DZ3VrQecZvluEw105rAfWMbiWusEq1DCUYN7KftKqi9eSVrP+vv9jP8AYi/Z6/YN+EVp8Hf2evCH9haO80epeKfE+qzR6p43+IHiJYBBJ4j8a+IPIt31PUGTdHZ2dtb2Oh6LbO1joOk6XYYtq/xl8bvHbxH+kFxlW418R85/tDGqnLC5TlWDhLCZDw7lrqOpHLMjy72lWOFwylaVatVqYjH46qliMwxmLxH70/oXhvhjKOFcvjl2UYf2VNtTr16jVTFYutazrYmtaLnO2kYxUKVKL5aVOEdD62r8dPoAoA4z4j/8k88ef9iZ4o/9Md9XucM/8lJw9/2PMp/9T8Oc2N/3PF/9g1f/ANNTP8cyv+1M/wA6QoAKACgAoAKACgAoA/04/wDggl4l0XxJ/wAEn/2Tzo99DdvoWkfEbw1rEMciNPputaT8XvHq3VjeRKzNbzNBLa38EcoR5tOvrG8VfJuomb/lg/aE5Xjss+l74v8A13DzoxzDGcM5pgpyjJU8VgcZwbw86WIoTaSqQVSFbD1JQvGGJoV6DfPSml/bfhTWp1uAcg9nJS9lTxtGok1eFSnmOL5oyXR2cZpPVwlGW0kfsHX8Xn6IFABQAUAFABQAUAFAHkvx88XaF8P/AIF/Gfx34nvodN8N+DPhT8Q/FWv6hcyLFBZaPoHhLV9V1K6lkf5USGztZpGJ/u9CeK+w8PMmx/EXH3BGQZVQniszzvi7hvKcvw1KLnUr43Mc4weEwtKEVrKVStWhFJdzz82xFLCZXmWKryUKOGwGMr1Zt2UadLD1Kk5N9lGLZ/j51/2fn+eAUAFABQAUAFABQAUAfu3/AMEY/wDgsnqn/BNrXfE3ww+KHhzW/iB+zH8StetfEWt6Z4dngbxd8NvGItbXSrzxv4QsNQubTS9bt9Z0iy07T/FXhu7vNMmv00fRNS0vV7O50y703X/4A+m79CfCfSdwGV8VcKZngOHfFThfL6uW4DF5lTqLJ+J8l9tVxdHIs6xGHpVsXgamCxlfE4nKM0o0MVDDyxuOwuLwdaliqOJy/wDVPDfxGqcGVa2Bx1Gri8kxtWNarCi19YwWJ5Y05YrDwm4wqqpTjCFejKUHNU6U6dSMoShV/sd8Lf8ABdb/AIJTeK9Fsdat/wBrrwpoovLeOaTSvFPhD4l+HNa0+ZgRNZX2n6n4LhYXFrKrwyS2kl3YTFBPY3t3Zy29zN/ipm30Avpc5RjsRgang3m+O9hUlCOLynOuFsywOJgn7lfD4jC55NezqwcZxhWjRxEE/Z16FGtCpSh/RdDxS4DxFKNVcQ4elzJN06+HxtGrB9YyhPDLWLum4uUHvGUotSfQ/wDD7P8A4JXf9Hm/DL/wXeOP/mTrzf8AiRb6Wv8A0ZHin/wpyD/58G3/ABEzgT/opMD/AOA4n/5QH/D7P/gld/0eb8Mv/Bd44/8AmTo/4kW+lr/0ZHin/wAKcg/+fAf8RM4E/wCikwP/AIDif/lAf8Ps/wDgld/0eb8Mv/Bd44/+ZOj/AIkW+lr/ANGR4p/8Kcg/+fAf8RM4E/6KTA/+A4n/AOUB/wAPs/8Agld/0eb8Mv8AwXeOP/mTo/4kW+lr/wBGR4p/8Kcg/wDnwH/ETOBP+ikwP/gOJ/8AlAf8Ps/+CV3/AEeb8Mv/AAXeOP8A5k6P+JFvpa/9GR4p/wDCnIP/AJ8B/wARM4E/6KTA/wDgOJ/+UB/w+z/4JXf9Hm/DL/wXeOP/AJk6P+JFvpa/9GR4p/8ACnIP/nwH/ETOBP8AopMD/wCA4n/5QVr3/gt9/wAEqbC0ub2f9sv4eSQ2kMlxKlloPxF1K7aOJS7Lbafp3gu6v7yYgER21nbT3EzYSKJ3IU60PoH/AEuMRWpUKfglxJGdacacJV8w4awtFSm0k6uIxOeUcPQgm/eq1qtOnBXlOcYpsmXidwHCMpPiTBtRTbUaWMnKy/lhDDSnJ9oxi2+iZ/M5/wAFmP8Agvz4Z/ar+Gmsfsq/scWvibTvhN4r8iL4sfF3xHY3PhvWvH2jQulyPA3hHw5My6po3hK9nSF/E2q68llrGvxwnQYtG07RTf3Gv/6kfQk/Z4Zp4R8UYLxb8a62VYnjDKPaT4Q4NyyvSzTA8PY2cZUnn2cZnBPCY3OKFOU45VhMvdfBZdKf9oSxuJx31enl34p4keLFDPsFUyHhyNeGX4iyx+YVoyo1MXTTUvquHov36eHk0nXqVeWpVS9kqcKfO6v8qVf63n4OFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAP/Z"
}), stopedLoading = {
  inProcess: !1,
  cnnName: jt.Undefined
}, useConnectModalCommon = ({
  props: n,
  isMobile: e,
  btnGutter: t,
  styles: o
}) => {
  const {
    onCancel: c,
    onClose: a,
    afterConnect: d,
    afterChainSwitch: p,
    web3: w,
    expectedChainId: M
  } = n, [I, B] = useState(stopedLoading), H = (y) => B({
    inProcess: !0,
    cnnName: y
  }), L = () => B(stopedLoading), W = /* @__PURE__ */ jsxs(Fragment$1, {
    children: ["By connecting, I accept Oort Digital\u2019s ", /* @__PURE__ */ jsx("a", {
      href: "https://oort.digital/terms",
      children: "Terms of Service"
    }), " and acknowledge"]
  }), $ = /* @__PURE__ */ jsxs(Fragment$1, {
    children: ["that you have read and understand the ", /* @__PURE__ */ jsx("a", {
      href: "https://oort.digital/terms#disclaimer",
      children: "Oort Digital protocol disclaimer"
    })]
  }), {
    supportedChains: P,
    chain: U,
    switchChain: G,
    canSwitchChain: D,
    connect: Z,
    account: J,
    connectorName: te,
    supportedConnectors: ue
  } = w, he = () => {
    a && a(), c && c();
  }, Se = async (y, m) => {
    H(m);
    try {
      await Z(y, m) && (c && c(), d && d());
    } finally {
      L();
    }
  }, C = async (y) => {
    H(te);
    try {
      await G(y) && (c && c(), p && p());
    } finally {
      L();
    }
  }, O = (y) => {
    const {
      chainId: m
    } = y;
    return /* @__PURE__ */ jsx(Col, {
      flex: e ? 24 : 3,
      children: /* @__PURE__ */ jsx(ChainButtonWithLogic, {
        onClick: () => C(m),
        loading: I.inProcess,
        expectedChainId: M,
        connectedChainId: U.chainId,
        canSwitchChain: D,
        chain: y
      })
    }, m);
  }, V = (y, m, _, R) => {
    if (J && _ === te)
      return /* @__PURE__ */ jsx(ConnectButton, {
        disabled: I.inProcess,
        walletName: m,
        walletIcon: R,
        account: J
      });
    const b = ue[_];
    return b.isInstalled ? /* @__PURE__ */ jsx(ConnectButton, {
      loading: _ === I.cnnName,
      disabled: I.inProcess,
      walletName: m,
      onClick: () => Se(y, _),
      walletIcon: R,
      labelText: "Connect"
    }) : /* @__PURE__ */ jsx(ConnectButton, {
      walletName: m,
      disabled: I.inProcess,
      onClick: () => window.open(b.installUrl, "_blank").focus(),
      walletIcon: R,
      labelText: "Install"
    });
  }, x = e ? void 0 : "space-between", u = e ? 24 : 12, h = M || P[0].chainId, g = /* @__PURE__ */ jsxs(Fragment$1, {
    children: [!isChainEmpty(U) && /* @__PURE__ */ jsxs(Fragment$1, {
      children: [/* @__PURE__ */ jsx("div", {
        className: o.description,
        children: /* @__PURE__ */ jsx(Alert, {
          account: J,
          chain: U,
          supportedChains: P,
          expectedChainId: M
        })
      }), /* @__PURE__ */ jsx(Row, {
        gutter: t,
        className: o.chain_buttons,
        justify: x,
        children: P.map((y) => O(y))
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: o.description,
      children: [/* @__PURE__ */ jsx(Bold, {
        children: "Connect your Wallet"
      }), " and jump into the world of NFT's"]
    }), /* @__PURE__ */ jsxs(Row, {
      gutter: t,
      justify: x,
      children: [/* @__PURE__ */ jsx(Col, {
        span: u,
        children: V(h, "Metamask", jt.Injected, MetamaskIcon)
      }), /* @__PURE__ */ jsx(Col, {
        span: u,
        children: V(h, "FaceWallet", jt.FaceWallet, FaceWalletIcon)
      }), /* @__PURE__ */ jsx(Col, {
        span: u,
        children: V(h, "WalletConnect", jt.WalletConnect, WalletConnectIcon)
      })]
    })]
  });
  return {
    footer1: W,
    footer2: $,
    content: g,
    onCancel: he,
    loading: I.inProcess
  };
};
export {
  useConnectModalCommon as u
};
//# sourceMappingURL=useConnectModalCommon.4b3ce12e.mjs.map
