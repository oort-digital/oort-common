import { Button, Spin, Row, Col } from "antd";
import * as React from "react";
import { useState } from "react";
import { A as AntdIcon, _ as _objectSpread2, j as jsx, g as getChainIconOld, t as toMasskedAddress, a as jsxs, I as Icon, F as Fragment$1, b as getChainName, i as isChainEmpty } from "./index.9e4632a6.mjs";
import "ethers";
var LoadingOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" };
const LoadingOutlinedSvg = LoadingOutlined$2;
var LoadingOutlined = function(t, s) {
  return /* @__PURE__ */ React.createElement(AntdIcon, _objectSpread2(_objectSpread2({}, t), {}, {
    ref: s,
    icon: LoadingOutlinedSvg
  }));
};
LoadingOutlined.displayName = "LoadingOutlined";
const LoadingOutlined$1 = /* @__PURE__ */ React.forwardRef(LoadingOutlined), require$$2$3 = {};
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getAugmentedNamespace(l) {
  var t = l.default;
  if (typeof t == "function") {
    var s = function() {
      return t.apply(this, arguments);
    };
    s.prototype = t.prototype;
  } else
    s = {};
  return Object.defineProperty(s, "__esModule", { value: !0 }), Object.keys(l).forEach(function(h) {
    var m = Object.getOwnPropertyDescriptor(l, h);
    Object.defineProperty(s, h, m.get ? m : {
      enumerable: !0,
      get: function() {
        return l[h];
      }
    });
  }), s;
}
var bn$5 = { exports: {} }, _nodeResolve_empty = {}, nodeCrypto = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: _nodeResolve_empty
}), require$$0$5 = /* @__PURE__ */ getAugmentedNamespace(nodeCrypto);
(function(l) {
  (function(t, s) {
    function h(k, p) {
      if (!k)
        throw new Error(p || "Assertion failed");
    }
    function m(k, p) {
      k.super_ = p;
      var x = function() {
      };
      x.prototype = p.prototype, k.prototype = new x(), k.prototype.constructor = k;
    }
    function d(k, p, x) {
      if (d.isBN(k))
        return k;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, k !== null && ((p === "le" || p === "be") && (x = p, p = 10), this._init(k || 0, p || 10, x || "be"));
    }
    typeof t == "object" ? t.exports = d : s.BN = d, d.BN = d, d.wordSize = 26;
    var v;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? v = window.Buffer : v = require$$0$5.Buffer;
    } catch {
    }
    d.isBN = function(p) {
      return p instanceof d ? !0 : p !== null && typeof p == "object" && p.constructor.wordSize === d.wordSize && Array.isArray(p.words);
    }, d.max = function(p, x) {
      return p.cmp(x) > 0 ? p : x;
    }, d.min = function(p, x) {
      return p.cmp(x) < 0 ? p : x;
    }, d.prototype._init = function(p, x, S) {
      if (typeof p == "number")
        return this._initNumber(p, x, S);
      if (typeof p == "object")
        return this._initArray(p, x, S);
      x === "hex" && (x = 16), h(x === (x | 0) && x >= 2 && x <= 36), p = p.toString().replace(/\s+/g, "");
      var B = 0;
      p[0] === "-" && (B++, this.negative = 1), B < p.length && (x === 16 ? this._parseHex(p, B, S) : (this._parseBase(p, x, B), S === "le" && this._initArray(this.toArray(), x, S)));
    }, d.prototype._initNumber = function(p, x, S) {
      p < 0 && (this.negative = 1, p = -p), p < 67108864 ? (this.words = [p & 67108863], this.length = 1) : p < 4503599627370496 ? (this.words = [
        p & 67108863,
        p / 67108864 & 67108863
      ], this.length = 2) : (h(p < 9007199254740992), this.words = [
        p & 67108863,
        p / 67108864 & 67108863,
        1
      ], this.length = 3), S === "le" && this._initArray(this.toArray(), x, S);
    }, d.prototype._initArray = function(p, x, S) {
      if (h(typeof p.length == "number"), p.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(p.length / 3), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var L, C, G = 0;
      if (S === "be")
        for (B = p.length - 1, L = 0; B >= 0; B -= 3)
          C = p[B] | p[B - 1] << 8 | p[B - 2] << 16, this.words[L] |= C << G & 67108863, this.words[L + 1] = C >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, L++);
      else if (S === "le")
        for (B = 0, L = 0; B < p.length; B += 3)
          C = p[B] | p[B + 1] << 8 | p[B + 2] << 16, this.words[L] |= C << G & 67108863, this.words[L + 1] = C >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, L++);
      return this._strip();
    };
    function _(k, p) {
      var x = k.charCodeAt(p);
      if (x >= 48 && x <= 57)
        return x - 48;
      if (x >= 65 && x <= 70)
        return x - 55;
      if (x >= 97 && x <= 102)
        return x - 87;
      h(!1, "Invalid character in " + k);
    }
    function T(k, p, x) {
      var S = _(k, x);
      return x - 1 >= p && (S |= _(k, x - 1) << 4), S;
    }
    d.prototype._parseHex = function(p, x, S) {
      this.length = Math.ceil((p.length - x) / 6), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var L = 0, C = 0, G;
      if (S === "be")
        for (B = p.length - 1; B >= x; B -= 2)
          G = T(p, x, B) << L, this.words[C] |= G & 67108863, L >= 18 ? (L -= 18, C += 1, this.words[C] |= G >>> 26) : L += 8;
      else {
        var R = p.length - x;
        for (B = R % 2 === 0 ? x + 1 : x; B < p.length; B += 2)
          G = T(p, x, B) << L, this.words[C] |= G & 67108863, L >= 18 ? (L -= 18, C += 1, this.words[C] |= G >>> 26) : L += 8;
      }
      this._strip();
    };
    function z(k, p, x, S) {
      for (var B = 0, L = 0, C = Math.min(k.length, x), G = p; G < C; G++) {
        var R = k.charCodeAt(G) - 48;
        B *= S, R >= 49 ? L = R - 49 + 10 : R >= 17 ? L = R - 17 + 10 : L = R, h(R >= 0 && L < S, "Invalid character"), B += L;
      }
      return B;
    }
    d.prototype._parseBase = function(p, x, S) {
      this.words = [0], this.length = 1;
      for (var B = 0, L = 1; L <= 67108863; L *= x)
        B++;
      B--, L = L / x | 0;
      for (var C = p.length - S, G = C % B, R = Math.min(C, C - G) + S, y = 0, j = S; j < R; j += B)
        y = z(p, j, j + B, x), this.imuln(L), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      if (G !== 0) {
        var ye = 1;
        for (y = z(p, j, p.length, x), j = 0; j < G; j++)
          ye *= x;
        this.imuln(ye), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      }
      this._strip();
    }, d.prototype.copy = function(p) {
      p.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        p.words[x] = this.words[x];
      p.length = this.length, p.negative = this.negative, p.red = this.red;
    };
    function J(k, p) {
      k.words = p.words, k.length = p.length, k.negative = p.negative, k.red = p.red;
    }
    if (d.prototype._move = function(p) {
      J(p, this);
    }, d.prototype.clone = function() {
      var p = new d(null);
      return this.copy(p), p;
    }, d.prototype._expand = function(p) {
      for (; this.length < p; )
        this.words[this.length++] = 0;
      return this;
    }, d.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, d.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        d.prototype[Symbol.for("nodejs.util.inspect.custom")] = Y;
      } catch {
        d.prototype.inspect = Y;
      }
    else
      d.prototype.inspect = Y;
    function Y() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var ie = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ne = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], de = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    d.prototype.toString = function(p, x) {
      p = p || 10, x = x | 0 || 1;
      var S;
      if (p === 16 || p === "hex") {
        S = "";
        for (var B = 0, L = 0, C = 0; C < this.length; C++) {
          var G = this.words[C], R = ((G << B | L) & 16777215).toString(16);
          L = G >>> 24 - B & 16777215, B += 2, B >= 26 && (B -= 26, C--), L !== 0 || C !== this.length - 1 ? S = ie[6 - R.length] + R + S : S = R + S;
        }
        for (L !== 0 && (S = L.toString(16) + S); S.length % x !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      if (p === (p | 0) && p >= 2 && p <= 36) {
        var y = ne[p], j = de[p];
        S = "";
        var ye = this.clone();
        for (ye.negative = 0; !ye.isZero(); ) {
          var ee = ye.modrn(j).toString(p);
          ye = ye.idivn(j), ye.isZero() ? S = ee + S : S = ie[y - ee.length] + ee + S;
        }
        for (this.isZero() && (S = "0" + S); S.length % x !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      h(!1, "Base should be between 2 and 36");
    }, d.prototype.toNumber = function() {
      var p = this.words[0];
      return this.length === 2 ? p += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? p += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && h(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -p : p;
    }, d.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, v && (d.prototype.toBuffer = function(p, x) {
      return this.toArrayLike(v, p, x);
    }), d.prototype.toArray = function(p, x) {
      return this.toArrayLike(Array, p, x);
    };
    var ce = function(p, x) {
      return p.allocUnsafe ? p.allocUnsafe(x) : new p(x);
    };
    d.prototype.toArrayLike = function(p, x, S) {
      this._strip();
      var B = this.byteLength(), L = S || Math.max(1, B);
      h(B <= L, "byte array longer than desired length"), h(L > 0, "Requested array length <= 0");
      var C = ce(p, L), G = x === "le" ? "LE" : "BE";
      return this["_toArrayLike" + G](C, B), C;
    }, d.prototype._toArrayLikeLE = function(p, x) {
      for (var S = 0, B = 0, L = 0, C = 0; L < this.length; L++) {
        var G = this.words[L] << C | B;
        p[S++] = G & 255, S < p.length && (p[S++] = G >> 8 & 255), S < p.length && (p[S++] = G >> 16 & 255), C === 6 ? (S < p.length && (p[S++] = G >> 24 & 255), B = 0, C = 0) : (B = G >>> 24, C += 2);
      }
      if (S < p.length)
        for (p[S++] = B; S < p.length; )
          p[S++] = 0;
    }, d.prototype._toArrayLikeBE = function(p, x) {
      for (var S = p.length - 1, B = 0, L = 0, C = 0; L < this.length; L++) {
        var G = this.words[L] << C | B;
        p[S--] = G & 255, S >= 0 && (p[S--] = G >> 8 & 255), S >= 0 && (p[S--] = G >> 16 & 255), C === 6 ? (S >= 0 && (p[S--] = G >> 24 & 255), B = 0, C = 0) : (B = G >>> 24, C += 2);
      }
      if (S >= 0)
        for (p[S--] = B; S >= 0; )
          p[S--] = 0;
    }, Math.clz32 ? d.prototype._countBits = function(p) {
      return 32 - Math.clz32(p);
    } : d.prototype._countBits = function(p) {
      var x = p, S = 0;
      return x >= 4096 && (S += 13, x >>>= 13), x >= 64 && (S += 7, x >>>= 7), x >= 8 && (S += 4, x >>>= 4), x >= 2 && (S += 2, x >>>= 2), S + x;
    }, d.prototype._zeroBits = function(p) {
      if (p === 0)
        return 26;
      var x = p, S = 0;
      return (x & 8191) === 0 && (S += 13, x >>>= 13), (x & 127) === 0 && (S += 7, x >>>= 7), (x & 15) === 0 && (S += 4, x >>>= 4), (x & 3) === 0 && (S += 2, x >>>= 2), (x & 1) === 0 && S++, S;
    }, d.prototype.bitLength = function() {
      var p = this.words[this.length - 1], x = this._countBits(p);
      return (this.length - 1) * 26 + x;
    };
    function re(k) {
      for (var p = new Array(k.bitLength()), x = 0; x < p.length; x++) {
        var S = x / 26 | 0, B = x % 26;
        p[x] = k.words[S] >>> B & 1;
      }
      return p;
    }
    d.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var p = 0, x = 0; x < this.length; x++) {
        var S = this._zeroBits(this.words[x]);
        if (p += S, S !== 26)
          break;
      }
      return p;
    }, d.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, d.prototype.toTwos = function(p) {
      return this.negative !== 0 ? this.abs().inotn(p).iaddn(1) : this.clone();
    }, d.prototype.fromTwos = function(p) {
      return this.testn(p - 1) ? this.notn(p).iaddn(1).ineg() : this.clone();
    }, d.prototype.isNeg = function() {
      return this.negative !== 0;
    }, d.prototype.neg = function() {
      return this.clone().ineg();
    }, d.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, d.prototype.iuor = function(p) {
      for (; this.length < p.length; )
        this.words[this.length++] = 0;
      for (var x = 0; x < p.length; x++)
        this.words[x] = this.words[x] | p.words[x];
      return this._strip();
    }, d.prototype.ior = function(p) {
      return h((this.negative | p.negative) === 0), this.iuor(p);
    }, d.prototype.or = function(p) {
      return this.length > p.length ? this.clone().ior(p) : p.clone().ior(this);
    }, d.prototype.uor = function(p) {
      return this.length > p.length ? this.clone().iuor(p) : p.clone().iuor(this);
    }, d.prototype.iuand = function(p) {
      var x;
      this.length > p.length ? x = p : x = this;
      for (var S = 0; S < x.length; S++)
        this.words[S] = this.words[S] & p.words[S];
      return this.length = x.length, this._strip();
    }, d.prototype.iand = function(p) {
      return h((this.negative | p.negative) === 0), this.iuand(p);
    }, d.prototype.and = function(p) {
      return this.length > p.length ? this.clone().iand(p) : p.clone().iand(this);
    }, d.prototype.uand = function(p) {
      return this.length > p.length ? this.clone().iuand(p) : p.clone().iuand(this);
    }, d.prototype.iuxor = function(p) {
      var x, S;
      this.length > p.length ? (x = this, S = p) : (x = p, S = this);
      for (var B = 0; B < S.length; B++)
        this.words[B] = x.words[B] ^ S.words[B];
      if (this !== x)
        for (; B < x.length; B++)
          this.words[B] = x.words[B];
      return this.length = x.length, this._strip();
    }, d.prototype.ixor = function(p) {
      return h((this.negative | p.negative) === 0), this.iuxor(p);
    }, d.prototype.xor = function(p) {
      return this.length > p.length ? this.clone().ixor(p) : p.clone().ixor(this);
    }, d.prototype.uxor = function(p) {
      return this.length > p.length ? this.clone().iuxor(p) : p.clone().iuxor(this);
    }, d.prototype.inotn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = Math.ceil(p / 26) | 0, S = p % 26;
      this._expand(x), S > 0 && x--;
      for (var B = 0; B < x; B++)
        this.words[B] = ~this.words[B] & 67108863;
      return S > 0 && (this.words[B] = ~this.words[B] & 67108863 >> 26 - S), this._strip();
    }, d.prototype.notn = function(p) {
      return this.clone().inotn(p);
    }, d.prototype.setn = function(p, x) {
      h(typeof p == "number" && p >= 0);
      var S = p / 26 | 0, B = p % 26;
      return this._expand(S + 1), x ? this.words[S] = this.words[S] | 1 << B : this.words[S] = this.words[S] & ~(1 << B), this._strip();
    }, d.prototype.iadd = function(p) {
      var x;
      if (this.negative !== 0 && p.negative === 0)
        return this.negative = 0, x = this.isub(p), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && p.negative !== 0)
        return p.negative = 0, x = this.isub(p), p.negative = 1, x._normSign();
      var S, B;
      this.length > p.length ? (S = this, B = p) : (S = p, B = this);
      for (var L = 0, C = 0; C < B.length; C++)
        x = (S.words[C] | 0) + (B.words[C] | 0) + L, this.words[C] = x & 67108863, L = x >>> 26;
      for (; L !== 0 && C < S.length; C++)
        x = (S.words[C] | 0) + L, this.words[C] = x & 67108863, L = x >>> 26;
      if (this.length = S.length, L !== 0)
        this.words[this.length] = L, this.length++;
      else if (S !== this)
        for (; C < S.length; C++)
          this.words[C] = S.words[C];
      return this;
    }, d.prototype.add = function(p) {
      var x;
      return p.negative !== 0 && this.negative === 0 ? (p.negative = 0, x = this.sub(p), p.negative ^= 1, x) : p.negative === 0 && this.negative !== 0 ? (this.negative = 0, x = p.sub(this), this.negative = 1, x) : this.length > p.length ? this.clone().iadd(p) : p.clone().iadd(this);
    }, d.prototype.isub = function(p) {
      if (p.negative !== 0) {
        p.negative = 0;
        var x = this.iadd(p);
        return p.negative = 1, x._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(p), this.negative = 1, this._normSign();
      var S = this.cmp(p);
      if (S === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var B, L;
      S > 0 ? (B = this, L = p) : (B = p, L = this);
      for (var C = 0, G = 0; G < L.length; G++)
        x = (B.words[G] | 0) - (L.words[G] | 0) + C, C = x >> 26, this.words[G] = x & 67108863;
      for (; C !== 0 && G < B.length; G++)
        x = (B.words[G] | 0) + C, C = x >> 26, this.words[G] = x & 67108863;
      if (C === 0 && G < B.length && B !== this)
        for (; G < B.length; G++)
          this.words[G] = B.words[G];
      return this.length = Math.max(this.length, G), B !== this && (this.negative = 1), this._strip();
    }, d.prototype.sub = function(p) {
      return this.clone().isub(p);
    };
    function oe(k, p, x) {
      x.negative = p.negative ^ k.negative;
      var S = k.length + p.length | 0;
      x.length = S, S = S - 1 | 0;
      var B = k.words[0] | 0, L = p.words[0] | 0, C = B * L, G = C & 67108863, R = C / 67108864 | 0;
      x.words[0] = G;
      for (var y = 1; y < S; y++) {
        for (var j = R >>> 26, ye = R & 67108863, ee = Math.min(y, p.length - 1), xe = Math.max(0, y - k.length + 1); xe <= ee; xe++) {
          var $e = y - xe | 0;
          B = k.words[$e] | 0, L = p.words[xe] | 0, C = B * L + ye, j += C / 67108864 | 0, ye = C & 67108863;
        }
        x.words[y] = ye | 0, R = j | 0;
      }
      return R !== 0 ? x.words[y] = R | 0 : x.length--, x._strip();
    }
    var pe = function(p, x, S) {
      var B = p.words, L = x.words, C = S.words, G = 0, R, y, j, ye = B[0] | 0, ee = ye & 8191, xe = ye >>> 13, $e = B[1] | 0, ke = $e & 8191, Ce = $e >>> 13, ht = B[2] | 0, Ue = ht & 8191, De = ht >>> 13, wt = B[3] | 0, He = wt & 8191, Ze = wt >>> 13, Ie = B[4] | 0, ue = Ie & 8191, he = Ie >>> 13, Ne = B[5] | 0, Be = Ne & 8191, Oe = Ne >>> 13, it = B[6] | 0, Ve = it & 8191, Ye = it >>> 13, Pt = B[7] | 0, et = Pt & 8191, Q = Pt >>> 13, W = B[8] | 0, V = W & 8191, se = W >>> 13, Ae = B[9] | 0, _e = Ae & 8191, Re = Ae >>> 13, mt = L[0] | 0, We = mt & 8191, ze = mt >>> 13, kt = L[1] | 0, je = kt & 8191, ot = kt >>> 13, Vt = L[2] | 0, ct = Vt & 8191, ut = Vt >>> 13, Zt = L[3] | 0, rt = Zt & 8191, nt = Zt >>> 13, Gt = L[4] | 0, st = Gt & 8191, at = Gt >>> 13, Jt = L[5] | 0, lt = Jt & 8191, tt = Jt >>> 13, Yt = L[6] | 0, le = Yt & 8191, be = Yt >>> 13, Me = L[7] | 0, te = Me & 8191, ve = Me >>> 13, qe = L[8] | 0, Pe = qe & 8191, Le = qe >>> 13, pt = L[9] | 0, Je = pt & 8191, Ge = pt >>> 13;
      S.negative = p.negative ^ x.negative, S.length = 19, R = Math.imul(ee, We), y = Math.imul(ee, ze), y = y + Math.imul(xe, We) | 0, j = Math.imul(xe, ze);
      var $t = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, R = Math.imul(ke, We), y = Math.imul(ke, ze), y = y + Math.imul(Ce, We) | 0, j = Math.imul(Ce, ze), R = R + Math.imul(ee, je) | 0, y = y + Math.imul(ee, ot) | 0, y = y + Math.imul(xe, je) | 0, j = j + Math.imul(xe, ot) | 0;
      var bt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, R = Math.imul(Ue, We), y = Math.imul(Ue, ze), y = y + Math.imul(De, We) | 0, j = Math.imul(De, ze), R = R + Math.imul(ke, je) | 0, y = y + Math.imul(ke, ot) | 0, y = y + Math.imul(Ce, je) | 0, j = j + Math.imul(Ce, ot) | 0, R = R + Math.imul(ee, ct) | 0, y = y + Math.imul(ee, ut) | 0, y = y + Math.imul(xe, ct) | 0, j = j + Math.imul(xe, ut) | 0;
      var Mt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, R = Math.imul(He, We), y = Math.imul(He, ze), y = y + Math.imul(Ze, We) | 0, j = Math.imul(Ze, ze), R = R + Math.imul(Ue, je) | 0, y = y + Math.imul(Ue, ot) | 0, y = y + Math.imul(De, je) | 0, j = j + Math.imul(De, ot) | 0, R = R + Math.imul(ke, ct) | 0, y = y + Math.imul(ke, ut) | 0, y = y + Math.imul(Ce, ct) | 0, j = j + Math.imul(Ce, ut) | 0, R = R + Math.imul(ee, rt) | 0, y = y + Math.imul(ee, nt) | 0, y = y + Math.imul(xe, rt) | 0, j = j + Math.imul(xe, nt) | 0;
      var Rt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, R = Math.imul(ue, We), y = Math.imul(ue, ze), y = y + Math.imul(he, We) | 0, j = Math.imul(he, ze), R = R + Math.imul(He, je) | 0, y = y + Math.imul(He, ot) | 0, y = y + Math.imul(Ze, je) | 0, j = j + Math.imul(Ze, ot) | 0, R = R + Math.imul(Ue, ct) | 0, y = y + Math.imul(Ue, ut) | 0, y = y + Math.imul(De, ct) | 0, j = j + Math.imul(De, ut) | 0, R = R + Math.imul(ke, rt) | 0, y = y + Math.imul(ke, nt) | 0, y = y + Math.imul(Ce, rt) | 0, j = j + Math.imul(Ce, nt) | 0, R = R + Math.imul(ee, st) | 0, y = y + Math.imul(ee, at) | 0, y = y + Math.imul(xe, st) | 0, j = j + Math.imul(xe, at) | 0;
      var Tt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, R = Math.imul(Be, We), y = Math.imul(Be, ze), y = y + Math.imul(Oe, We) | 0, j = Math.imul(Oe, ze), R = R + Math.imul(ue, je) | 0, y = y + Math.imul(ue, ot) | 0, y = y + Math.imul(he, je) | 0, j = j + Math.imul(he, ot) | 0, R = R + Math.imul(He, ct) | 0, y = y + Math.imul(He, ut) | 0, y = y + Math.imul(Ze, ct) | 0, j = j + Math.imul(Ze, ut) | 0, R = R + Math.imul(Ue, rt) | 0, y = y + Math.imul(Ue, nt) | 0, y = y + Math.imul(De, rt) | 0, j = j + Math.imul(De, nt) | 0, R = R + Math.imul(ke, st) | 0, y = y + Math.imul(ke, at) | 0, y = y + Math.imul(Ce, st) | 0, j = j + Math.imul(Ce, at) | 0, R = R + Math.imul(ee, lt) | 0, y = y + Math.imul(ee, tt) | 0, y = y + Math.imul(xe, lt) | 0, j = j + Math.imul(xe, tt) | 0;
      var Nt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, R = Math.imul(Ve, We), y = Math.imul(Ve, ze), y = y + Math.imul(Ye, We) | 0, j = Math.imul(Ye, ze), R = R + Math.imul(Be, je) | 0, y = y + Math.imul(Be, ot) | 0, y = y + Math.imul(Oe, je) | 0, j = j + Math.imul(Oe, ot) | 0, R = R + Math.imul(ue, ct) | 0, y = y + Math.imul(ue, ut) | 0, y = y + Math.imul(he, ct) | 0, j = j + Math.imul(he, ut) | 0, R = R + Math.imul(He, rt) | 0, y = y + Math.imul(He, nt) | 0, y = y + Math.imul(Ze, rt) | 0, j = j + Math.imul(Ze, nt) | 0, R = R + Math.imul(Ue, st) | 0, y = y + Math.imul(Ue, at) | 0, y = y + Math.imul(De, st) | 0, j = j + Math.imul(De, at) | 0, R = R + Math.imul(ke, lt) | 0, y = y + Math.imul(ke, tt) | 0, y = y + Math.imul(Ce, lt) | 0, j = j + Math.imul(Ce, tt) | 0, R = R + Math.imul(ee, le) | 0, y = y + Math.imul(ee, be) | 0, y = y + Math.imul(xe, le) | 0, j = j + Math.imul(xe, be) | 0;
      var It = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, R = Math.imul(et, We), y = Math.imul(et, ze), y = y + Math.imul(Q, We) | 0, j = Math.imul(Q, ze), R = R + Math.imul(Ve, je) | 0, y = y + Math.imul(Ve, ot) | 0, y = y + Math.imul(Ye, je) | 0, j = j + Math.imul(Ye, ot) | 0, R = R + Math.imul(Be, ct) | 0, y = y + Math.imul(Be, ut) | 0, y = y + Math.imul(Oe, ct) | 0, j = j + Math.imul(Oe, ut) | 0, R = R + Math.imul(ue, rt) | 0, y = y + Math.imul(ue, nt) | 0, y = y + Math.imul(he, rt) | 0, j = j + Math.imul(he, nt) | 0, R = R + Math.imul(He, st) | 0, y = y + Math.imul(He, at) | 0, y = y + Math.imul(Ze, st) | 0, j = j + Math.imul(Ze, at) | 0, R = R + Math.imul(Ue, lt) | 0, y = y + Math.imul(Ue, tt) | 0, y = y + Math.imul(De, lt) | 0, j = j + Math.imul(De, tt) | 0, R = R + Math.imul(ke, le) | 0, y = y + Math.imul(ke, be) | 0, y = y + Math.imul(Ce, le) | 0, j = j + Math.imul(Ce, be) | 0, R = R + Math.imul(ee, te) | 0, y = y + Math.imul(ee, ve) | 0, y = y + Math.imul(xe, te) | 0, j = j + Math.imul(xe, ve) | 0;
      var Ct = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, R = Math.imul(V, We), y = Math.imul(V, ze), y = y + Math.imul(se, We) | 0, j = Math.imul(se, ze), R = R + Math.imul(et, je) | 0, y = y + Math.imul(et, ot) | 0, y = y + Math.imul(Q, je) | 0, j = j + Math.imul(Q, ot) | 0, R = R + Math.imul(Ve, ct) | 0, y = y + Math.imul(Ve, ut) | 0, y = y + Math.imul(Ye, ct) | 0, j = j + Math.imul(Ye, ut) | 0, R = R + Math.imul(Be, rt) | 0, y = y + Math.imul(Be, nt) | 0, y = y + Math.imul(Oe, rt) | 0, j = j + Math.imul(Oe, nt) | 0, R = R + Math.imul(ue, st) | 0, y = y + Math.imul(ue, at) | 0, y = y + Math.imul(he, st) | 0, j = j + Math.imul(he, at) | 0, R = R + Math.imul(He, lt) | 0, y = y + Math.imul(He, tt) | 0, y = y + Math.imul(Ze, lt) | 0, j = j + Math.imul(Ze, tt) | 0, R = R + Math.imul(Ue, le) | 0, y = y + Math.imul(Ue, be) | 0, y = y + Math.imul(De, le) | 0, j = j + Math.imul(De, be) | 0, R = R + Math.imul(ke, te) | 0, y = y + Math.imul(ke, ve) | 0, y = y + Math.imul(Ce, te) | 0, j = j + Math.imul(Ce, ve) | 0, R = R + Math.imul(ee, Pe) | 0, y = y + Math.imul(ee, Le) | 0, y = y + Math.imul(xe, Pe) | 0, j = j + Math.imul(xe, Le) | 0;
      var Bt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, R = Math.imul(_e, We), y = Math.imul(_e, ze), y = y + Math.imul(Re, We) | 0, j = Math.imul(Re, ze), R = R + Math.imul(V, je) | 0, y = y + Math.imul(V, ot) | 0, y = y + Math.imul(se, je) | 0, j = j + Math.imul(se, ot) | 0, R = R + Math.imul(et, ct) | 0, y = y + Math.imul(et, ut) | 0, y = y + Math.imul(Q, ct) | 0, j = j + Math.imul(Q, ut) | 0, R = R + Math.imul(Ve, rt) | 0, y = y + Math.imul(Ve, nt) | 0, y = y + Math.imul(Ye, rt) | 0, j = j + Math.imul(Ye, nt) | 0, R = R + Math.imul(Be, st) | 0, y = y + Math.imul(Be, at) | 0, y = y + Math.imul(Oe, st) | 0, j = j + Math.imul(Oe, at) | 0, R = R + Math.imul(ue, lt) | 0, y = y + Math.imul(ue, tt) | 0, y = y + Math.imul(he, lt) | 0, j = j + Math.imul(he, tt) | 0, R = R + Math.imul(He, le) | 0, y = y + Math.imul(He, be) | 0, y = y + Math.imul(Ze, le) | 0, j = j + Math.imul(Ze, be) | 0, R = R + Math.imul(Ue, te) | 0, y = y + Math.imul(Ue, ve) | 0, y = y + Math.imul(De, te) | 0, j = j + Math.imul(De, ve) | 0, R = R + Math.imul(ke, Pe) | 0, y = y + Math.imul(ke, Le) | 0, y = y + Math.imul(Ce, Pe) | 0, j = j + Math.imul(Ce, Le) | 0, R = R + Math.imul(ee, Je) | 0, y = y + Math.imul(ee, Ge) | 0, y = y + Math.imul(xe, Je) | 0, j = j + Math.imul(xe, Ge) | 0;
      var _t = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, R = Math.imul(_e, je), y = Math.imul(_e, ot), y = y + Math.imul(Re, je) | 0, j = Math.imul(Re, ot), R = R + Math.imul(V, ct) | 0, y = y + Math.imul(V, ut) | 0, y = y + Math.imul(se, ct) | 0, j = j + Math.imul(se, ut) | 0, R = R + Math.imul(et, rt) | 0, y = y + Math.imul(et, nt) | 0, y = y + Math.imul(Q, rt) | 0, j = j + Math.imul(Q, nt) | 0, R = R + Math.imul(Ve, st) | 0, y = y + Math.imul(Ve, at) | 0, y = y + Math.imul(Ye, st) | 0, j = j + Math.imul(Ye, at) | 0, R = R + Math.imul(Be, lt) | 0, y = y + Math.imul(Be, tt) | 0, y = y + Math.imul(Oe, lt) | 0, j = j + Math.imul(Oe, tt) | 0, R = R + Math.imul(ue, le) | 0, y = y + Math.imul(ue, be) | 0, y = y + Math.imul(he, le) | 0, j = j + Math.imul(he, be) | 0, R = R + Math.imul(He, te) | 0, y = y + Math.imul(He, ve) | 0, y = y + Math.imul(Ze, te) | 0, j = j + Math.imul(Ze, ve) | 0, R = R + Math.imul(Ue, Pe) | 0, y = y + Math.imul(Ue, Le) | 0, y = y + Math.imul(De, Pe) | 0, j = j + Math.imul(De, Le) | 0, R = R + Math.imul(ke, Je) | 0, y = y + Math.imul(ke, Ge) | 0, y = y + Math.imul(Ce, Je) | 0, j = j + Math.imul(Ce, Ge) | 0;
      var St = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, R = Math.imul(_e, ct), y = Math.imul(_e, ut), y = y + Math.imul(Re, ct) | 0, j = Math.imul(Re, ut), R = R + Math.imul(V, rt) | 0, y = y + Math.imul(V, nt) | 0, y = y + Math.imul(se, rt) | 0, j = j + Math.imul(se, nt) | 0, R = R + Math.imul(et, st) | 0, y = y + Math.imul(et, at) | 0, y = y + Math.imul(Q, st) | 0, j = j + Math.imul(Q, at) | 0, R = R + Math.imul(Ve, lt) | 0, y = y + Math.imul(Ve, tt) | 0, y = y + Math.imul(Ye, lt) | 0, j = j + Math.imul(Ye, tt) | 0, R = R + Math.imul(Be, le) | 0, y = y + Math.imul(Be, be) | 0, y = y + Math.imul(Oe, le) | 0, j = j + Math.imul(Oe, be) | 0, R = R + Math.imul(ue, te) | 0, y = y + Math.imul(ue, ve) | 0, y = y + Math.imul(he, te) | 0, j = j + Math.imul(he, ve) | 0, R = R + Math.imul(He, Pe) | 0, y = y + Math.imul(He, Le) | 0, y = y + Math.imul(Ze, Pe) | 0, j = j + Math.imul(Ze, Le) | 0, R = R + Math.imul(Ue, Je) | 0, y = y + Math.imul(Ue, Ge) | 0, y = y + Math.imul(De, Je) | 0, j = j + Math.imul(De, Ge) | 0;
      var vt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, R = Math.imul(_e, rt), y = Math.imul(_e, nt), y = y + Math.imul(Re, rt) | 0, j = Math.imul(Re, nt), R = R + Math.imul(V, st) | 0, y = y + Math.imul(V, at) | 0, y = y + Math.imul(se, st) | 0, j = j + Math.imul(se, at) | 0, R = R + Math.imul(et, lt) | 0, y = y + Math.imul(et, tt) | 0, y = y + Math.imul(Q, lt) | 0, j = j + Math.imul(Q, tt) | 0, R = R + Math.imul(Ve, le) | 0, y = y + Math.imul(Ve, be) | 0, y = y + Math.imul(Ye, le) | 0, j = j + Math.imul(Ye, be) | 0, R = R + Math.imul(Be, te) | 0, y = y + Math.imul(Be, ve) | 0, y = y + Math.imul(Oe, te) | 0, j = j + Math.imul(Oe, ve) | 0, R = R + Math.imul(ue, Pe) | 0, y = y + Math.imul(ue, Le) | 0, y = y + Math.imul(he, Pe) | 0, j = j + Math.imul(he, Le) | 0, R = R + Math.imul(He, Je) | 0, y = y + Math.imul(He, Ge) | 0, y = y + Math.imul(Ze, Je) | 0, j = j + Math.imul(Ze, Ge) | 0;
      var At = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, R = Math.imul(_e, st), y = Math.imul(_e, at), y = y + Math.imul(Re, st) | 0, j = Math.imul(Re, at), R = R + Math.imul(V, lt) | 0, y = y + Math.imul(V, tt) | 0, y = y + Math.imul(se, lt) | 0, j = j + Math.imul(se, tt) | 0, R = R + Math.imul(et, le) | 0, y = y + Math.imul(et, be) | 0, y = y + Math.imul(Q, le) | 0, j = j + Math.imul(Q, be) | 0, R = R + Math.imul(Ve, te) | 0, y = y + Math.imul(Ve, ve) | 0, y = y + Math.imul(Ye, te) | 0, j = j + Math.imul(Ye, ve) | 0, R = R + Math.imul(Be, Pe) | 0, y = y + Math.imul(Be, Le) | 0, y = y + Math.imul(Oe, Pe) | 0, j = j + Math.imul(Oe, Le) | 0, R = R + Math.imul(ue, Je) | 0, y = y + Math.imul(ue, Ge) | 0, y = y + Math.imul(he, Je) | 0, j = j + Math.imul(he, Ge) | 0;
      var Et = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, R = Math.imul(_e, lt), y = Math.imul(_e, tt), y = y + Math.imul(Re, lt) | 0, j = Math.imul(Re, tt), R = R + Math.imul(V, le) | 0, y = y + Math.imul(V, be) | 0, y = y + Math.imul(se, le) | 0, j = j + Math.imul(se, be) | 0, R = R + Math.imul(et, te) | 0, y = y + Math.imul(et, ve) | 0, y = y + Math.imul(Q, te) | 0, j = j + Math.imul(Q, ve) | 0, R = R + Math.imul(Ve, Pe) | 0, y = y + Math.imul(Ve, Le) | 0, y = y + Math.imul(Ye, Pe) | 0, j = j + Math.imul(Ye, Le) | 0, R = R + Math.imul(Be, Je) | 0, y = y + Math.imul(Be, Ge) | 0, y = y + Math.imul(Oe, Je) | 0, j = j + Math.imul(Oe, Ge) | 0;
      var yt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, R = Math.imul(_e, le), y = Math.imul(_e, be), y = y + Math.imul(Re, le) | 0, j = Math.imul(Re, be), R = R + Math.imul(V, te) | 0, y = y + Math.imul(V, ve) | 0, y = y + Math.imul(se, te) | 0, j = j + Math.imul(se, ve) | 0, R = R + Math.imul(et, Pe) | 0, y = y + Math.imul(et, Le) | 0, y = y + Math.imul(Q, Pe) | 0, j = j + Math.imul(Q, Le) | 0, R = R + Math.imul(Ve, Je) | 0, y = y + Math.imul(Ve, Ge) | 0, y = y + Math.imul(Ye, Je) | 0, j = j + Math.imul(Ye, Ge) | 0;
      var Xe = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, R = Math.imul(_e, te), y = Math.imul(_e, ve), y = y + Math.imul(Re, te) | 0, j = Math.imul(Re, ve), R = R + Math.imul(V, Pe) | 0, y = y + Math.imul(V, Le) | 0, y = y + Math.imul(se, Pe) | 0, j = j + Math.imul(se, Le) | 0, R = R + Math.imul(et, Je) | 0, y = y + Math.imul(et, Ge) | 0, y = y + Math.imul(Q, Je) | 0, j = j + Math.imul(Q, Ge) | 0;
      var Qe = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, R = Math.imul(_e, Pe), y = Math.imul(_e, Le), y = y + Math.imul(Re, Pe) | 0, j = Math.imul(Re, Le), R = R + Math.imul(V, Je) | 0, y = y + Math.imul(V, Ge) | 0, y = y + Math.imul(se, Je) | 0, j = j + Math.imul(se, Ge) | 0;
      var dt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, R = Math.imul(_e, Je), y = Math.imul(_e, Ge), y = y + Math.imul(Re, Je) | 0, j = Math.imul(Re, Ge);
      var ft = (G + R | 0) + ((y & 8191) << 13) | 0;
      return G = (j + (y >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, C[0] = $t, C[1] = bt, C[2] = Mt, C[3] = Rt, C[4] = Tt, C[5] = Nt, C[6] = It, C[7] = Ct, C[8] = Bt, C[9] = _t, C[10] = St, C[11] = vt, C[12] = At, C[13] = Et, C[14] = yt, C[15] = Xe, C[16] = Qe, C[17] = dt, C[18] = ft, G !== 0 && (C[19] = G, S.length++), S;
    };
    Math.imul || (pe = oe);
    function ae(k, p, x) {
      x.negative = p.negative ^ k.negative, x.length = k.length + p.length;
      for (var S = 0, B = 0, L = 0; L < x.length - 1; L++) {
        var C = B;
        B = 0;
        for (var G = S & 67108863, R = Math.min(L, p.length - 1), y = Math.max(0, L - k.length + 1); y <= R; y++) {
          var j = L - y, ye = k.words[j] | 0, ee = p.words[y] | 0, xe = ye * ee, $e = xe & 67108863;
          C = C + (xe / 67108864 | 0) | 0, $e = $e + G | 0, G = $e & 67108863, C = C + ($e >>> 26) | 0, B += C >>> 26, C &= 67108863;
        }
        x.words[L] = G, S = C, C = B;
      }
      return S !== 0 ? x.words[L] = S : x.length--, x._strip();
    }
    function me(k, p, x) {
      return ae(k, p, x);
    }
    d.prototype.mulTo = function(p, x) {
      var S, B = this.length + p.length;
      return this.length === 10 && p.length === 10 ? S = pe(this, p, x) : B < 63 ? S = oe(this, p, x) : B < 1024 ? S = ae(this, p, x) : S = me(this, p, x), S;
    }, d.prototype.mul = function(p) {
      var x = new d(null);
      return x.words = new Array(this.length + p.length), this.mulTo(p, x);
    }, d.prototype.mulf = function(p) {
      var x = new d(null);
      return x.words = new Array(this.length + p.length), me(this, p, x);
    }, d.prototype.imul = function(p) {
      return this.clone().mulTo(p, this);
    }, d.prototype.imuln = function(p) {
      var x = p < 0;
      x && (p = -p), h(typeof p == "number"), h(p < 67108864);
      for (var S = 0, B = 0; B < this.length; B++) {
        var L = (this.words[B] | 0) * p, C = (L & 67108863) + (S & 67108863);
        S >>= 26, S += L / 67108864 | 0, S += C >>> 26, this.words[B] = C & 67108863;
      }
      return S !== 0 && (this.words[B] = S, this.length++), x ? this.ineg() : this;
    }, d.prototype.muln = function(p) {
      return this.clone().imuln(p);
    }, d.prototype.sqr = function() {
      return this.mul(this);
    }, d.prototype.isqr = function() {
      return this.imul(this.clone());
    }, d.prototype.pow = function(p) {
      var x = re(p);
      if (x.length === 0)
        return new d(1);
      for (var S = this, B = 0; B < x.length && x[B] === 0; B++, S = S.sqr())
        ;
      if (++B < x.length)
        for (var L = S.sqr(); B < x.length; B++, L = L.sqr())
          x[B] !== 0 && (S = S.mul(L));
      return S;
    }, d.prototype.iushln = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26, B = 67108863 >>> 26 - x << 26 - x, L;
      if (x !== 0) {
        var C = 0;
        for (L = 0; L < this.length; L++) {
          var G = this.words[L] & B, R = (this.words[L] | 0) - G << x;
          this.words[L] = R | C, C = G >>> 26 - x;
        }
        C && (this.words[L] = C, this.length++);
      }
      if (S !== 0) {
        for (L = this.length - 1; L >= 0; L--)
          this.words[L + S] = this.words[L];
        for (L = 0; L < S; L++)
          this.words[L] = 0;
        this.length += S;
      }
      return this._strip();
    }, d.prototype.ishln = function(p) {
      return h(this.negative === 0), this.iushln(p);
    }, d.prototype.iushrn = function(p, x, S) {
      h(typeof p == "number" && p >= 0);
      var B;
      x ? B = (x - x % 26) / 26 : B = 0;
      var L = p % 26, C = Math.min((p - L) / 26, this.length), G = 67108863 ^ 67108863 >>> L << L, R = S;
      if (B -= C, B = Math.max(0, B), R) {
        for (var y = 0; y < C; y++)
          R.words[y] = this.words[y];
        R.length = C;
      }
      if (C !== 0)
        if (this.length > C)
          for (this.length -= C, y = 0; y < this.length; y++)
            this.words[y] = this.words[y + C];
        else
          this.words[0] = 0, this.length = 1;
      var j = 0;
      for (y = this.length - 1; y >= 0 && (j !== 0 || y >= B); y--) {
        var ye = this.words[y] | 0;
        this.words[y] = j << 26 - L | ye >>> L, j = ye & G;
      }
      return R && j !== 0 && (R.words[R.length++] = j), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, d.prototype.ishrn = function(p, x, S) {
      return h(this.negative === 0), this.iushrn(p, x, S);
    }, d.prototype.shln = function(p) {
      return this.clone().ishln(p);
    }, d.prototype.ushln = function(p) {
      return this.clone().iushln(p);
    }, d.prototype.shrn = function(p) {
      return this.clone().ishrn(p);
    }, d.prototype.ushrn = function(p) {
      return this.clone().iushrn(p);
    }, d.prototype.testn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26, B = 1 << x;
      if (this.length <= S)
        return !1;
      var L = this.words[S];
      return !!(L & B);
    }, d.prototype.imaskn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26;
      if (h(this.negative === 0, "imaskn works only with positive numbers"), this.length <= S)
        return this;
      if (x !== 0 && S++, this.length = Math.min(S, this.length), x !== 0) {
        var B = 67108863 ^ 67108863 >>> x << x;
        this.words[this.length - 1] &= B;
      }
      return this._strip();
    }, d.prototype.maskn = function(p) {
      return this.clone().imaskn(p);
    }, d.prototype.iaddn = function(p) {
      return h(typeof p == "number"), h(p < 67108864), p < 0 ? this.isubn(-p) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= p ? (this.words[0] = p - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(p), this.negative = 1, this) : this._iaddn(p);
    }, d.prototype._iaddn = function(p) {
      this.words[0] += p;
      for (var x = 0; x < this.length && this.words[x] >= 67108864; x++)
        this.words[x] -= 67108864, x === this.length - 1 ? this.words[x + 1] = 1 : this.words[x + 1]++;
      return this.length = Math.max(this.length, x + 1), this;
    }, d.prototype.isubn = function(p) {
      if (h(typeof p == "number"), h(p < 67108864), p < 0)
        return this.iaddn(-p);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(p), this.negative = 1, this;
      if (this.words[0] -= p, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var x = 0; x < this.length && this.words[x] < 0; x++)
          this.words[x] += 67108864, this.words[x + 1] -= 1;
      return this._strip();
    }, d.prototype.addn = function(p) {
      return this.clone().iaddn(p);
    }, d.prototype.subn = function(p) {
      return this.clone().isubn(p);
    }, d.prototype.iabs = function() {
      return this.negative = 0, this;
    }, d.prototype.abs = function() {
      return this.clone().iabs();
    }, d.prototype._ishlnsubmul = function(p, x, S) {
      var B = p.length + S, L;
      this._expand(B);
      var C, G = 0;
      for (L = 0; L < p.length; L++) {
        C = (this.words[L + S] | 0) + G;
        var R = (p.words[L] | 0) * x;
        C -= R & 67108863, G = (C >> 26) - (R / 67108864 | 0), this.words[L + S] = C & 67108863;
      }
      for (; L < this.length - S; L++)
        C = (this.words[L + S] | 0) + G, G = C >> 26, this.words[L + S] = C & 67108863;
      if (G === 0)
        return this._strip();
      for (h(G === -1), G = 0, L = 0; L < this.length; L++)
        C = -(this.words[L] | 0) + G, G = C >> 26, this.words[L] = C & 67108863;
      return this.negative = 1, this._strip();
    }, d.prototype._wordDiv = function(p, x) {
      var S = this.length - p.length, B = this.clone(), L = p, C = L.words[L.length - 1] | 0, G = this._countBits(C);
      S = 26 - G, S !== 0 && (L = L.ushln(S), B.iushln(S), C = L.words[L.length - 1] | 0);
      var R = B.length - L.length, y;
      if (x !== "mod") {
        y = new d(null), y.length = R + 1, y.words = new Array(y.length);
        for (var j = 0; j < y.length; j++)
          y.words[j] = 0;
      }
      var ye = B.clone()._ishlnsubmul(L, 1, R);
      ye.negative === 0 && (B = ye, y && (y.words[R] = 1));
      for (var ee = R - 1; ee >= 0; ee--) {
        var xe = (B.words[L.length + ee] | 0) * 67108864 + (B.words[L.length + ee - 1] | 0);
        for (xe = Math.min(xe / C | 0, 67108863), B._ishlnsubmul(L, xe, ee); B.negative !== 0; )
          xe--, B.negative = 0, B._ishlnsubmul(L, 1, ee), B.isZero() || (B.negative ^= 1);
        y && (y.words[ee] = xe);
      }
      return y && y._strip(), B._strip(), x !== "div" && S !== 0 && B.iushrn(S), {
        div: y || null,
        mod: B
      };
    }, d.prototype.divmod = function(p, x, S) {
      if (h(!p.isZero()), this.isZero())
        return {
          div: new d(0),
          mod: new d(0)
        };
      var B, L, C;
      return this.negative !== 0 && p.negative === 0 ? (C = this.neg().divmod(p, x), x !== "mod" && (B = C.div.neg()), x !== "div" && (L = C.mod.neg(), S && L.negative !== 0 && L.iadd(p)), {
        div: B,
        mod: L
      }) : this.negative === 0 && p.negative !== 0 ? (C = this.divmod(p.neg(), x), x !== "mod" && (B = C.div.neg()), {
        div: B,
        mod: C.mod
      }) : (this.negative & p.negative) !== 0 ? (C = this.neg().divmod(p.neg(), x), x !== "div" && (L = C.mod.neg(), S && L.negative !== 0 && L.isub(p)), {
        div: C.div,
        mod: L
      }) : p.length > this.length || this.cmp(p) < 0 ? {
        div: new d(0),
        mod: this
      } : p.length === 1 ? x === "div" ? {
        div: this.divn(p.words[0]),
        mod: null
      } : x === "mod" ? {
        div: null,
        mod: new d(this.modrn(p.words[0]))
      } : {
        div: this.divn(p.words[0]),
        mod: new d(this.modrn(p.words[0]))
      } : this._wordDiv(p, x);
    }, d.prototype.div = function(p) {
      return this.divmod(p, "div", !1).div;
    }, d.prototype.mod = function(p) {
      return this.divmod(p, "mod", !1).mod;
    }, d.prototype.umod = function(p) {
      return this.divmod(p, "mod", !0).mod;
    }, d.prototype.divRound = function(p) {
      var x = this.divmod(p);
      if (x.mod.isZero())
        return x.div;
      var S = x.div.negative !== 0 ? x.mod.isub(p) : x.mod, B = p.ushrn(1), L = p.andln(1), C = S.cmp(B);
      return C < 0 || L === 1 && C === 0 ? x.div : x.div.negative !== 0 ? x.div.isubn(1) : x.div.iaddn(1);
    }, d.prototype.modrn = function(p) {
      var x = p < 0;
      x && (p = -p), h(p <= 67108863);
      for (var S = (1 << 26) % p, B = 0, L = this.length - 1; L >= 0; L--)
        B = (S * B + (this.words[L] | 0)) % p;
      return x ? -B : B;
    }, d.prototype.modn = function(p) {
      return this.modrn(p);
    }, d.prototype.idivn = function(p) {
      var x = p < 0;
      x && (p = -p), h(p <= 67108863);
      for (var S = 0, B = this.length - 1; B >= 0; B--) {
        var L = (this.words[B] | 0) + S * 67108864;
        this.words[B] = L / p | 0, S = L % p;
      }
      return this._strip(), x ? this.ineg() : this;
    }, d.prototype.divn = function(p) {
      return this.clone().idivn(p);
    }, d.prototype.egcd = function(p) {
      h(p.negative === 0), h(!p.isZero());
      var x = this, S = p.clone();
      x.negative !== 0 ? x = x.umod(p) : x = x.clone();
      for (var B = new d(1), L = new d(0), C = new d(0), G = new d(1), R = 0; x.isEven() && S.isEven(); )
        x.iushrn(1), S.iushrn(1), ++R;
      for (var y = S.clone(), j = x.clone(); !x.isZero(); ) {
        for (var ye = 0, ee = 1; (x.words[0] & ee) === 0 && ye < 26; ++ye, ee <<= 1)
          ;
        if (ye > 0)
          for (x.iushrn(ye); ye-- > 0; )
            (B.isOdd() || L.isOdd()) && (B.iadd(y), L.isub(j)), B.iushrn(1), L.iushrn(1);
        for (var xe = 0, $e = 1; (S.words[0] & $e) === 0 && xe < 26; ++xe, $e <<= 1)
          ;
        if (xe > 0)
          for (S.iushrn(xe); xe-- > 0; )
            (C.isOdd() || G.isOdd()) && (C.iadd(y), G.isub(j)), C.iushrn(1), G.iushrn(1);
        x.cmp(S) >= 0 ? (x.isub(S), B.isub(C), L.isub(G)) : (S.isub(x), C.isub(B), G.isub(L));
      }
      return {
        a: C,
        b: G,
        gcd: S.iushln(R)
      };
    }, d.prototype._invmp = function(p) {
      h(p.negative === 0), h(!p.isZero());
      var x = this, S = p.clone();
      x.negative !== 0 ? x = x.umod(p) : x = x.clone();
      for (var B = new d(1), L = new d(0), C = S.clone(); x.cmpn(1) > 0 && S.cmpn(1) > 0; ) {
        for (var G = 0, R = 1; (x.words[0] & R) === 0 && G < 26; ++G, R <<= 1)
          ;
        if (G > 0)
          for (x.iushrn(G); G-- > 0; )
            B.isOdd() && B.iadd(C), B.iushrn(1);
        for (var y = 0, j = 1; (S.words[0] & j) === 0 && y < 26; ++y, j <<= 1)
          ;
        if (y > 0)
          for (S.iushrn(y); y-- > 0; )
            L.isOdd() && L.iadd(C), L.iushrn(1);
        x.cmp(S) >= 0 ? (x.isub(S), B.isub(L)) : (S.isub(x), L.isub(B));
      }
      var ye;
      return x.cmpn(1) === 0 ? ye = B : ye = L, ye.cmpn(0) < 0 && ye.iadd(p), ye;
    }, d.prototype.gcd = function(p) {
      if (this.isZero())
        return p.abs();
      if (p.isZero())
        return this.abs();
      var x = this.clone(), S = p.clone();
      x.negative = 0, S.negative = 0;
      for (var B = 0; x.isEven() && S.isEven(); B++)
        x.iushrn(1), S.iushrn(1);
      do {
        for (; x.isEven(); )
          x.iushrn(1);
        for (; S.isEven(); )
          S.iushrn(1);
        var L = x.cmp(S);
        if (L < 0) {
          var C = x;
          x = S, S = C;
        } else if (L === 0 || S.cmpn(1) === 0)
          break;
        x.isub(S);
      } while (!0);
      return S.iushln(B);
    }, d.prototype.invm = function(p) {
      return this.egcd(p).a.umod(p);
    }, d.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, d.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, d.prototype.andln = function(p) {
      return this.words[0] & p;
    }, d.prototype.bincn = function(p) {
      h(typeof p == "number");
      var x = p % 26, S = (p - x) / 26, B = 1 << x;
      if (this.length <= S)
        return this._expand(S + 1), this.words[S] |= B, this;
      for (var L = B, C = S; L !== 0 && C < this.length; C++) {
        var G = this.words[C] | 0;
        G += L, L = G >>> 26, G &= 67108863, this.words[C] = G;
      }
      return L !== 0 && (this.words[C] = L, this.length++), this;
    }, d.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, d.prototype.cmpn = function(p) {
      var x = p < 0;
      if (this.negative !== 0 && !x)
        return -1;
      if (this.negative === 0 && x)
        return 1;
      this._strip();
      var S;
      if (this.length > 1)
        S = 1;
      else {
        x && (p = -p), h(p <= 67108863, "Number is too big");
        var B = this.words[0] | 0;
        S = B === p ? 0 : B < p ? -1 : 1;
      }
      return this.negative !== 0 ? -S | 0 : S;
    }, d.prototype.cmp = function(p) {
      if (this.negative !== 0 && p.negative === 0)
        return -1;
      if (this.negative === 0 && p.negative !== 0)
        return 1;
      var x = this.ucmp(p);
      return this.negative !== 0 ? -x | 0 : x;
    }, d.prototype.ucmp = function(p) {
      if (this.length > p.length)
        return 1;
      if (this.length < p.length)
        return -1;
      for (var x = 0, S = this.length - 1; S >= 0; S--) {
        var B = this.words[S] | 0, L = p.words[S] | 0;
        if (B !== L) {
          B < L ? x = -1 : B > L && (x = 1);
          break;
        }
      }
      return x;
    }, d.prototype.gtn = function(p) {
      return this.cmpn(p) === 1;
    }, d.prototype.gt = function(p) {
      return this.cmp(p) === 1;
    }, d.prototype.gten = function(p) {
      return this.cmpn(p) >= 0;
    }, d.prototype.gte = function(p) {
      return this.cmp(p) >= 0;
    }, d.prototype.ltn = function(p) {
      return this.cmpn(p) === -1;
    }, d.prototype.lt = function(p) {
      return this.cmp(p) === -1;
    }, d.prototype.lten = function(p) {
      return this.cmpn(p) <= 0;
    }, d.prototype.lte = function(p) {
      return this.cmp(p) <= 0;
    }, d.prototype.eqn = function(p) {
      return this.cmpn(p) === 0;
    }, d.prototype.eq = function(p) {
      return this.cmp(p) === 0;
    }, d.red = function(p) {
      return new X(p);
    }, d.prototype.toRed = function(p) {
      return h(!this.red, "Already a number in reduction context"), h(this.negative === 0, "red works only with positives"), p.convertTo(this)._forceRed(p);
    }, d.prototype.fromRed = function() {
      return h(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, d.prototype._forceRed = function(p) {
      return this.red = p, this;
    }, d.prototype.forceRed = function(p) {
      return h(!this.red, "Already a number in reduction context"), this._forceRed(p);
    }, d.prototype.redAdd = function(p) {
      return h(this.red, "redAdd works only with red numbers"), this.red.add(this, p);
    }, d.prototype.redIAdd = function(p) {
      return h(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, p);
    }, d.prototype.redSub = function(p) {
      return h(this.red, "redSub works only with red numbers"), this.red.sub(this, p);
    }, d.prototype.redISub = function(p) {
      return h(this.red, "redISub works only with red numbers"), this.red.isub(this, p);
    }, d.prototype.redShl = function(p) {
      return h(this.red, "redShl works only with red numbers"), this.red.shl(this, p);
    }, d.prototype.redMul = function(p) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.mul(this, p);
    }, d.prototype.redIMul = function(p) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.imul(this, p);
    }, d.prototype.redSqr = function() {
      return h(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, d.prototype.redISqr = function() {
      return h(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, d.prototype.redSqrt = function() {
      return h(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, d.prototype.redInvm = function() {
      return h(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, d.prototype.redNeg = function() {
      return h(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, d.prototype.redPow = function(p) {
      return h(this.red && !p.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, p);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function we(k, p) {
      this.name = k, this.p = new d(p, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    we.prototype._tmp = function() {
      var p = new d(null);
      return p.words = new Array(Math.ceil(this.n / 13)), p;
    }, we.prototype.ireduce = function(p) {
      var x = p, S;
      do
        this.split(x, this.tmp), x = this.imulK(x), x = x.iadd(this.tmp), S = x.bitLength();
      while (S > this.n);
      var B = S < this.n ? -1 : x.ucmp(this.p);
      return B === 0 ? (x.words[0] = 0, x.length = 1) : B > 0 ? x.isub(this.p) : x.strip !== void 0 ? x.strip() : x._strip(), x;
    }, we.prototype.split = function(p, x) {
      p.iushrn(this.n, 0, x);
    }, we.prototype.imulK = function(p) {
      return p.imul(this.k);
    };
    function Ee() {
      we.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    m(Ee, we), Ee.prototype.split = function(p, x) {
      for (var S = 4194303, B = Math.min(p.length, 9), L = 0; L < B; L++)
        x.words[L] = p.words[L];
      if (x.length = B, p.length <= 9) {
        p.words[0] = 0, p.length = 1;
        return;
      }
      var C = p.words[9];
      for (x.words[x.length++] = C & S, L = 10; L < p.length; L++) {
        var G = p.words[L] | 0;
        p.words[L - 10] = (G & S) << 4 | C >>> 22, C = G;
      }
      C >>>= 22, p.words[L - 10] = C, C === 0 && p.length > 10 ? p.length -= 10 : p.length -= 9;
    }, Ee.prototype.imulK = function(p) {
      p.words[p.length] = 0, p.words[p.length + 1] = 0, p.length += 2;
      for (var x = 0, S = 0; S < p.length; S++) {
        var B = p.words[S] | 0;
        x += B * 977, p.words[S] = x & 67108863, x = B * 64 + (x / 67108864 | 0);
      }
      return p.words[p.length - 1] === 0 && (p.length--, p.words[p.length - 1] === 0 && p.length--), p;
    };
    function Te() {
      we.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    m(Te, we);
    function Ke() {
      we.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    m(Ke, we);
    function Se() {
      we.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    m(Se, we), Se.prototype.imulK = function(p) {
      for (var x = 0, S = 0; S < p.length; S++) {
        var B = (p.words[S] | 0) * 19 + x, L = B & 67108863;
        B >>>= 26, p.words[S] = L, x = B;
      }
      return x !== 0 && (p.words[p.length++] = x), p;
    }, d._prime = function(p) {
      if (ge[p])
        return ge[p];
      var x;
      if (p === "k256")
        x = new Ee();
      else if (p === "p224")
        x = new Te();
      else if (p === "p192")
        x = new Ke();
      else if (p === "p25519")
        x = new Se();
      else
        throw new Error("Unknown prime " + p);
      return ge[p] = x, x;
    };
    function X(k) {
      if (typeof k == "string") {
        var p = d._prime(k);
        this.m = p.p, this.prime = p;
      } else
        h(k.gtn(1), "modulus must be greater than 1"), this.m = k, this.prime = null;
    }
    X.prototype._verify1 = function(p) {
      h(p.negative === 0, "red works only with positives"), h(p.red, "red works only with red numbers");
    }, X.prototype._verify2 = function(p, x) {
      h((p.negative | x.negative) === 0, "red works only with positives"), h(
        p.red && p.red === x.red,
        "red works only with red numbers"
      );
    }, X.prototype.imod = function(p) {
      return this.prime ? this.prime.ireduce(p)._forceRed(this) : (J(p, p.umod(this.m)._forceRed(this)), p);
    }, X.prototype.neg = function(p) {
      return p.isZero() ? p.clone() : this.m.sub(p)._forceRed(this);
    }, X.prototype.add = function(p, x) {
      this._verify2(p, x);
      var S = p.add(x);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S._forceRed(this);
    }, X.prototype.iadd = function(p, x) {
      this._verify2(p, x);
      var S = p.iadd(x);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S;
    }, X.prototype.sub = function(p, x) {
      this._verify2(p, x);
      var S = p.sub(x);
      return S.cmpn(0) < 0 && S.iadd(this.m), S._forceRed(this);
    }, X.prototype.isub = function(p, x) {
      this._verify2(p, x);
      var S = p.isub(x);
      return S.cmpn(0) < 0 && S.iadd(this.m), S;
    }, X.prototype.shl = function(p, x) {
      return this._verify1(p), this.imod(p.ushln(x));
    }, X.prototype.imul = function(p, x) {
      return this._verify2(p, x), this.imod(p.imul(x));
    }, X.prototype.mul = function(p, x) {
      return this._verify2(p, x), this.imod(p.mul(x));
    }, X.prototype.isqr = function(p) {
      return this.imul(p, p.clone());
    }, X.prototype.sqr = function(p) {
      return this.mul(p, p);
    }, X.prototype.sqrt = function(p) {
      if (p.isZero())
        return p.clone();
      var x = this.m.andln(3);
      if (h(x % 2 === 1), x === 3) {
        var S = this.m.add(new d(1)).iushrn(2);
        return this.pow(p, S);
      }
      for (var B = this.m.subn(1), L = 0; !B.isZero() && B.andln(1) === 0; )
        L++, B.iushrn(1);
      h(!B.isZero());
      var C = new d(1).toRed(this), G = C.redNeg(), R = this.m.subn(1).iushrn(1), y = this.m.bitLength();
      for (y = new d(2 * y * y).toRed(this); this.pow(y, R).cmp(G) !== 0; )
        y.redIAdd(G);
      for (var j = this.pow(y, B), ye = this.pow(p, B.addn(1).iushrn(1)), ee = this.pow(p, B), xe = L; ee.cmp(C) !== 0; ) {
        for (var $e = ee, ke = 0; $e.cmp(C) !== 0; ke++)
          $e = $e.redSqr();
        h(ke < xe);
        var Ce = this.pow(j, new d(1).iushln(xe - ke - 1));
        ye = ye.redMul(Ce), j = Ce.redSqr(), ee = ee.redMul(j), xe = ke;
      }
      return ye;
    }, X.prototype.invm = function(p) {
      var x = p._invmp(this.m);
      return x.negative !== 0 ? (x.negative = 0, this.imod(x).redNeg()) : this.imod(x);
    }, X.prototype.pow = function(p, x) {
      if (x.isZero())
        return new d(1).toRed(this);
      if (x.cmpn(1) === 0)
        return p.clone();
      var S = 4, B = new Array(1 << S);
      B[0] = new d(1).toRed(this), B[1] = p;
      for (var L = 2; L < B.length; L++)
        B[L] = this.mul(B[L - 1], p);
      var C = B[0], G = 0, R = 0, y = x.bitLength() % 26;
      for (y === 0 && (y = 26), L = x.length - 1; L >= 0; L--) {
        for (var j = x.words[L], ye = y - 1; ye >= 0; ye--) {
          var ee = j >> ye & 1;
          if (C !== B[0] && (C = this.sqr(C)), ee === 0 && G === 0) {
            R = 0;
            continue;
          }
          G <<= 1, G |= ee, R++, !(R !== S && (L !== 0 || ye !== 0)) && (C = this.mul(C, B[G]), R = 0, G = 0);
        }
        y = 26;
      }
      return C;
    }, X.prototype.convertTo = function(p) {
      var x = p.umod(this.m);
      return x === p ? x.clone() : x;
    }, X.prototype.convertFrom = function(p) {
      var x = p.clone();
      return x.red = null, x;
    }, d.mont = function(p) {
      return new fe(p);
    };
    function fe(k) {
      X.call(this, k), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    m(fe, X), fe.prototype.convertTo = function(p) {
      return this.imod(p.ushln(this.shift));
    }, fe.prototype.convertFrom = function(p) {
      var x = this.imod(p.mul(this.rinv));
      return x.red = null, x;
    }, fe.prototype.imul = function(p, x) {
      if (p.isZero() || x.isZero())
        return p.words[0] = 0, p.length = 1, p;
      var S = p.imul(x), B = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = S.isub(B).iushrn(this.shift), C = L;
      return L.cmp(this.m) >= 0 ? C = L.isub(this.m) : L.cmpn(0) < 0 && (C = L.iadd(this.m)), C._forceRed(this);
    }, fe.prototype.mul = function(p, x) {
      if (p.isZero() || x.isZero())
        return new d(0)._forceRed(this);
      var S = p.mul(x), B = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = S.isub(B).iushrn(this.shift), C = L;
      return L.cmp(this.m) >= 0 ? C = L.isub(this.m) : L.cmpn(0) < 0 && (C = L.iadd(this.m)), C._forceRed(this);
    }, fe.prototype.invm = function(p) {
      var x = this.imod(p._invmp(this.m).mul(this.r2));
      return x._forceRed(this);
    };
  })(l, commonjsGlobal);
})(bn$5);
var _BN = bn$5.exports;
const version$r = "logger/5.7.0";
let _permanentCensorErrors = !1, _censorErrors = !1;
const LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels.default, _globalLogger = null;
function _checkNormalize() {
  try {
    const l = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
      try {
        if ("test".normalize(t) !== "test")
          throw new Error("bad normalize");
      } catch {
        l.push(t);
      }
    }), l.length)
      throw new Error("missing " + l.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (l) {
    return l.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(l) {
  l.DEBUG = "DEBUG", l.INFO = "INFO", l.WARNING = "WARNING", l.ERROR = "ERROR", l.OFF = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(l) {
  l.UNKNOWN_ERROR = "UNKNOWN_ERROR", l.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", l.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", l.NETWORK_ERROR = "NETWORK_ERROR", l.SERVER_ERROR = "SERVER_ERROR", l.TIMEOUT = "TIMEOUT", l.BUFFER_OVERRUN = "BUFFER_OVERRUN", l.NUMERIC_FAULT = "NUMERIC_FAULT", l.MISSING_NEW = "MISSING_NEW", l.INVALID_ARGUMENT = "INVALID_ARGUMENT", l.MISSING_ARGUMENT = "MISSING_ARGUMENT", l.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", l.CALL_EXCEPTION = "CALL_EXCEPTION", l.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", l.NONCE_EXPIRED = "NONCE_EXPIRED", l.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", l.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", l.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", l.ACTION_REJECTED = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(t) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: t,
      writable: !1
    });
  }
  _log(t, s) {
    const h = t.toLowerCase();
    LogLevels[h] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(_logLevel > LogLevels[h]) && console.log.apply(console, s);
  }
  debug(...t) {
    this._log(Logger.levels.DEBUG, t);
  }
  info(...t) {
    this._log(Logger.levels.INFO, t);
  }
  warn(...t) {
    this._log(Logger.levels.WARNING, t);
  }
  makeError(t, s, h) {
    if (_censorErrors)
      return this.makeError("censored error", s, {});
    s || (s = Logger.errors.UNKNOWN_ERROR), h || (h = {});
    const m = [];
    Object.keys(h).forEach((T) => {
      const z = h[T];
      try {
        if (z instanceof Uint8Array) {
          let J = "";
          for (let Y = 0; Y < z.length; Y++)
            J += HEX[z[Y] >> 4], J += HEX[z[Y] & 15];
          m.push(T + "=Uint8Array(0x" + J + ")");
        } else
          m.push(T + "=" + JSON.stringify(z));
      } catch {
        m.push(T + "=" + JSON.stringify(h[T].toString()));
      }
    }), m.push(`code=${s}`), m.push(`version=${this.version}`);
    const d = t;
    let v = "";
    switch (s) {
      case ErrorCode.NUMERIC_FAULT: {
        v = "NUMERIC_FAULT";
        const T = t;
        switch (T) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            v += "-" + T;
            break;
          case "negative-power":
          case "negative-width":
            v += "-unsupported";
            break;
          case "unbound-bitwise-result":
            v += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        v = s;
        break;
    }
    v && (t += " [ See: https://links.ethers.org/v5-errors-" + v + " ]"), m.length && (t += " (" + m.join(", ") + ")");
    const _ = new Error(t);
    return _.reason = d, _.code = s, Object.keys(h).forEach(function(T) {
      _[T] = h[T];
    }), _;
  }
  throwError(t, s, h) {
    throw this.makeError(t, s, h);
  }
  throwArgumentError(t, s, h) {
    return this.throwError(t, Logger.errors.INVALID_ARGUMENT, {
      argument: s,
      value: h
    });
  }
  assert(t, s, h, m) {
    t || this.throwError(s, h, m);
  }
  assertArgument(t, s, h, m) {
    t || this.throwArgumentError(s, h, m);
  }
  checkNormalize(t) {
    _normalizeError && this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: _normalizeError
    });
  }
  checkSafeUint53(t, s) {
    typeof t == "number" && (s == null && (s = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(s, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: t
    }), t % 1 && this.throwError(s, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: t
    }));
  }
  checkArgumentCount(t, s, h) {
    h ? h = ": " + h : h = "", t < s && this.throwError("missing argument" + h, Logger.errors.MISSING_ARGUMENT, {
      count: t,
      expectedCount: s
    }), t > s && this.throwError("too many arguments" + h, Logger.errors.UNEXPECTED_ARGUMENT, {
      count: t,
      expectedCount: s
    });
  }
  checkNew(t, s) {
    (t === Object || t == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: s.name });
  }
  checkAbstract(t, s) {
    t === s ? this.throwError("cannot instantiate abstract class " + JSON.stringify(s.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: t.name, operation: "new" }) : (t === Object || t == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: s.name });
  }
  static globalLogger() {
    return _globalLogger || (_globalLogger = new Logger(version$r)), _globalLogger;
  }
  static setCensorship(t, s) {
    if (!t && s && this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), _permanentCensorErrors) {
      if (!t)
        return;
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!t, _permanentCensorErrors = !!s;
  }
  static setLogLevel(t) {
    const s = LogLevels[t.toLowerCase()];
    if (s == null) {
      Logger.globalLogger().warn("invalid log level - " + t);
      return;
    }
    _logLevel = s;
  }
  static from(t) {
    return new Logger(t);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
var lib_esm$l = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get ErrorCode() {
    return ErrorCode;
  },
  get LogLevel() {
    return LogLevel;
  },
  Logger
});
const version$q = "bytes/5.7.0", logger$J = new Logger(version$q);
function isHexable(l) {
  return !!l.toHexString;
}
function addSlice(l) {
  return l.slice || (l.slice = function() {
    const t = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(l, t)));
  }), l;
}
function isBytesLike(l) {
  return isHexString$2(l) && !(l.length % 2) || isBytes(l);
}
function isInteger(l) {
  return typeof l == "number" && l == l && l % 1 === 0;
}
function isBytes(l) {
  if (l == null)
    return !1;
  if (l.constructor === Uint8Array)
    return !0;
  if (typeof l == "string" || !isInteger(l.length) || l.length < 0)
    return !1;
  for (let t = 0; t < l.length; t++) {
    const s = l[t];
    if (!isInteger(s) || s < 0 || s >= 256)
      return !1;
  }
  return !0;
}
function arrayify(l, t) {
  if (t || (t = {}), typeof l == "number") {
    logger$J.checkSafeUint53(l, "invalid arrayify value");
    const s = [];
    for (; l; )
      s.unshift(l & 255), l = parseInt(String(l / 256));
    return s.length === 0 && s.push(0), addSlice(new Uint8Array(s));
  }
  if (t.allowMissingPrefix && typeof l == "string" && l.substring(0, 2) !== "0x" && (l = "0x" + l), isHexable(l) && (l = l.toHexString()), isHexString$2(l)) {
    let s = l.substring(2);
    s.length % 2 && (t.hexPad === "left" ? s = "0" + s : t.hexPad === "right" ? s += "0" : logger$J.throwArgumentError("hex data is odd-length", "value", l));
    const h = [];
    for (let m = 0; m < s.length; m += 2)
      h.push(parseInt(s.substring(m, m + 2), 16));
    return addSlice(new Uint8Array(h));
  }
  return isBytes(l) ? addSlice(new Uint8Array(l)) : logger$J.throwArgumentError("invalid arrayify value", "value", l);
}
function concat(l) {
  const t = l.map((m) => arrayify(m)), s = t.reduce((m, d) => m + d.length, 0), h = new Uint8Array(s);
  return t.reduce((m, d) => (h.set(d, m), m + d.length), 0), addSlice(h);
}
function stripZeros(l) {
  let t = arrayify(l);
  if (t.length === 0)
    return t;
  let s = 0;
  for (; s < t.length && t[s] === 0; )
    s++;
  return s && (t = t.slice(s)), t;
}
function zeroPad(l, t) {
  l = arrayify(l), l.length > t && logger$J.throwArgumentError("value out of range", "value", arguments[0]);
  const s = new Uint8Array(t);
  return s.set(l, t - l.length), addSlice(s);
}
function isHexString$2(l, t) {
  return !(typeof l != "string" || !l.match(/^0x[0-9A-Fa-f]*$/) || t && l.length !== 2 + 2 * t);
}
const HexCharacters = "0123456789abcdef";
function hexlify(l, t) {
  if (t || (t = {}), typeof l == "number") {
    logger$J.checkSafeUint53(l, "invalid hexlify value");
    let s = "";
    for (; l; )
      s = HexCharacters[l & 15] + s, l = Math.floor(l / 16);
    return s.length ? (s.length % 2 && (s = "0" + s), "0x" + s) : "0x00";
  }
  if (typeof l == "bigint")
    return l = l.toString(16), l.length % 2 ? "0x0" + l : "0x" + l;
  if (t.allowMissingPrefix && typeof l == "string" && l.substring(0, 2) !== "0x" && (l = "0x" + l), isHexable(l))
    return l.toHexString();
  if (isHexString$2(l))
    return l.length % 2 && (t.hexPad === "left" ? l = "0x0" + l.substring(2) : t.hexPad === "right" ? l += "0" : logger$J.throwArgumentError("hex data is odd-length", "value", l)), l.toLowerCase();
  if (isBytes(l)) {
    let s = "0x";
    for (let h = 0; h < l.length; h++) {
      let m = l[h];
      s += HexCharacters[(m & 240) >> 4] + HexCharacters[m & 15];
    }
    return s;
  }
  return logger$J.throwArgumentError("invalid hexlify value", "value", l);
}
function hexDataLength(l) {
  if (typeof l != "string")
    l = hexlify(l);
  else if (!isHexString$2(l) || l.length % 2)
    return null;
  return (l.length - 2) / 2;
}
function hexDataSlice(l, t, s) {
  return typeof l != "string" ? l = hexlify(l) : (!isHexString$2(l) || l.length % 2) && logger$J.throwArgumentError("invalid hexData", "value", l), t = 2 + 2 * t, s != null ? "0x" + l.substring(t, 2 + 2 * s) : "0x" + l.substring(t);
}
function hexConcat(l) {
  let t = "0x";
  return l.forEach((s) => {
    t += hexlify(s).substring(2);
  }), t;
}
function hexValue(l) {
  const t = hexStripZeros(hexlify(l, { hexPad: "left" }));
  return t === "0x" ? "0x0" : t;
}
function hexStripZeros(l) {
  typeof l != "string" && (l = hexlify(l)), isHexString$2(l) || logger$J.throwArgumentError("invalid hex string", "value", l), l = l.substring(2);
  let t = 0;
  for (; t < l.length && l[t] === "0"; )
    t++;
  return "0x" + l.substring(t);
}
function hexZeroPad(l, t) {
  for (typeof l != "string" ? l = hexlify(l) : isHexString$2(l) || logger$J.throwArgumentError("invalid hex string", "value", l), l.length > 2 * t + 2 && logger$J.throwArgumentError("value out of range", "value", arguments[1]); l.length < 2 * t + 2; )
    l = "0x0" + l.substring(2);
  return l;
}
function splitSignature(l) {
  const t = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(l)) {
    let s = arrayify(l);
    s.length === 64 ? (t.v = 27 + (s[32] >> 7), s[32] &= 127, t.r = hexlify(s.slice(0, 32)), t.s = hexlify(s.slice(32, 64))) : s.length === 65 ? (t.r = hexlify(s.slice(0, 32)), t.s = hexlify(s.slice(32, 64)), t.v = s[64]) : logger$J.throwArgumentError("invalid signature string", "signature", l), t.v < 27 && (t.v === 0 || t.v === 1 ? t.v += 27 : logger$J.throwArgumentError("signature invalid v byte", "signature", l)), t.recoveryParam = 1 - t.v % 2, t.recoveryParam && (s[32] |= 128), t._vs = hexlify(s.slice(32, 64));
  } else {
    if (t.r = l.r, t.s = l.s, t.v = l.v, t.recoveryParam = l.recoveryParam, t._vs = l._vs, t._vs != null) {
      const m = zeroPad(arrayify(t._vs), 32);
      t._vs = hexlify(m);
      const d = m[0] >= 128 ? 1 : 0;
      t.recoveryParam == null ? t.recoveryParam = d : t.recoveryParam !== d && logger$J.throwArgumentError("signature recoveryParam mismatch _vs", "signature", l), m[0] &= 127;
      const v = hexlify(m);
      t.s == null ? t.s = v : t.s !== v && logger$J.throwArgumentError("signature v mismatch _vs", "signature", l);
    }
    if (t.recoveryParam == null)
      t.v == null ? logger$J.throwArgumentError("signature missing v and recoveryParam", "signature", l) : t.v === 0 || t.v === 1 ? t.recoveryParam = t.v : t.recoveryParam = 1 - t.v % 2;
    else if (t.v == null)
      t.v = 27 + t.recoveryParam;
    else {
      const m = t.v === 0 || t.v === 1 ? t.v : 1 - t.v % 2;
      t.recoveryParam !== m && logger$J.throwArgumentError("signature recoveryParam mismatch v", "signature", l);
    }
    t.r == null || !isHexString$2(t.r) ? logger$J.throwArgumentError("signature missing or invalid r", "signature", l) : t.r = hexZeroPad(t.r, 32), t.s == null || !isHexString$2(t.s) ? logger$J.throwArgumentError("signature missing or invalid s", "signature", l) : t.s = hexZeroPad(t.s, 32);
    const s = arrayify(t.s);
    s[0] >= 128 && logger$J.throwArgumentError("signature s out of range", "signature", l), t.recoveryParam && (s[0] |= 128);
    const h = hexlify(s);
    t._vs && (isHexString$2(t._vs) || logger$J.throwArgumentError("signature invalid _vs", "signature", l), t._vs = hexZeroPad(t._vs, 32)), t._vs == null ? t._vs = h : t._vs !== h && logger$J.throwArgumentError("signature _vs mismatch v and s", "signature", l);
  }
  return t.yParityAndS = t._vs, t.compact = t.r + t.yParityAndS.substring(2), t;
}
function joinSignature(l) {
  return l = splitSignature(l), hexlify(concat([
    l.r,
    l.s,
    l.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
var lib_esm$k = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  arrayify,
  concat,
  hexConcat,
  hexDataLength,
  hexDataSlice,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  hexlify,
  isBytes,
  isBytesLike,
  isHexString: isHexString$2,
  joinSignature,
  splitSignature,
  stripZeros,
  zeroPad
});
const version$p = "bignumber/5.7.0";
var BN$3 = _BN.BN;
const logger$I = new Logger(version$p), _constructorGuard$4 = {}, MAX_SAFE = 9007199254740991;
function isBigNumberish(l) {
  return l != null && (BigNumber.isBigNumber(l) || typeof l == "number" && l % 1 === 0 || typeof l == "string" && !!l.match(/^-?[0-9]+$/) || isHexString$2(l) || typeof l == "bigint" || isBytes(l));
}
let _warnedToStringRadix = !1;
class BigNumber {
  constructor(t, s) {
    t !== _constructorGuard$4 && logger$I.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = s, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(t) {
    return toBigNumber(toBN(this).fromTwos(t));
  }
  toTwos(t) {
    return toBigNumber(toBN(this).toTwos(t));
  }
  abs() {
    return this._hex[0] === "-" ? BigNumber.from(this._hex.substring(1)) : this;
  }
  add(t) {
    return toBigNumber(toBN(this).add(toBN(t)));
  }
  sub(t) {
    return toBigNumber(toBN(this).sub(toBN(t)));
  }
  div(t) {
    return BigNumber.from(t).isZero() && throwFault$1("division-by-zero", "div"), toBigNumber(toBN(this).div(toBN(t)));
  }
  mul(t) {
    return toBigNumber(toBN(this).mul(toBN(t)));
  }
  mod(t) {
    const s = toBN(t);
    return s.isNeg() && throwFault$1("division-by-zero", "mod"), toBigNumber(toBN(this).umod(s));
  }
  pow(t) {
    const s = toBN(t);
    return s.isNeg() && throwFault$1("negative-power", "pow"), toBigNumber(toBN(this).pow(s));
  }
  and(t) {
    const s = toBN(t);
    return (this.isNegative() || s.isNeg()) && throwFault$1("unbound-bitwise-result", "and"), toBigNumber(toBN(this).and(s));
  }
  or(t) {
    const s = toBN(t);
    return (this.isNegative() || s.isNeg()) && throwFault$1("unbound-bitwise-result", "or"), toBigNumber(toBN(this).or(s));
  }
  xor(t) {
    const s = toBN(t);
    return (this.isNegative() || s.isNeg()) && throwFault$1("unbound-bitwise-result", "xor"), toBigNumber(toBN(this).xor(s));
  }
  mask(t) {
    return (this.isNegative() || t < 0) && throwFault$1("negative-width", "mask"), toBigNumber(toBN(this).maskn(t));
  }
  shl(t) {
    return (this.isNegative() || t < 0) && throwFault$1("negative-width", "shl"), toBigNumber(toBN(this).shln(t));
  }
  shr(t) {
    return (this.isNegative() || t < 0) && throwFault$1("negative-width", "shr"), toBigNumber(toBN(this).shrn(t));
  }
  eq(t) {
    return toBN(this).eq(toBN(t));
  }
  lt(t) {
    return toBN(this).lt(toBN(t));
  }
  lte(t) {
    return toBN(this).lte(toBN(t));
  }
  gt(t) {
    return toBN(this).gt(toBN(t));
  }
  gte(t) {
    return toBN(this).gte(toBN(t));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return logger$I.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? _warnedToStringRadix || (_warnedToStringRadix = !0, logger$I.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? logger$I.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {}) : logger$I.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {})), toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(t) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(t) {
    if (t instanceof BigNumber)
      return t;
    if (typeof t == "string")
      return t.match(/^-?0x[0-9a-f]+$/i) ? new BigNumber(_constructorGuard$4, toHex$1(t)) : t.match(/^-?[0-9]+$/) ? new BigNumber(_constructorGuard$4, toHex$1(new BN$3(t))) : logger$I.throwArgumentError("invalid BigNumber string", "value", t);
    if (typeof t == "number")
      return t % 1 && throwFault$1("underflow", "BigNumber.from", t), (t >= MAX_SAFE || t <= -MAX_SAFE) && throwFault$1("overflow", "BigNumber.from", t), BigNumber.from(String(t));
    const s = t;
    if (typeof s == "bigint")
      return BigNumber.from(s.toString());
    if (isBytes(s))
      return BigNumber.from(hexlify(s));
    if (s)
      if (s.toHexString) {
        const h = s.toHexString();
        if (typeof h == "string")
          return BigNumber.from(h);
      } else {
        let h = s._hex;
        if (h == null && s.type === "BigNumber" && (h = s.hex), typeof h == "string" && (isHexString$2(h) || h[0] === "-" && isHexString$2(h.substring(1))))
          return BigNumber.from(h);
      }
    return logger$I.throwArgumentError("invalid BigNumber value", "value", t);
  }
  static isBigNumber(t) {
    return !!(t && t._isBigNumber);
  }
}
function toHex$1(l) {
  if (typeof l != "string")
    return toHex$1(l.toString(16));
  if (l[0] === "-")
    return l = l.substring(1), l[0] === "-" && logger$I.throwArgumentError("invalid hex", "value", l), l = toHex$1(l), l === "0x00" ? l : "-" + l;
  if (l.substring(0, 2) !== "0x" && (l = "0x" + l), l === "0x")
    return "0x00";
  for (l.length % 2 && (l = "0x0" + l.substring(2)); l.length > 4 && l.substring(0, 4) === "0x00"; )
    l = "0x" + l.substring(4);
  return l;
}
function toBigNumber(l) {
  return BigNumber.from(toHex$1(l));
}
function toBN(l) {
  const t = BigNumber.from(l).toHexString();
  return t[0] === "-" ? new BN$3("-" + t.substring(3), 16) : new BN$3(t.substring(2), 16);
}
function throwFault$1(l, t, s) {
  const h = { fault: l, operation: t };
  return s != null && (h.value = s), logger$I.throwError(l, Logger.errors.NUMERIC_FAULT, h);
}
function _base36To16(l) {
  return new BN$3(l, 36).toString(16);
}
function _base16To36(l) {
  return new BN$3(l, 16).toString(36);
}
const logger$H = new Logger(version$p), _constructorGuard$3 = {}, Zero$2 = BigNumber.from(0), NegativeOne$2 = BigNumber.from(-1);
function throwFault(l, t, s, h) {
  const m = { fault: t, operation: s };
  return h !== void 0 && (m.value = h), logger$H.throwError(l, Logger.errors.NUMERIC_FAULT, m);
}
let zeros = "0";
for (; zeros.length < 256; )
  zeros += zeros;
function getMultiplier(l) {
  if (typeof l != "number")
    try {
      l = BigNumber.from(l).toNumber();
    } catch {
    }
  return typeof l == "number" && l >= 0 && l <= 256 && !(l % 1) ? "1" + zeros.substring(0, l) : logger$H.throwArgumentError("invalid decimal size", "decimals", l);
}
function formatFixed(l, t) {
  t == null && (t = 0);
  const s = getMultiplier(t);
  l = BigNumber.from(l);
  const h = l.lt(Zero$2);
  h && (l = l.mul(NegativeOne$2));
  let m = l.mod(s).toString();
  for (; m.length < s.length - 1; )
    m = "0" + m;
  m = m.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const d = l.div(s).toString();
  return s.length === 1 ? l = d : l = d + "." + m, h && (l = "-" + l), l;
}
function parseFixed(l, t) {
  t == null && (t = 0);
  const s = getMultiplier(t);
  (typeof l != "string" || !l.match(/^-?[0-9.]+$/)) && logger$H.throwArgumentError("invalid decimal value", "value", l);
  const h = l.substring(0, 1) === "-";
  h && (l = l.substring(1)), l === "." && logger$H.throwArgumentError("missing value", "value", l);
  const m = l.split(".");
  m.length > 2 && logger$H.throwArgumentError("too many decimal points", "value", l);
  let d = m[0], v = m[1];
  for (d || (d = "0"), v || (v = "0"); v[v.length - 1] === "0"; )
    v = v.substring(0, v.length - 1);
  for (v.length > s.length - 1 && throwFault("fractional component exceeds decimals", "underflow", "parseFixed"), v === "" && (v = "0"); v.length < s.length - 1; )
    v += "0";
  const _ = BigNumber.from(d), T = BigNumber.from(v);
  let z = _.mul(s).add(T);
  return h && (z = z.mul(NegativeOne$2)), z;
}
class FixedFormat {
  constructor(t, s, h, m) {
    t !== _constructorGuard$3 && logger$H.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.signed = s, this.width = h, this.decimals = m, this.name = (s ? "" : "u") + "fixed" + String(h) + "x" + String(m), this._multiplier = getMultiplier(m), Object.freeze(this);
  }
  static from(t) {
    if (t instanceof FixedFormat)
      return t;
    typeof t == "number" && (t = `fixed128x${t}`);
    let s = !0, h = 128, m = 18;
    if (typeof t == "string") {
      if (t !== "fixed")
        if (t === "ufixed")
          s = !1;
        else {
          const d = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          d || logger$H.throwArgumentError("invalid fixed format", "format", t), s = d[1] !== "u", h = parseInt(d[2]), m = parseInt(d[3]);
        }
    } else if (t) {
      const d = (v, _, T) => t[v] == null ? T : (typeof t[v] !== _ && logger$H.throwArgumentError("invalid fixed format (" + v + " not " + _ + ")", "format." + v, t[v]), t[v]);
      s = d("signed", "boolean", s), h = d("width", "number", h), m = d("decimals", "number", m);
    }
    return h % 8 && logger$H.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", h), m > 80 && logger$H.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", m), new FixedFormat(_constructorGuard$3, s, h, m);
  }
}
class FixedNumber {
  constructor(t, s, h, m) {
    t !== _constructorGuard$3 && logger$H.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.format = m, this._hex = s, this._value = h, this._isFixedNumber = !0, Object.freeze(this);
  }
  _checkFormat(t) {
    this.format.name !== t.format.name && logger$H.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", t);
  }
  addUnsafe(t) {
    this._checkFormat(t);
    const s = parseFixed(this._value, this.format.decimals), h = parseFixed(t._value, t.format.decimals);
    return FixedNumber.fromValue(s.add(h), this.format.decimals, this.format);
  }
  subUnsafe(t) {
    this._checkFormat(t);
    const s = parseFixed(this._value, this.format.decimals), h = parseFixed(t._value, t.format.decimals);
    return FixedNumber.fromValue(s.sub(h), this.format.decimals, this.format);
  }
  mulUnsafe(t) {
    this._checkFormat(t);
    const s = parseFixed(this._value, this.format.decimals), h = parseFixed(t._value, t.format.decimals);
    return FixedNumber.fromValue(s.mul(h).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(t) {
    this._checkFormat(t);
    const s = parseFixed(this._value, this.format.decimals), h = parseFixed(t._value, t.format.decimals);
    return FixedNumber.fromValue(s.mul(this.format._multiplier).div(h), this.format.decimals, this.format);
  }
  floor() {
    const t = this.toString().split(".");
    t.length === 1 && t.push("0");
    let s = FixedNumber.from(t[0], this.format);
    const h = !t[1].match(/^(0*)$/);
    return this.isNegative() && h && (s = s.subUnsafe(ONE.toFormat(s.format))), s;
  }
  ceiling() {
    const t = this.toString().split(".");
    t.length === 1 && t.push("0");
    let s = FixedNumber.from(t[0], this.format);
    const h = !t[1].match(/^(0*)$/);
    return !this.isNegative() && h && (s = s.addUnsafe(ONE.toFormat(s.format))), s;
  }
  round(t) {
    t == null && (t = 0);
    const s = this.toString().split(".");
    if (s.length === 1 && s.push("0"), (t < 0 || t > 80 || t % 1) && logger$H.throwArgumentError("invalid decimal count", "decimals", t), s[1].length <= t)
      return this;
    const h = FixedNumber.from("1" + zeros.substring(0, t), this.format), m = BUMP.toFormat(this.format);
    return this.mulUnsafe(h).addUnsafe(m).floor().divUnsafe(h);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(t) {
    if (t == null)
      return this._hex;
    t % 8 && logger$H.throwArgumentError("invalid byte width", "width", t);
    const s = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(t).toHexString();
    return hexZeroPad(s, t / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(t) {
    return FixedNumber.fromString(this._value, t);
  }
  static fromValue(t, s, h) {
    return h == null && s != null && !isBigNumberish(s) && (h = s, s = null), s == null && (s = 0), h == null && (h = "fixed"), FixedNumber.fromString(formatFixed(t, s), FixedFormat.from(h));
  }
  static fromString(t, s) {
    s == null && (s = "fixed");
    const h = FixedFormat.from(s), m = parseFixed(t, h.decimals);
    !h.signed && m.lt(Zero$2) && throwFault("unsigned value cannot be negative", "overflow", "value", t);
    let d = null;
    h.signed ? d = m.toTwos(h.width).toHexString() : (d = m.toHexString(), d = hexZeroPad(d, h.width / 8));
    const v = formatFixed(m, h.decimals);
    return new FixedNumber(_constructorGuard$3, d, v, h);
  }
  static fromBytes(t, s) {
    s == null && (s = "fixed");
    const h = FixedFormat.from(s);
    if (arrayify(t).length > h.width / 8)
      throw new Error("overflow");
    let m = BigNumber.from(t);
    h.signed && (m = m.fromTwos(h.width));
    const d = m.toTwos((h.signed ? 0 : 1) + h.width).toHexString(), v = formatFixed(m, h.decimals);
    return new FixedNumber(_constructorGuard$3, d, v, h);
  }
  static from(t, s) {
    if (typeof t == "string")
      return FixedNumber.fromString(t, s);
    if (isBytes(t))
      return FixedNumber.fromBytes(t, s);
    try {
      return FixedNumber.fromValue(t, 0, s);
    } catch (h) {
      if (h.code !== Logger.errors.INVALID_ARGUMENT)
        throw h;
    }
    return logger$H.throwArgumentError("invalid FixedNumber value", "value", t);
  }
  static isFixedNumber(t) {
    return !!(t && t._isFixedNumber);
  }
}
const ONE = FixedNumber.from(1), BUMP = FixedNumber.from("0.5"), version$o = "properties/5.7.0";
var __awaiter$m = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$G = new Logger(version$o);
function defineReadOnly(l, t, s) {
  Object.defineProperty(l, t, {
    enumerable: !0,
    value: s,
    writable: !1
  });
}
function getStatic(l, t) {
  for (let s = 0; s < 32; s++) {
    if (l[t])
      return l[t];
    if (!l.prototype || typeof l.prototype != "object")
      break;
    l = Object.getPrototypeOf(l.prototype).constructor;
  }
  return null;
}
function resolveProperties(l) {
  return __awaiter$m(this, void 0, void 0, function* () {
    const t = Object.keys(l).map((h) => {
      const m = l[h];
      return Promise.resolve(m).then((d) => ({ key: h, value: d }));
    });
    return (yield Promise.all(t)).reduce((h, m) => (h[m.key] = m.value, h), {});
  });
}
function checkProperties(l, t) {
  (!l || typeof l != "object") && logger$G.throwArgumentError("invalid object", "object", l), Object.keys(l).forEach((s) => {
    t[s] || logger$G.throwArgumentError("invalid object key - " + s, "transaction:" + s, l);
  });
}
function shallowCopy(l) {
  const t = {};
  for (const s in l)
    t[s] = l[s];
  return t;
}
const opaque = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function _isFrozen(l) {
  if (l == null || opaque[typeof l])
    return !0;
  if (Array.isArray(l) || typeof l == "object") {
    if (!Object.isFrozen(l))
      return !1;
    const t = Object.keys(l);
    for (let s = 0; s < t.length; s++) {
      let h = null;
      try {
        h = l[t[s]];
      } catch {
        continue;
      }
      if (!_isFrozen(h))
        return !1;
    }
    return !0;
  }
  return logger$G.throwArgumentError(`Cannot deepCopy ${typeof l}`, "object", l);
}
function _deepCopy(l) {
  if (_isFrozen(l))
    return l;
  if (Array.isArray(l))
    return Object.freeze(l.map((t) => deepCopy(t)));
  if (typeof l == "object") {
    const t = {};
    for (const s in l) {
      const h = l[s];
      h !== void 0 && defineReadOnly(t, s, deepCopy(h));
    }
    return t;
  }
  return logger$G.throwArgumentError(`Cannot deepCopy ${typeof l}`, "object", l);
}
function deepCopy(l) {
  return _deepCopy(l);
}
class Description {
  constructor(t) {
    for (const s in t)
      this[s] = deepCopy(t[s]);
  }
}
var lib_esm$j = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Description,
  checkProperties,
  deepCopy,
  defineReadOnly,
  getStatic,
  resolveProperties,
  shallowCopy
});
const version$n = "abi/5.7.0", logger$F = new Logger(version$n), _constructorGuard$2 = {};
let ModifiersBytes = { calldata: !0, memory: !0, storage: !0 }, ModifiersNest = { calldata: !0, memory: !0 };
function checkModifier(l, t) {
  if (l === "bytes" || l === "string") {
    if (ModifiersBytes[t])
      return !0;
  } else if (l === "address") {
    if (t === "payable")
      return !0;
  } else if ((l.indexOf("[") >= 0 || l === "tuple") && ModifiersNest[t])
    return !0;
  return (ModifiersBytes[t] || t === "payable") && logger$F.throwArgumentError("invalid modifier", "name", t), !1;
}
function parseParamType(l, t) {
  let s = l;
  function h(_) {
    logger$F.throwArgumentError(`unexpected character at position ${_}`, "param", l);
  }
  l = l.replace(/\s/g, " ");
  function m(_) {
    let T = { type: "", name: "", parent: _, state: { allowType: !0 } };
    return t && (T.indexed = !1), T;
  }
  let d = { type: "", name: "", state: { allowType: !0 } }, v = d;
  for (let _ = 0; _ < l.length; _++) {
    let T = l[_];
    switch (T) {
      case "(":
        v.state.allowType && v.type === "" ? v.type = "tuple" : v.state.allowParams || h(_), v.state.allowType = !1, v.type = verifyType(v.type), v.components = [m(v)], v = v.components[0];
        break;
      case ")":
        delete v.state, v.name === "indexed" && (t || h(_), v.indexed = !0, v.name = ""), checkModifier(v.type, v.name) && (v.name = ""), v.type = verifyType(v.type);
        let z = v;
        v = v.parent, v || h(_), delete z.parent, v.state.allowParams = !1, v.state.allowName = !0, v.state.allowArray = !0;
        break;
      case ",":
        delete v.state, v.name === "indexed" && (t || h(_), v.indexed = !0, v.name = ""), checkModifier(v.type, v.name) && (v.name = ""), v.type = verifyType(v.type);
        let J = m(v.parent);
        v.parent.components.push(J), delete v.parent, v = J;
        break;
      case " ":
        v.state.allowType && v.type !== "" && (v.type = verifyType(v.type), delete v.state.allowType, v.state.allowName = !0, v.state.allowParams = !0), v.state.allowName && v.name !== "" && (v.name === "indexed" ? (t || h(_), v.indexed && h(_), v.indexed = !0, v.name = "") : checkModifier(v.type, v.name) ? v.name = "" : v.state.allowName = !1);
        break;
      case "[":
        v.state.allowArray || h(_), v.type += T, v.state.allowArray = !1, v.state.allowName = !1, v.state.readArray = !0;
        break;
      case "]":
        v.state.readArray || h(_), v.type += T, v.state.readArray = !1, v.state.allowArray = !0, v.state.allowName = !0;
        break;
      default:
        v.state.allowType ? (v.type += T, v.state.allowParams = !0, v.state.allowArray = !0) : v.state.allowName ? (v.name += T, delete v.state.allowArray) : v.state.readArray ? v.type += T : h(_);
    }
  }
  return v.parent && logger$F.throwArgumentError("unexpected eof", "param", l), delete d.state, v.name === "indexed" ? (t || h(s.length - 7), v.indexed && h(s.length - 7), v.indexed = !0, v.name = "") : checkModifier(v.type, v.name) && (v.name = ""), d.type = verifyType(d.type), d;
}
function populate(l, t) {
  for (let s in t)
    defineReadOnly(l, s, t[s]);
}
const FormatTypes = Object.freeze({
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
}), paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(t, s) {
    t !== _constructorGuard$2 && logger$F.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new ParamType()"
    }), populate(this, s);
    let h = this.type.match(paramTypeArray);
    h ? populate(this, {
      arrayLength: parseInt(h[2] || "-1"),
      arrayChildren: ParamType.fromObject({
        type: h[1],
        components: this.components
      }),
      baseType: "array"
    }) : populate(this, {
      arrayLength: null,
      arrayChildren: null,
      baseType: this.components != null ? "tuple" : this.type
    }), this._isParamType = !0, Object.freeze(this);
  }
  format(t) {
    if (t || (t = FormatTypes.sighash), FormatTypes[t] || logger$F.throwArgumentError("invalid format type", "format", t), t === FormatTypes.json) {
      let h = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      return typeof this.indexed == "boolean" && (h.indexed = this.indexed), this.components && (h.components = this.components.map((m) => JSON.parse(m.format(t)))), JSON.stringify(h);
    }
    let s = "";
    return this.baseType === "array" ? (s += this.arrayChildren.format(t), s += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (t !== FormatTypes.sighash && (s += this.type), s += "(" + this.components.map((h) => h.format(t)).join(t === FormatTypes.full ? ", " : ",") + ")") : s += this.type, t !== FormatTypes.sighash && (this.indexed === !0 && (s += " indexed"), t === FormatTypes.full && this.name && (s += " " + this.name)), s;
  }
  static from(t, s) {
    return typeof t == "string" ? ParamType.fromString(t, s) : ParamType.fromObject(t);
  }
  static fromObject(t) {
    return ParamType.isParamType(t) ? t : new ParamType(_constructorGuard$2, {
      name: t.name || null,
      type: verifyType(t.type),
      indexed: t.indexed == null ? null : !!t.indexed,
      components: t.components ? t.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(t, s) {
    function h(m) {
      return ParamType.fromObject({
        name: m.name,
        type: m.type,
        indexed: m.indexed,
        components: m.components
      });
    }
    return h(parseParamType(t, !!s));
  }
  static isParamType(t) {
    return !!(t != null && t._isParamType);
  }
}
function parseParams(l, t) {
  return splitNesting(l).map((s) => ParamType.fromString(s, t));
}
class Fragment {
  constructor(t, s) {
    t !== _constructorGuard$2 && logger$F.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new Fragment()"
    }), populate(this, s), this._isFragment = !0, Object.freeze(this);
  }
  static from(t) {
    return Fragment.isFragment(t) ? t : typeof t == "string" ? Fragment.fromString(t) : Fragment.fromObject(t);
  }
  static fromObject(t) {
    if (Fragment.isFragment(t))
      return t;
    switch (t.type) {
      case "function":
        return FunctionFragment.fromObject(t);
      case "event":
        return EventFragment.fromObject(t);
      case "constructor":
        return ConstructorFragment.fromObject(t);
      case "error":
        return ErrorFragment.fromObject(t);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$F.throwArgumentError("invalid fragment object", "value", t);
  }
  static fromString(t) {
    return t = t.replace(/\s/g, " "), t = t.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), t = t.trim(), t.split(" ")[0] === "event" ? EventFragment.fromString(t.substring(5).trim()) : t.split(" ")[0] === "function" ? FunctionFragment.fromString(t.substring(8).trim()) : t.split("(")[0].trim() === "constructor" ? ConstructorFragment.fromString(t.trim()) : t.split(" ")[0] === "error" ? ErrorFragment.fromString(t.substring(5).trim()) : logger$F.throwArgumentError("unsupported fragment", "value", t);
  }
  static isFragment(t) {
    return !!(t && t._isFragment);
  }
}
class EventFragment extends Fragment {
  format(t) {
    if (t || (t = FormatTypes.sighash), FormatTypes[t] || logger$F.throwArgumentError("invalid format type", "format", t), t === FormatTypes.json)
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((h) => JSON.parse(h.format(t)))
      });
    let s = "";
    return t !== FormatTypes.sighash && (s += "event "), s += this.name + "(" + this.inputs.map((h) => h.format(t)).join(t === FormatTypes.full ? ", " : ",") + ") ", t !== FormatTypes.sighash && this.anonymous && (s += "anonymous "), s.trim();
  }
  static from(t) {
    return typeof t == "string" ? EventFragment.fromString(t) : EventFragment.fromObject(t);
  }
  static fromObject(t) {
    if (EventFragment.isEventFragment(t))
      return t;
    t.type !== "event" && logger$F.throwArgumentError("invalid event object", "value", t);
    const s = {
      name: verifyIdentifier(t.name),
      anonymous: t.anonymous,
      inputs: t.inputs ? t.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$2, s);
  }
  static fromString(t) {
    let s = t.match(regexParen);
    s || logger$F.throwArgumentError("invalid event string", "value", t);
    let h = !1;
    return s[3].split(" ").forEach((m) => {
      switch (m.trim()) {
        case "anonymous":
          h = !0;
          break;
        case "":
          break;
        default:
          logger$F.warn("unknown modifier: " + m);
      }
    }), EventFragment.fromObject({
      name: s[1].trim(),
      anonymous: h,
      inputs: parseParams(s[2], !0),
      type: "event"
    });
  }
  static isEventFragment(t) {
    return t && t._isFragment && t.type === "event";
  }
}
function parseGas(l, t) {
  t.gas = null;
  let s = l.split("@");
  return s.length !== 1 ? (s.length > 2 && logger$F.throwArgumentError("invalid human-readable ABI signature", "value", l), s[1].match(/^[0-9]+$/) || logger$F.throwArgumentError("invalid human-readable ABI signature gas", "value", l), t.gas = BigNumber.from(s[1]), s[0]) : l;
}
function parseModifiers(l, t) {
  t.constant = !1, t.payable = !1, t.stateMutability = "nonpayable", l.split(" ").forEach((s) => {
    switch (s.trim()) {
      case "constant":
        t.constant = !0;
        break;
      case "payable":
        t.payable = !0, t.stateMutability = "payable";
        break;
      case "nonpayable":
        t.payable = !1, t.stateMutability = "nonpayable";
        break;
      case "pure":
        t.constant = !0, t.stateMutability = "pure";
        break;
      case "view":
        t.constant = !0, t.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + s);
    }
  });
}
function verifyState(l) {
  let t = {
    constant: !1,
    payable: !0,
    stateMutability: "payable"
  };
  return l.stateMutability != null ? (t.stateMutability = l.stateMutability, t.constant = t.stateMutability === "view" || t.stateMutability === "pure", l.constant != null && !!l.constant !== t.constant && logger$F.throwArgumentError("cannot have constant function with mutability " + t.stateMutability, "value", l), t.payable = t.stateMutability === "payable", l.payable != null && !!l.payable !== t.payable && logger$F.throwArgumentError("cannot have payable function with mutability " + t.stateMutability, "value", l)) : l.payable != null ? (t.payable = !!l.payable, l.constant == null && !t.payable && l.type !== "constructor" && logger$F.throwArgumentError("unable to determine stateMutability", "value", l), t.constant = !!l.constant, t.constant ? t.stateMutability = "view" : t.stateMutability = t.payable ? "payable" : "nonpayable", t.payable && t.constant && logger$F.throwArgumentError("cannot have constant payable function", "value", l)) : l.constant != null ? (t.constant = !!l.constant, t.payable = !t.constant, t.stateMutability = t.constant ? "view" : "payable") : l.type !== "constructor" && logger$F.throwArgumentError("unable to determine stateMutability", "value", l), t;
}
class ConstructorFragment extends Fragment {
  format(t) {
    if (t || (t = FormatTypes.sighash), FormatTypes[t] || logger$F.throwArgumentError("invalid format type", "format", t), t === FormatTypes.json)
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((h) => JSON.parse(h.format(t)))
      });
    t === FormatTypes.sighash && logger$F.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "format(sighash)"
    });
    let s = "constructor(" + this.inputs.map((h) => h.format(t)).join(t === FormatTypes.full ? ", " : ",") + ") ";
    return this.stateMutability && this.stateMutability !== "nonpayable" && (s += this.stateMutability + " "), s.trim();
  }
  static from(t) {
    return typeof t == "string" ? ConstructorFragment.fromString(t) : ConstructorFragment.fromObject(t);
  }
  static fromObject(t) {
    if (ConstructorFragment.isConstructorFragment(t))
      return t;
    t.type !== "constructor" && logger$F.throwArgumentError("invalid constructor object", "value", t);
    let s = verifyState(t);
    s.constant && logger$F.throwArgumentError("constructor cannot be constant", "value", t);
    const h = {
      name: null,
      type: t.type,
      inputs: t.inputs ? t.inputs.map(ParamType.fromObject) : [],
      payable: s.payable,
      stateMutability: s.stateMutability,
      gas: t.gas ? BigNumber.from(t.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$2, h);
  }
  static fromString(t) {
    let s = { type: "constructor" };
    t = parseGas(t, s);
    let h = t.match(regexParen);
    return (!h || h[1].trim() !== "constructor") && logger$F.throwArgumentError("invalid constructor string", "value", t), s.inputs = parseParams(h[2].trim(), !1), parseModifiers(h[3].trim(), s), ConstructorFragment.fromObject(s);
  }
  static isConstructorFragment(t) {
    return t && t._isFragment && t.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(t) {
    if (t || (t = FormatTypes.sighash), FormatTypes[t] || logger$F.throwArgumentError("invalid format type", "format", t), t === FormatTypes.json)
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((h) => JSON.parse(h.format(t))),
        outputs: this.outputs.map((h) => JSON.parse(h.format(t)))
      });
    let s = "";
    return t !== FormatTypes.sighash && (s += "function "), s += this.name + "(" + this.inputs.map((h) => h.format(t)).join(t === FormatTypes.full ? ", " : ",") + ") ", t !== FormatTypes.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (s += this.stateMutability + " ") : this.constant && (s += "view "), this.outputs && this.outputs.length && (s += "returns (" + this.outputs.map((h) => h.format(t)).join(", ") + ") "), this.gas != null && (s += "@" + this.gas.toString() + " ")), s.trim();
  }
  static from(t) {
    return typeof t == "string" ? FunctionFragment.fromString(t) : FunctionFragment.fromObject(t);
  }
  static fromObject(t) {
    if (FunctionFragment.isFunctionFragment(t))
      return t;
    t.type !== "function" && logger$F.throwArgumentError("invalid function object", "value", t);
    let s = verifyState(t);
    const h = {
      type: t.type,
      name: verifyIdentifier(t.name),
      constant: s.constant,
      inputs: t.inputs ? t.inputs.map(ParamType.fromObject) : [],
      outputs: t.outputs ? t.outputs.map(ParamType.fromObject) : [],
      payable: s.payable,
      stateMutability: s.stateMutability,
      gas: t.gas ? BigNumber.from(t.gas) : null
    };
    return new FunctionFragment(_constructorGuard$2, h);
  }
  static fromString(t) {
    let s = { type: "function" };
    t = parseGas(t, s);
    let h = t.split(" returns ");
    h.length > 2 && logger$F.throwArgumentError("invalid function string", "value", t);
    let m = h[0].match(regexParen);
    if (m || logger$F.throwArgumentError("invalid function signature", "value", t), s.name = m[1].trim(), s.name && verifyIdentifier(s.name), s.inputs = parseParams(m[2], !1), parseModifiers(m[3].trim(), s), h.length > 1) {
      let d = h[1].match(regexParen);
      (d[1].trim() != "" || d[3].trim() != "") && logger$F.throwArgumentError("unexpected tokens", "value", t), s.outputs = parseParams(d[2], !1);
    } else
      s.outputs = [];
    return FunctionFragment.fromObject(s);
  }
  static isFunctionFragment(t) {
    return t && t._isFragment && t.type === "function";
  }
}
function checkForbidden(l) {
  const t = l.format();
  return (t === "Error(string)" || t === "Panic(uint256)") && logger$F.throwArgumentError(`cannot specify user defined ${t} error`, "fragment", l), l;
}
class ErrorFragment extends Fragment {
  format(t) {
    if (t || (t = FormatTypes.sighash), FormatTypes[t] || logger$F.throwArgumentError("invalid format type", "format", t), t === FormatTypes.json)
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((h) => JSON.parse(h.format(t)))
      });
    let s = "";
    return t !== FormatTypes.sighash && (s += "error "), s += this.name + "(" + this.inputs.map((h) => h.format(t)).join(t === FormatTypes.full ? ", " : ",") + ") ", s.trim();
  }
  static from(t) {
    return typeof t == "string" ? ErrorFragment.fromString(t) : ErrorFragment.fromObject(t);
  }
  static fromObject(t) {
    if (ErrorFragment.isErrorFragment(t))
      return t;
    t.type !== "error" && logger$F.throwArgumentError("invalid error object", "value", t);
    const s = {
      type: t.type,
      name: verifyIdentifier(t.name),
      inputs: t.inputs ? t.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$2, s));
  }
  static fromString(t) {
    let s = { type: "error" }, h = t.match(regexParen);
    return h || logger$F.throwArgumentError("invalid error signature", "value", t), s.name = h[1].trim(), s.name && verifyIdentifier(s.name), s.inputs = parseParams(h[2], !1), checkForbidden(ErrorFragment.fromObject(s));
  }
  static isErrorFragment(t) {
    return t && t._isFragment && t.type === "error";
  }
}
function verifyType(l) {
  return l.match(/^uint($|[^1-9])/) ? l = "uint256" + l.substring(4) : l.match(/^int($|[^1-9])/) && (l = "int256" + l.substring(3)), l;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(l) {
  return (!l || !l.match(regexIdentifier)) && logger$F.throwArgumentError(`invalid identifier "${l}"`, "value", l), l;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(l) {
  l = l.trim();
  let t = [], s = "", h = 0;
  for (let m = 0; m < l.length; m++) {
    let d = l[m];
    d === "," && h === 0 ? (t.push(s), s = "") : (s += d, d === "(" ? h++ : d === ")" && (h--, h === -1 && logger$F.throwArgumentError("unbalanced parenthesis", "value", l)));
  }
  return s && t.push(s), t;
}
const logger$E = new Logger(version$n);
function checkResultErrors(l) {
  const t = [], s = function(h, m) {
    if (!!Array.isArray(m))
      for (let d in m) {
        const v = h.slice();
        v.push(d);
        try {
          s(v, m[d]);
        } catch (_) {
          t.push({ path: v, error: _ });
        }
      }
  };
  return s([], l), t;
}
class Coder {
  constructor(t, s, h, m) {
    this.name = t, this.type = s, this.localName = h, this.dynamic = m;
  }
  _throwError(t, s) {
    logger$E.throwArgumentError(t, this.localName, s);
  }
}
class Writer {
  constructor(t) {
    defineReadOnly(this, "wordSize", t || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(t);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(t) {
    return this._data.push(t), this._dataLength += t.length, t.length;
  }
  appendWriter(t) {
    return this._writeData(concat(t._data));
  }
  writeBytes(t) {
    let s = arrayify(t);
    const h = s.length % this.wordSize;
    return h && (s = concat([s, this._padding.slice(h)])), this._writeData(s);
  }
  _getValue(t) {
    let s = arrayify(BigNumber.from(t));
    return s.length > this.wordSize && logger$E.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
      length: this.wordSize,
      offset: s.length
    }), s.length % this.wordSize && (s = concat([this._padding.slice(s.length % this.wordSize), s])), s;
  }
  writeValue(t) {
    return this._writeData(this._getValue(t));
  }
  writeUpdatableValue() {
    const t = this._data.length;
    return this._data.push(this._padding), this._dataLength += this.wordSize, (s) => {
      this._data[t] = this._getValue(s);
    };
  }
}
class Reader {
  constructor(t, s, h, m) {
    defineReadOnly(this, "_data", arrayify(t)), defineReadOnly(this, "wordSize", s || 32), defineReadOnly(this, "_coerceFunc", h), defineReadOnly(this, "allowLoose", m), this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(t, s) {
    let h = t.match("^u?int([0-9]+)$");
    return h && parseInt(h[1]) <= 48 && (s = s.toNumber()), s;
  }
  coerce(t, s) {
    return this._coerceFunc ? this._coerceFunc(t, s) : Reader.coerce(t, s);
  }
  _peekBytes(t, s, h) {
    let m = Math.ceil(s / this.wordSize) * this.wordSize;
    return this._offset + m > this._data.length && (this.allowLoose && h && this._offset + s <= this._data.length ? m = s : logger$E.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
      length: this._data.length,
      offset: this._offset + m
    })), this._data.slice(this._offset, this._offset + m);
  }
  subReader(t) {
    return new Reader(this._data.slice(this._offset + t), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(t, s) {
    let h = this._peekBytes(0, t, !!s);
    return this._offset += h.length, h.slice(0, t);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}
var sha3$1 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(l) {
  (function() {
    var t = "input is invalid type", s = "finalize already called", h = typeof window == "object", m = h ? window : {};
    m.JS_SHA3_NO_WINDOW && (h = !1);
    var d = !h && typeof self == "object", v = !m.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    v ? m = commonjsGlobal : d && (m = self);
    var _ = !m.JS_SHA3_NO_COMMON_JS && !0 && l.exports, T = !m.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", z = "0123456789abcdef".split(""), J = [31, 7936, 2031616, 520093696], Y = [4, 1024, 262144, 67108864], ie = [1, 256, 65536, 16777216], ne = [6, 1536, 393216, 100663296], de = [0, 8, 16, 24], ce = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], re = [224, 256, 384, 512], oe = [128, 256], pe = ["hex", "buffer", "arrayBuffer", "array", "digest"], ae = {
      128: 168,
      256: 136
    };
    (m.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(ee) {
      return Object.prototype.toString.call(ee) === "[object Array]";
    }), T && (m.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(ee) {
      return typeof ee == "object" && ee.buffer && ee.buffer.constructor === ArrayBuffer;
    });
    for (var me = function(ee, xe, $e) {
      return function(ke) {
        return new y(ee, xe, ee).update(ke)[$e]();
      };
    }, ge = function(ee, xe, $e) {
      return function(ke, Ce) {
        return new y(ee, xe, Ce).update(ke)[$e]();
      };
    }, we = function(ee, xe, $e) {
      return function(ke, Ce, ht, Ue) {
        return p["cshake" + ee].update(ke, Ce, ht, Ue)[$e]();
      };
    }, Ee = function(ee, xe, $e) {
      return function(ke, Ce, ht, Ue) {
        return p["kmac" + ee].update(ke, Ce, ht, Ue)[$e]();
      };
    }, Te = function(ee, xe, $e, ke) {
      for (var Ce = 0; Ce < pe.length; ++Ce) {
        var ht = pe[Ce];
        ee[ht] = xe($e, ke, ht);
      }
      return ee;
    }, Ke = function(ee, xe) {
      var $e = me(ee, xe, "hex");
      return $e.create = function() {
        return new y(ee, xe, ee);
      }, $e.update = function(ke) {
        return $e.create().update(ke);
      }, Te($e, me, ee, xe);
    }, Se = function(ee, xe) {
      var $e = ge(ee, xe, "hex");
      return $e.create = function(ke) {
        return new y(ee, xe, ke);
      }, $e.update = function(ke, Ce) {
        return $e.create(Ce).update(ke);
      }, Te($e, ge, ee, xe);
    }, X = function(ee, xe) {
      var $e = ae[ee], ke = we(ee, xe, "hex");
      return ke.create = function(Ce, ht, Ue) {
        return !ht && !Ue ? p["shake" + ee].create(Ce) : new y(ee, xe, Ce).bytepad([ht, Ue], $e);
      }, ke.update = function(Ce, ht, Ue, De) {
        return ke.create(ht, Ue, De).update(Ce);
      }, Te(ke, we, ee, xe);
    }, fe = function(ee, xe) {
      var $e = ae[ee], ke = Ee(ee, xe, "hex");
      return ke.create = function(Ce, ht, Ue) {
        return new j(ee, xe, ht).bytepad(["KMAC", Ue], $e).bytepad([Ce], $e);
      }, ke.update = function(Ce, ht, Ue, De) {
        return ke.create(Ce, Ue, De).update(ht);
      }, Te(ke, Ee, ee, xe);
    }, k = [
      { name: "keccak", padding: ie, bits: re, createMethod: Ke },
      { name: "sha3", padding: ne, bits: re, createMethod: Ke },
      { name: "shake", padding: J, bits: oe, createMethod: Se },
      { name: "cshake", padding: Y, bits: oe, createMethod: X },
      { name: "kmac", padding: Y, bits: oe, createMethod: fe }
    ], p = {}, x = [], S = 0; S < k.length; ++S)
      for (var B = k[S], L = B.bits, C = 0; C < L.length; ++C) {
        var G = B.name + "_" + L[C];
        if (x.push(G), p[G] = B.createMethod(L[C], B.padding), B.name !== "sha3") {
          var R = B.name + L[C];
          x.push(R), p[R] = p[G];
        }
      }
    function y(ee, xe, $e) {
      this.blocks = [], this.s = [], this.padding = xe, this.outputBits = $e, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (ee << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = $e >> 5, this.extraBytes = ($e & 31) >> 3;
      for (var ke = 0; ke < 50; ++ke)
        this.s[ke] = 0;
    }
    y.prototype.update = function(ee) {
      if (this.finalized)
        throw new Error(s);
      var xe, $e = typeof ee;
      if ($e !== "string") {
        if ($e === "object") {
          if (ee === null)
            throw new Error(t);
          if (T && ee.constructor === ArrayBuffer)
            ee = new Uint8Array(ee);
          else if (!Array.isArray(ee) && (!T || !ArrayBuffer.isView(ee)))
            throw new Error(t);
        } else
          throw new Error(t);
        xe = !0;
      }
      for (var ke = this.blocks, Ce = this.byteCount, ht = ee.length, Ue = this.blockCount, De = 0, wt = this.s, He, Ze; De < ht; ) {
        if (this.reset)
          for (this.reset = !1, ke[0] = this.block, He = 1; He < Ue + 1; ++He)
            ke[He] = 0;
        if (xe)
          for (He = this.start; De < ht && He < Ce; ++De)
            ke[He >> 2] |= ee[De] << de[He++ & 3];
        else
          for (He = this.start; De < ht && He < Ce; ++De)
            Ze = ee.charCodeAt(De), Ze < 128 ? ke[He >> 2] |= Ze << de[He++ & 3] : Ze < 2048 ? (ke[He >> 2] |= (192 | Ze >> 6) << de[He++ & 3], ke[He >> 2] |= (128 | Ze & 63) << de[He++ & 3]) : Ze < 55296 || Ze >= 57344 ? (ke[He >> 2] |= (224 | Ze >> 12) << de[He++ & 3], ke[He >> 2] |= (128 | Ze >> 6 & 63) << de[He++ & 3], ke[He >> 2] |= (128 | Ze & 63) << de[He++ & 3]) : (Ze = 65536 + ((Ze & 1023) << 10 | ee.charCodeAt(++De) & 1023), ke[He >> 2] |= (240 | Ze >> 18) << de[He++ & 3], ke[He >> 2] |= (128 | Ze >> 12 & 63) << de[He++ & 3], ke[He >> 2] |= (128 | Ze >> 6 & 63) << de[He++ & 3], ke[He >> 2] |= (128 | Ze & 63) << de[He++ & 3]);
        if (this.lastByteIndex = He, He >= Ce) {
          for (this.start = He - Ce, this.block = ke[Ue], He = 0; He < Ue; ++He)
            wt[He] ^= ke[He];
          ye(wt), this.reset = !0;
        } else
          this.start = He;
      }
      return this;
    }, y.prototype.encode = function(ee, xe) {
      var $e = ee & 255, ke = 1, Ce = [$e];
      for (ee = ee >> 8, $e = ee & 255; $e > 0; )
        Ce.unshift($e), ee = ee >> 8, $e = ee & 255, ++ke;
      return xe ? Ce.push(ke) : Ce.unshift(ke), this.update(Ce), Ce.length;
    }, y.prototype.encodeString = function(ee) {
      var xe, $e = typeof ee;
      if ($e !== "string") {
        if ($e === "object") {
          if (ee === null)
            throw new Error(t);
          if (T && ee.constructor === ArrayBuffer)
            ee = new Uint8Array(ee);
          else if (!Array.isArray(ee) && (!T || !ArrayBuffer.isView(ee)))
            throw new Error(t);
        } else
          throw new Error(t);
        xe = !0;
      }
      var ke = 0, Ce = ee.length;
      if (xe)
        ke = Ce;
      else
        for (var ht = 0; ht < ee.length; ++ht) {
          var Ue = ee.charCodeAt(ht);
          Ue < 128 ? ke += 1 : Ue < 2048 ? ke += 2 : Ue < 55296 || Ue >= 57344 ? ke += 3 : (Ue = 65536 + ((Ue & 1023) << 10 | ee.charCodeAt(++ht) & 1023), ke += 4);
        }
      return ke += this.encode(ke * 8), this.update(ee), ke;
    }, y.prototype.bytepad = function(ee, xe) {
      for (var $e = this.encode(xe), ke = 0; ke < ee.length; ++ke)
        $e += this.encodeString(ee[ke]);
      var Ce = xe - $e % xe, ht = [];
      return ht.length = Ce, this.update(ht), this;
    }, y.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var ee = this.blocks, xe = this.lastByteIndex, $e = this.blockCount, ke = this.s;
        if (ee[xe >> 2] |= this.padding[xe & 3], this.lastByteIndex === this.byteCount)
          for (ee[0] = ee[$e], xe = 1; xe < $e + 1; ++xe)
            ee[xe] = 0;
        for (ee[$e - 1] |= 2147483648, xe = 0; xe < $e; ++xe)
          ke[xe] ^= ee[xe];
        ye(ke);
      }
    }, y.prototype.toString = y.prototype.hex = function() {
      this.finalize();
      for (var ee = this.blockCount, xe = this.s, $e = this.outputBlocks, ke = this.extraBytes, Ce = 0, ht = 0, Ue = "", De; ht < $e; ) {
        for (Ce = 0; Ce < ee && ht < $e; ++Ce, ++ht)
          De = xe[Ce], Ue += z[De >> 4 & 15] + z[De & 15] + z[De >> 12 & 15] + z[De >> 8 & 15] + z[De >> 20 & 15] + z[De >> 16 & 15] + z[De >> 28 & 15] + z[De >> 24 & 15];
        ht % ee === 0 && (ye(xe), Ce = 0);
      }
      return ke && (De = xe[Ce], Ue += z[De >> 4 & 15] + z[De & 15], ke > 1 && (Ue += z[De >> 12 & 15] + z[De >> 8 & 15]), ke > 2 && (Ue += z[De >> 20 & 15] + z[De >> 16 & 15])), Ue;
    }, y.prototype.arrayBuffer = function() {
      this.finalize();
      var ee = this.blockCount, xe = this.s, $e = this.outputBlocks, ke = this.extraBytes, Ce = 0, ht = 0, Ue = this.outputBits >> 3, De;
      ke ? De = new ArrayBuffer($e + 1 << 2) : De = new ArrayBuffer(Ue);
      for (var wt = new Uint32Array(De); ht < $e; ) {
        for (Ce = 0; Ce < ee && ht < $e; ++Ce, ++ht)
          wt[ht] = xe[Ce];
        ht % ee === 0 && ye(xe);
      }
      return ke && (wt[Ce] = xe[Ce], De = De.slice(0, Ue)), De;
    }, y.prototype.buffer = y.prototype.arrayBuffer, y.prototype.digest = y.prototype.array = function() {
      this.finalize();
      for (var ee = this.blockCount, xe = this.s, $e = this.outputBlocks, ke = this.extraBytes, Ce = 0, ht = 0, Ue = [], De, wt; ht < $e; ) {
        for (Ce = 0; Ce < ee && ht < $e; ++Ce, ++ht)
          De = ht << 2, wt = xe[Ce], Ue[De] = wt & 255, Ue[De + 1] = wt >> 8 & 255, Ue[De + 2] = wt >> 16 & 255, Ue[De + 3] = wt >> 24 & 255;
        ht % ee === 0 && ye(xe);
      }
      return ke && (De = ht << 2, wt = xe[Ce], Ue[De] = wt & 255, ke > 1 && (Ue[De + 1] = wt >> 8 & 255), ke > 2 && (Ue[De + 2] = wt >> 16 & 255)), Ue;
    };
    function j(ee, xe, $e) {
      y.call(this, ee, xe, $e);
    }
    j.prototype = new y(), j.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), y.prototype.finalize.call(this);
    };
    var ye = function(ee) {
      var xe, $e, ke, Ce, ht, Ue, De, wt, He, Ze, Ie, ue, he, Ne, Be, Oe, it, Ve, Ye, Pt, et, Q, W, V, se, Ae, _e, Re, mt, We, ze, kt, je, ot, Vt, ct, ut, Zt, rt, nt, Gt, st, at, Jt, lt, tt, Yt, le, be, Me, te, ve, qe, Pe, Le, pt, Je, Ge, $t, bt, Mt, Rt, Tt;
      for (ke = 0; ke < 48; ke += 2)
        Ce = ee[0] ^ ee[10] ^ ee[20] ^ ee[30] ^ ee[40], ht = ee[1] ^ ee[11] ^ ee[21] ^ ee[31] ^ ee[41], Ue = ee[2] ^ ee[12] ^ ee[22] ^ ee[32] ^ ee[42], De = ee[3] ^ ee[13] ^ ee[23] ^ ee[33] ^ ee[43], wt = ee[4] ^ ee[14] ^ ee[24] ^ ee[34] ^ ee[44], He = ee[5] ^ ee[15] ^ ee[25] ^ ee[35] ^ ee[45], Ze = ee[6] ^ ee[16] ^ ee[26] ^ ee[36] ^ ee[46], Ie = ee[7] ^ ee[17] ^ ee[27] ^ ee[37] ^ ee[47], ue = ee[8] ^ ee[18] ^ ee[28] ^ ee[38] ^ ee[48], he = ee[9] ^ ee[19] ^ ee[29] ^ ee[39] ^ ee[49], xe = ue ^ (Ue << 1 | De >>> 31), $e = he ^ (De << 1 | Ue >>> 31), ee[0] ^= xe, ee[1] ^= $e, ee[10] ^= xe, ee[11] ^= $e, ee[20] ^= xe, ee[21] ^= $e, ee[30] ^= xe, ee[31] ^= $e, ee[40] ^= xe, ee[41] ^= $e, xe = Ce ^ (wt << 1 | He >>> 31), $e = ht ^ (He << 1 | wt >>> 31), ee[2] ^= xe, ee[3] ^= $e, ee[12] ^= xe, ee[13] ^= $e, ee[22] ^= xe, ee[23] ^= $e, ee[32] ^= xe, ee[33] ^= $e, ee[42] ^= xe, ee[43] ^= $e, xe = Ue ^ (Ze << 1 | Ie >>> 31), $e = De ^ (Ie << 1 | Ze >>> 31), ee[4] ^= xe, ee[5] ^= $e, ee[14] ^= xe, ee[15] ^= $e, ee[24] ^= xe, ee[25] ^= $e, ee[34] ^= xe, ee[35] ^= $e, ee[44] ^= xe, ee[45] ^= $e, xe = wt ^ (ue << 1 | he >>> 31), $e = He ^ (he << 1 | ue >>> 31), ee[6] ^= xe, ee[7] ^= $e, ee[16] ^= xe, ee[17] ^= $e, ee[26] ^= xe, ee[27] ^= $e, ee[36] ^= xe, ee[37] ^= $e, ee[46] ^= xe, ee[47] ^= $e, xe = Ze ^ (Ce << 1 | ht >>> 31), $e = Ie ^ (ht << 1 | Ce >>> 31), ee[8] ^= xe, ee[9] ^= $e, ee[18] ^= xe, ee[19] ^= $e, ee[28] ^= xe, ee[29] ^= $e, ee[38] ^= xe, ee[39] ^= $e, ee[48] ^= xe, ee[49] ^= $e, Ne = ee[0], Be = ee[1], tt = ee[11] << 4 | ee[10] >>> 28, Yt = ee[10] << 4 | ee[11] >>> 28, Re = ee[20] << 3 | ee[21] >>> 29, mt = ee[21] << 3 | ee[20] >>> 29, bt = ee[31] << 9 | ee[30] >>> 23, Mt = ee[30] << 9 | ee[31] >>> 23, st = ee[40] << 18 | ee[41] >>> 14, at = ee[41] << 18 | ee[40] >>> 14, ot = ee[2] << 1 | ee[3] >>> 31, Vt = ee[3] << 1 | ee[2] >>> 31, Oe = ee[13] << 12 | ee[12] >>> 20, it = ee[12] << 12 | ee[13] >>> 20, le = ee[22] << 10 | ee[23] >>> 22, be = ee[23] << 10 | ee[22] >>> 22, We = ee[33] << 13 | ee[32] >>> 19, ze = ee[32] << 13 | ee[33] >>> 19, Rt = ee[42] << 2 | ee[43] >>> 30, Tt = ee[43] << 2 | ee[42] >>> 30, Pe = ee[5] << 30 | ee[4] >>> 2, Le = ee[4] << 30 | ee[5] >>> 2, ct = ee[14] << 6 | ee[15] >>> 26, ut = ee[15] << 6 | ee[14] >>> 26, Ve = ee[25] << 11 | ee[24] >>> 21, Ye = ee[24] << 11 | ee[25] >>> 21, Me = ee[34] << 15 | ee[35] >>> 17, te = ee[35] << 15 | ee[34] >>> 17, kt = ee[45] << 29 | ee[44] >>> 3, je = ee[44] << 29 | ee[45] >>> 3, V = ee[6] << 28 | ee[7] >>> 4, se = ee[7] << 28 | ee[6] >>> 4, pt = ee[17] << 23 | ee[16] >>> 9, Je = ee[16] << 23 | ee[17] >>> 9, Zt = ee[26] << 25 | ee[27] >>> 7, rt = ee[27] << 25 | ee[26] >>> 7, Pt = ee[36] << 21 | ee[37] >>> 11, et = ee[37] << 21 | ee[36] >>> 11, ve = ee[47] << 24 | ee[46] >>> 8, qe = ee[46] << 24 | ee[47] >>> 8, Jt = ee[8] << 27 | ee[9] >>> 5, lt = ee[9] << 27 | ee[8] >>> 5, Ae = ee[18] << 20 | ee[19] >>> 12, _e = ee[19] << 20 | ee[18] >>> 12, Ge = ee[29] << 7 | ee[28] >>> 25, $t = ee[28] << 7 | ee[29] >>> 25, nt = ee[38] << 8 | ee[39] >>> 24, Gt = ee[39] << 8 | ee[38] >>> 24, Q = ee[48] << 14 | ee[49] >>> 18, W = ee[49] << 14 | ee[48] >>> 18, ee[0] = Ne ^ ~Oe & Ve, ee[1] = Be ^ ~it & Ye, ee[10] = V ^ ~Ae & Re, ee[11] = se ^ ~_e & mt, ee[20] = ot ^ ~ct & Zt, ee[21] = Vt ^ ~ut & rt, ee[30] = Jt ^ ~tt & le, ee[31] = lt ^ ~Yt & be, ee[40] = Pe ^ ~pt & Ge, ee[41] = Le ^ ~Je & $t, ee[2] = Oe ^ ~Ve & Pt, ee[3] = it ^ ~Ye & et, ee[12] = Ae ^ ~Re & We, ee[13] = _e ^ ~mt & ze, ee[22] = ct ^ ~Zt & nt, ee[23] = ut ^ ~rt & Gt, ee[32] = tt ^ ~le & Me, ee[33] = Yt ^ ~be & te, ee[42] = pt ^ ~Ge & bt, ee[43] = Je ^ ~$t & Mt, ee[4] = Ve ^ ~Pt & Q, ee[5] = Ye ^ ~et & W, ee[14] = Re ^ ~We & kt, ee[15] = mt ^ ~ze & je, ee[24] = Zt ^ ~nt & st, ee[25] = rt ^ ~Gt & at, ee[34] = le ^ ~Me & ve, ee[35] = be ^ ~te & qe, ee[44] = Ge ^ ~bt & Rt, ee[45] = $t ^ ~Mt & Tt, ee[6] = Pt ^ ~Q & Ne, ee[7] = et ^ ~W & Be, ee[16] = We ^ ~kt & V, ee[17] = ze ^ ~je & se, ee[26] = nt ^ ~st & ot, ee[27] = Gt ^ ~at & Vt, ee[36] = Me ^ ~ve & Jt, ee[37] = te ^ ~qe & lt, ee[46] = bt ^ ~Rt & Pe, ee[47] = Mt ^ ~Tt & Le, ee[8] = Q ^ ~Ne & Oe, ee[9] = W ^ ~Be & it, ee[18] = kt ^ ~V & Ae, ee[19] = je ^ ~se & _e, ee[28] = st ^ ~ot & ct, ee[29] = at ^ ~Vt & ut, ee[38] = ve ^ ~Jt & tt, ee[39] = qe ^ ~lt & Yt, ee[48] = Rt ^ ~Pe & pt, ee[49] = Tt ^ ~Le & Je, ee[0] ^= ce[ke], ee[1] ^= ce[ke + 1];
    };
    if (_)
      l.exports = p;
    else
      for (S = 0; S < x.length; ++S)
        m[x[S]] = p[x[S]];
  })();
})(sha3$1);
var sha3 = sha3$1.exports;
function keccak256$1(l) {
  return "0x" + sha3.keccak_256(arrayify(l));
}
var lib_esm$i = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  keccak256: keccak256$1
});
const version$m = "rlp/5.7.0", logger$D = new Logger(version$m);
function arrayifyInteger(l) {
  const t = [];
  for (; l; )
    t.unshift(l & 255), l >>= 8;
  return t;
}
function unarrayifyInteger(l, t, s) {
  let h = 0;
  for (let m = 0; m < s; m++)
    h = h * 256 + l[t + m];
  return h;
}
function _encode(l) {
  if (Array.isArray(l)) {
    let h = [];
    if (l.forEach(function(d) {
      h = h.concat(_encode(d));
    }), h.length <= 55)
      return h.unshift(192 + h.length), h;
    const m = arrayifyInteger(h.length);
    return m.unshift(247 + m.length), m.concat(h);
  }
  isBytesLike(l) || logger$D.throwArgumentError("RLP object must be BytesLike", "object", l);
  const t = Array.prototype.slice.call(arrayify(l));
  if (t.length === 1 && t[0] <= 127)
    return t;
  if (t.length <= 55)
    return t.unshift(128 + t.length), t;
  const s = arrayifyInteger(t.length);
  return s.unshift(183 + s.length), s.concat(t);
}
function encode$3(l) {
  return hexlify(_encode(l));
}
function _decodeChildren(l, t, s, h) {
  const m = [];
  for (; s < t + 1 + h; ) {
    const d = _decode(l, s);
    m.push(d.result), s += d.consumed, s > t + 1 + h && logger$D.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + h, result: m };
}
function _decode(l, t) {
  if (l.length === 0 && logger$D.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {}), l[t] >= 248) {
    const s = l[t] - 247;
    t + 1 + s > l.length && logger$D.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    const h = unarrayifyInteger(l, t + 1, s);
    return t + 1 + s + h > l.length && logger$D.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {}), _decodeChildren(l, t, t + 1 + s, s + h);
  } else if (l[t] >= 192) {
    const s = l[t] - 192;
    return t + 1 + s > l.length && logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {}), _decodeChildren(l, t, t + 1, s);
  } else if (l[t] >= 184) {
    const s = l[t] - 183;
    t + 1 + s > l.length && logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    const h = unarrayifyInteger(l, t + 1, s);
    t + 1 + s + h > l.length && logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    const m = hexlify(l.slice(t + 1 + s, t + 1 + s + h));
    return { consumed: 1 + s + h, result: m };
  } else if (l[t] >= 128) {
    const s = l[t] - 128;
    t + 1 + s > l.length && logger$D.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    const h = hexlify(l.slice(t + 1, t + 1 + s));
    return { consumed: 1 + s, result: h };
  }
  return { consumed: 1, result: hexlify(l[t]) };
}
function decode$4(l) {
  const t = arrayify(l), s = _decode(t, 0);
  return s.consumed !== t.length && logger$D.throwArgumentError("invalid rlp data", "data", l), s.result;
}
var lib_esm$h = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  decode: decode$4,
  encode: encode$3
});
const version$l = "address/5.7.0", logger$C = new Logger(version$l);
function getChecksumAddress(l) {
  isHexString$2(l, 20) || logger$C.throwArgumentError("invalid address", "address", l), l = l.toLowerCase();
  const t = l.substring(2).split(""), s = new Uint8Array(40);
  for (let m = 0; m < 40; m++)
    s[m] = t[m].charCodeAt(0);
  const h = arrayify(keccak256$1(s));
  for (let m = 0; m < 40; m += 2)
    h[m >> 1] >> 4 >= 8 && (t[m] = t[m].toUpperCase()), (h[m >> 1] & 15) >= 8 && (t[m + 1] = t[m + 1].toUpperCase());
  return "0x" + t.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(l) {
  return Math.log10 ? Math.log10(l) : Math.log(l) / Math.LN10;
}
const ibanLookup = {};
for (let l = 0; l < 10; l++)
  ibanLookup[String(l)] = String(l);
for (let l = 0; l < 26; l++)
  ibanLookup[String.fromCharCode(65 + l)] = String(10 + l);
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(l) {
  l = l.toUpperCase(), l = l.substring(4) + l.substring(0, 2) + "00";
  let t = l.split("").map((h) => ibanLookup[h]).join("");
  for (; t.length >= safeDigits; ) {
    let h = t.substring(0, safeDigits);
    t = parseInt(h, 10) % 97 + t.substring(h.length);
  }
  let s = String(98 - parseInt(t, 10) % 97);
  for (; s.length < 2; )
    s = "0" + s;
  return s;
}
function getAddress(l) {
  let t = null;
  if (typeof l != "string" && logger$C.throwArgumentError("invalid address", "address", l), l.match(/^(0x)?[0-9a-fA-F]{40}$/))
    l.substring(0, 2) !== "0x" && (l = "0x" + l), t = getChecksumAddress(l), l.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== l && logger$C.throwArgumentError("bad address checksum", "address", l);
  else if (l.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (l.substring(2, 4) !== ibanChecksum(l) && logger$C.throwArgumentError("bad icap checksum", "address", l), t = _base36To16(l.substring(4)); t.length < 40; )
      t = "0" + t;
    t = getChecksumAddress("0x" + t);
  } else
    logger$C.throwArgumentError("invalid address", "address", l);
  return t;
}
function isAddress(l) {
  try {
    return getAddress(l), !0;
  } catch {
  }
  return !1;
}
function getIcapAddress(l) {
  let t = _base16To36(getAddress(l).substring(2)).toUpperCase();
  for (; t.length < 30; )
    t = "0" + t;
  return "XE" + ibanChecksum("XE00" + t) + t;
}
function getContractAddress(l) {
  let t = null;
  try {
    t = getAddress(l.from);
  } catch {
    logger$C.throwArgumentError("missing from address", "transaction", l);
  }
  const s = stripZeros(arrayify(BigNumber.from(l.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256$1(encode$3([t, s])), 12));
}
function getCreate2Address(l, t, s) {
  return hexDataLength(t) !== 32 && logger$C.throwArgumentError("salt must be 32 bytes", "salt", t), hexDataLength(s) !== 32 && logger$C.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", s), getAddress(hexDataSlice(keccak256$1(concat(["0xff", getAddress(l), t, s])), 12));
}
var lib_esm$g = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  getAddress,
  getContractAddress,
  getCreate2Address,
  getIcapAddress,
  isAddress
});
class AddressCoder extends Coder {
  constructor(t) {
    super("address", "address", t, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(t, s) {
    try {
      s = getAddress(s);
    } catch (h) {
      this._throwError(h.message, s);
    }
    return t.writeValue(s);
  }
  decode(t) {
    return getAddress(hexZeroPad(t.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(t) {
    super(t.name, t.type, void 0, t.dynamic), this.coder = t;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(t, s) {
    return this.coder.encode(t, s);
  }
  decode(t) {
    return this.coder.decode(t);
  }
}
const logger$B = new Logger(version$n);
function pack$1(l, t, s) {
  let h = null;
  if (Array.isArray(s))
    h = s;
  else if (s && typeof s == "object") {
    let T = {};
    h = t.map((z) => {
      const J = z.localName;
      return J || logger$B.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: z,
        value: s
      }), T[J] && logger$B.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: z,
        value: s
      }), T[J] = !0, s[J];
    });
  } else
    logger$B.throwArgumentError("invalid tuple value", "tuple", s);
  t.length !== h.length && logger$B.throwArgumentError("types/value length mismatch", "tuple", s);
  let m = new Writer(l.wordSize), d = new Writer(l.wordSize), v = [];
  t.forEach((T, z) => {
    let J = h[z];
    if (T.dynamic) {
      let Y = d.length;
      T.encode(d, J);
      let ie = m.writeUpdatableValue();
      v.push((ne) => {
        ie(ne + Y);
      });
    } else
      T.encode(m, J);
  }), v.forEach((T) => {
    T(m.length);
  });
  let _ = l.appendWriter(m);
  return _ += l.appendWriter(d), _;
}
function unpack(l, t) {
  let s = [], h = l.subReader(0);
  t.forEach((d) => {
    let v = null;
    if (d.dynamic) {
      let _ = l.readValue(), T = h.subReader(_.toNumber());
      try {
        v = d.decode(T);
      } catch (z) {
        if (z.code === Logger.errors.BUFFER_OVERRUN)
          throw z;
        v = z, v.baseType = d.name, v.name = d.localName, v.type = d.type;
      }
    } else
      try {
        v = d.decode(l);
      } catch (_) {
        if (_.code === Logger.errors.BUFFER_OVERRUN)
          throw _;
        v = _, v.baseType = d.name, v.name = d.localName, v.type = d.type;
      }
    v != null && s.push(v);
  });
  const m = t.reduce((d, v) => {
    const _ = v.localName;
    return _ && (d[_] || (d[_] = 0), d[_]++), d;
  }, {});
  t.forEach((d, v) => {
    let _ = d.localName;
    if (!_ || m[_] !== 1 || (_ === "length" && (_ = "_length"), s[_] != null))
      return;
    const T = s[v];
    T instanceof Error ? Object.defineProperty(s, _, {
      enumerable: !0,
      get: () => {
        throw T;
      }
    }) : s[_] = T;
  });
  for (let d = 0; d < s.length; d++) {
    const v = s[d];
    v instanceof Error && Object.defineProperty(s, d, {
      enumerable: !0,
      get: () => {
        throw v;
      }
    });
  }
  return Object.freeze(s);
}
class ArrayCoder extends Coder {
  constructor(t, s, h) {
    const m = t.type + "[" + (s >= 0 ? s : "") + "]", d = s === -1 || t.dynamic;
    super("array", m, h, d), this.coder = t, this.length = s;
  }
  defaultValue() {
    const t = this.coder.defaultValue(), s = [];
    for (let h = 0; h < this.length; h++)
      s.push(t);
    return s;
  }
  encode(t, s) {
    Array.isArray(s) || this._throwError("expected array value", s);
    let h = this.length;
    h === -1 && (h = s.length, t.writeValue(s.length)), logger$B.checkArgumentCount(s.length, h, "coder array" + (this.localName ? " " + this.localName : ""));
    let m = [];
    for (let d = 0; d < s.length; d++)
      m.push(this.coder);
    return pack$1(t, m, s);
  }
  decode(t) {
    let s = this.length;
    s === -1 && (s = t.readValue().toNumber(), s * 32 > t._data.length && logger$B.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
      length: t._data.length,
      count: s
    }));
    let h = [];
    for (let m = 0; m < s; m++)
      h.push(new AnonymousCoder(this.coder));
    return t.coerce(this.name, unpack(t, h));
  }
}
class BooleanCoder extends Coder {
  constructor(t) {
    super("bool", "bool", t, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(t, s) {
    return t.writeValue(s ? 1 : 0);
  }
  decode(t) {
    return t.coerce(this.type, !t.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(t, s) {
    super(t, t, s, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(t, s) {
    s = arrayify(s);
    let h = t.writeValue(s.length);
    return h += t.writeBytes(s), h;
  }
  decode(t) {
    return t.readBytes(t.readValue().toNumber(), !0);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(t) {
    super("bytes", t);
  }
  decode(t) {
    return t.coerce(this.name, hexlify(super.decode(t)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(t, s) {
    let h = "bytes" + String(t);
    super(h, h, s, !1), this.size = t;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(t, s) {
    let h = arrayify(s);
    return h.length !== this.size && this._throwError("incorrect data length", s), t.writeBytes(h);
  }
  decode(t) {
    return t.coerce(this.name, hexlify(t.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(t) {
    super("null", "", t, !1);
  }
  defaultValue() {
    return null;
  }
  encode(t, s) {
    return s != null && this._throwError("not null", s), t.writeBytes([]);
  }
  decode(t) {
    return t.readBytes(0), t.coerce(this.name, null);
  }
}
const AddressZero = "0x0000000000000000000000000000000000000000", NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1), Zero$1 = /* @__PURE__ */ BigNumber.from(0), One$1 = /* @__PURE__ */ BigNumber.from(1), Two = /* @__PURE__ */ BigNumber.from(2), WeiPerEther = /* @__PURE__ */ BigNumber.from("1000000000000000000"), MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), MinInt256 = /* @__PURE__ */ BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000"), MaxInt256 = /* @__PURE__ */ BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000", EtherSymbol = "\u039E";
var index$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AddressZero,
  EtherSymbol,
  HashZero,
  MaxInt256,
  MaxUint256: MaxUint256$1,
  MinInt256,
  NegativeOne: NegativeOne$1,
  One: One$1,
  Two,
  WeiPerEther,
  Zero: Zero$1
});
class NumberCoder extends Coder {
  constructor(t, s, h) {
    const m = (s ? "int" : "uint") + t * 8;
    super(m, m, h, !1), this.size = t, this.signed = s;
  }
  defaultValue() {
    return 0;
  }
  encode(t, s) {
    let h = BigNumber.from(s), m = MaxUint256$1.mask(t.wordSize * 8);
    if (this.signed) {
      let d = m.mask(this.size * 8 - 1);
      (h.gt(d) || h.lt(d.add(One$1).mul(NegativeOne$1))) && this._throwError("value out-of-bounds", s);
    } else
      (h.lt(Zero$1) || h.gt(m.mask(this.size * 8))) && this._throwError("value out-of-bounds", s);
    return h = h.toTwos(this.size * 8).mask(this.size * 8), this.signed && (h = h.fromTwos(this.size * 8).toTwos(8 * t.wordSize)), t.writeValue(h);
  }
  decode(t) {
    let s = t.readValue().mask(this.size * 8);
    return this.signed && (s = s.fromTwos(this.size * 8)), t.coerce(this.name, s);
  }
}
const version$k = "strings/5.7.0", logger$A = new Logger(version$k);
var UnicodeNormalizationForm;
(function(l) {
  l.current = "", l.NFC = "NFC", l.NFD = "NFD", l.NFKC = "NFKC", l.NFKD = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(l) {
  l.UNEXPECTED_CONTINUE = "unexpected continuation byte", l.BAD_PREFIX = "bad codepoint prefix", l.OVERRUN = "string overrun", l.MISSING_CONTINUE = "missing continuation byte", l.OUT_OF_RANGE = "out of UTF-8 range", l.UTF16_SURROGATE = "UTF-16 surrogate", l.OVERLONG = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(l, t, s, h, m) {
  return logger$A.throwArgumentError(`invalid codepoint at offset ${t}; ${l}`, "bytes", s);
}
function ignoreFunc(l, t, s, h, m) {
  if (l === Utf8ErrorReason.BAD_PREFIX || l === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let d = 0;
    for (let v = t + 1; v < s.length && s[v] >> 6 === 2; v++)
      d++;
    return d;
  }
  return l === Utf8ErrorReason.OVERRUN ? s.length - t - 1 : 0;
}
function replaceFunc(l, t, s, h, m) {
  return l === Utf8ErrorReason.OVERLONG ? (h.push(m), 0) : (h.push(65533), ignoreFunc(l, t, s));
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(l, t) {
  t == null && (t = Utf8ErrorFuncs.error), l = arrayify(l);
  const s = [];
  let h = 0;
  for (; h < l.length; ) {
    const m = l[h++];
    if (m >> 7 === 0) {
      s.push(m);
      continue;
    }
    let d = null, v = null;
    if ((m & 224) === 192)
      d = 1, v = 127;
    else if ((m & 240) === 224)
      d = 2, v = 2047;
    else if ((m & 248) === 240)
      d = 3, v = 65535;
    else {
      (m & 192) === 128 ? h += t(Utf8ErrorReason.UNEXPECTED_CONTINUE, h - 1, l, s) : h += t(Utf8ErrorReason.BAD_PREFIX, h - 1, l, s);
      continue;
    }
    if (h - 1 + d >= l.length) {
      h += t(Utf8ErrorReason.OVERRUN, h - 1, l, s);
      continue;
    }
    let _ = m & (1 << 8 - d - 1) - 1;
    for (let T = 0; T < d; T++) {
      let z = l[h];
      if ((z & 192) != 128) {
        h += t(Utf8ErrorReason.MISSING_CONTINUE, h, l, s), _ = null;
        break;
      }
      _ = _ << 6 | z & 63, h++;
    }
    if (_ !== null) {
      if (_ > 1114111) {
        h += t(Utf8ErrorReason.OUT_OF_RANGE, h - 1 - d, l, s, _);
        continue;
      }
      if (_ >= 55296 && _ <= 57343) {
        h += t(Utf8ErrorReason.UTF16_SURROGATE, h - 1 - d, l, s, _);
        continue;
      }
      if (_ <= v) {
        h += t(Utf8ErrorReason.OVERLONG, h - 1 - d, l, s, _);
        continue;
      }
      s.push(_);
    }
  }
  return s;
}
function toUtf8Bytes(l, t = UnicodeNormalizationForm.current) {
  t != UnicodeNormalizationForm.current && (logger$A.checkNormalize(), l = l.normalize(t));
  let s = [];
  for (let h = 0; h < l.length; h++) {
    const m = l.charCodeAt(h);
    if (m < 128)
      s.push(m);
    else if (m < 2048)
      s.push(m >> 6 | 192), s.push(m & 63 | 128);
    else if ((m & 64512) == 55296) {
      h++;
      const d = l.charCodeAt(h);
      if (h >= l.length || (d & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const v = 65536 + ((m & 1023) << 10) + (d & 1023);
      s.push(v >> 18 | 240), s.push(v >> 12 & 63 | 128), s.push(v >> 6 & 63 | 128), s.push(v & 63 | 128);
    } else
      s.push(m >> 12 | 224), s.push(m >> 6 & 63 | 128), s.push(m & 63 | 128);
  }
  return arrayify(s);
}
function escapeChar(l) {
  const t = "0000" + l.toString(16);
  return "\\u" + t.substring(t.length - 4);
}
function _toEscapedUtf8String(l, t) {
  return '"' + getUtf8CodePoints(l, t).map((s) => {
    if (s < 256) {
      switch (s) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (s >= 32 && s < 127)
        return String.fromCharCode(s);
    }
    return s <= 65535 ? escapeChar(s) : (s -= 65536, escapeChar((s >> 10 & 1023) + 55296) + escapeChar((s & 1023) + 56320));
  }).join("") + '"';
}
function _toUtf8String(l) {
  return l.map((t) => t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10 & 1023) + 55296, (t & 1023) + 56320))).join("");
}
function toUtf8String(l, t) {
  return _toUtf8String(getUtf8CodePoints(l, t));
}
function toUtf8CodePoints(l, t = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(l, t));
}
function formatBytes32String(l) {
  const t = toUtf8Bytes(l);
  if (t.length > 31)
    throw new Error("bytes32 string must be less than 32 bytes");
  return hexlify(concat([t, HashZero]).slice(0, 32));
}
function parseBytes32String(l) {
  const t = arrayify(l);
  if (t.length !== 32)
    throw new Error("invalid bytes32 - not 32 bytes long");
  if (t[31] !== 0)
    throw new Error("invalid bytes32 string - no null terminator");
  let s = 31;
  for (; t[s - 1] === 0; )
    s--;
  return toUtf8String(t.slice(0, s));
}
function bytes2(l) {
  if (l.length % 4 !== 0)
    throw new Error("bad data");
  let t = [];
  for (let s = 0; s < l.length; s += 4)
    t.push(parseInt(l.substring(s, s + 4), 16));
  return t;
}
function createTable(l, t) {
  t || (t = function(m) {
    return [parseInt(m, 16)];
  });
  let s = 0, h = {};
  return l.split(",").forEach((m) => {
    let d = m.split(":");
    s += parseInt(d[0], 16), h[s] = t(d[1]);
  }), h;
}
function createRangeTable(l) {
  let t = 0;
  return l.split(",").map((s) => {
    let h = s.split("-");
    h.length === 1 ? h[1] = "0" : h[1] === "" && (h[1] = "1");
    let m = t + parseInt(h[0], 16);
    return t = parseInt(h[1], 16), { l: m, h: t };
  });
}
function matchMap(l, t) {
  let s = 0;
  for (let h = 0; h < t.length; h++) {
    let m = t[h];
    if (s += m.l, l >= s && l <= s + m.h && (l - s) % (m.d || 1) === 0) {
      if (m.e && m.e.indexOf(l - s) !== -1)
        continue;
      return m;
    }
  }
  return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"), Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((l) => parseInt(l, 16)), Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
], Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"), Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"), Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2), Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(l) {
  return l.reduce((t, s) => (s.forEach((h) => {
    t.push(h);
  }), t), []);
}
function _nameprepTableA1(l) {
  return !!matchMap(l, Table_A_1_ranges);
}
function _nameprepTableB2(l) {
  let t = matchMap(l, Table_B_2_ranges);
  if (t)
    return [l + t.s];
  let s = Table_B_2_lut_abs[l];
  if (s)
    return s;
  let h = Table_B_2_lut_rel[l];
  if (h)
    return [l + h[0]];
  let m = Table_B_2_complex[l];
  return m || null;
}
function _nameprepTableC(l) {
  return !!matchMap(l, Table_C_ranges);
}
function nameprep(l) {
  if (l.match(/^[a-z0-9-]*$/i) && l.length <= 59)
    return l.toLowerCase();
  let t = toUtf8CodePoints(l);
  t = flatten(t.map((h) => {
    if (Table_B_1_flags.indexOf(h) >= 0)
      return [];
    if (h >= 65024 && h <= 65039)
      return [];
    let m = _nameprepTableB2(h);
    return m || [h];
  })), t = toUtf8CodePoints(_toUtf8String(t), UnicodeNormalizationForm.NFKC), t.forEach((h) => {
    if (_nameprepTableC(h))
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
  }), t.forEach((h) => {
    if (_nameprepTableA1(h))
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
  });
  let s = _toUtf8String(t);
  if (s.substring(0, 1) === "-" || s.substring(2, 4) === "--" || s.substring(s.length - 1) === "-")
    throw new Error("invalid hyphen");
  return s;
}
var lib_esm$f = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get UnicodeNormalizationForm() {
    return UnicodeNormalizationForm;
  },
  Utf8ErrorFuncs,
  get Utf8ErrorReason() {
    return Utf8ErrorReason;
  },
  _toEscapedUtf8String,
  formatBytes32String,
  nameprep,
  parseBytes32String,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String
});
class StringCoder extends DynamicBytesCoder {
  constructor(t) {
    super("string", t);
  }
  defaultValue() {
    return "";
  }
  encode(t, s) {
    return super.encode(t, toUtf8Bytes(s));
  }
  decode(t) {
    return toUtf8String(super.decode(t));
  }
}
class TupleCoder extends Coder {
  constructor(t, s) {
    let h = !1;
    const m = [];
    t.forEach((v) => {
      v.dynamic && (h = !0), m.push(v.type);
    });
    const d = "tuple(" + m.join(",") + ")";
    super("tuple", d, s, h), this.coders = t;
  }
  defaultValue() {
    const t = [];
    this.coders.forEach((h) => {
      t.push(h.defaultValue());
    });
    const s = this.coders.reduce((h, m) => {
      const d = m.localName;
      return d && (h[d] || (h[d] = 0), h[d]++), h;
    }, {});
    return this.coders.forEach((h, m) => {
      let d = h.localName;
      !d || s[d] !== 1 || (d === "length" && (d = "_length"), t[d] == null && (t[d] = t[m]));
    }), Object.freeze(t);
  }
  encode(t, s) {
    return pack$1(t, this.coders, s);
  }
  decode(t) {
    return t.coerce(this.name, unpack(t, this.coders));
  }
}
const logger$z = new Logger(version$n), paramTypeBytes = new RegExp(/^bytes([0-9]*)$/), paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(t) {
    defineReadOnly(this, "coerceFunc", t || null);
  }
  _getCoder(t) {
    switch (t.baseType) {
      case "address":
        return new AddressCoder(t.name);
      case "bool":
        return new BooleanCoder(t.name);
      case "string":
        return new StringCoder(t.name);
      case "bytes":
        return new BytesCoder(t.name);
      case "array":
        return new ArrayCoder(this._getCoder(t.arrayChildren), t.arrayLength, t.name);
      case "tuple":
        return new TupleCoder((t.components || []).map((h) => this._getCoder(h)), t.name);
      case "":
        return new NullCoder(t.name);
    }
    let s = t.type.match(paramTypeNumber);
    if (s) {
      let h = parseInt(s[2] || "256");
      return (h === 0 || h > 256 || h % 8 !== 0) && logger$z.throwArgumentError("invalid " + s[1] + " bit length", "param", t), new NumberCoder(h / 8, s[1] === "int", t.name);
    }
    if (s = t.type.match(paramTypeBytes), s) {
      let h = parseInt(s[1]);
      return (h === 0 || h > 32) && logger$z.throwArgumentError("invalid bytes length", "param", t), new FixedBytesCoder(h, t.name);
    }
    return logger$z.throwArgumentError("invalid type", "type", t.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(t, s) {
    return new Reader(t, this._getWordSize(), this.coerceFunc, s);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(t) {
    const s = t.map((m) => this._getCoder(ParamType.from(m)));
    return new TupleCoder(s, "_").defaultValue();
  }
  encode(t, s) {
    t.length !== s.length && logger$z.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
      count: { types: t.length, values: s.length },
      value: { types: t, values: s }
    });
    const h = t.map((v) => this._getCoder(ParamType.from(v))), m = new TupleCoder(h, "_"), d = this._getWriter();
    return m.encode(d, s), d.data;
  }
  decode(t, s, h) {
    const m = t.map((v) => this._getCoder(ParamType.from(v)));
    return new TupleCoder(m, "_").decode(this._getReader(arrayify(s), h));
  }
}
const defaultAbiCoder = new AbiCoder();
function id(l) {
  return keccak256$1(toUtf8Bytes(l));
}
const version$j = "hash/5.7.0";
function decode$3(l) {
  l = atob(l);
  const t = [];
  for (let s = 0; s < l.length; s++)
    t.push(l.charCodeAt(s));
  return arrayify(t);
}
function encode$2(l) {
  l = arrayify(l);
  let t = "";
  for (let s = 0; s < l.length; s++)
    t += String.fromCharCode(l[s]);
  return btoa(t);
}
var lib_esm$e = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  decode: decode$3,
  encode: encode$2
});
function flat(l, t) {
  t == null && (t = 1);
  const s = [], h = s.forEach, m = function(d, v) {
    h.call(d, function(_) {
      v > 0 && Array.isArray(_) ? m(_, v - 1) : s.push(_);
    });
  };
  return m(l, t), s;
}
function fromEntries(l) {
  const t = {};
  for (let s = 0; s < l.length; s++) {
    const h = l[s];
    t[h[0]] = h[1];
  }
  return t;
}
function decode_arithmetic(l) {
  let t = 0;
  function s() {
    return l[t++] << 8 | l[t++];
  }
  let h = s(), m = 1, d = [0, 1];
  for (let ge = 1; ge < h; ge++)
    d.push(m += s());
  let v = s(), _ = t;
  t += v;
  let T = 0, z = 0;
  function J() {
    return T == 0 && (z = z << 8 | l[t++], T = 8), z >> --T & 1;
  }
  const Y = 31, ie = Math.pow(2, Y), ne = ie >>> 1, de = ne >> 1, ce = ie - 1;
  let re = 0;
  for (let ge = 0; ge < Y; ge++)
    re = re << 1 | J();
  let oe = [], pe = 0, ae = ie;
  for (; ; ) {
    let ge = Math.floor(((re - pe + 1) * m - 1) / ae), we = 0, Ee = h;
    for (; Ee - we > 1; ) {
      let Se = we + Ee >>> 1;
      ge < d[Se] ? Ee = Se : we = Se;
    }
    if (we == 0)
      break;
    oe.push(we);
    let Te = pe + Math.floor(ae * d[we] / m), Ke = pe + Math.floor(ae * d[we + 1] / m) - 1;
    for (; ((Te ^ Ke) & ne) == 0; )
      re = re << 1 & ce | J(), Te = Te << 1 & ce, Ke = Ke << 1 & ce | 1;
    for (; Te & ~Ke & de; )
      re = re & ne | re << 1 & ce >>> 1 | J(), Te = Te << 1 ^ ne, Ke = (Ke ^ ne) << 1 | ne | 1;
    pe = Te, ae = 1 + Ke - Te;
  }
  let me = h - 4;
  return oe.map((ge) => {
    switch (ge - me) {
      case 3:
        return me + 65792 + (l[_++] << 16 | l[_++] << 8 | l[_++]);
      case 2:
        return me + 256 + (l[_++] << 8 | l[_++]);
      case 1:
        return me + l[_++];
      default:
        return ge - 1;
    }
  });
}
function read_payload(l) {
  let t = 0;
  return () => l[t++];
}
function read_compressed_payload(l) {
  return read_payload(decode_arithmetic(l));
}
function signed(l) {
  return l & 1 ? ~l >> 1 : l >> 1;
}
function read_counts(l, t) {
  let s = Array(l);
  for (let h = 0; h < l; h++)
    s[h] = 1 + t();
  return s;
}
function read_ascending(l, t) {
  let s = Array(l);
  for (let h = 0, m = -1; h < l; h++)
    s[h] = m += 1 + t();
  return s;
}
function read_deltas(l, t) {
  let s = Array(l);
  for (let h = 0, m = 0; h < l; h++)
    s[h] = m += signed(t());
  return s;
}
function read_member_array(l, t) {
  let s = read_ascending(l(), l), h = l(), m = read_ascending(h, l), d = read_counts(h, l);
  for (let v = 0; v < h; v++)
    for (let _ = 0; _ < d[v]; _++)
      s.push(m[v] + _);
  return t ? s.map((v) => t[v]) : s;
}
function read_mapped_map(l) {
  let t = [];
  for (; ; ) {
    let s = l();
    if (s == 0)
      break;
    t.push(read_linear_table(s, l));
  }
  for (; ; ) {
    let s = l() - 1;
    if (s < 0)
      break;
    t.push(read_replacement_table(s, l));
  }
  return fromEntries(flat(t));
}
function read_zero_terminated_array(l) {
  let t = [];
  for (; ; ) {
    let s = l();
    if (s == 0)
      break;
    t.push(s);
  }
  return t;
}
function read_transposed(l, t, s) {
  let h = Array(l).fill(void 0).map(() => []);
  for (let m = 0; m < t; m++)
    read_deltas(l, s).forEach((d, v) => h[v].push(d));
  return h;
}
function read_linear_table(l, t) {
  let s = 1 + t(), h = t(), m = read_zero_terminated_array(t), d = read_transposed(m.length, 1 + l, t);
  return flat(d.map((v, _) => {
    const T = v[0], z = v.slice(1);
    return Array(m[_]).fill(void 0).map((J, Y) => {
      let ie = Y * h;
      return [T + Y * s, z.map((ne) => ne + ie)];
    });
  }));
}
function read_replacement_table(l, t) {
  let s = 1 + t();
  return read_transposed(s, 1 + l, t).map((m) => [m[0], m.slice(1)]);
}
function read_emoji_trie(l) {
  let t = read_member_array(l).sort((h, m) => h - m);
  return s();
  function s() {
    let h = [];
    for (; ; ) {
      let z = read_member_array(l, t);
      if (z.length == 0)
        break;
      h.push({ set: new Set(z), node: s() });
    }
    h.sort((z, J) => J.set.size - z.set.size);
    let m = l(), d = m % 3;
    m = m / 3 | 0;
    let v = !!(m & 1);
    m >>= 1;
    let _ = m == 1, T = m == 2;
    return { branches: h, valid: d, fe0f: v, save: _, check: T };
  }
}
function getData() {
  return read_compressed_payload(decode$3("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const r$3 = getData(), VALID = new Set(read_member_array(r$3)), IGNORED = new Set(read_member_array(r$3)), MAPPED = read_mapped_map(r$3), EMOJI_ROOT = read_emoji_trie(r$3), HYPHEN = 45, UNDERSCORE = 95;
function explode_cp(l) {
  return toUtf8CodePoints(l);
}
function filter_fe0f(l) {
  return l.filter((t) => t != 65039);
}
function ens_normalize_post_check(l) {
  for (let t of l.split(".")) {
    let s = explode_cp(t);
    try {
      for (let h = s.lastIndexOf(UNDERSCORE) - 1; h >= 0; h--)
        if (s[h] !== UNDERSCORE)
          throw new Error("underscore only allowed at start");
      if (s.length >= 4 && s.every((h) => h < 128) && s[2] === HYPHEN && s[3] === HYPHEN)
        throw new Error("invalid label extension");
    } catch (h) {
      throw new Error(`Invalid label "${t}": ${h.message}`);
    }
  }
  return l;
}
function ens_normalize(l) {
  return ens_normalize_post_check(normalize(l, filter_fe0f));
}
function normalize(l, t) {
  let s = explode_cp(l).reverse(), h = [];
  for (; s.length; ) {
    let m = consume_emoji_reversed(s);
    if (m) {
      h.push(...t(m));
      continue;
    }
    let d = s.pop();
    if (VALID.has(d)) {
      h.push(d);
      continue;
    }
    if (IGNORED.has(d))
      continue;
    let v = MAPPED[d];
    if (v) {
      h.push(...v);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${d.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...h)));
}
function nfc(l) {
  return l.normalize("NFC");
}
function consume_emoji_reversed(l, t) {
  var s;
  let h = EMOJI_ROOT, m, d, v = [], _ = l.length;
  for (t && (t.length = 0); _; ) {
    let T = l[--_];
    if (h = (s = h.branches.find((z) => z.set.has(T))) === null || s === void 0 ? void 0 : s.node, !h)
      break;
    if (h.save)
      d = T;
    else if (h.check && T === d)
      break;
    v.push(T), h.fe0f && (v.push(65039), _ > 0 && l[_ - 1] == 65039 && _--), h.valid && (m = v.slice(), h.valid == 2 && m.splice(1, 1), t && t.push(...l.slice(_).reverse()), l.length = _);
  }
  return m;
}
const logger$y = new Logger(version$j), Zeros$1 = new Uint8Array(32);
Zeros$1.fill(0);
function checkComponent(l) {
  if (l.length === 0)
    throw new Error("invalid ENS name; empty component");
  return l;
}
function ensNameSplit(l) {
  const t = toUtf8Bytes(ens_normalize(l)), s = [];
  if (l.length === 0)
    return s;
  let h = 0;
  for (let m = 0; m < t.length; m++)
    t[m] === 46 && (s.push(checkComponent(t.slice(h, m))), h = m + 1);
  if (h >= t.length)
    throw new Error("invalid ENS name; empty component");
  return s.push(checkComponent(t.slice(h))), s;
}
function ensNormalize(l) {
  return ensNameSplit(l).map((t) => toUtf8String(t)).join(".");
}
function isValidName(l) {
  try {
    return ensNameSplit(l).length !== 0;
  } catch {
  }
  return !1;
}
function namehash(l) {
  typeof l != "string" && logger$y.throwArgumentError("invalid ENS name; not a string", "name", l);
  let t = Zeros$1;
  const s = ensNameSplit(l);
  for (; s.length; )
    t = keccak256$1(concat([t, keccak256$1(s.pop())]));
  return hexlify(t);
}
function dnsEncode(l) {
  return hexlify(concat(ensNameSplit(l).map((t) => {
    if (t.length > 63)
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const s = new Uint8Array(t.length + 1);
    return s.set(t, 1), s[0] = s.length - 1, s;
  }))) + "00";
}
const messagePrefix = `Ethereum Signed Message:
`;
function hashMessage(l) {
  return typeof l == "string" && (l = toUtf8Bytes(l)), keccak256$1(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(l.length)),
    l
  ]));
}
var __awaiter$l = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$x = new Logger(version$j), padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1), Zero = BigNumber.from(0), One = BigNumber.from(1), MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(l) {
  const t = arrayify(l), s = t.length % 32;
  return s ? hexConcat([t, padding.slice(s)]) : hexlify(t);
}
const hexTrue = hexZeroPad(One.toHexString(), 32), hexFalse = hexZeroPad(Zero.toHexString(), 32), domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(l) {
  return function(t) {
    return typeof t != "string" && logger$x.throwArgumentError(`invalid domain value for ${JSON.stringify(l)}`, `domain.${l}`, t), t;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(l) {
    try {
      return BigNumber.from(l).toString();
    } catch {
    }
    return logger$x.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", l);
  },
  verifyingContract: function(l) {
    try {
      return getAddress(l).toLowerCase();
    } catch {
    }
    return logger$x.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", l);
  },
  salt: function(l) {
    try {
      const t = arrayify(l);
      if (t.length !== 32)
        throw new Error("bad length");
      return hexlify(t);
    } catch {
    }
    return logger$x.throwArgumentError('invalid domain value "salt"', "domain.salt", l);
  }
};
function getBaseEncoder(l) {
  {
    const t = l.match(/^(u?)int(\d*)$/);
    if (t) {
      const s = t[1] === "", h = parseInt(t[2] || "256");
      (h % 8 !== 0 || h > 256 || t[2] && t[2] !== String(h)) && logger$x.throwArgumentError("invalid numeric width", "type", l);
      const m = MaxUint256.mask(s ? h - 1 : h), d = s ? m.add(One).mul(NegativeOne) : Zero;
      return function(v) {
        const _ = BigNumber.from(v);
        return (_.lt(d) || _.gt(m)) && logger$x.throwArgumentError(`value out-of-bounds for ${l}`, "value", v), hexZeroPad(_.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const t = l.match(/^bytes(\d+)$/);
    if (t) {
      const s = parseInt(t[1]);
      return (s === 0 || s > 32 || t[1] !== String(s)) && logger$x.throwArgumentError("invalid bytes width", "type", l), function(h) {
        return arrayify(h).length !== s && logger$x.throwArgumentError(`invalid length for ${l}`, "value", h), hexPadRight(h);
      };
    }
  }
  switch (l) {
    case "address":
      return function(t) {
        return hexZeroPad(getAddress(t), 32);
      };
    case "bool":
      return function(t) {
        return t ? hexTrue : hexFalse;
      };
    case "bytes":
      return function(t) {
        return keccak256$1(t);
      };
    case "string":
      return function(t) {
        return id(t);
      };
  }
  return null;
}
function encodeType(l, t) {
  return `${l}(${t.map(({ name: s, type: h }) => h + " " + s).join(",")})`;
}
class TypedDataEncoder {
  constructor(t) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(t))), defineReadOnly(this, "_encoderCache", {}), defineReadOnly(this, "_types", {});
    const s = {}, h = {}, m = {};
    Object.keys(t).forEach((_) => {
      s[_] = {}, h[_] = [], m[_] = {};
    });
    for (const _ in t) {
      const T = {};
      t[_].forEach((z) => {
        T[z.name] && logger$x.throwArgumentError(`duplicate variable name ${JSON.stringify(z.name)} in ${JSON.stringify(_)}`, "types", t), T[z.name] = !0;
        const J = z.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        J === _ && logger$x.throwArgumentError(`circular type reference to ${JSON.stringify(J)}`, "types", t), !getBaseEncoder(J) && (h[J] || logger$x.throwArgumentError(`unknown type ${JSON.stringify(J)}`, "types", t), h[J].push(_), s[_][J] = !0);
      });
    }
    const d = Object.keys(h).filter((_) => h[_].length === 0);
    d.length === 0 ? logger$x.throwArgumentError("missing primary type", "types", t) : d.length > 1 && logger$x.throwArgumentError(`ambiguous primary types or unused types: ${d.map((_) => JSON.stringify(_)).join(", ")}`, "types", t), defineReadOnly(this, "primaryType", d[0]);
    function v(_, T) {
      T[_] && logger$x.throwArgumentError(`circular type reference to ${JSON.stringify(_)}`, "types", t), T[_] = !0, Object.keys(s[_]).forEach((z) => {
        !h[z] || (v(z, T), Object.keys(T).forEach((J) => {
          m[J][z] = !0;
        }));
      }), delete T[_];
    }
    v(this.primaryType, {});
    for (const _ in m) {
      const T = Object.keys(m[_]);
      T.sort(), this._types[_] = encodeType(_, t[_]) + T.map((z) => encodeType(z, t[z])).join("");
    }
  }
  getEncoder(t) {
    let s = this._encoderCache[t];
    return s || (s = this._encoderCache[t] = this._getEncoder(t)), s;
  }
  _getEncoder(t) {
    {
      const m = getBaseEncoder(t);
      if (m)
        return m;
    }
    const s = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (s) {
      const m = s[1], d = this.getEncoder(m), v = parseInt(s[3]);
      return (_) => {
        v >= 0 && _.length !== v && logger$x.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", _);
        let T = _.map(d);
        return this._types[m] && (T = T.map(keccak256$1)), keccak256$1(hexConcat(T));
      };
    }
    const h = this.types[t];
    if (h) {
      const m = id(this._types[t]);
      return (d) => {
        const v = h.map(({ name: _, type: T }) => {
          const z = this.getEncoder(T)(d[_]);
          return this._types[T] ? keccak256$1(z) : z;
        });
        return v.unshift(m), hexConcat(v);
      };
    }
    return logger$x.throwArgumentError(`unknown type: ${t}`, "type", t);
  }
  encodeType(t) {
    const s = this._types[t];
    return s || logger$x.throwArgumentError(`unknown type: ${JSON.stringify(t)}`, "name", t), s;
  }
  encodeData(t, s) {
    return this.getEncoder(t)(s);
  }
  hashStruct(t, s) {
    return keccak256$1(this.encodeData(t, s));
  }
  encode(t) {
    return this.encodeData(this.primaryType, t);
  }
  hash(t) {
    return this.hashStruct(this.primaryType, t);
  }
  _visit(t, s, h) {
    if (getBaseEncoder(t))
      return h(t, s);
    const m = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (m) {
      const v = m[1], _ = parseInt(m[3]);
      return _ >= 0 && s.length !== _ && logger$x.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", s), s.map((T) => this._visit(v, T, h));
    }
    const d = this.types[t];
    return d ? d.reduce((v, { name: _, type: T }) => (v[_] = this._visit(T, s[_], h), v), {}) : logger$x.throwArgumentError(`unknown type: ${t}`, "type", t);
  }
  visit(t, s) {
    return this._visit(this.primaryType, t, s);
  }
  static from(t) {
    return new TypedDataEncoder(t);
  }
  static getPrimaryType(t) {
    return TypedDataEncoder.from(t).primaryType;
  }
  static hashStruct(t, s, h) {
    return TypedDataEncoder.from(s).hashStruct(t, h);
  }
  static hashDomain(t) {
    const s = [];
    for (const h in t) {
      const m = domainFieldTypes[h];
      m || logger$x.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(h)}`, "domain", t), s.push({ name: h, type: m });
    }
    return s.sort((h, m) => domainFieldNames.indexOf(h.name) - domainFieldNames.indexOf(m.name)), TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: s }, t);
  }
  static encode(t, s, h) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(t),
      TypedDataEncoder.from(s).hash(h)
    ]);
  }
  static hash(t, s, h) {
    return keccak256$1(TypedDataEncoder.encode(t, s, h));
  }
  static resolveNames(t, s, h, m) {
    return __awaiter$l(this, void 0, void 0, function* () {
      t = shallowCopy(t);
      const d = {};
      t.verifyingContract && !isHexString$2(t.verifyingContract, 20) && (d[t.verifyingContract] = "0x");
      const v = TypedDataEncoder.from(s);
      v.visit(h, (_, T) => (_ === "address" && !isHexString$2(T, 20) && (d[T] = "0x"), T));
      for (const _ in d)
        d[_] = yield m(_);
      return t.verifyingContract && d[t.verifyingContract] && (t.verifyingContract = d[t.verifyingContract]), h = v.visit(h, (_, T) => _ === "address" && d[T] ? d[T] : T), { domain: t, value: h };
    });
  }
  static getPayload(t, s, h) {
    TypedDataEncoder.hashDomain(t);
    const m = {}, d = [];
    domainFieldNames.forEach((T) => {
      const z = t[T];
      z != null && (m[T] = domainChecks[T](z), d.push({ name: T, type: domainFieldTypes[T] }));
    });
    const v = TypedDataEncoder.from(s), _ = shallowCopy(s);
    return _.EIP712Domain ? logger$x.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", s) : _.EIP712Domain = d, v.encode(h), {
      types: _,
      domain: m,
      primaryType: v.primaryType,
      message: v.visit(h, (T, z) => {
        if (T.match(/^bytes(\d*)/))
          return hexlify(arrayify(z));
        if (T.match(/^u?int/))
          return BigNumber.from(z).toString();
        switch (T) {
          case "address":
            return z.toLowerCase();
          case "bool":
            return !!z;
          case "string":
            return typeof z != "string" && logger$x.throwArgumentError("invalid string", "value", z), z;
        }
        return logger$x.throwArgumentError("unsupported type", "type", T);
      })
    };
  }
}
var lib_esm$d = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _TypedDataEncoder: TypedDataEncoder,
  dnsEncode,
  ensNormalize,
  hashMessage,
  id,
  isValidName,
  messagePrefix,
  namehash
});
const logger$w = new Logger(version$n);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(t) {
    return !!(t && t._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(l, t) {
  const s = new Error(`deferred error during ABI decoding triggered accessing ${l}`);
  return s.error = t, s;
}
class Interface {
  constructor(t) {
    let s = [];
    typeof t == "string" ? s = JSON.parse(t) : s = t, defineReadOnly(this, "fragments", s.map((h) => Fragment.from(h)).filter((h) => h != null)), defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")()), defineReadOnly(this, "functions", {}), defineReadOnly(this, "errors", {}), defineReadOnly(this, "events", {}), defineReadOnly(this, "structs", {}), this.fragments.forEach((h) => {
      let m = null;
      switch (h.type) {
        case "constructor":
          if (this.deploy) {
            logger$w.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", h);
          return;
        case "function":
          m = this.functions;
          break;
        case "event":
          m = this.events;
          break;
        case "error":
          m = this.errors;
          break;
        default:
          return;
      }
      let d = h.format();
      if (m[d]) {
        logger$w.warn("duplicate definition - " + d);
        return;
      }
      m[d] = h;
    }), this.deploy || defineReadOnly(this, "deploy", ConstructorFragment.from({
      payable: !1,
      type: "constructor"
    })), defineReadOnly(this, "_isInterface", !0);
  }
  format(t) {
    t || (t = FormatTypes.full), t === FormatTypes.sighash && logger$w.throwArgumentError("interface does not support formatting sighash", "format", t);
    const s = this.fragments.map((h) => h.format(t));
    return t === FormatTypes.json ? JSON.stringify(s.map((h) => JSON.parse(h))) : s;
  }
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(t) {
    return getAddress(t);
  }
  static getSighash(t) {
    return hexDataSlice(id(t.format()), 0, 4);
  }
  static getEventTopic(t) {
    return id(t.format());
  }
  getFunction(t) {
    if (isHexString$2(t)) {
      for (const h in this.functions)
        if (t === this.getSighash(h))
          return this.functions[h];
      logger$w.throwArgumentError("no matching function", "sighash", t);
    }
    if (t.indexOf("(") === -1) {
      const h = t.trim(), m = Object.keys(this.functions).filter((d) => d.split("(")[0] === h);
      return m.length === 0 ? logger$w.throwArgumentError("no matching function", "name", h) : m.length > 1 && logger$w.throwArgumentError("multiple matching functions", "name", h), this.functions[m[0]];
    }
    const s = this.functions[FunctionFragment.fromString(t).format()];
    return s || logger$w.throwArgumentError("no matching function", "signature", t), s;
  }
  getEvent(t) {
    if (isHexString$2(t)) {
      const h = t.toLowerCase();
      for (const m in this.events)
        if (h === this.getEventTopic(m))
          return this.events[m];
      logger$w.throwArgumentError("no matching event", "topichash", h);
    }
    if (t.indexOf("(") === -1) {
      const h = t.trim(), m = Object.keys(this.events).filter((d) => d.split("(")[0] === h);
      return m.length === 0 ? logger$w.throwArgumentError("no matching event", "name", h) : m.length > 1 && logger$w.throwArgumentError("multiple matching events", "name", h), this.events[m[0]];
    }
    const s = this.events[EventFragment.fromString(t).format()];
    return s || logger$w.throwArgumentError("no matching event", "signature", t), s;
  }
  getError(t) {
    if (isHexString$2(t)) {
      const h = getStatic(this.constructor, "getSighash");
      for (const m in this.errors) {
        const d = this.errors[m];
        if (t === h(d))
          return this.errors[m];
      }
      logger$w.throwArgumentError("no matching error", "sighash", t);
    }
    if (t.indexOf("(") === -1) {
      const h = t.trim(), m = Object.keys(this.errors).filter((d) => d.split("(")[0] === h);
      return m.length === 0 ? logger$w.throwArgumentError("no matching error", "name", h) : m.length > 1 && logger$w.throwArgumentError("multiple matching errors", "name", h), this.errors[m[0]];
    }
    const s = this.errors[FunctionFragment.fromString(t).format()];
    return s || logger$w.throwArgumentError("no matching error", "signature", t), s;
  }
  getSighash(t) {
    if (typeof t == "string")
      try {
        t = this.getFunction(t);
      } catch (s) {
        try {
          t = this.getError(t);
        } catch {
          throw s;
        }
      }
    return getStatic(this.constructor, "getSighash")(t);
  }
  getEventTopic(t) {
    return typeof t == "string" && (t = this.getEvent(t)), getStatic(this.constructor, "getEventTopic")(t);
  }
  _decodeParams(t, s) {
    return this._abiCoder.decode(t, s);
  }
  _encodeParams(t, s) {
    return this._abiCoder.encode(t, s);
  }
  encodeDeploy(t) {
    return this._encodeParams(this.deploy.inputs, t || []);
  }
  decodeErrorResult(t, s) {
    typeof t == "string" && (t = this.getError(t));
    const h = arrayify(s);
    return hexlify(h.slice(0, 4)) !== this.getSighash(t) && logger$w.throwArgumentError(`data signature does not match error ${t.name}.`, "data", hexlify(h)), this._decodeParams(t.inputs, h.slice(4));
  }
  encodeErrorResult(t, s) {
    return typeof t == "string" && (t = this.getError(t)), hexlify(concat([
      this.getSighash(t),
      this._encodeParams(t.inputs, s || [])
    ]));
  }
  decodeFunctionData(t, s) {
    typeof t == "string" && (t = this.getFunction(t));
    const h = arrayify(s);
    return hexlify(h.slice(0, 4)) !== this.getSighash(t) && logger$w.throwArgumentError(`data signature does not match function ${t.name}.`, "data", hexlify(h)), this._decodeParams(t.inputs, h.slice(4));
  }
  encodeFunctionData(t, s) {
    return typeof t == "string" && (t = this.getFunction(t)), hexlify(concat([
      this.getSighash(t),
      this._encodeParams(t.inputs, s || [])
    ]));
  }
  decodeFunctionResult(t, s) {
    typeof t == "string" && (t = this.getFunction(t));
    let h = arrayify(s), m = null, d = "", v = null, _ = null, T = null;
    switch (h.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(t.outputs, h);
        } catch {
        }
        break;
      case 4: {
        const z = hexlify(h.slice(0, 4)), J = BuiltinErrors[z];
        if (J)
          v = this._abiCoder.decode(J.inputs, h.slice(4)), _ = J.name, T = J.signature, J.reason && (m = v[0]), _ === "Error" ? d = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(v[0])}` : _ === "Panic" && (d = `; VM Exception while processing transaction: reverted with panic code ${v[0]}`);
        else
          try {
            const Y = this.getError(z);
            v = this._abiCoder.decode(Y.inputs, h.slice(4)), _ = Y.name, T = Y.format();
          } catch {
          }
        break;
      }
    }
    return logger$w.throwError("call revert exception" + d, Logger.errors.CALL_EXCEPTION, {
      method: t.format(),
      data: hexlify(s),
      errorArgs: v,
      errorName: _,
      errorSignature: T,
      reason: m
    });
  }
  encodeFunctionResult(t, s) {
    return typeof t == "string" && (t = this.getFunction(t)), hexlify(this._abiCoder.encode(t.outputs, s || []));
  }
  encodeFilterTopics(t, s) {
    typeof t == "string" && (t = this.getEvent(t)), s.length > t.inputs.length && logger$w.throwError("too many arguments for " + t.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
      argument: "values",
      value: s
    });
    let h = [];
    t.anonymous || h.push(this.getEventTopic(t));
    const m = (d, v) => d.type === "string" ? id(v) : d.type === "bytes" ? keccak256$1(hexlify(v)) : (d.type === "bool" && typeof v == "boolean" && (v = v ? "0x01" : "0x00"), d.type.match(/^u?int/) && (v = BigNumber.from(v).toHexString()), d.type === "address" && this._abiCoder.encode(["address"], [v]), hexZeroPad(hexlify(v), 32));
    for (s.forEach((d, v) => {
      let _ = t.inputs[v];
      if (!_.indexed) {
        d != null && logger$w.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + _.name, d);
        return;
      }
      d == null ? h.push(null) : _.baseType === "array" || _.baseType === "tuple" ? logger$w.throwArgumentError("filtering with tuples or arrays not supported", "contract." + _.name, d) : Array.isArray(d) ? h.push(d.map((T) => m(_, T))) : h.push(m(_, d));
    }); h.length && h[h.length - 1] === null; )
      h.pop();
    return h;
  }
  encodeEventLog(t, s) {
    typeof t == "string" && (t = this.getEvent(t));
    const h = [], m = [], d = [];
    return t.anonymous || h.push(this.getEventTopic(t)), s.length !== t.inputs.length && logger$w.throwArgumentError("event arguments/values mismatch", "values", s), t.inputs.forEach((v, _) => {
      const T = s[_];
      if (v.indexed)
        if (v.type === "string")
          h.push(id(T));
        else if (v.type === "bytes")
          h.push(keccak256$1(T));
        else {
          if (v.baseType === "tuple" || v.baseType === "array")
            throw new Error("not implemented");
          h.push(this._abiCoder.encode([v.type], [T]));
        }
      else
        m.push(v), d.push(T);
    }), {
      data: this._abiCoder.encode(m, d),
      topics: h
    };
  }
  decodeEventLog(t, s, h) {
    if (typeof t == "string" && (t = this.getEvent(t)), h != null && !t.anonymous) {
      let ie = this.getEventTopic(t);
      (!isHexString$2(h[0], 32) || h[0].toLowerCase() !== ie) && logger$w.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: ie, value: h[0] }), h = h.slice(1);
    }
    let m = [], d = [], v = [];
    t.inputs.forEach((ie, ne) => {
      ie.indexed ? ie.type === "string" || ie.type === "bytes" || ie.baseType === "tuple" || ie.baseType === "array" ? (m.push(ParamType.fromObject({ type: "bytes32", name: ie.name })), v.push(!0)) : (m.push(ie), v.push(!1)) : (d.push(ie), v.push(!1));
    });
    let _ = h != null ? this._abiCoder.decode(m, concat(h)) : null, T = this._abiCoder.decode(d, s, !0), z = [], J = 0, Y = 0;
    t.inputs.forEach((ie, ne) => {
      if (ie.indexed)
        if (_ == null)
          z[ne] = new Indexed({ _isIndexed: !0, hash: null });
        else if (v[ne])
          z[ne] = new Indexed({ _isIndexed: !0, hash: _[Y++] });
        else
          try {
            z[ne] = _[Y++];
          } catch (de) {
            z[ne] = de;
          }
      else
        try {
          z[ne] = T[J++];
        } catch (de) {
          z[ne] = de;
        }
      if (ie.name && z[ie.name] == null) {
        const de = z[ne];
        de instanceof Error ? Object.defineProperty(z, ie.name, {
          enumerable: !0,
          get: () => {
            throw wrapAccessError(`property ${JSON.stringify(ie.name)}`, de);
          }
        }) : z[ie.name] = de;
      }
    });
    for (let ie = 0; ie < z.length; ie++) {
      const ne = z[ie];
      ne instanceof Error && Object.defineProperty(z, ie, {
        enumerable: !0,
        get: () => {
          throw wrapAccessError(`index ${ie}`, ne);
        }
      });
    }
    return Object.freeze(z);
  }
  parseTransaction(t) {
    let s = this.getFunction(t.data.substring(0, 10).toLowerCase());
    return s ? new TransactionDescription({
      args: this._abiCoder.decode(s.inputs, "0x" + t.data.substring(10)),
      functionFragment: s,
      name: s.name,
      signature: s.format(),
      sighash: this.getSighash(s),
      value: BigNumber.from(t.value || "0")
    }) : null;
  }
  parseLog(t) {
    let s = this.getEvent(t.topics[0]);
    return !s || s.anonymous ? null : new LogDescription({
      eventFragment: s,
      name: s.name,
      signature: s.format(),
      topic: this.getEventTopic(s),
      args: this.decodeEventLog(s, t.data, t.topics)
    });
  }
  parseError(t) {
    const s = hexlify(t);
    let h = this.getError(s.substring(0, 10).toLowerCase());
    return h ? new ErrorDescription({
      args: this._abiCoder.decode(h.inputs, "0x" + s.substring(10)),
      errorFragment: h,
      name: h.name,
      signature: h.format(),
      sighash: this.getSighash(h)
    }) : null;
  }
  static isInterface(t) {
    return !!(t && t._isInterface);
  }
}
var lib_esm$c = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AbiCoder,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  FormatTypes,
  Fragment,
  FunctionFragment,
  Indexed,
  Interface,
  LogDescription,
  ParamType,
  TransactionDescription,
  checkResultErrors,
  defaultAbiCoder
});
const version$i = "abstract-provider/5.7.0";
var __awaiter$k = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$v = new Logger(version$i);
class ForkEvent extends Description {
  static isForkEvent(t) {
    return !!(t && t._isForkEvent);
  }
}
let Provider$1 = class {
  constructor() {
    logger$v.checkAbstract(new.target, Provider$1), defineReadOnly(this, "_isProvider", !0);
  }
  getFeeData() {
    return __awaiter$k(this, void 0, void 0, function* () {
      const { block: t, gasPrice: s } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((v) => null)
      });
      let h = null, m = null, d = null;
      return t && t.baseFeePerGas && (h = t.baseFeePerGas, d = BigNumber.from("1500000000"), m = t.baseFeePerGas.mul(2).add(d)), { lastBaseFeePerGas: h, maxFeePerGas: m, maxPriorityFeePerGas: d, gasPrice: s };
    });
  }
  addListener(t, s) {
    return this.on(t, s);
  }
  removeListener(t, s) {
    return this.off(t, s);
  }
  static isProvider(t) {
    return !!(t && t._isProvider);
  }
};
const version$h = "abstract-signer/5.7.0";
var __awaiter$j = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$u = new Logger(version$h), allowedTransactionKeys$3 = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
], forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
let Signer$1 = class {
  constructor() {
    logger$u.checkAbstract(new.target, Signer$1), defineReadOnly(this, "_isSigner", !0);
  }
  getBalance(t) {
    return __awaiter$j(this, void 0, void 0, function* () {
      return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), t);
    });
  }
  getTransactionCount(t) {
    return __awaiter$j(this, void 0, void 0, function* () {
      return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), t);
    });
  }
  estimateGas(t) {
    return __awaiter$j(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const s = yield resolveProperties(this.checkTransaction(t));
      return yield this.provider.estimateGas(s);
    });
  }
  call(t, s) {
    return __awaiter$j(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const h = yield resolveProperties(this.checkTransaction(t));
      return yield this.provider.call(h, s);
    });
  }
  sendTransaction(t) {
    return __awaiter$j(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const s = yield this.populateTransaction(t), h = yield this.signTransaction(s);
      return yield this.provider.sendTransaction(h);
    });
  }
  getChainId() {
    return __awaiter$j(this, void 0, void 0, function* () {
      return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId;
    });
  }
  getGasPrice() {
    return __awaiter$j(this, void 0, void 0, function* () {
      return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$j(this, void 0, void 0, function* () {
      return this._checkProvider("getFeeData"), yield this.provider.getFeeData();
    });
  }
  resolveName(t) {
    return __awaiter$j(this, void 0, void 0, function* () {
      return this._checkProvider("resolveName"), yield this.provider.resolveName(t);
    });
  }
  checkTransaction(t) {
    for (const h in t)
      allowedTransactionKeys$3.indexOf(h) === -1 && logger$u.throwArgumentError("invalid transaction key: " + h, "transaction", t);
    const s = shallowCopy(t);
    return s.from == null ? s.from = this.getAddress() : s.from = Promise.all([
      Promise.resolve(s.from),
      this.getAddress()
    ]).then((h) => (h[0].toLowerCase() !== h[1].toLowerCase() && logger$u.throwArgumentError("from address mismatch", "transaction", t), h[0])), s;
  }
  populateTransaction(t) {
    return __awaiter$j(this, void 0, void 0, function* () {
      const s = yield resolveProperties(this.checkTransaction(t));
      s.to != null && (s.to = Promise.resolve(s.to).then((m) => __awaiter$j(this, void 0, void 0, function* () {
        if (m == null)
          return null;
        const d = yield this.resolveName(m);
        return d == null && logger$u.throwArgumentError("provided ENS name resolves to null", "tx.to", m), d;
      })), s.to.catch((m) => {
      }));
      const h = s.maxFeePerGas != null || s.maxPriorityFeePerGas != null;
      if (s.gasPrice != null && (s.type === 2 || h) ? logger$u.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", t) : (s.type === 0 || s.type === 1) && h && logger$u.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", t), (s.type === 2 || s.type == null) && s.maxFeePerGas != null && s.maxPriorityFeePerGas != null)
        s.type = 2;
      else if (s.type === 0 || s.type === 1)
        s.gasPrice == null && (s.gasPrice = this.getGasPrice());
      else {
        const m = yield this.getFeeData();
        if (s.type == null)
          if (m.maxFeePerGas != null && m.maxPriorityFeePerGas != null)
            if (s.type = 2, s.gasPrice != null) {
              const d = s.gasPrice;
              delete s.gasPrice, s.maxFeePerGas = d, s.maxPriorityFeePerGas = d;
            } else
              s.maxFeePerGas == null && (s.maxFeePerGas = m.maxFeePerGas), s.maxPriorityFeePerGas == null && (s.maxPriorityFeePerGas = m.maxPriorityFeePerGas);
          else
            m.gasPrice != null ? (h && logger$u.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "populateTransaction"
            }), s.gasPrice == null && (s.gasPrice = m.gasPrice), s.type = 0) : logger$u.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
        else
          s.type === 2 && (s.maxFeePerGas == null && (s.maxFeePerGas = m.maxFeePerGas), s.maxPriorityFeePerGas == null && (s.maxPriorityFeePerGas = m.maxPriorityFeePerGas));
      }
      return s.nonce == null && (s.nonce = this.getTransactionCount("pending")), s.gasLimit == null && (s.gasLimit = this.estimateGas(s).catch((m) => {
        if (forwardErrors.indexOf(m.code) >= 0)
          throw m;
        return logger$u.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
          error: m,
          tx: s
        });
      })), s.chainId == null ? s.chainId = this.getChainId() : s.chainId = Promise.all([
        Promise.resolve(s.chainId),
        this.getChainId()
      ]).then((m) => (m[1] !== 0 && m[0] !== m[1] && logger$u.throwArgumentError("chainId address mismatch", "transaction", t), m[0])), yield resolveProperties(s);
    });
  }
  _checkProvider(t) {
    this.provider || logger$u.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: t || "_checkProvider"
    });
  }
  static isSigner(t) {
    return !!(t && t._isSigner);
  }
};
class VoidSigner extends Signer$1 {
  constructor(t, s) {
    super(), defineReadOnly(this, "address", t), defineReadOnly(this, "provider", s || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(t, s) {
    return Promise.resolve().then(() => {
      logger$u.throwError(t, Logger.errors.UNSUPPORTED_OPERATION, { operation: s });
    });
  }
  signMessage(t) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(t) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(t, s, h) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(t) {
    return new VoidSigner(this.address, t);
  }
}
var bn$4 = { exports: {} };
(function(l) {
  (function(t, s) {
    function h(k, p) {
      if (!k)
        throw new Error(p || "Assertion failed");
    }
    function m(k, p) {
      k.super_ = p;
      var x = function() {
      };
      x.prototype = p.prototype, k.prototype = new x(), k.prototype.constructor = k;
    }
    function d(k, p, x) {
      if (d.isBN(k))
        return k;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, k !== null && ((p === "le" || p === "be") && (x = p, p = 10), this._init(k || 0, p || 10, x || "be"));
    }
    typeof t == "object" ? t.exports = d : s.BN = d, d.BN = d, d.wordSize = 26;
    var v;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? v = window.Buffer : v = require$$0$5.Buffer;
    } catch {
    }
    d.isBN = function(p) {
      return p instanceof d ? !0 : p !== null && typeof p == "object" && p.constructor.wordSize === d.wordSize && Array.isArray(p.words);
    }, d.max = function(p, x) {
      return p.cmp(x) > 0 ? p : x;
    }, d.min = function(p, x) {
      return p.cmp(x) < 0 ? p : x;
    }, d.prototype._init = function(p, x, S) {
      if (typeof p == "number")
        return this._initNumber(p, x, S);
      if (typeof p == "object")
        return this._initArray(p, x, S);
      x === "hex" && (x = 16), h(x === (x | 0) && x >= 2 && x <= 36), p = p.toString().replace(/\s+/g, "");
      var B = 0;
      p[0] === "-" && (B++, this.negative = 1), B < p.length && (x === 16 ? this._parseHex(p, B, S) : (this._parseBase(p, x, B), S === "le" && this._initArray(this.toArray(), x, S)));
    }, d.prototype._initNumber = function(p, x, S) {
      p < 0 && (this.negative = 1, p = -p), p < 67108864 ? (this.words = [p & 67108863], this.length = 1) : p < 4503599627370496 ? (this.words = [
        p & 67108863,
        p / 67108864 & 67108863
      ], this.length = 2) : (h(p < 9007199254740992), this.words = [
        p & 67108863,
        p / 67108864 & 67108863,
        1
      ], this.length = 3), S === "le" && this._initArray(this.toArray(), x, S);
    }, d.prototype._initArray = function(p, x, S) {
      if (h(typeof p.length == "number"), p.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(p.length / 3), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var L, C, G = 0;
      if (S === "be")
        for (B = p.length - 1, L = 0; B >= 0; B -= 3)
          C = p[B] | p[B - 1] << 8 | p[B - 2] << 16, this.words[L] |= C << G & 67108863, this.words[L + 1] = C >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, L++);
      else if (S === "le")
        for (B = 0, L = 0; B < p.length; B += 3)
          C = p[B] | p[B + 1] << 8 | p[B + 2] << 16, this.words[L] |= C << G & 67108863, this.words[L + 1] = C >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, L++);
      return this._strip();
    };
    function _(k, p) {
      var x = k.charCodeAt(p);
      if (x >= 48 && x <= 57)
        return x - 48;
      if (x >= 65 && x <= 70)
        return x - 55;
      if (x >= 97 && x <= 102)
        return x - 87;
      h(!1, "Invalid character in " + k);
    }
    function T(k, p, x) {
      var S = _(k, x);
      return x - 1 >= p && (S |= _(k, x - 1) << 4), S;
    }
    d.prototype._parseHex = function(p, x, S) {
      this.length = Math.ceil((p.length - x) / 6), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var L = 0, C = 0, G;
      if (S === "be")
        for (B = p.length - 1; B >= x; B -= 2)
          G = T(p, x, B) << L, this.words[C] |= G & 67108863, L >= 18 ? (L -= 18, C += 1, this.words[C] |= G >>> 26) : L += 8;
      else {
        var R = p.length - x;
        for (B = R % 2 === 0 ? x + 1 : x; B < p.length; B += 2)
          G = T(p, x, B) << L, this.words[C] |= G & 67108863, L >= 18 ? (L -= 18, C += 1, this.words[C] |= G >>> 26) : L += 8;
      }
      this._strip();
    };
    function z(k, p, x, S) {
      for (var B = 0, L = 0, C = Math.min(k.length, x), G = p; G < C; G++) {
        var R = k.charCodeAt(G) - 48;
        B *= S, R >= 49 ? L = R - 49 + 10 : R >= 17 ? L = R - 17 + 10 : L = R, h(R >= 0 && L < S, "Invalid character"), B += L;
      }
      return B;
    }
    d.prototype._parseBase = function(p, x, S) {
      this.words = [0], this.length = 1;
      for (var B = 0, L = 1; L <= 67108863; L *= x)
        B++;
      B--, L = L / x | 0;
      for (var C = p.length - S, G = C % B, R = Math.min(C, C - G) + S, y = 0, j = S; j < R; j += B)
        y = z(p, j, j + B, x), this.imuln(L), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      if (G !== 0) {
        var ye = 1;
        for (y = z(p, j, p.length, x), j = 0; j < G; j++)
          ye *= x;
        this.imuln(ye), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      }
      this._strip();
    }, d.prototype.copy = function(p) {
      p.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        p.words[x] = this.words[x];
      p.length = this.length, p.negative = this.negative, p.red = this.red;
    };
    function J(k, p) {
      k.words = p.words, k.length = p.length, k.negative = p.negative, k.red = p.red;
    }
    if (d.prototype._move = function(p) {
      J(p, this);
    }, d.prototype.clone = function() {
      var p = new d(null);
      return this.copy(p), p;
    }, d.prototype._expand = function(p) {
      for (; this.length < p; )
        this.words[this.length++] = 0;
      return this;
    }, d.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, d.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        d.prototype[Symbol.for("nodejs.util.inspect.custom")] = Y;
      } catch {
        d.prototype.inspect = Y;
      }
    else
      d.prototype.inspect = Y;
    function Y() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var ie = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ne = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], de = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    d.prototype.toString = function(p, x) {
      p = p || 10, x = x | 0 || 1;
      var S;
      if (p === 16 || p === "hex") {
        S = "";
        for (var B = 0, L = 0, C = 0; C < this.length; C++) {
          var G = this.words[C], R = ((G << B | L) & 16777215).toString(16);
          L = G >>> 24 - B & 16777215, B += 2, B >= 26 && (B -= 26, C--), L !== 0 || C !== this.length - 1 ? S = ie[6 - R.length] + R + S : S = R + S;
        }
        for (L !== 0 && (S = L.toString(16) + S); S.length % x !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      if (p === (p | 0) && p >= 2 && p <= 36) {
        var y = ne[p], j = de[p];
        S = "";
        var ye = this.clone();
        for (ye.negative = 0; !ye.isZero(); ) {
          var ee = ye.modrn(j).toString(p);
          ye = ye.idivn(j), ye.isZero() ? S = ee + S : S = ie[y - ee.length] + ee + S;
        }
        for (this.isZero() && (S = "0" + S); S.length % x !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      h(!1, "Base should be between 2 and 36");
    }, d.prototype.toNumber = function() {
      var p = this.words[0];
      return this.length === 2 ? p += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? p += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && h(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -p : p;
    }, d.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, v && (d.prototype.toBuffer = function(p, x) {
      return this.toArrayLike(v, p, x);
    }), d.prototype.toArray = function(p, x) {
      return this.toArrayLike(Array, p, x);
    };
    var ce = function(p, x) {
      return p.allocUnsafe ? p.allocUnsafe(x) : new p(x);
    };
    d.prototype.toArrayLike = function(p, x, S) {
      this._strip();
      var B = this.byteLength(), L = S || Math.max(1, B);
      h(B <= L, "byte array longer than desired length"), h(L > 0, "Requested array length <= 0");
      var C = ce(p, L), G = x === "le" ? "LE" : "BE";
      return this["_toArrayLike" + G](C, B), C;
    }, d.prototype._toArrayLikeLE = function(p, x) {
      for (var S = 0, B = 0, L = 0, C = 0; L < this.length; L++) {
        var G = this.words[L] << C | B;
        p[S++] = G & 255, S < p.length && (p[S++] = G >> 8 & 255), S < p.length && (p[S++] = G >> 16 & 255), C === 6 ? (S < p.length && (p[S++] = G >> 24 & 255), B = 0, C = 0) : (B = G >>> 24, C += 2);
      }
      if (S < p.length)
        for (p[S++] = B; S < p.length; )
          p[S++] = 0;
    }, d.prototype._toArrayLikeBE = function(p, x) {
      for (var S = p.length - 1, B = 0, L = 0, C = 0; L < this.length; L++) {
        var G = this.words[L] << C | B;
        p[S--] = G & 255, S >= 0 && (p[S--] = G >> 8 & 255), S >= 0 && (p[S--] = G >> 16 & 255), C === 6 ? (S >= 0 && (p[S--] = G >> 24 & 255), B = 0, C = 0) : (B = G >>> 24, C += 2);
      }
      if (S >= 0)
        for (p[S--] = B; S >= 0; )
          p[S--] = 0;
    }, Math.clz32 ? d.prototype._countBits = function(p) {
      return 32 - Math.clz32(p);
    } : d.prototype._countBits = function(p) {
      var x = p, S = 0;
      return x >= 4096 && (S += 13, x >>>= 13), x >= 64 && (S += 7, x >>>= 7), x >= 8 && (S += 4, x >>>= 4), x >= 2 && (S += 2, x >>>= 2), S + x;
    }, d.prototype._zeroBits = function(p) {
      if (p === 0)
        return 26;
      var x = p, S = 0;
      return (x & 8191) === 0 && (S += 13, x >>>= 13), (x & 127) === 0 && (S += 7, x >>>= 7), (x & 15) === 0 && (S += 4, x >>>= 4), (x & 3) === 0 && (S += 2, x >>>= 2), (x & 1) === 0 && S++, S;
    }, d.prototype.bitLength = function() {
      var p = this.words[this.length - 1], x = this._countBits(p);
      return (this.length - 1) * 26 + x;
    };
    function re(k) {
      for (var p = new Array(k.bitLength()), x = 0; x < p.length; x++) {
        var S = x / 26 | 0, B = x % 26;
        p[x] = k.words[S] >>> B & 1;
      }
      return p;
    }
    d.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var p = 0, x = 0; x < this.length; x++) {
        var S = this._zeroBits(this.words[x]);
        if (p += S, S !== 26)
          break;
      }
      return p;
    }, d.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, d.prototype.toTwos = function(p) {
      return this.negative !== 0 ? this.abs().inotn(p).iaddn(1) : this.clone();
    }, d.prototype.fromTwos = function(p) {
      return this.testn(p - 1) ? this.notn(p).iaddn(1).ineg() : this.clone();
    }, d.prototype.isNeg = function() {
      return this.negative !== 0;
    }, d.prototype.neg = function() {
      return this.clone().ineg();
    }, d.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, d.prototype.iuor = function(p) {
      for (; this.length < p.length; )
        this.words[this.length++] = 0;
      for (var x = 0; x < p.length; x++)
        this.words[x] = this.words[x] | p.words[x];
      return this._strip();
    }, d.prototype.ior = function(p) {
      return h((this.negative | p.negative) === 0), this.iuor(p);
    }, d.prototype.or = function(p) {
      return this.length > p.length ? this.clone().ior(p) : p.clone().ior(this);
    }, d.prototype.uor = function(p) {
      return this.length > p.length ? this.clone().iuor(p) : p.clone().iuor(this);
    }, d.prototype.iuand = function(p) {
      var x;
      this.length > p.length ? x = p : x = this;
      for (var S = 0; S < x.length; S++)
        this.words[S] = this.words[S] & p.words[S];
      return this.length = x.length, this._strip();
    }, d.prototype.iand = function(p) {
      return h((this.negative | p.negative) === 0), this.iuand(p);
    }, d.prototype.and = function(p) {
      return this.length > p.length ? this.clone().iand(p) : p.clone().iand(this);
    }, d.prototype.uand = function(p) {
      return this.length > p.length ? this.clone().iuand(p) : p.clone().iuand(this);
    }, d.prototype.iuxor = function(p) {
      var x, S;
      this.length > p.length ? (x = this, S = p) : (x = p, S = this);
      for (var B = 0; B < S.length; B++)
        this.words[B] = x.words[B] ^ S.words[B];
      if (this !== x)
        for (; B < x.length; B++)
          this.words[B] = x.words[B];
      return this.length = x.length, this._strip();
    }, d.prototype.ixor = function(p) {
      return h((this.negative | p.negative) === 0), this.iuxor(p);
    }, d.prototype.xor = function(p) {
      return this.length > p.length ? this.clone().ixor(p) : p.clone().ixor(this);
    }, d.prototype.uxor = function(p) {
      return this.length > p.length ? this.clone().iuxor(p) : p.clone().iuxor(this);
    }, d.prototype.inotn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = Math.ceil(p / 26) | 0, S = p % 26;
      this._expand(x), S > 0 && x--;
      for (var B = 0; B < x; B++)
        this.words[B] = ~this.words[B] & 67108863;
      return S > 0 && (this.words[B] = ~this.words[B] & 67108863 >> 26 - S), this._strip();
    }, d.prototype.notn = function(p) {
      return this.clone().inotn(p);
    }, d.prototype.setn = function(p, x) {
      h(typeof p == "number" && p >= 0);
      var S = p / 26 | 0, B = p % 26;
      return this._expand(S + 1), x ? this.words[S] = this.words[S] | 1 << B : this.words[S] = this.words[S] & ~(1 << B), this._strip();
    }, d.prototype.iadd = function(p) {
      var x;
      if (this.negative !== 0 && p.negative === 0)
        return this.negative = 0, x = this.isub(p), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && p.negative !== 0)
        return p.negative = 0, x = this.isub(p), p.negative = 1, x._normSign();
      var S, B;
      this.length > p.length ? (S = this, B = p) : (S = p, B = this);
      for (var L = 0, C = 0; C < B.length; C++)
        x = (S.words[C] | 0) + (B.words[C] | 0) + L, this.words[C] = x & 67108863, L = x >>> 26;
      for (; L !== 0 && C < S.length; C++)
        x = (S.words[C] | 0) + L, this.words[C] = x & 67108863, L = x >>> 26;
      if (this.length = S.length, L !== 0)
        this.words[this.length] = L, this.length++;
      else if (S !== this)
        for (; C < S.length; C++)
          this.words[C] = S.words[C];
      return this;
    }, d.prototype.add = function(p) {
      var x;
      return p.negative !== 0 && this.negative === 0 ? (p.negative = 0, x = this.sub(p), p.negative ^= 1, x) : p.negative === 0 && this.negative !== 0 ? (this.negative = 0, x = p.sub(this), this.negative = 1, x) : this.length > p.length ? this.clone().iadd(p) : p.clone().iadd(this);
    }, d.prototype.isub = function(p) {
      if (p.negative !== 0) {
        p.negative = 0;
        var x = this.iadd(p);
        return p.negative = 1, x._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(p), this.negative = 1, this._normSign();
      var S = this.cmp(p);
      if (S === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var B, L;
      S > 0 ? (B = this, L = p) : (B = p, L = this);
      for (var C = 0, G = 0; G < L.length; G++)
        x = (B.words[G] | 0) - (L.words[G] | 0) + C, C = x >> 26, this.words[G] = x & 67108863;
      for (; C !== 0 && G < B.length; G++)
        x = (B.words[G] | 0) + C, C = x >> 26, this.words[G] = x & 67108863;
      if (C === 0 && G < B.length && B !== this)
        for (; G < B.length; G++)
          this.words[G] = B.words[G];
      return this.length = Math.max(this.length, G), B !== this && (this.negative = 1), this._strip();
    }, d.prototype.sub = function(p) {
      return this.clone().isub(p);
    };
    function oe(k, p, x) {
      x.negative = p.negative ^ k.negative;
      var S = k.length + p.length | 0;
      x.length = S, S = S - 1 | 0;
      var B = k.words[0] | 0, L = p.words[0] | 0, C = B * L, G = C & 67108863, R = C / 67108864 | 0;
      x.words[0] = G;
      for (var y = 1; y < S; y++) {
        for (var j = R >>> 26, ye = R & 67108863, ee = Math.min(y, p.length - 1), xe = Math.max(0, y - k.length + 1); xe <= ee; xe++) {
          var $e = y - xe | 0;
          B = k.words[$e] | 0, L = p.words[xe] | 0, C = B * L + ye, j += C / 67108864 | 0, ye = C & 67108863;
        }
        x.words[y] = ye | 0, R = j | 0;
      }
      return R !== 0 ? x.words[y] = R | 0 : x.length--, x._strip();
    }
    var pe = function(p, x, S) {
      var B = p.words, L = x.words, C = S.words, G = 0, R, y, j, ye = B[0] | 0, ee = ye & 8191, xe = ye >>> 13, $e = B[1] | 0, ke = $e & 8191, Ce = $e >>> 13, ht = B[2] | 0, Ue = ht & 8191, De = ht >>> 13, wt = B[3] | 0, He = wt & 8191, Ze = wt >>> 13, Ie = B[4] | 0, ue = Ie & 8191, he = Ie >>> 13, Ne = B[5] | 0, Be = Ne & 8191, Oe = Ne >>> 13, it = B[6] | 0, Ve = it & 8191, Ye = it >>> 13, Pt = B[7] | 0, et = Pt & 8191, Q = Pt >>> 13, W = B[8] | 0, V = W & 8191, se = W >>> 13, Ae = B[9] | 0, _e = Ae & 8191, Re = Ae >>> 13, mt = L[0] | 0, We = mt & 8191, ze = mt >>> 13, kt = L[1] | 0, je = kt & 8191, ot = kt >>> 13, Vt = L[2] | 0, ct = Vt & 8191, ut = Vt >>> 13, Zt = L[3] | 0, rt = Zt & 8191, nt = Zt >>> 13, Gt = L[4] | 0, st = Gt & 8191, at = Gt >>> 13, Jt = L[5] | 0, lt = Jt & 8191, tt = Jt >>> 13, Yt = L[6] | 0, le = Yt & 8191, be = Yt >>> 13, Me = L[7] | 0, te = Me & 8191, ve = Me >>> 13, qe = L[8] | 0, Pe = qe & 8191, Le = qe >>> 13, pt = L[9] | 0, Je = pt & 8191, Ge = pt >>> 13;
      S.negative = p.negative ^ x.negative, S.length = 19, R = Math.imul(ee, We), y = Math.imul(ee, ze), y = y + Math.imul(xe, We) | 0, j = Math.imul(xe, ze);
      var $t = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, R = Math.imul(ke, We), y = Math.imul(ke, ze), y = y + Math.imul(Ce, We) | 0, j = Math.imul(Ce, ze), R = R + Math.imul(ee, je) | 0, y = y + Math.imul(ee, ot) | 0, y = y + Math.imul(xe, je) | 0, j = j + Math.imul(xe, ot) | 0;
      var bt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, R = Math.imul(Ue, We), y = Math.imul(Ue, ze), y = y + Math.imul(De, We) | 0, j = Math.imul(De, ze), R = R + Math.imul(ke, je) | 0, y = y + Math.imul(ke, ot) | 0, y = y + Math.imul(Ce, je) | 0, j = j + Math.imul(Ce, ot) | 0, R = R + Math.imul(ee, ct) | 0, y = y + Math.imul(ee, ut) | 0, y = y + Math.imul(xe, ct) | 0, j = j + Math.imul(xe, ut) | 0;
      var Mt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, R = Math.imul(He, We), y = Math.imul(He, ze), y = y + Math.imul(Ze, We) | 0, j = Math.imul(Ze, ze), R = R + Math.imul(Ue, je) | 0, y = y + Math.imul(Ue, ot) | 0, y = y + Math.imul(De, je) | 0, j = j + Math.imul(De, ot) | 0, R = R + Math.imul(ke, ct) | 0, y = y + Math.imul(ke, ut) | 0, y = y + Math.imul(Ce, ct) | 0, j = j + Math.imul(Ce, ut) | 0, R = R + Math.imul(ee, rt) | 0, y = y + Math.imul(ee, nt) | 0, y = y + Math.imul(xe, rt) | 0, j = j + Math.imul(xe, nt) | 0;
      var Rt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, R = Math.imul(ue, We), y = Math.imul(ue, ze), y = y + Math.imul(he, We) | 0, j = Math.imul(he, ze), R = R + Math.imul(He, je) | 0, y = y + Math.imul(He, ot) | 0, y = y + Math.imul(Ze, je) | 0, j = j + Math.imul(Ze, ot) | 0, R = R + Math.imul(Ue, ct) | 0, y = y + Math.imul(Ue, ut) | 0, y = y + Math.imul(De, ct) | 0, j = j + Math.imul(De, ut) | 0, R = R + Math.imul(ke, rt) | 0, y = y + Math.imul(ke, nt) | 0, y = y + Math.imul(Ce, rt) | 0, j = j + Math.imul(Ce, nt) | 0, R = R + Math.imul(ee, st) | 0, y = y + Math.imul(ee, at) | 0, y = y + Math.imul(xe, st) | 0, j = j + Math.imul(xe, at) | 0;
      var Tt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, R = Math.imul(Be, We), y = Math.imul(Be, ze), y = y + Math.imul(Oe, We) | 0, j = Math.imul(Oe, ze), R = R + Math.imul(ue, je) | 0, y = y + Math.imul(ue, ot) | 0, y = y + Math.imul(he, je) | 0, j = j + Math.imul(he, ot) | 0, R = R + Math.imul(He, ct) | 0, y = y + Math.imul(He, ut) | 0, y = y + Math.imul(Ze, ct) | 0, j = j + Math.imul(Ze, ut) | 0, R = R + Math.imul(Ue, rt) | 0, y = y + Math.imul(Ue, nt) | 0, y = y + Math.imul(De, rt) | 0, j = j + Math.imul(De, nt) | 0, R = R + Math.imul(ke, st) | 0, y = y + Math.imul(ke, at) | 0, y = y + Math.imul(Ce, st) | 0, j = j + Math.imul(Ce, at) | 0, R = R + Math.imul(ee, lt) | 0, y = y + Math.imul(ee, tt) | 0, y = y + Math.imul(xe, lt) | 0, j = j + Math.imul(xe, tt) | 0;
      var Nt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, R = Math.imul(Ve, We), y = Math.imul(Ve, ze), y = y + Math.imul(Ye, We) | 0, j = Math.imul(Ye, ze), R = R + Math.imul(Be, je) | 0, y = y + Math.imul(Be, ot) | 0, y = y + Math.imul(Oe, je) | 0, j = j + Math.imul(Oe, ot) | 0, R = R + Math.imul(ue, ct) | 0, y = y + Math.imul(ue, ut) | 0, y = y + Math.imul(he, ct) | 0, j = j + Math.imul(he, ut) | 0, R = R + Math.imul(He, rt) | 0, y = y + Math.imul(He, nt) | 0, y = y + Math.imul(Ze, rt) | 0, j = j + Math.imul(Ze, nt) | 0, R = R + Math.imul(Ue, st) | 0, y = y + Math.imul(Ue, at) | 0, y = y + Math.imul(De, st) | 0, j = j + Math.imul(De, at) | 0, R = R + Math.imul(ke, lt) | 0, y = y + Math.imul(ke, tt) | 0, y = y + Math.imul(Ce, lt) | 0, j = j + Math.imul(Ce, tt) | 0, R = R + Math.imul(ee, le) | 0, y = y + Math.imul(ee, be) | 0, y = y + Math.imul(xe, le) | 0, j = j + Math.imul(xe, be) | 0;
      var It = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, R = Math.imul(et, We), y = Math.imul(et, ze), y = y + Math.imul(Q, We) | 0, j = Math.imul(Q, ze), R = R + Math.imul(Ve, je) | 0, y = y + Math.imul(Ve, ot) | 0, y = y + Math.imul(Ye, je) | 0, j = j + Math.imul(Ye, ot) | 0, R = R + Math.imul(Be, ct) | 0, y = y + Math.imul(Be, ut) | 0, y = y + Math.imul(Oe, ct) | 0, j = j + Math.imul(Oe, ut) | 0, R = R + Math.imul(ue, rt) | 0, y = y + Math.imul(ue, nt) | 0, y = y + Math.imul(he, rt) | 0, j = j + Math.imul(he, nt) | 0, R = R + Math.imul(He, st) | 0, y = y + Math.imul(He, at) | 0, y = y + Math.imul(Ze, st) | 0, j = j + Math.imul(Ze, at) | 0, R = R + Math.imul(Ue, lt) | 0, y = y + Math.imul(Ue, tt) | 0, y = y + Math.imul(De, lt) | 0, j = j + Math.imul(De, tt) | 0, R = R + Math.imul(ke, le) | 0, y = y + Math.imul(ke, be) | 0, y = y + Math.imul(Ce, le) | 0, j = j + Math.imul(Ce, be) | 0, R = R + Math.imul(ee, te) | 0, y = y + Math.imul(ee, ve) | 0, y = y + Math.imul(xe, te) | 0, j = j + Math.imul(xe, ve) | 0;
      var Ct = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, R = Math.imul(V, We), y = Math.imul(V, ze), y = y + Math.imul(se, We) | 0, j = Math.imul(se, ze), R = R + Math.imul(et, je) | 0, y = y + Math.imul(et, ot) | 0, y = y + Math.imul(Q, je) | 0, j = j + Math.imul(Q, ot) | 0, R = R + Math.imul(Ve, ct) | 0, y = y + Math.imul(Ve, ut) | 0, y = y + Math.imul(Ye, ct) | 0, j = j + Math.imul(Ye, ut) | 0, R = R + Math.imul(Be, rt) | 0, y = y + Math.imul(Be, nt) | 0, y = y + Math.imul(Oe, rt) | 0, j = j + Math.imul(Oe, nt) | 0, R = R + Math.imul(ue, st) | 0, y = y + Math.imul(ue, at) | 0, y = y + Math.imul(he, st) | 0, j = j + Math.imul(he, at) | 0, R = R + Math.imul(He, lt) | 0, y = y + Math.imul(He, tt) | 0, y = y + Math.imul(Ze, lt) | 0, j = j + Math.imul(Ze, tt) | 0, R = R + Math.imul(Ue, le) | 0, y = y + Math.imul(Ue, be) | 0, y = y + Math.imul(De, le) | 0, j = j + Math.imul(De, be) | 0, R = R + Math.imul(ke, te) | 0, y = y + Math.imul(ke, ve) | 0, y = y + Math.imul(Ce, te) | 0, j = j + Math.imul(Ce, ve) | 0, R = R + Math.imul(ee, Pe) | 0, y = y + Math.imul(ee, Le) | 0, y = y + Math.imul(xe, Pe) | 0, j = j + Math.imul(xe, Le) | 0;
      var Bt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, R = Math.imul(_e, We), y = Math.imul(_e, ze), y = y + Math.imul(Re, We) | 0, j = Math.imul(Re, ze), R = R + Math.imul(V, je) | 0, y = y + Math.imul(V, ot) | 0, y = y + Math.imul(se, je) | 0, j = j + Math.imul(se, ot) | 0, R = R + Math.imul(et, ct) | 0, y = y + Math.imul(et, ut) | 0, y = y + Math.imul(Q, ct) | 0, j = j + Math.imul(Q, ut) | 0, R = R + Math.imul(Ve, rt) | 0, y = y + Math.imul(Ve, nt) | 0, y = y + Math.imul(Ye, rt) | 0, j = j + Math.imul(Ye, nt) | 0, R = R + Math.imul(Be, st) | 0, y = y + Math.imul(Be, at) | 0, y = y + Math.imul(Oe, st) | 0, j = j + Math.imul(Oe, at) | 0, R = R + Math.imul(ue, lt) | 0, y = y + Math.imul(ue, tt) | 0, y = y + Math.imul(he, lt) | 0, j = j + Math.imul(he, tt) | 0, R = R + Math.imul(He, le) | 0, y = y + Math.imul(He, be) | 0, y = y + Math.imul(Ze, le) | 0, j = j + Math.imul(Ze, be) | 0, R = R + Math.imul(Ue, te) | 0, y = y + Math.imul(Ue, ve) | 0, y = y + Math.imul(De, te) | 0, j = j + Math.imul(De, ve) | 0, R = R + Math.imul(ke, Pe) | 0, y = y + Math.imul(ke, Le) | 0, y = y + Math.imul(Ce, Pe) | 0, j = j + Math.imul(Ce, Le) | 0, R = R + Math.imul(ee, Je) | 0, y = y + Math.imul(ee, Ge) | 0, y = y + Math.imul(xe, Je) | 0, j = j + Math.imul(xe, Ge) | 0;
      var _t = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, R = Math.imul(_e, je), y = Math.imul(_e, ot), y = y + Math.imul(Re, je) | 0, j = Math.imul(Re, ot), R = R + Math.imul(V, ct) | 0, y = y + Math.imul(V, ut) | 0, y = y + Math.imul(se, ct) | 0, j = j + Math.imul(se, ut) | 0, R = R + Math.imul(et, rt) | 0, y = y + Math.imul(et, nt) | 0, y = y + Math.imul(Q, rt) | 0, j = j + Math.imul(Q, nt) | 0, R = R + Math.imul(Ve, st) | 0, y = y + Math.imul(Ve, at) | 0, y = y + Math.imul(Ye, st) | 0, j = j + Math.imul(Ye, at) | 0, R = R + Math.imul(Be, lt) | 0, y = y + Math.imul(Be, tt) | 0, y = y + Math.imul(Oe, lt) | 0, j = j + Math.imul(Oe, tt) | 0, R = R + Math.imul(ue, le) | 0, y = y + Math.imul(ue, be) | 0, y = y + Math.imul(he, le) | 0, j = j + Math.imul(he, be) | 0, R = R + Math.imul(He, te) | 0, y = y + Math.imul(He, ve) | 0, y = y + Math.imul(Ze, te) | 0, j = j + Math.imul(Ze, ve) | 0, R = R + Math.imul(Ue, Pe) | 0, y = y + Math.imul(Ue, Le) | 0, y = y + Math.imul(De, Pe) | 0, j = j + Math.imul(De, Le) | 0, R = R + Math.imul(ke, Je) | 0, y = y + Math.imul(ke, Ge) | 0, y = y + Math.imul(Ce, Je) | 0, j = j + Math.imul(Ce, Ge) | 0;
      var St = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, R = Math.imul(_e, ct), y = Math.imul(_e, ut), y = y + Math.imul(Re, ct) | 0, j = Math.imul(Re, ut), R = R + Math.imul(V, rt) | 0, y = y + Math.imul(V, nt) | 0, y = y + Math.imul(se, rt) | 0, j = j + Math.imul(se, nt) | 0, R = R + Math.imul(et, st) | 0, y = y + Math.imul(et, at) | 0, y = y + Math.imul(Q, st) | 0, j = j + Math.imul(Q, at) | 0, R = R + Math.imul(Ve, lt) | 0, y = y + Math.imul(Ve, tt) | 0, y = y + Math.imul(Ye, lt) | 0, j = j + Math.imul(Ye, tt) | 0, R = R + Math.imul(Be, le) | 0, y = y + Math.imul(Be, be) | 0, y = y + Math.imul(Oe, le) | 0, j = j + Math.imul(Oe, be) | 0, R = R + Math.imul(ue, te) | 0, y = y + Math.imul(ue, ve) | 0, y = y + Math.imul(he, te) | 0, j = j + Math.imul(he, ve) | 0, R = R + Math.imul(He, Pe) | 0, y = y + Math.imul(He, Le) | 0, y = y + Math.imul(Ze, Pe) | 0, j = j + Math.imul(Ze, Le) | 0, R = R + Math.imul(Ue, Je) | 0, y = y + Math.imul(Ue, Ge) | 0, y = y + Math.imul(De, Je) | 0, j = j + Math.imul(De, Ge) | 0;
      var vt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, R = Math.imul(_e, rt), y = Math.imul(_e, nt), y = y + Math.imul(Re, rt) | 0, j = Math.imul(Re, nt), R = R + Math.imul(V, st) | 0, y = y + Math.imul(V, at) | 0, y = y + Math.imul(se, st) | 0, j = j + Math.imul(se, at) | 0, R = R + Math.imul(et, lt) | 0, y = y + Math.imul(et, tt) | 0, y = y + Math.imul(Q, lt) | 0, j = j + Math.imul(Q, tt) | 0, R = R + Math.imul(Ve, le) | 0, y = y + Math.imul(Ve, be) | 0, y = y + Math.imul(Ye, le) | 0, j = j + Math.imul(Ye, be) | 0, R = R + Math.imul(Be, te) | 0, y = y + Math.imul(Be, ve) | 0, y = y + Math.imul(Oe, te) | 0, j = j + Math.imul(Oe, ve) | 0, R = R + Math.imul(ue, Pe) | 0, y = y + Math.imul(ue, Le) | 0, y = y + Math.imul(he, Pe) | 0, j = j + Math.imul(he, Le) | 0, R = R + Math.imul(He, Je) | 0, y = y + Math.imul(He, Ge) | 0, y = y + Math.imul(Ze, Je) | 0, j = j + Math.imul(Ze, Ge) | 0;
      var At = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, R = Math.imul(_e, st), y = Math.imul(_e, at), y = y + Math.imul(Re, st) | 0, j = Math.imul(Re, at), R = R + Math.imul(V, lt) | 0, y = y + Math.imul(V, tt) | 0, y = y + Math.imul(se, lt) | 0, j = j + Math.imul(se, tt) | 0, R = R + Math.imul(et, le) | 0, y = y + Math.imul(et, be) | 0, y = y + Math.imul(Q, le) | 0, j = j + Math.imul(Q, be) | 0, R = R + Math.imul(Ve, te) | 0, y = y + Math.imul(Ve, ve) | 0, y = y + Math.imul(Ye, te) | 0, j = j + Math.imul(Ye, ve) | 0, R = R + Math.imul(Be, Pe) | 0, y = y + Math.imul(Be, Le) | 0, y = y + Math.imul(Oe, Pe) | 0, j = j + Math.imul(Oe, Le) | 0, R = R + Math.imul(ue, Je) | 0, y = y + Math.imul(ue, Ge) | 0, y = y + Math.imul(he, Je) | 0, j = j + Math.imul(he, Ge) | 0;
      var Et = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, R = Math.imul(_e, lt), y = Math.imul(_e, tt), y = y + Math.imul(Re, lt) | 0, j = Math.imul(Re, tt), R = R + Math.imul(V, le) | 0, y = y + Math.imul(V, be) | 0, y = y + Math.imul(se, le) | 0, j = j + Math.imul(se, be) | 0, R = R + Math.imul(et, te) | 0, y = y + Math.imul(et, ve) | 0, y = y + Math.imul(Q, te) | 0, j = j + Math.imul(Q, ve) | 0, R = R + Math.imul(Ve, Pe) | 0, y = y + Math.imul(Ve, Le) | 0, y = y + Math.imul(Ye, Pe) | 0, j = j + Math.imul(Ye, Le) | 0, R = R + Math.imul(Be, Je) | 0, y = y + Math.imul(Be, Ge) | 0, y = y + Math.imul(Oe, Je) | 0, j = j + Math.imul(Oe, Ge) | 0;
      var yt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, R = Math.imul(_e, le), y = Math.imul(_e, be), y = y + Math.imul(Re, le) | 0, j = Math.imul(Re, be), R = R + Math.imul(V, te) | 0, y = y + Math.imul(V, ve) | 0, y = y + Math.imul(se, te) | 0, j = j + Math.imul(se, ve) | 0, R = R + Math.imul(et, Pe) | 0, y = y + Math.imul(et, Le) | 0, y = y + Math.imul(Q, Pe) | 0, j = j + Math.imul(Q, Le) | 0, R = R + Math.imul(Ve, Je) | 0, y = y + Math.imul(Ve, Ge) | 0, y = y + Math.imul(Ye, Je) | 0, j = j + Math.imul(Ye, Ge) | 0;
      var Xe = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, R = Math.imul(_e, te), y = Math.imul(_e, ve), y = y + Math.imul(Re, te) | 0, j = Math.imul(Re, ve), R = R + Math.imul(V, Pe) | 0, y = y + Math.imul(V, Le) | 0, y = y + Math.imul(se, Pe) | 0, j = j + Math.imul(se, Le) | 0, R = R + Math.imul(et, Je) | 0, y = y + Math.imul(et, Ge) | 0, y = y + Math.imul(Q, Je) | 0, j = j + Math.imul(Q, Ge) | 0;
      var Qe = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, R = Math.imul(_e, Pe), y = Math.imul(_e, Le), y = y + Math.imul(Re, Pe) | 0, j = Math.imul(Re, Le), R = R + Math.imul(V, Je) | 0, y = y + Math.imul(V, Ge) | 0, y = y + Math.imul(se, Je) | 0, j = j + Math.imul(se, Ge) | 0;
      var dt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, R = Math.imul(_e, Je), y = Math.imul(_e, Ge), y = y + Math.imul(Re, Je) | 0, j = Math.imul(Re, Ge);
      var ft = (G + R | 0) + ((y & 8191) << 13) | 0;
      return G = (j + (y >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, C[0] = $t, C[1] = bt, C[2] = Mt, C[3] = Rt, C[4] = Tt, C[5] = Nt, C[6] = It, C[7] = Ct, C[8] = Bt, C[9] = _t, C[10] = St, C[11] = vt, C[12] = At, C[13] = Et, C[14] = yt, C[15] = Xe, C[16] = Qe, C[17] = dt, C[18] = ft, G !== 0 && (C[19] = G, S.length++), S;
    };
    Math.imul || (pe = oe);
    function ae(k, p, x) {
      x.negative = p.negative ^ k.negative, x.length = k.length + p.length;
      for (var S = 0, B = 0, L = 0; L < x.length - 1; L++) {
        var C = B;
        B = 0;
        for (var G = S & 67108863, R = Math.min(L, p.length - 1), y = Math.max(0, L - k.length + 1); y <= R; y++) {
          var j = L - y, ye = k.words[j] | 0, ee = p.words[y] | 0, xe = ye * ee, $e = xe & 67108863;
          C = C + (xe / 67108864 | 0) | 0, $e = $e + G | 0, G = $e & 67108863, C = C + ($e >>> 26) | 0, B += C >>> 26, C &= 67108863;
        }
        x.words[L] = G, S = C, C = B;
      }
      return S !== 0 ? x.words[L] = S : x.length--, x._strip();
    }
    function me(k, p, x) {
      return ae(k, p, x);
    }
    d.prototype.mulTo = function(p, x) {
      var S, B = this.length + p.length;
      return this.length === 10 && p.length === 10 ? S = pe(this, p, x) : B < 63 ? S = oe(this, p, x) : B < 1024 ? S = ae(this, p, x) : S = me(this, p, x), S;
    }, d.prototype.mul = function(p) {
      var x = new d(null);
      return x.words = new Array(this.length + p.length), this.mulTo(p, x);
    }, d.prototype.mulf = function(p) {
      var x = new d(null);
      return x.words = new Array(this.length + p.length), me(this, p, x);
    }, d.prototype.imul = function(p) {
      return this.clone().mulTo(p, this);
    }, d.prototype.imuln = function(p) {
      var x = p < 0;
      x && (p = -p), h(typeof p == "number"), h(p < 67108864);
      for (var S = 0, B = 0; B < this.length; B++) {
        var L = (this.words[B] | 0) * p, C = (L & 67108863) + (S & 67108863);
        S >>= 26, S += L / 67108864 | 0, S += C >>> 26, this.words[B] = C & 67108863;
      }
      return S !== 0 && (this.words[B] = S, this.length++), x ? this.ineg() : this;
    }, d.prototype.muln = function(p) {
      return this.clone().imuln(p);
    }, d.prototype.sqr = function() {
      return this.mul(this);
    }, d.prototype.isqr = function() {
      return this.imul(this.clone());
    }, d.prototype.pow = function(p) {
      var x = re(p);
      if (x.length === 0)
        return new d(1);
      for (var S = this, B = 0; B < x.length && x[B] === 0; B++, S = S.sqr())
        ;
      if (++B < x.length)
        for (var L = S.sqr(); B < x.length; B++, L = L.sqr())
          x[B] !== 0 && (S = S.mul(L));
      return S;
    }, d.prototype.iushln = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26, B = 67108863 >>> 26 - x << 26 - x, L;
      if (x !== 0) {
        var C = 0;
        for (L = 0; L < this.length; L++) {
          var G = this.words[L] & B, R = (this.words[L] | 0) - G << x;
          this.words[L] = R | C, C = G >>> 26 - x;
        }
        C && (this.words[L] = C, this.length++);
      }
      if (S !== 0) {
        for (L = this.length - 1; L >= 0; L--)
          this.words[L + S] = this.words[L];
        for (L = 0; L < S; L++)
          this.words[L] = 0;
        this.length += S;
      }
      return this._strip();
    }, d.prototype.ishln = function(p) {
      return h(this.negative === 0), this.iushln(p);
    }, d.prototype.iushrn = function(p, x, S) {
      h(typeof p == "number" && p >= 0);
      var B;
      x ? B = (x - x % 26) / 26 : B = 0;
      var L = p % 26, C = Math.min((p - L) / 26, this.length), G = 67108863 ^ 67108863 >>> L << L, R = S;
      if (B -= C, B = Math.max(0, B), R) {
        for (var y = 0; y < C; y++)
          R.words[y] = this.words[y];
        R.length = C;
      }
      if (C !== 0)
        if (this.length > C)
          for (this.length -= C, y = 0; y < this.length; y++)
            this.words[y] = this.words[y + C];
        else
          this.words[0] = 0, this.length = 1;
      var j = 0;
      for (y = this.length - 1; y >= 0 && (j !== 0 || y >= B); y--) {
        var ye = this.words[y] | 0;
        this.words[y] = j << 26 - L | ye >>> L, j = ye & G;
      }
      return R && j !== 0 && (R.words[R.length++] = j), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, d.prototype.ishrn = function(p, x, S) {
      return h(this.negative === 0), this.iushrn(p, x, S);
    }, d.prototype.shln = function(p) {
      return this.clone().ishln(p);
    }, d.prototype.ushln = function(p) {
      return this.clone().iushln(p);
    }, d.prototype.shrn = function(p) {
      return this.clone().ishrn(p);
    }, d.prototype.ushrn = function(p) {
      return this.clone().iushrn(p);
    }, d.prototype.testn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26, B = 1 << x;
      if (this.length <= S)
        return !1;
      var L = this.words[S];
      return !!(L & B);
    }, d.prototype.imaskn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26;
      if (h(this.negative === 0, "imaskn works only with positive numbers"), this.length <= S)
        return this;
      if (x !== 0 && S++, this.length = Math.min(S, this.length), x !== 0) {
        var B = 67108863 ^ 67108863 >>> x << x;
        this.words[this.length - 1] &= B;
      }
      return this._strip();
    }, d.prototype.maskn = function(p) {
      return this.clone().imaskn(p);
    }, d.prototype.iaddn = function(p) {
      return h(typeof p == "number"), h(p < 67108864), p < 0 ? this.isubn(-p) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= p ? (this.words[0] = p - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(p), this.negative = 1, this) : this._iaddn(p);
    }, d.prototype._iaddn = function(p) {
      this.words[0] += p;
      for (var x = 0; x < this.length && this.words[x] >= 67108864; x++)
        this.words[x] -= 67108864, x === this.length - 1 ? this.words[x + 1] = 1 : this.words[x + 1]++;
      return this.length = Math.max(this.length, x + 1), this;
    }, d.prototype.isubn = function(p) {
      if (h(typeof p == "number"), h(p < 67108864), p < 0)
        return this.iaddn(-p);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(p), this.negative = 1, this;
      if (this.words[0] -= p, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var x = 0; x < this.length && this.words[x] < 0; x++)
          this.words[x] += 67108864, this.words[x + 1] -= 1;
      return this._strip();
    }, d.prototype.addn = function(p) {
      return this.clone().iaddn(p);
    }, d.prototype.subn = function(p) {
      return this.clone().isubn(p);
    }, d.prototype.iabs = function() {
      return this.negative = 0, this;
    }, d.prototype.abs = function() {
      return this.clone().iabs();
    }, d.prototype._ishlnsubmul = function(p, x, S) {
      var B = p.length + S, L;
      this._expand(B);
      var C, G = 0;
      for (L = 0; L < p.length; L++) {
        C = (this.words[L + S] | 0) + G;
        var R = (p.words[L] | 0) * x;
        C -= R & 67108863, G = (C >> 26) - (R / 67108864 | 0), this.words[L + S] = C & 67108863;
      }
      for (; L < this.length - S; L++)
        C = (this.words[L + S] | 0) + G, G = C >> 26, this.words[L + S] = C & 67108863;
      if (G === 0)
        return this._strip();
      for (h(G === -1), G = 0, L = 0; L < this.length; L++)
        C = -(this.words[L] | 0) + G, G = C >> 26, this.words[L] = C & 67108863;
      return this.negative = 1, this._strip();
    }, d.prototype._wordDiv = function(p, x) {
      var S = this.length - p.length, B = this.clone(), L = p, C = L.words[L.length - 1] | 0, G = this._countBits(C);
      S = 26 - G, S !== 0 && (L = L.ushln(S), B.iushln(S), C = L.words[L.length - 1] | 0);
      var R = B.length - L.length, y;
      if (x !== "mod") {
        y = new d(null), y.length = R + 1, y.words = new Array(y.length);
        for (var j = 0; j < y.length; j++)
          y.words[j] = 0;
      }
      var ye = B.clone()._ishlnsubmul(L, 1, R);
      ye.negative === 0 && (B = ye, y && (y.words[R] = 1));
      for (var ee = R - 1; ee >= 0; ee--) {
        var xe = (B.words[L.length + ee] | 0) * 67108864 + (B.words[L.length + ee - 1] | 0);
        for (xe = Math.min(xe / C | 0, 67108863), B._ishlnsubmul(L, xe, ee); B.negative !== 0; )
          xe--, B.negative = 0, B._ishlnsubmul(L, 1, ee), B.isZero() || (B.negative ^= 1);
        y && (y.words[ee] = xe);
      }
      return y && y._strip(), B._strip(), x !== "div" && S !== 0 && B.iushrn(S), {
        div: y || null,
        mod: B
      };
    }, d.prototype.divmod = function(p, x, S) {
      if (h(!p.isZero()), this.isZero())
        return {
          div: new d(0),
          mod: new d(0)
        };
      var B, L, C;
      return this.negative !== 0 && p.negative === 0 ? (C = this.neg().divmod(p, x), x !== "mod" && (B = C.div.neg()), x !== "div" && (L = C.mod.neg(), S && L.negative !== 0 && L.iadd(p)), {
        div: B,
        mod: L
      }) : this.negative === 0 && p.negative !== 0 ? (C = this.divmod(p.neg(), x), x !== "mod" && (B = C.div.neg()), {
        div: B,
        mod: C.mod
      }) : (this.negative & p.negative) !== 0 ? (C = this.neg().divmod(p.neg(), x), x !== "div" && (L = C.mod.neg(), S && L.negative !== 0 && L.isub(p)), {
        div: C.div,
        mod: L
      }) : p.length > this.length || this.cmp(p) < 0 ? {
        div: new d(0),
        mod: this
      } : p.length === 1 ? x === "div" ? {
        div: this.divn(p.words[0]),
        mod: null
      } : x === "mod" ? {
        div: null,
        mod: new d(this.modrn(p.words[0]))
      } : {
        div: this.divn(p.words[0]),
        mod: new d(this.modrn(p.words[0]))
      } : this._wordDiv(p, x);
    }, d.prototype.div = function(p) {
      return this.divmod(p, "div", !1).div;
    }, d.prototype.mod = function(p) {
      return this.divmod(p, "mod", !1).mod;
    }, d.prototype.umod = function(p) {
      return this.divmod(p, "mod", !0).mod;
    }, d.prototype.divRound = function(p) {
      var x = this.divmod(p);
      if (x.mod.isZero())
        return x.div;
      var S = x.div.negative !== 0 ? x.mod.isub(p) : x.mod, B = p.ushrn(1), L = p.andln(1), C = S.cmp(B);
      return C < 0 || L === 1 && C === 0 ? x.div : x.div.negative !== 0 ? x.div.isubn(1) : x.div.iaddn(1);
    }, d.prototype.modrn = function(p) {
      var x = p < 0;
      x && (p = -p), h(p <= 67108863);
      for (var S = (1 << 26) % p, B = 0, L = this.length - 1; L >= 0; L--)
        B = (S * B + (this.words[L] | 0)) % p;
      return x ? -B : B;
    }, d.prototype.modn = function(p) {
      return this.modrn(p);
    }, d.prototype.idivn = function(p) {
      var x = p < 0;
      x && (p = -p), h(p <= 67108863);
      for (var S = 0, B = this.length - 1; B >= 0; B--) {
        var L = (this.words[B] | 0) + S * 67108864;
        this.words[B] = L / p | 0, S = L % p;
      }
      return this._strip(), x ? this.ineg() : this;
    }, d.prototype.divn = function(p) {
      return this.clone().idivn(p);
    }, d.prototype.egcd = function(p) {
      h(p.negative === 0), h(!p.isZero());
      var x = this, S = p.clone();
      x.negative !== 0 ? x = x.umod(p) : x = x.clone();
      for (var B = new d(1), L = new d(0), C = new d(0), G = new d(1), R = 0; x.isEven() && S.isEven(); )
        x.iushrn(1), S.iushrn(1), ++R;
      for (var y = S.clone(), j = x.clone(); !x.isZero(); ) {
        for (var ye = 0, ee = 1; (x.words[0] & ee) === 0 && ye < 26; ++ye, ee <<= 1)
          ;
        if (ye > 0)
          for (x.iushrn(ye); ye-- > 0; )
            (B.isOdd() || L.isOdd()) && (B.iadd(y), L.isub(j)), B.iushrn(1), L.iushrn(1);
        for (var xe = 0, $e = 1; (S.words[0] & $e) === 0 && xe < 26; ++xe, $e <<= 1)
          ;
        if (xe > 0)
          for (S.iushrn(xe); xe-- > 0; )
            (C.isOdd() || G.isOdd()) && (C.iadd(y), G.isub(j)), C.iushrn(1), G.iushrn(1);
        x.cmp(S) >= 0 ? (x.isub(S), B.isub(C), L.isub(G)) : (S.isub(x), C.isub(B), G.isub(L));
      }
      return {
        a: C,
        b: G,
        gcd: S.iushln(R)
      };
    }, d.prototype._invmp = function(p) {
      h(p.negative === 0), h(!p.isZero());
      var x = this, S = p.clone();
      x.negative !== 0 ? x = x.umod(p) : x = x.clone();
      for (var B = new d(1), L = new d(0), C = S.clone(); x.cmpn(1) > 0 && S.cmpn(1) > 0; ) {
        for (var G = 0, R = 1; (x.words[0] & R) === 0 && G < 26; ++G, R <<= 1)
          ;
        if (G > 0)
          for (x.iushrn(G); G-- > 0; )
            B.isOdd() && B.iadd(C), B.iushrn(1);
        for (var y = 0, j = 1; (S.words[0] & j) === 0 && y < 26; ++y, j <<= 1)
          ;
        if (y > 0)
          for (S.iushrn(y); y-- > 0; )
            L.isOdd() && L.iadd(C), L.iushrn(1);
        x.cmp(S) >= 0 ? (x.isub(S), B.isub(L)) : (S.isub(x), L.isub(B));
      }
      var ye;
      return x.cmpn(1) === 0 ? ye = B : ye = L, ye.cmpn(0) < 0 && ye.iadd(p), ye;
    }, d.prototype.gcd = function(p) {
      if (this.isZero())
        return p.abs();
      if (p.isZero())
        return this.abs();
      var x = this.clone(), S = p.clone();
      x.negative = 0, S.negative = 0;
      for (var B = 0; x.isEven() && S.isEven(); B++)
        x.iushrn(1), S.iushrn(1);
      do {
        for (; x.isEven(); )
          x.iushrn(1);
        for (; S.isEven(); )
          S.iushrn(1);
        var L = x.cmp(S);
        if (L < 0) {
          var C = x;
          x = S, S = C;
        } else if (L === 0 || S.cmpn(1) === 0)
          break;
        x.isub(S);
      } while (!0);
      return S.iushln(B);
    }, d.prototype.invm = function(p) {
      return this.egcd(p).a.umod(p);
    }, d.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, d.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, d.prototype.andln = function(p) {
      return this.words[0] & p;
    }, d.prototype.bincn = function(p) {
      h(typeof p == "number");
      var x = p % 26, S = (p - x) / 26, B = 1 << x;
      if (this.length <= S)
        return this._expand(S + 1), this.words[S] |= B, this;
      for (var L = B, C = S; L !== 0 && C < this.length; C++) {
        var G = this.words[C] | 0;
        G += L, L = G >>> 26, G &= 67108863, this.words[C] = G;
      }
      return L !== 0 && (this.words[C] = L, this.length++), this;
    }, d.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, d.prototype.cmpn = function(p) {
      var x = p < 0;
      if (this.negative !== 0 && !x)
        return -1;
      if (this.negative === 0 && x)
        return 1;
      this._strip();
      var S;
      if (this.length > 1)
        S = 1;
      else {
        x && (p = -p), h(p <= 67108863, "Number is too big");
        var B = this.words[0] | 0;
        S = B === p ? 0 : B < p ? -1 : 1;
      }
      return this.negative !== 0 ? -S | 0 : S;
    }, d.prototype.cmp = function(p) {
      if (this.negative !== 0 && p.negative === 0)
        return -1;
      if (this.negative === 0 && p.negative !== 0)
        return 1;
      var x = this.ucmp(p);
      return this.negative !== 0 ? -x | 0 : x;
    }, d.prototype.ucmp = function(p) {
      if (this.length > p.length)
        return 1;
      if (this.length < p.length)
        return -1;
      for (var x = 0, S = this.length - 1; S >= 0; S--) {
        var B = this.words[S] | 0, L = p.words[S] | 0;
        if (B !== L) {
          B < L ? x = -1 : B > L && (x = 1);
          break;
        }
      }
      return x;
    }, d.prototype.gtn = function(p) {
      return this.cmpn(p) === 1;
    }, d.prototype.gt = function(p) {
      return this.cmp(p) === 1;
    }, d.prototype.gten = function(p) {
      return this.cmpn(p) >= 0;
    }, d.prototype.gte = function(p) {
      return this.cmp(p) >= 0;
    }, d.prototype.ltn = function(p) {
      return this.cmpn(p) === -1;
    }, d.prototype.lt = function(p) {
      return this.cmp(p) === -1;
    }, d.prototype.lten = function(p) {
      return this.cmpn(p) <= 0;
    }, d.prototype.lte = function(p) {
      return this.cmp(p) <= 0;
    }, d.prototype.eqn = function(p) {
      return this.cmpn(p) === 0;
    }, d.prototype.eq = function(p) {
      return this.cmp(p) === 0;
    }, d.red = function(p) {
      return new X(p);
    }, d.prototype.toRed = function(p) {
      return h(!this.red, "Already a number in reduction context"), h(this.negative === 0, "red works only with positives"), p.convertTo(this)._forceRed(p);
    }, d.prototype.fromRed = function() {
      return h(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, d.prototype._forceRed = function(p) {
      return this.red = p, this;
    }, d.prototype.forceRed = function(p) {
      return h(!this.red, "Already a number in reduction context"), this._forceRed(p);
    }, d.prototype.redAdd = function(p) {
      return h(this.red, "redAdd works only with red numbers"), this.red.add(this, p);
    }, d.prototype.redIAdd = function(p) {
      return h(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, p);
    }, d.prototype.redSub = function(p) {
      return h(this.red, "redSub works only with red numbers"), this.red.sub(this, p);
    }, d.prototype.redISub = function(p) {
      return h(this.red, "redISub works only with red numbers"), this.red.isub(this, p);
    }, d.prototype.redShl = function(p) {
      return h(this.red, "redShl works only with red numbers"), this.red.shl(this, p);
    }, d.prototype.redMul = function(p) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.mul(this, p);
    }, d.prototype.redIMul = function(p) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.imul(this, p);
    }, d.prototype.redSqr = function() {
      return h(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, d.prototype.redISqr = function() {
      return h(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, d.prototype.redSqrt = function() {
      return h(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, d.prototype.redInvm = function() {
      return h(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, d.prototype.redNeg = function() {
      return h(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, d.prototype.redPow = function(p) {
      return h(this.red && !p.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, p);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function we(k, p) {
      this.name = k, this.p = new d(p, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    we.prototype._tmp = function() {
      var p = new d(null);
      return p.words = new Array(Math.ceil(this.n / 13)), p;
    }, we.prototype.ireduce = function(p) {
      var x = p, S;
      do
        this.split(x, this.tmp), x = this.imulK(x), x = x.iadd(this.tmp), S = x.bitLength();
      while (S > this.n);
      var B = S < this.n ? -1 : x.ucmp(this.p);
      return B === 0 ? (x.words[0] = 0, x.length = 1) : B > 0 ? x.isub(this.p) : x.strip !== void 0 ? x.strip() : x._strip(), x;
    }, we.prototype.split = function(p, x) {
      p.iushrn(this.n, 0, x);
    }, we.prototype.imulK = function(p) {
      return p.imul(this.k);
    };
    function Ee() {
      we.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    m(Ee, we), Ee.prototype.split = function(p, x) {
      for (var S = 4194303, B = Math.min(p.length, 9), L = 0; L < B; L++)
        x.words[L] = p.words[L];
      if (x.length = B, p.length <= 9) {
        p.words[0] = 0, p.length = 1;
        return;
      }
      var C = p.words[9];
      for (x.words[x.length++] = C & S, L = 10; L < p.length; L++) {
        var G = p.words[L] | 0;
        p.words[L - 10] = (G & S) << 4 | C >>> 22, C = G;
      }
      C >>>= 22, p.words[L - 10] = C, C === 0 && p.length > 10 ? p.length -= 10 : p.length -= 9;
    }, Ee.prototype.imulK = function(p) {
      p.words[p.length] = 0, p.words[p.length + 1] = 0, p.length += 2;
      for (var x = 0, S = 0; S < p.length; S++) {
        var B = p.words[S] | 0;
        x += B * 977, p.words[S] = x & 67108863, x = B * 64 + (x / 67108864 | 0);
      }
      return p.words[p.length - 1] === 0 && (p.length--, p.words[p.length - 1] === 0 && p.length--), p;
    };
    function Te() {
      we.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    m(Te, we);
    function Ke() {
      we.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    m(Ke, we);
    function Se() {
      we.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    m(Se, we), Se.prototype.imulK = function(p) {
      for (var x = 0, S = 0; S < p.length; S++) {
        var B = (p.words[S] | 0) * 19 + x, L = B & 67108863;
        B >>>= 26, p.words[S] = L, x = B;
      }
      return x !== 0 && (p.words[p.length++] = x), p;
    }, d._prime = function(p) {
      if (ge[p])
        return ge[p];
      var x;
      if (p === "k256")
        x = new Ee();
      else if (p === "p224")
        x = new Te();
      else if (p === "p192")
        x = new Ke();
      else if (p === "p25519")
        x = new Se();
      else
        throw new Error("Unknown prime " + p);
      return ge[p] = x, x;
    };
    function X(k) {
      if (typeof k == "string") {
        var p = d._prime(k);
        this.m = p.p, this.prime = p;
      } else
        h(k.gtn(1), "modulus must be greater than 1"), this.m = k, this.prime = null;
    }
    X.prototype._verify1 = function(p) {
      h(p.negative === 0, "red works only with positives"), h(p.red, "red works only with red numbers");
    }, X.prototype._verify2 = function(p, x) {
      h((p.negative | x.negative) === 0, "red works only with positives"), h(
        p.red && p.red === x.red,
        "red works only with red numbers"
      );
    }, X.prototype.imod = function(p) {
      return this.prime ? this.prime.ireduce(p)._forceRed(this) : (J(p, p.umod(this.m)._forceRed(this)), p);
    }, X.prototype.neg = function(p) {
      return p.isZero() ? p.clone() : this.m.sub(p)._forceRed(this);
    }, X.prototype.add = function(p, x) {
      this._verify2(p, x);
      var S = p.add(x);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S._forceRed(this);
    }, X.prototype.iadd = function(p, x) {
      this._verify2(p, x);
      var S = p.iadd(x);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S;
    }, X.prototype.sub = function(p, x) {
      this._verify2(p, x);
      var S = p.sub(x);
      return S.cmpn(0) < 0 && S.iadd(this.m), S._forceRed(this);
    }, X.prototype.isub = function(p, x) {
      this._verify2(p, x);
      var S = p.isub(x);
      return S.cmpn(0) < 0 && S.iadd(this.m), S;
    }, X.prototype.shl = function(p, x) {
      return this._verify1(p), this.imod(p.ushln(x));
    }, X.prototype.imul = function(p, x) {
      return this._verify2(p, x), this.imod(p.imul(x));
    }, X.prototype.mul = function(p, x) {
      return this._verify2(p, x), this.imod(p.mul(x));
    }, X.prototype.isqr = function(p) {
      return this.imul(p, p.clone());
    }, X.prototype.sqr = function(p) {
      return this.mul(p, p);
    }, X.prototype.sqrt = function(p) {
      if (p.isZero())
        return p.clone();
      var x = this.m.andln(3);
      if (h(x % 2 === 1), x === 3) {
        var S = this.m.add(new d(1)).iushrn(2);
        return this.pow(p, S);
      }
      for (var B = this.m.subn(1), L = 0; !B.isZero() && B.andln(1) === 0; )
        L++, B.iushrn(1);
      h(!B.isZero());
      var C = new d(1).toRed(this), G = C.redNeg(), R = this.m.subn(1).iushrn(1), y = this.m.bitLength();
      for (y = new d(2 * y * y).toRed(this); this.pow(y, R).cmp(G) !== 0; )
        y.redIAdd(G);
      for (var j = this.pow(y, B), ye = this.pow(p, B.addn(1).iushrn(1)), ee = this.pow(p, B), xe = L; ee.cmp(C) !== 0; ) {
        for (var $e = ee, ke = 0; $e.cmp(C) !== 0; ke++)
          $e = $e.redSqr();
        h(ke < xe);
        var Ce = this.pow(j, new d(1).iushln(xe - ke - 1));
        ye = ye.redMul(Ce), j = Ce.redSqr(), ee = ee.redMul(j), xe = ke;
      }
      return ye;
    }, X.prototype.invm = function(p) {
      var x = p._invmp(this.m);
      return x.negative !== 0 ? (x.negative = 0, this.imod(x).redNeg()) : this.imod(x);
    }, X.prototype.pow = function(p, x) {
      if (x.isZero())
        return new d(1).toRed(this);
      if (x.cmpn(1) === 0)
        return p.clone();
      var S = 4, B = new Array(1 << S);
      B[0] = new d(1).toRed(this), B[1] = p;
      for (var L = 2; L < B.length; L++)
        B[L] = this.mul(B[L - 1], p);
      var C = B[0], G = 0, R = 0, y = x.bitLength() % 26;
      for (y === 0 && (y = 26), L = x.length - 1; L >= 0; L--) {
        for (var j = x.words[L], ye = y - 1; ye >= 0; ye--) {
          var ee = j >> ye & 1;
          if (C !== B[0] && (C = this.sqr(C)), ee === 0 && G === 0) {
            R = 0;
            continue;
          }
          G <<= 1, G |= ee, R++, !(R !== S && (L !== 0 || ye !== 0)) && (C = this.mul(C, B[G]), R = 0, G = 0);
        }
        y = 26;
      }
      return C;
    }, X.prototype.convertTo = function(p) {
      var x = p.umod(this.m);
      return x === p ? x.clone() : x;
    }, X.prototype.convertFrom = function(p) {
      var x = p.clone();
      return x.red = null, x;
    }, d.mont = function(p) {
      return new fe(p);
    };
    function fe(k) {
      X.call(this, k), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    m(fe, X), fe.prototype.convertTo = function(p) {
      return this.imod(p.ushln(this.shift));
    }, fe.prototype.convertFrom = function(p) {
      var x = this.imod(p.mul(this.rinv));
      return x.red = null, x;
    }, fe.prototype.imul = function(p, x) {
      if (p.isZero() || x.isZero())
        return p.words[0] = 0, p.length = 1, p;
      var S = p.imul(x), B = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = S.isub(B).iushrn(this.shift), C = L;
      return L.cmp(this.m) >= 0 ? C = L.isub(this.m) : L.cmpn(0) < 0 && (C = L.iadd(this.m)), C._forceRed(this);
    }, fe.prototype.mul = function(p, x) {
      if (p.isZero() || x.isZero())
        return new d(0)._forceRed(this);
      var S = p.mul(x), B = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = S.isub(B).iushrn(this.shift), C = L;
      return L.cmp(this.m) >= 0 ? C = L.isub(this.m) : L.cmpn(0) < 0 && (C = L.iadd(this.m)), C._forceRed(this);
    }, fe.prototype.invm = function(p) {
      var x = this.imod(p._invmp(this.m).mul(this.r2));
      return x._forceRed(this);
    };
  })(l, commonjsGlobal);
})(bn$4);
var BN$2 = bn$4.exports, hash$1 = {}, utils$g = {}, minimalisticAssert$1 = assert$b;
function assert$b(l, t) {
  if (!l)
    throw new Error(t || "Assertion failed");
}
assert$b.equal = function(t, s, h) {
  if (t != s)
    throw new Error(h || "Assertion failed: " + t + " != " + s);
};
var inherits_browser$1 = { exports: {} };
typeof Object.create == "function" ? inherits_browser$1.exports = function(t, s) {
  s && (t.super_ = s, t.prototype = Object.create(s.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser$1.exports = function(t, s) {
  if (s) {
    t.super_ = s;
    var h = function() {
    };
    h.prototype = s.prototype, t.prototype = new h(), t.prototype.constructor = t;
  }
};
var assert$a = minimalisticAssert$1, inherits$1 = inherits_browser$1.exports;
utils$g.inherits = inherits$1;
function isSurrogatePair(l, t) {
  return (l.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= l.length ? !1 : (l.charCodeAt(t + 1) & 64512) === 56320;
}
function toArray(l, t) {
  if (Array.isArray(l))
    return l.slice();
  if (!l)
    return [];
  var s = [];
  if (typeof l == "string")
    if (t) {
      if (t === "hex")
        for (l = l.replace(/[^a-z0-9]+/ig, ""), l.length % 2 !== 0 && (l = "0" + l), m = 0; m < l.length; m += 2)
          s.push(parseInt(l[m] + l[m + 1], 16));
    } else
      for (var h = 0, m = 0; m < l.length; m++) {
        var d = l.charCodeAt(m);
        d < 128 ? s[h++] = d : d < 2048 ? (s[h++] = d >> 6 | 192, s[h++] = d & 63 | 128) : isSurrogatePair(l, m) ? (d = 65536 + ((d & 1023) << 10) + (l.charCodeAt(++m) & 1023), s[h++] = d >> 18 | 240, s[h++] = d >> 12 & 63 | 128, s[h++] = d >> 6 & 63 | 128, s[h++] = d & 63 | 128) : (s[h++] = d >> 12 | 224, s[h++] = d >> 6 & 63 | 128, s[h++] = d & 63 | 128);
      }
  else
    for (m = 0; m < l.length; m++)
      s[m] = l[m] | 0;
  return s;
}
utils$g.toArray = toArray;
function toHex(l) {
  for (var t = "", s = 0; s < l.length; s++)
    t += zero2(l[s].toString(16));
  return t;
}
utils$g.toHex = toHex;
function htonl(l) {
  var t = l >>> 24 | l >>> 8 & 65280 | l << 8 & 16711680 | (l & 255) << 24;
  return t >>> 0;
}
utils$g.htonl = htonl;
function toHex32(l, t) {
  for (var s = "", h = 0; h < l.length; h++) {
    var m = l[h];
    t === "little" && (m = htonl(m)), s += zero8(m.toString(16));
  }
  return s;
}
utils$g.toHex32 = toHex32;
function zero2(l) {
  return l.length === 1 ? "0" + l : l;
}
utils$g.zero2 = zero2;
function zero8(l) {
  return l.length === 7 ? "0" + l : l.length === 6 ? "00" + l : l.length === 5 ? "000" + l : l.length === 4 ? "0000" + l : l.length === 3 ? "00000" + l : l.length === 2 ? "000000" + l : l.length === 1 ? "0000000" + l : l;
}
utils$g.zero8 = zero8;
function join32(l, t, s, h) {
  var m = s - t;
  assert$a(m % 4 === 0);
  for (var d = new Array(m / 4), v = 0, _ = t; v < d.length; v++, _ += 4) {
    var T;
    h === "big" ? T = l[_] << 24 | l[_ + 1] << 16 | l[_ + 2] << 8 | l[_ + 3] : T = l[_ + 3] << 24 | l[_ + 2] << 16 | l[_ + 1] << 8 | l[_], d[v] = T >>> 0;
  }
  return d;
}
utils$g.join32 = join32;
function split32(l, t) {
  for (var s = new Array(l.length * 4), h = 0, m = 0; h < l.length; h++, m += 4) {
    var d = l[h];
    t === "big" ? (s[m] = d >>> 24, s[m + 1] = d >>> 16 & 255, s[m + 2] = d >>> 8 & 255, s[m + 3] = d & 255) : (s[m + 3] = d >>> 24, s[m + 2] = d >>> 16 & 255, s[m + 1] = d >>> 8 & 255, s[m] = d & 255);
  }
  return s;
}
utils$g.split32 = split32;
function rotr32$1(l, t) {
  return l >>> t | l << 32 - t;
}
utils$g.rotr32 = rotr32$1;
function rotl32$2(l, t) {
  return l << t | l >>> 32 - t;
}
utils$g.rotl32 = rotl32$2;
function sum32$3(l, t) {
  return l + t >>> 0;
}
utils$g.sum32 = sum32$3;
function sum32_3$1(l, t, s) {
  return l + t + s >>> 0;
}
utils$g.sum32_3 = sum32_3$1;
function sum32_4$2(l, t, s, h) {
  return l + t + s + h >>> 0;
}
utils$g.sum32_4 = sum32_4$2;
function sum32_5$2(l, t, s, h, m) {
  return l + t + s + h + m >>> 0;
}
utils$g.sum32_5 = sum32_5$2;
function sum64$1(l, t, s, h) {
  var m = l[t], d = l[t + 1], v = h + d >>> 0, _ = (v < h ? 1 : 0) + s + m;
  l[t] = _ >>> 0, l[t + 1] = v;
}
utils$g.sum64 = sum64$1;
function sum64_hi$1(l, t, s, h) {
  var m = t + h >>> 0, d = (m < t ? 1 : 0) + l + s;
  return d >>> 0;
}
utils$g.sum64_hi = sum64_hi$1;
function sum64_lo$1(l, t, s, h) {
  var m = t + h;
  return m >>> 0;
}
utils$g.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(l, t, s, h, m, d, v, _) {
  var T = 0, z = t;
  z = z + h >>> 0, T += z < t ? 1 : 0, z = z + d >>> 0, T += z < d ? 1 : 0, z = z + _ >>> 0, T += z < _ ? 1 : 0;
  var J = l + s + m + v + T;
  return J >>> 0;
}
utils$g.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(l, t, s, h, m, d, v, _) {
  var T = t + h + d + _;
  return T >>> 0;
}
utils$g.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(l, t, s, h, m, d, v, _, T, z) {
  var J = 0, Y = t;
  Y = Y + h >>> 0, J += Y < t ? 1 : 0, Y = Y + d >>> 0, J += Y < d ? 1 : 0, Y = Y + _ >>> 0, J += Y < _ ? 1 : 0, Y = Y + z >>> 0, J += Y < z ? 1 : 0;
  var ie = l + s + m + v + T + J;
  return ie >>> 0;
}
utils$g.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(l, t, s, h, m, d, v, _, T, z) {
  var J = t + h + d + _ + z;
  return J >>> 0;
}
utils$g.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(l, t, s) {
  var h = t << 32 - s | l >>> s;
  return h >>> 0;
}
utils$g.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(l, t, s) {
  var h = l << 32 - s | t >>> s;
  return h >>> 0;
}
utils$g.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(l, t, s) {
  return l >>> s;
}
utils$g.shr64_hi = shr64_hi$1;
function shr64_lo$1(l, t, s) {
  var h = l << 32 - s | t >>> s;
  return h >>> 0;
}
utils$g.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$f = utils$g, assert$9 = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(t, s) {
  if (t = utils$f.toArray(t, s), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
    t = this.pending;
    var h = t.length % this._delta8;
    this.pending = t.slice(t.length - h, t.length), this.pending.length === 0 && (this.pending = null), t = utils$f.join32(t, 0, t.length - h, this.endian);
    for (var m = 0; m < t.length; m += this._delta32)
      this._update(t, m, m + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(t) {
  return this.update(this._pad()), assert$9(this.pending === null), this._digest(t);
};
BlockHash$4.prototype._pad = function() {
  var t = this.pendingTotal, s = this._delta8, h = s - (t + this.padLength) % s, m = new Array(h + this.padLength);
  m[0] = 128;
  for (var d = 1; d < h; d++)
    m[d] = 0;
  if (t <<= 3, this.endian === "big") {
    for (var v = 8; v < this.padLength; v++)
      m[d++] = 0;
    m[d++] = 0, m[d++] = 0, m[d++] = 0, m[d++] = 0, m[d++] = t >>> 24 & 255, m[d++] = t >>> 16 & 255, m[d++] = t >>> 8 & 255, m[d++] = t & 255;
  } else
    for (m[d++] = t & 255, m[d++] = t >>> 8 & 255, m[d++] = t >>> 16 & 255, m[d++] = t >>> 24 & 255, m[d++] = 0, m[d++] = 0, m[d++] = 0, m[d++] = 0, v = 8; v < this.padLength; v++)
      m[d++] = 0;
  return m;
};
var sha = {}, common$4 = {}, utils$e = utils$g, rotr32 = utils$e.rotr32;
function ft_1$1(l, t, s, h) {
  if (l === 0)
    return ch32$1(t, s, h);
  if (l === 1 || l === 3)
    return p32(t, s, h);
  if (l === 2)
    return maj32$1(t, s, h);
}
common$4.ft_1 = ft_1$1;
function ch32$1(l, t, s) {
  return l & t ^ ~l & s;
}
common$4.ch32 = ch32$1;
function maj32$1(l, t, s) {
  return l & t ^ l & s ^ t & s;
}
common$4.maj32 = maj32$1;
function p32(l, t, s) {
  return l ^ t ^ s;
}
common$4.p32 = p32;
function s0_256$1(l) {
  return rotr32(l, 2) ^ rotr32(l, 13) ^ rotr32(l, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(l) {
  return rotr32(l, 6) ^ rotr32(l, 11) ^ rotr32(l, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(l) {
  return rotr32(l, 7) ^ rotr32(l, 18) ^ l >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(l) {
  return rotr32(l, 17) ^ rotr32(l, 19) ^ l >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$d = utils$g, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$d.rotl32, sum32$2 = utils$d.sum32, sum32_5$1 = utils$d.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$d.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(t, s) {
  for (var h = this.W, m = 0; m < 16; m++)
    h[m] = t[s + m];
  for (; m < h.length; m++)
    h[m] = rotl32$1(h[m - 3] ^ h[m - 8] ^ h[m - 14] ^ h[m - 16], 1);
  var d = this.h[0], v = this.h[1], _ = this.h[2], T = this.h[3], z = this.h[4];
  for (m = 0; m < h.length; m++) {
    var J = ~~(m / 20), Y = sum32_5$1(rotl32$1(d, 5), ft_1(J, v, _, T), z, h[m], sha1_K[J]);
    z = T, T = _, _ = rotl32$1(v, 30), v = d, d = Y;
  }
  this.h[0] = sum32$2(this.h[0], d), this.h[1] = sum32$2(this.h[1], v), this.h[2] = sum32$2(this.h[2], _), this.h[3] = sum32$2(this.h[3], T), this.h[4] = sum32$2(this.h[4], z);
};
SHA1.prototype._digest = function(t) {
  return t === "hex" ? utils$d.toHex32(this.h, "big") : utils$d.split32(this.h, "big");
};
var utils$c = utils$g, common$2 = common$5, shaCommon = common$4, assert$8 = minimalisticAssert$1, sum32$1 = utils$c.sum32, sum32_4$1 = utils$c.sum32_4, sum32_5 = utils$c.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$2() {
  if (!(this instanceof SHA256$2))
    return new SHA256$2();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$c.inherits(SHA256$2, BlockHash$2);
var _256 = SHA256$2;
SHA256$2.blockSize = 512;
SHA256$2.outSize = 256;
SHA256$2.hmacStrength = 192;
SHA256$2.padLength = 64;
SHA256$2.prototype._update = function(t, s) {
  for (var h = this.W, m = 0; m < 16; m++)
    h[m] = t[s + m];
  for (; m < h.length; m++)
    h[m] = sum32_4$1(g1_256(h[m - 2]), h[m - 7], g0_256(h[m - 15]), h[m - 16]);
  var d = this.h[0], v = this.h[1], _ = this.h[2], T = this.h[3], z = this.h[4], J = this.h[5], Y = this.h[6], ie = this.h[7];
  for (assert$8(this.k.length === h.length), m = 0; m < h.length; m++) {
    var ne = sum32_5(ie, s1_256(z), ch32(z, J, Y), this.k[m], h[m]), de = sum32$1(s0_256(d), maj32(d, v, _));
    ie = Y, Y = J, J = z, z = sum32$1(T, ne), T = _, _ = v, v = d, d = sum32$1(ne, de);
  }
  this.h[0] = sum32$1(this.h[0], d), this.h[1] = sum32$1(this.h[1], v), this.h[2] = sum32$1(this.h[2], _), this.h[3] = sum32$1(this.h[3], T), this.h[4] = sum32$1(this.h[4], z), this.h[5] = sum32$1(this.h[5], J), this.h[6] = sum32$1(this.h[6], Y), this.h[7] = sum32$1(this.h[7], ie);
};
SHA256$2.prototype._digest = function(t) {
  return t === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$g, SHA256$1 = _256;
function SHA224$1() {
  if (!(this instanceof SHA224$1))
    return new SHA224$1();
  SHA256$1.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$b.inherits(SHA224$1, SHA256$1);
var _224 = SHA224$1;
SHA224$1.blockSize = 512;
SHA224$1.outSize = 224;
SHA224$1.hmacStrength = 192;
SHA224$1.padLength = 64;
SHA224$1.prototype._digest = function(t) {
  return t === "hex" ? utils$b.toHex32(this.h.slice(0, 7), "big") : utils$b.split32(this.h.slice(0, 7), "big");
};
var utils$a = utils$g, common$1 = common$5, assert$7 = minimalisticAssert$1, rotr64_hi = utils$a.rotr64_hi, rotr64_lo = utils$a.rotr64_lo, shr64_hi = utils$a.shr64_hi, shr64_lo = utils$a.shr64_lo, sum64 = utils$a.sum64, sum64_hi = utils$a.sum64_hi, sum64_lo = utils$a.sum64_lo, sum64_4_hi = utils$a.sum64_4_hi, sum64_4_lo = utils$a.sum64_4_lo, sum64_5_hi = utils$a.sum64_5_hi, sum64_5_lo = utils$a.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$2() {
  if (!(this instanceof SHA512$2))
    return new SHA512$2();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$a.inherits(SHA512$2, BlockHash$1);
var _512 = SHA512$2;
SHA512$2.blockSize = 1024;
SHA512$2.outSize = 512;
SHA512$2.hmacStrength = 192;
SHA512$2.padLength = 128;
SHA512$2.prototype._prepareBlock = function(t, s) {
  for (var h = this.W, m = 0; m < 32; m++)
    h[m] = t[s + m];
  for (; m < h.length; m += 2) {
    var d = g1_512_hi(h[m - 4], h[m - 3]), v = g1_512_lo(h[m - 4], h[m - 3]), _ = h[m - 14], T = h[m - 13], z = g0_512_hi(h[m - 30], h[m - 29]), J = g0_512_lo(h[m - 30], h[m - 29]), Y = h[m - 32], ie = h[m - 31];
    h[m] = sum64_4_hi(
      d,
      v,
      _,
      T,
      z,
      J,
      Y,
      ie
    ), h[m + 1] = sum64_4_lo(
      d,
      v,
      _,
      T,
      z,
      J,
      Y,
      ie
    );
  }
};
SHA512$2.prototype._update = function(t, s) {
  this._prepareBlock(t, s);
  var h = this.W, m = this.h[0], d = this.h[1], v = this.h[2], _ = this.h[3], T = this.h[4], z = this.h[5], J = this.h[6], Y = this.h[7], ie = this.h[8], ne = this.h[9], de = this.h[10], ce = this.h[11], re = this.h[12], oe = this.h[13], pe = this.h[14], ae = this.h[15];
  assert$7(this.k.length === h.length);
  for (var me = 0; me < h.length; me += 2) {
    var ge = pe, we = ae, Ee = s1_512_hi(ie, ne), Te = s1_512_lo(ie, ne), Ke = ch64_hi(ie, ne, de, ce, re), Se = ch64_lo(ie, ne, de, ce, re, oe), X = this.k[me], fe = this.k[me + 1], k = h[me], p = h[me + 1], x = sum64_5_hi(
      ge,
      we,
      Ee,
      Te,
      Ke,
      Se,
      X,
      fe,
      k,
      p
    ), S = sum64_5_lo(
      ge,
      we,
      Ee,
      Te,
      Ke,
      Se,
      X,
      fe,
      k,
      p
    );
    ge = s0_512_hi(m, d), we = s0_512_lo(m, d), Ee = maj64_hi(m, d, v, _, T), Te = maj64_lo(m, d, v, _, T, z);
    var B = sum64_hi(ge, we, Ee, Te), L = sum64_lo(ge, we, Ee, Te);
    pe = re, ae = oe, re = de, oe = ce, de = ie, ce = ne, ie = sum64_hi(J, Y, x, S), ne = sum64_lo(Y, Y, x, S), J = T, Y = z, T = v, z = _, v = m, _ = d, m = sum64_hi(x, S, B, L), d = sum64_lo(x, S, B, L);
  }
  sum64(this.h, 0, m, d), sum64(this.h, 2, v, _), sum64(this.h, 4, T, z), sum64(this.h, 6, J, Y), sum64(this.h, 8, ie, ne), sum64(this.h, 10, de, ce), sum64(this.h, 12, re, oe), sum64(this.h, 14, pe, ae);
};
SHA512$2.prototype._digest = function(t) {
  return t === "hex" ? utils$a.toHex32(this.h, "big") : utils$a.split32(this.h, "big");
};
function ch64_hi(l, t, s, h, m) {
  var d = l & s ^ ~l & m;
  return d < 0 && (d += 4294967296), d;
}
function ch64_lo(l, t, s, h, m, d) {
  var v = t & h ^ ~t & d;
  return v < 0 && (v += 4294967296), v;
}
function maj64_hi(l, t, s, h, m) {
  var d = l & s ^ l & m ^ s & m;
  return d < 0 && (d += 4294967296), d;
}
function maj64_lo(l, t, s, h, m, d) {
  var v = t & h ^ t & d ^ h & d;
  return v < 0 && (v += 4294967296), v;
}
function s0_512_hi(l, t) {
  var s = rotr64_hi(l, t, 28), h = rotr64_hi(t, l, 2), m = rotr64_hi(t, l, 7), d = s ^ h ^ m;
  return d < 0 && (d += 4294967296), d;
}
function s0_512_lo(l, t) {
  var s = rotr64_lo(l, t, 28), h = rotr64_lo(t, l, 2), m = rotr64_lo(t, l, 7), d = s ^ h ^ m;
  return d < 0 && (d += 4294967296), d;
}
function s1_512_hi(l, t) {
  var s = rotr64_hi(l, t, 14), h = rotr64_hi(l, t, 18), m = rotr64_hi(t, l, 9), d = s ^ h ^ m;
  return d < 0 && (d += 4294967296), d;
}
function s1_512_lo(l, t) {
  var s = rotr64_lo(l, t, 14), h = rotr64_lo(l, t, 18), m = rotr64_lo(t, l, 9), d = s ^ h ^ m;
  return d < 0 && (d += 4294967296), d;
}
function g0_512_hi(l, t) {
  var s = rotr64_hi(l, t, 1), h = rotr64_hi(l, t, 8), m = shr64_hi(l, t, 7), d = s ^ h ^ m;
  return d < 0 && (d += 4294967296), d;
}
function g0_512_lo(l, t) {
  var s = rotr64_lo(l, t, 1), h = rotr64_lo(l, t, 8), m = shr64_lo(l, t, 7), d = s ^ h ^ m;
  return d < 0 && (d += 4294967296), d;
}
function g1_512_hi(l, t) {
  var s = rotr64_hi(l, t, 19), h = rotr64_hi(t, l, 29), m = shr64_hi(l, t, 6), d = s ^ h ^ m;
  return d < 0 && (d += 4294967296), d;
}
function g1_512_lo(l, t) {
  var s = rotr64_lo(l, t, 19), h = rotr64_lo(t, l, 29), m = shr64_lo(l, t, 6), d = s ^ h ^ m;
  return d < 0 && (d += 4294967296), d;
}
var utils$9 = utils$g, SHA512$1 = _512;
function SHA384$1() {
  if (!(this instanceof SHA384$1))
    return new SHA384$1();
  SHA512$1.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$9.inherits(SHA384$1, SHA512$1);
var _384 = SHA384$1;
SHA384$1.blockSize = 1024;
SHA384$1.outSize = 384;
SHA384$1.hmacStrength = 192;
SHA384$1.padLength = 128;
SHA384$1.prototype._digest = function(t) {
  return t === "hex" ? utils$9.toHex32(this.h.slice(0, 12), "big") : utils$9.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$8 = utils$g, common = common$5, rotl32 = utils$8.rotl32, sum32 = utils$8.sum32, sum32_3 = utils$8.sum32_3, sum32_4 = utils$8.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$8.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function(t, s) {
  for (var h = this.h[0], m = this.h[1], d = this.h[2], v = this.h[3], _ = this.h[4], T = h, z = m, J = d, Y = v, ie = _, ne = 0; ne < 80; ne++) {
    var de = sum32(
      rotl32(
        sum32_4(h, f$3(ne, m, d, v), t[r$2[ne] + s], K$1(ne)),
        s$2[ne]
      ),
      _
    );
    h = _, _ = v, v = rotl32(d, 10), d = m, m = de, de = sum32(
      rotl32(
        sum32_4(T, f$3(79 - ne, z, J, Y), t[rh[ne] + s], Kh(ne)),
        sh[ne]
      ),
      ie
    ), T = ie, ie = Y, Y = rotl32(J, 10), J = z, z = de;
  }
  de = sum32_3(this.h[1], d, Y), this.h[1] = sum32_3(this.h[2], v, ie), this.h[2] = sum32_3(this.h[3], _, T), this.h[3] = sum32_3(this.h[4], h, z), this.h[4] = sum32_3(this.h[0], m, J), this.h[0] = de;
};
RIPEMD160.prototype._digest = function(t) {
  return t === "hex" ? utils$8.toHex32(this.h, "little") : utils$8.split32(this.h, "little");
};
function f$3(l, t, s, h) {
  return l <= 15 ? t ^ s ^ h : l <= 31 ? t & s | ~t & h : l <= 47 ? (t | ~s) ^ h : l <= 63 ? t & h | s & ~h : t ^ (s | ~h);
}
function K$1(l) {
  return l <= 15 ? 0 : l <= 31 ? 1518500249 : l <= 47 ? 1859775393 : l <= 63 ? 2400959708 : 2840853838;
}
function Kh(l) {
  return l <= 15 ? 1352829926 : l <= 31 ? 1548603684 : l <= 47 ? 1836072691 : l <= 63 ? 2053994217 : 0;
}
var r$2 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$2 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$7 = utils$g, assert$6 = minimalisticAssert$1;
function Hmac(l, t, s) {
  if (!(this instanceof Hmac))
    return new Hmac(l, t, s);
  this.Hash = l, this.blockSize = l.blockSize / 8, this.outSize = l.outSize / 8, this.inner = null, this.outer = null, this._init(utils$7.toArray(t, s));
}
var hmac$1 = Hmac;
Hmac.prototype._init = function(t) {
  t.length > this.blockSize && (t = new this.Hash().update(t).digest()), assert$6(t.length <= this.blockSize);
  for (var s = t.length; s < this.blockSize; s++)
    t.push(0);
  for (s = 0; s < t.length; s++)
    t[s] ^= 54;
  for (this.inner = new this.Hash().update(t), s = 0; s < t.length; s++)
    t[s] ^= 106;
  this.outer = new this.Hash().update(t);
};
Hmac.prototype.update = function(t, s) {
  return this.inner.update(t, s), this;
};
Hmac.prototype.digest = function(t) {
  return this.outer.update(this.inner.digest()), this.outer.digest(t);
};
(function(l) {
  var t = l;
  t.utils = utils$g, t.common = common$5, t.sha = sha, t.ripemd = ripemd, t.hmac = hmac$1, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
})(hash$1);
function createCommonjsModule(l, t, s) {
  return s = {
    path: t,
    exports: {},
    require: function(h, m) {
      return commonjsRequire$1(h, m == null ? s.path : m);
    }
  }, l(s, s.exports), s.exports;
}
function commonjsRequire$1() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert$3;
function assert$3(l, t) {
  if (!l)
    throw new Error(t || "Assertion failed");
}
assert$3.equal = function(t, s, h) {
  if (t != s)
    throw new Error(h || "Assertion failed: " + t + " != " + s);
};
var utils_1$1 = createCommonjsModule(function(l, t) {
  var s = t;
  function h(v, _) {
    if (Array.isArray(v))
      return v.slice();
    if (!v)
      return [];
    var T = [];
    if (typeof v != "string") {
      for (var z = 0; z < v.length; z++)
        T[z] = v[z] | 0;
      return T;
    }
    if (_ === "hex") {
      v = v.replace(/[^a-z0-9]+/ig, ""), v.length % 2 !== 0 && (v = "0" + v);
      for (var z = 0; z < v.length; z += 2)
        T.push(parseInt(v[z] + v[z + 1], 16));
    } else
      for (var z = 0; z < v.length; z++) {
        var J = v.charCodeAt(z), Y = J >> 8, ie = J & 255;
        Y ? T.push(Y, ie) : T.push(ie);
      }
    return T;
  }
  s.toArray = h;
  function m(v) {
    return v.length === 1 ? "0" + v : v;
  }
  s.zero2 = m;
  function d(v) {
    for (var _ = "", T = 0; T < v.length; T++)
      _ += m(v[T].toString(16));
    return _;
  }
  s.toHex = d, s.encode = function(_, T) {
    return T === "hex" ? d(_) : _;
  };
}), utils_1$1$1 = createCommonjsModule(function(l, t) {
  var s = t;
  s.assert = minimalisticAssert, s.toArray = utils_1$1.toArray, s.zero2 = utils_1$1.zero2, s.toHex = utils_1$1.toHex, s.encode = utils_1$1.encode;
  function h(T, z, J) {
    var Y = new Array(Math.max(T.bitLength(), J) + 1);
    Y.fill(0);
    for (var ie = 1 << z + 1, ne = T.clone(), de = 0; de < Y.length; de++) {
      var ce, re = ne.andln(ie - 1);
      ne.isOdd() ? (re > (ie >> 1) - 1 ? ce = (ie >> 1) - re : ce = re, ne.isubn(ce)) : ce = 0, Y[de] = ce, ne.iushrn(1);
    }
    return Y;
  }
  s.getNAF = h;
  function m(T, z) {
    var J = [
      [],
      []
    ];
    T = T.clone(), z = z.clone();
    for (var Y = 0, ie = 0, ne; T.cmpn(-Y) > 0 || z.cmpn(-ie) > 0; ) {
      var de = T.andln(3) + Y & 3, ce = z.andln(3) + ie & 3;
      de === 3 && (de = -1), ce === 3 && (ce = -1);
      var re;
      (de & 1) === 0 ? re = 0 : (ne = T.andln(7) + Y & 7, (ne === 3 || ne === 5) && ce === 2 ? re = -de : re = de), J[0].push(re);
      var oe;
      (ce & 1) === 0 ? oe = 0 : (ne = z.andln(7) + ie & 7, (ne === 3 || ne === 5) && de === 2 ? oe = -ce : oe = ce), J[1].push(oe), 2 * Y === re + 1 && (Y = 1 - Y), 2 * ie === oe + 1 && (ie = 1 - ie), T.iushrn(1), z.iushrn(1);
    }
    return J;
  }
  s.getJSF = m;
  function d(T, z, J) {
    var Y = "_" + z;
    T.prototype[z] = function() {
      return this[Y] !== void 0 ? this[Y] : this[Y] = J.call(this);
    };
  }
  s.cachedProperty = d;
  function v(T) {
    return typeof T == "string" ? s.toArray(T, "hex") : T;
  }
  s.parseBytes = v;
  function _(T) {
    return new BN$2(T, "hex", "le");
  }
  s.intFromLE = _;
}), getNAF = utils_1$1$1.getNAF, getJSF = utils_1$1$1.getJSF, assert$1$1 = utils_1$1$1.assert;
function BaseCurve(l, t) {
  this.type = l, this.p = new BN$2(t.p, 16), this.red = t.prime ? BN$2.red(t.prime) : BN$2.mont(this.p), this.zero = new BN$2(0).toRed(this.red), this.one = new BN$2(1).toRed(this.red), this.two = new BN$2(2).toRed(this.red), this.n = t.n && new BN$2(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var s = this.n && this.p.div(this.n);
  !s || s.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(t, s) {
  assert$1$1(t.precomputed);
  var h = t._getDoubles(), m = getNAF(s, 1, this._bitLength), d = (1 << h.step + 1) - (h.step % 2 === 0 ? 2 : 1);
  d /= 3;
  var v = [], _, T;
  for (_ = 0; _ < m.length; _ += h.step) {
    T = 0;
    for (var z = _ + h.step - 1; z >= _; z--)
      T = (T << 1) + m[z];
    v.push(T);
  }
  for (var J = this.jpoint(null, null, null), Y = this.jpoint(null, null, null), ie = d; ie > 0; ie--) {
    for (_ = 0; _ < v.length; _++)
      T = v[_], T === ie ? Y = Y.mixedAdd(h.points[_]) : T === -ie && (Y = Y.mixedAdd(h.points[_].neg()));
    J = J.add(Y);
  }
  return J.toP();
};
BaseCurve.prototype._wnafMul = function(t, s) {
  var h = 4, m = t._getNAFPoints(h);
  h = m.wnd;
  for (var d = m.points, v = getNAF(s, h, this._bitLength), _ = this.jpoint(null, null, null), T = v.length - 1; T >= 0; T--) {
    for (var z = 0; T >= 0 && v[T] === 0; T--)
      z++;
    if (T >= 0 && z++, _ = _.dblp(z), T < 0)
      break;
    var J = v[T];
    assert$1$1(J !== 0), t.type === "affine" ? J > 0 ? _ = _.mixedAdd(d[J - 1 >> 1]) : _ = _.mixedAdd(d[-J - 1 >> 1].neg()) : J > 0 ? _ = _.add(d[J - 1 >> 1]) : _ = _.add(d[-J - 1 >> 1].neg());
  }
  return t.type === "affine" ? _.toP() : _;
};
BaseCurve.prototype._wnafMulAdd = function(t, s, h, m, d) {
  var v = this._wnafT1, _ = this._wnafT2, T = this._wnafT3, z = 0, J, Y, ie;
  for (J = 0; J < m; J++) {
    ie = s[J];
    var ne = ie._getNAFPoints(t);
    v[J] = ne.wnd, _[J] = ne.points;
  }
  for (J = m - 1; J >= 1; J -= 2) {
    var de = J - 1, ce = J;
    if (v[de] !== 1 || v[ce] !== 1) {
      T[de] = getNAF(h[de], v[de], this._bitLength), T[ce] = getNAF(h[ce], v[ce], this._bitLength), z = Math.max(T[de].length, z), z = Math.max(T[ce].length, z);
      continue;
    }
    var re = [
      s[de],
      null,
      null,
      s[ce]
    ];
    s[de].y.cmp(s[ce].y) === 0 ? (re[1] = s[de].add(s[ce]), re[2] = s[de].toJ().mixedAdd(s[ce].neg())) : s[de].y.cmp(s[ce].y.redNeg()) === 0 ? (re[1] = s[de].toJ().mixedAdd(s[ce]), re[2] = s[de].add(s[ce].neg())) : (re[1] = s[de].toJ().mixedAdd(s[ce]), re[2] = s[de].toJ().mixedAdd(s[ce].neg()));
    var oe = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ], pe = getJSF(h[de], h[ce]);
    for (z = Math.max(pe[0].length, z), T[de] = new Array(z), T[ce] = new Array(z), Y = 0; Y < z; Y++) {
      var ae = pe[0][Y] | 0, me = pe[1][Y] | 0;
      T[de][Y] = oe[(ae + 1) * 3 + (me + 1)], T[ce][Y] = 0, _[de] = re;
    }
  }
  var ge = this.jpoint(null, null, null), we = this._wnafT4;
  for (J = z; J >= 0; J--) {
    for (var Ee = 0; J >= 0; ) {
      var Te = !0;
      for (Y = 0; Y < m; Y++)
        we[Y] = T[Y][J] | 0, we[Y] !== 0 && (Te = !1);
      if (!Te)
        break;
      Ee++, J--;
    }
    if (J >= 0 && Ee++, ge = ge.dblp(Ee), J < 0)
      break;
    for (Y = 0; Y < m; Y++) {
      var Ke = we[Y];
      Ke !== 0 && (Ke > 0 ? ie = _[Y][Ke - 1 >> 1] : Ke < 0 && (ie = _[Y][-Ke - 1 >> 1].neg()), ie.type === "affine" ? ge = ge.mixedAdd(ie) : ge = ge.add(ie));
    }
  }
  for (J = 0; J < m; J++)
    _[J] = null;
  return d ? ge : ge.toP();
};
function BasePoint(l, t) {
  this.curve = l, this.type = t, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(t, s) {
  t = utils_1$1$1.toArray(t, s);
  var h = this.p.byteLength();
  if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * h) {
    t[0] === 6 ? assert$1$1(t[t.length - 1] % 2 === 0) : t[0] === 7 && assert$1$1(t[t.length - 1] % 2 === 1);
    var m = this.point(
      t.slice(1, 1 + h),
      t.slice(1 + h, 1 + 2 * h)
    );
    return m;
  } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === h)
    return this.pointFromX(t.slice(1, 1 + h), t[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(t) {
  return this.encode(t, !0);
};
BasePoint.prototype._encode = function(t) {
  var s = this.curve.p.byteLength(), h = this.getX().toArray("be", s);
  return t ? [this.getY().isEven() ? 2 : 3].concat(h) : [4].concat(h, this.getY().toArray("be", s));
};
BasePoint.prototype.encode = function(t, s) {
  return utils_1$1$1.encode(this._encode(s), t);
};
BasePoint.prototype.precompute = function(t) {
  if (this.precomputed)
    return this;
  var s = {
    doubles: null,
    naf: null,
    beta: null
  };
  return s.naf = this._getNAFPoints(8), s.doubles = this._getDoubles(4, t), s.beta = this._getBeta(), this.precomputed = s, this;
};
BasePoint.prototype._hasDoubles = function(t) {
  if (!this.precomputed)
    return !1;
  var s = this.precomputed.doubles;
  return s ? s.points.length >= Math.ceil((t.bitLength() + 1) / s.step) : !1;
};
BasePoint.prototype._getDoubles = function(t, s) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var h = [this], m = this, d = 0; d < s; d += t) {
    for (var v = 0; v < t; v++)
      m = m.dbl();
    h.push(m);
  }
  return {
    step: t,
    points: h
  };
};
BasePoint.prototype._getNAFPoints = function(t) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var s = [this], h = (1 << t) - 1, m = h === 1 ? null : this.dbl(), d = 1; d < h; d++)
    s[d] = s[d - 1].add(m);
  return {
    wnd: t,
    points: s
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(t) {
  for (var s = this, h = 0; h < t; h++)
    s = s.dbl();
  return s;
};
var inherits_browser = createCommonjsModule(function(l) {
  typeof Object.create == "function" ? l.exports = function(s, h) {
    h && (s.super_ = h, s.prototype = Object.create(h.prototype, {
      constructor: {
        value: s,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : l.exports = function(s, h) {
    if (h) {
      s.super_ = h;
      var m = function() {
      };
      m.prototype = h.prototype, s.prototype = new m(), s.prototype.constructor = s;
    }
  };
}), assert$2$1 = utils_1$1$1.assert;
function ShortCurve(l) {
  base$1.call(this, "short", l), this.a = new BN$2(l.a, 16).toRed(this.red), this.b = new BN$2(l.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(l), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base$1);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(t) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var s, h;
    if (t.beta)
      s = new BN$2(t.beta, 16).toRed(this.red);
    else {
      var m = this._getEndoRoots(this.p);
      s = m[0].cmp(m[1]) < 0 ? m[0] : m[1], s = s.toRed(this.red);
    }
    if (t.lambda)
      h = new BN$2(t.lambda, 16);
    else {
      var d = this._getEndoRoots(this.n);
      this.g.mul(d[0]).x.cmp(this.g.x.redMul(s)) === 0 ? h = d[0] : (h = d[1], assert$2$1(this.g.mul(h).x.cmp(this.g.x.redMul(s)) === 0));
    }
    var v;
    return t.basis ? v = t.basis.map(function(_) {
      return {
        a: new BN$2(_.a, 16),
        b: new BN$2(_.b, 16)
      };
    }) : v = this._getEndoBasis(h), {
      beta: s,
      lambda: h,
      basis: v
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(t) {
  var s = t === this.p ? this.red : BN$2.mont(t), h = new BN$2(2).toRed(s).redInvm(), m = h.redNeg(), d = new BN$2(3).toRed(s).redNeg().redSqrt().redMul(h), v = m.redAdd(d).fromRed(), _ = m.redSub(d).fromRed();
  return [v, _];
};
ShortCurve.prototype._getEndoBasis = function(t) {
  for (var s = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), h = t, m = this.n.clone(), d = new BN$2(1), v = new BN$2(0), _ = new BN$2(0), T = new BN$2(1), z, J, Y, ie, ne, de, ce, re = 0, oe, pe; h.cmpn(0) !== 0; ) {
    var ae = m.div(h);
    oe = m.sub(ae.mul(h)), pe = _.sub(ae.mul(d));
    var me = T.sub(ae.mul(v));
    if (!Y && oe.cmp(s) < 0)
      z = ce.neg(), J = d, Y = oe.neg(), ie = pe;
    else if (Y && ++re === 2)
      break;
    ce = oe, m = h, h = oe, _ = d, d = pe, T = v, v = me;
  }
  ne = oe.neg(), de = pe;
  var ge = Y.sqr().add(ie.sqr()), we = ne.sqr().add(de.sqr());
  return we.cmp(ge) >= 0 && (ne = z, de = J), Y.negative && (Y = Y.neg(), ie = ie.neg()), ne.negative && (ne = ne.neg(), de = de.neg()), [
    { a: Y, b: ie },
    { a: ne, b: de }
  ];
};
ShortCurve.prototype._endoSplit = function(t) {
  var s = this.endo.basis, h = s[0], m = s[1], d = m.b.mul(t).divRound(this.n), v = h.b.neg().mul(t).divRound(this.n), _ = d.mul(h.a), T = v.mul(m.a), z = d.mul(h.b), J = v.mul(m.b), Y = t.sub(_).sub(T), ie = z.add(J).neg();
  return { k1: Y, k2: ie };
};
ShortCurve.prototype.pointFromX = function(t, s) {
  t = new BN$2(t, 16), t.red || (t = t.toRed(this.red));
  var h = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), m = h.redSqrt();
  if (m.redSqr().redSub(h).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var d = m.fromRed().isOdd();
  return (s && !d || !s && d) && (m = m.redNeg()), this.point(t, m);
};
ShortCurve.prototype.validate = function(t) {
  if (t.inf)
    return !0;
  var s = t.x, h = t.y, m = this.a.redMul(s), d = s.redSqr().redMul(s).redIAdd(m).redIAdd(this.b);
  return h.redSqr().redISub(d).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(t, s, h) {
  for (var m = this._endoWnafT1, d = this._endoWnafT2, v = 0; v < t.length; v++) {
    var _ = this._endoSplit(s[v]), T = t[v], z = T._getBeta();
    _.k1.negative && (_.k1.ineg(), T = T.neg(!0)), _.k2.negative && (_.k2.ineg(), z = z.neg(!0)), m[v * 2] = T, m[v * 2 + 1] = z, d[v * 2] = _.k1, d[v * 2 + 1] = _.k2;
  }
  for (var J = this._wnafMulAdd(1, m, d, v * 2, h), Y = 0; Y < v * 2; Y++)
    m[Y] = null, d[Y] = null;
  return J;
};
function Point$2(l, t, s, h) {
  base$1.BasePoint.call(this, l, "affine"), t === null && s === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$2(t, 16), this.y = new BN$2(s, 16), h && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits_browser(Point$2, base$1.BasePoint);
ShortCurve.prototype.point = function(t, s, h) {
  return new Point$2(this, t, s, h);
};
ShortCurve.prototype.pointFromJSON = function(t, s) {
  return Point$2.fromJSON(this, t, s);
};
Point$2.prototype._getBeta = function() {
  if (!!this.curve.endo) {
    var t = this.precomputed;
    if (t && t.beta)
      return t.beta;
    var s = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t) {
      var h = this.curve, m = function(d) {
        return h.point(d.x.redMul(h.endo.beta), d.y);
      };
      t.beta = s, s.precomputed = {
        beta: null,
        naf: t.naf && {
          wnd: t.naf.wnd,
          points: t.naf.points.map(m)
        },
        doubles: t.doubles && {
          step: t.doubles.step,
          points: t.doubles.points.map(m)
        }
      };
    }
    return s;
  }
};
Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function(t, s, h) {
  typeof s == "string" && (s = JSON.parse(s));
  var m = t.point(s[0], s[1], h);
  if (!s[2])
    return m;
  function d(_) {
    return t.point(_[0], _[1], h);
  }
  var v = s[2];
  return m.precomputed = {
    beta: null,
    doubles: v.doubles && {
      step: v.doubles.step,
      points: [m].concat(v.doubles.points.map(d))
    },
    naf: v.naf && {
      wnd: v.naf.wnd,
      points: [m].concat(v.naf.points.map(d))
    }
  }, m;
};
Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function() {
  return this.inf;
};
Point$2.prototype.add = function(t) {
  if (this.inf)
    return t;
  if (t.inf)
    return this;
  if (this.eq(t))
    return this.dbl();
  if (this.neg().eq(t))
    return this.curve.point(null, null);
  if (this.x.cmp(t.x) === 0)
    return this.curve.point(null, null);
  var s = this.y.redSub(t.y);
  s.cmpn(0) !== 0 && (s = s.redMul(this.x.redSub(t.x).redInvm()));
  var h = s.redSqr().redISub(this.x).redISub(t.x), m = s.redMul(this.x.redSub(h)).redISub(this.y);
  return this.curve.point(h, m);
};
Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var t = this.y.redAdd(this.y);
  if (t.cmpn(0) === 0)
    return this.curve.point(null, null);
  var s = this.curve.a, h = this.x.redSqr(), m = t.redInvm(), d = h.redAdd(h).redIAdd(h).redIAdd(s).redMul(m), v = d.redSqr().redISub(this.x.redAdd(this.x)), _ = d.redMul(this.x.redSub(v)).redISub(this.y);
  return this.curve.point(v, _);
};
Point$2.prototype.getX = function() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function(t) {
  return t = new BN$2(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t);
};
Point$2.prototype.mulAdd = function(t, s, h) {
  var m = [this, s], d = [t, h];
  return this.curve.endo ? this.curve._endoWnafMulAdd(m, d) : this.curve._wnafMulAdd(1, m, d, 2);
};
Point$2.prototype.jmulAdd = function(t, s, h) {
  var m = [this, s], d = [t, h];
  return this.curve.endo ? this.curve._endoWnafMulAdd(m, d, !0) : this.curve._wnafMulAdd(1, m, d, 2, !0);
};
Point$2.prototype.eq = function(t) {
  return this === t || this.inf === t.inf && (this.inf || this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0);
};
Point$2.prototype.neg = function(t) {
  if (this.inf)
    return this;
  var s = this.curve.point(this.x, this.y.redNeg());
  if (t && this.precomputed) {
    var h = this.precomputed, m = function(d) {
      return d.neg();
    };
    s.precomputed = {
      naf: h.naf && {
        wnd: h.naf.wnd,
        points: h.naf.points.map(m)
      },
      doubles: h.doubles && {
        step: h.doubles.step,
        points: h.doubles.points.map(m)
      }
    };
  }
  return s;
};
Point$2.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var t = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t;
};
function JPoint(l, t, s, h) {
  base$1.BasePoint.call(this, l, "jacobian"), t === null && s === null && h === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$2(0)) : (this.x = new BN$2(t, 16), this.y = new BN$2(s, 16), this.z = new BN$2(h, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base$1.BasePoint);
ShortCurve.prototype.jpoint = function(t, s, h) {
  return new JPoint(this, t, s, h);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var t = this.z.redInvm(), s = t.redSqr(), h = this.x.redMul(s), m = this.y.redMul(s).redMul(t);
  return this.curve.point(h, m);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(t) {
  if (this.isInfinity())
    return t;
  if (t.isInfinity())
    return this;
  var s = t.z.redSqr(), h = this.z.redSqr(), m = this.x.redMul(s), d = t.x.redMul(h), v = this.y.redMul(s.redMul(t.z)), _ = t.y.redMul(h.redMul(this.z)), T = m.redSub(d), z = v.redSub(_);
  if (T.cmpn(0) === 0)
    return z.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var J = T.redSqr(), Y = J.redMul(T), ie = m.redMul(J), ne = z.redSqr().redIAdd(Y).redISub(ie).redISub(ie), de = z.redMul(ie.redISub(ne)).redISub(v.redMul(Y)), ce = this.z.redMul(t.z).redMul(T);
  return this.curve.jpoint(ne, de, ce);
};
JPoint.prototype.mixedAdd = function(t) {
  if (this.isInfinity())
    return t.toJ();
  if (t.isInfinity())
    return this;
  var s = this.z.redSqr(), h = this.x, m = t.x.redMul(s), d = this.y, v = t.y.redMul(s).redMul(this.z), _ = h.redSub(m), T = d.redSub(v);
  if (_.cmpn(0) === 0)
    return T.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var z = _.redSqr(), J = z.redMul(_), Y = h.redMul(z), ie = T.redSqr().redIAdd(J).redISub(Y).redISub(Y), ne = T.redMul(Y.redISub(ie)).redISub(d.redMul(J)), de = this.z.redMul(_);
  return this.curve.jpoint(ie, ne, de);
};
JPoint.prototype.dblp = function(t) {
  if (t === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!t)
    return this.dbl();
  var s;
  if (this.curve.zeroA || this.curve.threeA) {
    var h = this;
    for (s = 0; s < t; s++)
      h = h.dbl();
    return h;
  }
  var m = this.curve.a, d = this.curve.tinv, v = this.x, _ = this.y, T = this.z, z = T.redSqr().redSqr(), J = _.redAdd(_);
  for (s = 0; s < t; s++) {
    var Y = v.redSqr(), ie = J.redSqr(), ne = ie.redSqr(), de = Y.redAdd(Y).redIAdd(Y).redIAdd(m.redMul(z)), ce = v.redMul(ie), re = de.redSqr().redISub(ce.redAdd(ce)), oe = ce.redISub(re), pe = de.redMul(oe);
    pe = pe.redIAdd(pe).redISub(ne);
    var ae = J.redMul(T);
    s + 1 < t && (z = z.redMul(ne)), v = re, T = ae, J = pe;
  }
  return this.curve.jpoint(v, J.redMul(d), T);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var t, s, h;
  if (this.zOne) {
    var m = this.x.redSqr(), d = this.y.redSqr(), v = d.redSqr(), _ = this.x.redAdd(d).redSqr().redISub(m).redISub(v);
    _ = _.redIAdd(_);
    var T = m.redAdd(m).redIAdd(m), z = T.redSqr().redISub(_).redISub(_), J = v.redIAdd(v);
    J = J.redIAdd(J), J = J.redIAdd(J), t = z, s = T.redMul(_.redISub(z)).redISub(J), h = this.y.redAdd(this.y);
  } else {
    var Y = this.x.redSqr(), ie = this.y.redSqr(), ne = ie.redSqr(), de = this.x.redAdd(ie).redSqr().redISub(Y).redISub(ne);
    de = de.redIAdd(de);
    var ce = Y.redAdd(Y).redIAdd(Y), re = ce.redSqr(), oe = ne.redIAdd(ne);
    oe = oe.redIAdd(oe), oe = oe.redIAdd(oe), t = re.redISub(de).redISub(de), s = ce.redMul(de.redISub(t)).redISub(oe), h = this.y.redMul(this.z), h = h.redIAdd(h);
  }
  return this.curve.jpoint(t, s, h);
};
JPoint.prototype._threeDbl = function() {
  var t, s, h;
  if (this.zOne) {
    var m = this.x.redSqr(), d = this.y.redSqr(), v = d.redSqr(), _ = this.x.redAdd(d).redSqr().redISub(m).redISub(v);
    _ = _.redIAdd(_);
    var T = m.redAdd(m).redIAdd(m).redIAdd(this.curve.a), z = T.redSqr().redISub(_).redISub(_);
    t = z;
    var J = v.redIAdd(v);
    J = J.redIAdd(J), J = J.redIAdd(J), s = T.redMul(_.redISub(z)).redISub(J), h = this.y.redAdd(this.y);
  } else {
    var Y = this.z.redSqr(), ie = this.y.redSqr(), ne = this.x.redMul(ie), de = this.x.redSub(Y).redMul(this.x.redAdd(Y));
    de = de.redAdd(de).redIAdd(de);
    var ce = ne.redIAdd(ne);
    ce = ce.redIAdd(ce);
    var re = ce.redAdd(ce);
    t = de.redSqr().redISub(re), h = this.y.redAdd(this.z).redSqr().redISub(ie).redISub(Y);
    var oe = ie.redSqr();
    oe = oe.redIAdd(oe), oe = oe.redIAdd(oe), oe = oe.redIAdd(oe), s = de.redMul(ce.redISub(t)).redISub(oe);
  }
  return this.curve.jpoint(t, s, h);
};
JPoint.prototype._dbl = function() {
  var t = this.curve.a, s = this.x, h = this.y, m = this.z, d = m.redSqr().redSqr(), v = s.redSqr(), _ = h.redSqr(), T = v.redAdd(v).redIAdd(v).redIAdd(t.redMul(d)), z = s.redAdd(s);
  z = z.redIAdd(z);
  var J = z.redMul(_), Y = T.redSqr().redISub(J.redAdd(J)), ie = J.redISub(Y), ne = _.redSqr();
  ne = ne.redIAdd(ne), ne = ne.redIAdd(ne), ne = ne.redIAdd(ne);
  var de = T.redMul(ie).redISub(ne), ce = h.redAdd(h).redMul(m);
  return this.curve.jpoint(Y, de, ce);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var t = this.x.redSqr(), s = this.y.redSqr(), h = this.z.redSqr(), m = s.redSqr(), d = t.redAdd(t).redIAdd(t), v = d.redSqr(), _ = this.x.redAdd(s).redSqr().redISub(t).redISub(m);
  _ = _.redIAdd(_), _ = _.redAdd(_).redIAdd(_), _ = _.redISub(v);
  var T = _.redSqr(), z = m.redIAdd(m);
  z = z.redIAdd(z), z = z.redIAdd(z), z = z.redIAdd(z);
  var J = d.redIAdd(_).redSqr().redISub(v).redISub(T).redISub(z), Y = s.redMul(J);
  Y = Y.redIAdd(Y), Y = Y.redIAdd(Y);
  var ie = this.x.redMul(T).redISub(Y);
  ie = ie.redIAdd(ie), ie = ie.redIAdd(ie);
  var ne = this.y.redMul(J.redMul(z.redISub(J)).redISub(_.redMul(T)));
  ne = ne.redIAdd(ne), ne = ne.redIAdd(ne), ne = ne.redIAdd(ne);
  var de = this.z.redAdd(_).redSqr().redISub(h).redISub(T);
  return this.curve.jpoint(ie, ne, de);
};
JPoint.prototype.mul = function(t, s) {
  return t = new BN$2(t, s), this.curve._wnafMul(this, t);
};
JPoint.prototype.eq = function(t) {
  if (t.type === "affine")
    return this.eq(t.toJ());
  if (this === t)
    return !0;
  var s = this.z.redSqr(), h = t.z.redSqr();
  if (this.x.redMul(h).redISub(t.x.redMul(s)).cmpn(0) !== 0)
    return !1;
  var m = s.redMul(this.z), d = h.redMul(t.z);
  return this.y.redMul(d).redISub(t.y.redMul(m)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(t) {
  var s = this.z.redSqr(), h = t.toRed(this.curve.red).redMul(s);
  if (this.x.cmp(h) === 0)
    return !0;
  for (var m = t.clone(), d = this.curve.redN.redMul(s); ; ) {
    if (m.iadd(this.curve.n), m.cmp(this.curve.p) >= 0)
      return !1;
    if (h.redIAdd(d), this.x.cmp(h) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(l, t) {
  var s = t;
  s.base = base$1, s.short = short_1, s.mont = null, s.edwards = null;
}), curves_1 = createCommonjsModule(function(l, t) {
  var s = t, h = utils_1$1$1.assert;
  function m(_) {
    _.type === "short" ? this.curve = new curve_1.short(_) : _.type === "edwards" ? this.curve = new curve_1.edwards(_) : this.curve = new curve_1.mont(_), this.g = this.curve.g, this.n = this.curve.n, this.hash = _.hash, h(this.g.validate(), "Invalid curve"), h(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  s.PresetCurve = m;
  function d(_, T) {
    Object.defineProperty(s, _, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var z = new m(T);
        return Object.defineProperty(s, _, {
          configurable: !0,
          enumerable: !0,
          value: z
        }), z;
      }
    });
  }
  d("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$1.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), d("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$1.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), d("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$1.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), d("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$1.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), d("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$1.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), d("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$1.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), d("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$1.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var v;
  try {
    v = null.crash();
  } catch {
    v = void 0;
  }
  d("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$1.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      v
    ]
  });
});
function HmacDRBG(l) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(l);
  this.hash = l.hash, this.predResist = !!l.predResist, this.outLen = this.hash.outSize, this.minEntropy = l.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = utils_1$1.toArray(l.entropy, l.entropyEnc || "hex"), s = utils_1$1.toArray(l.nonce, l.nonceEnc || "hex"), h = utils_1$1.toArray(l.pers, l.persEnc || "hex");
  minimalisticAssert(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, s, h);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function(t, s, h) {
  var m = t.concat(s).concat(h);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var d = 0; d < this.V.length; d++)
    this.K[d] = 0, this.V[d] = 1;
  this._update(m), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function(t) {
  var s = this._hmac().update(this.V).update([0]);
  t && (s = s.update(t)), this.K = s.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function(t, s, h, m) {
  typeof s != "string" && (m = h, h = s, s = null), t = utils_1$1.toArray(t, s), h = utils_1$1.toArray(h, m), minimalisticAssert(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(t.concat(h || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function(t, s, h, m) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof s != "string" && (m = h, h = s, s = null), h && (h = utils_1$1.toArray(h, m || "hex"), this._update(h));
  for (var d = []; d.length < t; )
    this.V = this._hmac().update(this.V).digest(), d = d.concat(this.V);
  var v = d.slice(0, t);
  return this._update(h), this._reseed++, utils_1$1.encode(v, s);
};
var assert$3$1 = utils_1$1$1.assert;
function KeyPair(l, t) {
  this.ec = l, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function(t, s, h) {
  return s instanceof KeyPair ? s : new KeyPair(t, {
    pub: s,
    pubEnc: h
  });
};
KeyPair.fromPrivate = function(t, s, h) {
  return s instanceof KeyPair ? s : new KeyPair(t, {
    priv: s,
    privEnc: h
  });
};
KeyPair.prototype.validate = function() {
  var t = this.getPublic();
  return t.isInfinity() ? { result: !1, reason: "Invalid public key" } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair.prototype.getPublic = function(t, s) {
  return typeof t == "string" && (s = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), s ? this.pub.encode(s, t) : this.pub;
};
KeyPair.prototype.getPrivate = function(t) {
  return t === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair.prototype._importPrivate = function(t, s) {
  this.priv = new BN$2(t, s || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function(t, s) {
  if (t.x || t.y) {
    this.ec.curve.type === "mont" ? assert$3$1(t.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$3$1(t.x && t.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t.x, t.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(t, s);
};
KeyPair.prototype.derive = function(t) {
  return t.validate() || assert$3$1(t.validate(), "public point not validated"), t.mul(this.priv).getX();
};
KeyPair.prototype.sign = function(t, s, h) {
  return this.ec.sign(t, this, s, h);
};
KeyPair.prototype.verify = function(t, s) {
  return this.ec.verify(t, s, this);
};
KeyPair.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1$1.assert;
function Signature$2(l, t) {
  if (l instanceof Signature$2)
    return l;
  this._importDER(l, t) || (assert$4(l.r && l.s, "Signature without r or s"), this.r = new BN$2(l.r, 16), this.s = new BN$2(l.s, 16), l.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = l.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(l, t) {
  var s = l[t.place++];
  if (!(s & 128))
    return s;
  var h = s & 15;
  if (h === 0 || h > 4)
    return !1;
  for (var m = 0, d = 0, v = t.place; d < h; d++, v++)
    m <<= 8, m |= l[v], m >>>= 0;
  return m <= 127 ? !1 : (t.place = v, m);
}
function rmPadding(l) {
  for (var t = 0, s = l.length - 1; !l[t] && !(l[t + 1] & 128) && t < s; )
    t++;
  return t === 0 ? l : l.slice(t);
}
Signature$2.prototype._importDER = function(t, s) {
  t = utils_1$1$1.toArray(t, s);
  var h = new Position();
  if (t[h.place++] !== 48)
    return !1;
  var m = getLength(t, h);
  if (m === !1 || m + h.place !== t.length || t[h.place++] !== 2)
    return !1;
  var d = getLength(t, h);
  if (d === !1)
    return !1;
  var v = t.slice(h.place, d + h.place);
  if (h.place += d, t[h.place++] !== 2)
    return !1;
  var _ = getLength(t, h);
  if (_ === !1 || t.length !== _ + h.place)
    return !1;
  var T = t.slice(h.place, _ + h.place);
  if (v[0] === 0)
    if (v[1] & 128)
      v = v.slice(1);
    else
      return !1;
  if (T[0] === 0)
    if (T[1] & 128)
      T = T.slice(1);
    else
      return !1;
  return this.r = new BN$2(v), this.s = new BN$2(T), this.recoveryParam = null, !0;
};
function constructLength(l, t) {
  if (t < 128) {
    l.push(t);
    return;
  }
  var s = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (l.push(s | 128); --s; )
    l.push(t >>> (s << 3) & 255);
  l.push(t);
}
Signature$2.prototype.toDER = function(t) {
  var s = this.r.toArray(), h = this.s.toArray();
  for (s[0] & 128 && (s = [0].concat(s)), h[0] & 128 && (h = [0].concat(h)), s = rmPadding(s), h = rmPadding(h); !h[0] && !(h[1] & 128); )
    h = h.slice(1);
  var m = [2];
  constructLength(m, s.length), m = m.concat(s), m.push(2), constructLength(m, h.length);
  var d = m.concat(h), v = [48];
  return constructLength(v, d.length), v = v.concat(d), utils_1$1$1.encode(v, t);
};
var rand = function() {
  throw new Error("unsupported");
}, assert$5 = utils_1$1$1.assert;
function EC(l) {
  if (!(this instanceof EC))
    return new EC(l);
  typeof l == "string" && (assert$5(
    Object.prototype.hasOwnProperty.call(curves_1, l),
    "Unknown curve " + l
  ), l = curves_1[l]), l instanceof curves_1.PresetCurve && (l = { curve: l }), this.curve = l.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = l.curve.g, this.g.precompute(l.curve.n.bitLength() + 1), this.hash = l.hash || l.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function(t) {
  return new key(this, t);
};
EC.prototype.keyFromPrivate = function(t, s) {
  return key.fromPrivate(this, t, s);
};
EC.prototype.keyFromPublic = function(t, s) {
  return key.fromPublic(this, t, s);
};
EC.prototype.genKeyPair = function(t) {
  t || (t = {});
  for (var s = new hmacDrbg({
    hash: this.hash,
    pers: t.pers,
    persEnc: t.persEnc || "utf8",
    entropy: t.entropy || rand(this.hash.hmacStrength),
    entropyEnc: t.entropy && t.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), h = this.n.byteLength(), m = this.n.sub(new BN$2(2)); ; ) {
    var d = new BN$2(s.generate(h));
    if (!(d.cmp(m) > 0))
      return d.iaddn(1), this.keyFromPrivate(d);
  }
};
EC.prototype._truncateToN = function(t, s) {
  var h = t.byteLength() * 8 - this.n.bitLength();
  return h > 0 && (t = t.ushrn(h)), !s && t.cmp(this.n) >= 0 ? t.sub(this.n) : t;
};
EC.prototype.sign = function(t, s, h, m) {
  typeof h == "object" && (m = h, h = null), m || (m = {}), s = this.keyFromPrivate(s, h), t = this._truncateToN(new BN$2(t, 16));
  for (var d = this.n.byteLength(), v = s.getPrivate().toArray("be", d), _ = t.toArray("be", d), T = new hmacDrbg({
    hash: this.hash,
    entropy: v,
    nonce: _,
    pers: m.pers,
    persEnc: m.persEnc || "utf8"
  }), z = this.n.sub(new BN$2(1)), J = 0; ; J++) {
    var Y = m.k ? m.k(J) : new BN$2(T.generate(this.n.byteLength()));
    if (Y = this._truncateToN(Y, !0), !(Y.cmpn(1) <= 0 || Y.cmp(z) >= 0)) {
      var ie = this.g.mul(Y);
      if (!ie.isInfinity()) {
        var ne = ie.getX(), de = ne.umod(this.n);
        if (de.cmpn(0) !== 0) {
          var ce = Y.invm(this.n).mul(de.mul(s.getPrivate()).iadd(t));
          if (ce = ce.umod(this.n), ce.cmpn(0) !== 0) {
            var re = (ie.getY().isOdd() ? 1 : 0) | (ne.cmp(de) !== 0 ? 2 : 0);
            return m.canonical && ce.cmp(this.nh) > 0 && (ce = this.n.sub(ce), re ^= 1), new signature$1({ r: de, s: ce, recoveryParam: re });
          }
        }
      }
    }
  }
};
EC.prototype.verify = function(t, s, h, m) {
  t = this._truncateToN(new BN$2(t, 16)), h = this.keyFromPublic(h, m), s = new signature$1(s, "hex");
  var d = s.r, v = s.s;
  if (d.cmpn(1) < 0 || d.cmp(this.n) >= 0 || v.cmpn(1) < 0 || v.cmp(this.n) >= 0)
    return !1;
  var _ = v.invm(this.n), T = _.mul(t).umod(this.n), z = _.mul(d).umod(this.n), J;
  return this.curve._maxwellTrick ? (J = this.g.jmulAdd(T, h.getPublic(), z), J.isInfinity() ? !1 : J.eqXToP(d)) : (J = this.g.mulAdd(T, h.getPublic(), z), J.isInfinity() ? !1 : J.getX().umod(this.n).cmp(d) === 0);
};
EC.prototype.recoverPubKey = function(l, t, s, h) {
  assert$5((3 & s) === s, "The recovery param is more than two bits"), t = new signature$1(t, h);
  var m = this.n, d = new BN$2(l), v = t.r, _ = t.s, T = s & 1, z = s >> 1;
  if (v.cmp(this.curve.p.umod(this.curve.n)) >= 0 && z)
    throw new Error("Unable to find sencond key candinate");
  z ? v = this.curve.pointFromX(v.add(this.curve.n), T) : v = this.curve.pointFromX(v, T);
  var J = t.r.invm(m), Y = m.sub(d).mul(J).umod(m), ie = _.mul(J).umod(m);
  return this.g.mulAdd(Y, v, ie);
};
EC.prototype.getKeyRecoveryParam = function(l, t, s, h) {
  if (t = new signature$1(t, h), t.recoveryParam !== null)
    return t.recoveryParam;
  for (var m = 0; m < 4; m++) {
    var d;
    try {
      d = this.recoverPubKey(l, t, m);
    } catch {
      continue;
    }
    if (d.eq(s))
      return m;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(l, t) {
  var s = t;
  s.version = "6.5.4", s.utils = utils_1$1$1, s.rand = function() {
    throw new Error("unsupported");
  }, s.curve = curve_1, s.curves = curves_1, s.ec = ec, s.eddsa = null;
}), EC$1 = elliptic_1.ec;
const version$g = "signing-key/5.7.0", logger$t = new Logger(version$g);
let _curve = null;
function getCurve() {
  return _curve || (_curve = new EC$1("secp256k1")), _curve;
}
class SigningKey {
  constructor(t) {
    defineReadOnly(this, "curve", "secp256k1"), defineReadOnly(this, "privateKey", hexlify(t)), hexDataLength(this.privateKey) !== 32 && logger$t.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const s = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + s.getPublic(!1, "hex")), defineReadOnly(this, "compressedPublicKey", "0x" + s.getPublic(!0, "hex")), defineReadOnly(this, "_isSigningKey", !0);
  }
  _addPoint(t) {
    const s = getCurve().keyFromPublic(arrayify(this.publicKey)), h = getCurve().keyFromPublic(arrayify(t));
    return "0x" + s.pub.add(h.pub).encodeCompressed("hex");
  }
  signDigest(t) {
    const s = getCurve().keyFromPrivate(arrayify(this.privateKey)), h = arrayify(t);
    h.length !== 32 && logger$t.throwArgumentError("bad digest length", "digest", t);
    const m = s.sign(h, { canonical: !0 });
    return splitSignature({
      recoveryParam: m.recoveryParam,
      r: hexZeroPad("0x" + m.r.toString(16), 32),
      s: hexZeroPad("0x" + m.s.toString(16), 32)
    });
  }
  computeSharedSecret(t) {
    const s = getCurve().keyFromPrivate(arrayify(this.privateKey)), h = getCurve().keyFromPublic(arrayify(computePublicKey(t)));
    return hexZeroPad("0x" + s.derive(h.getPublic()).toString(16), 32);
  }
  static isSigningKey(t) {
    return !!(t && t._isSigningKey);
  }
}
function recoverPublicKey(l, t) {
  const s = splitSignature(t), h = { r: arrayify(s.r), s: arrayify(s.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(l), h, s.recoveryParam).encode("hex", !1);
}
function computePublicKey(l, t) {
  const s = arrayify(l);
  if (s.length === 32) {
    const h = new SigningKey(s);
    return t ? "0x" + getCurve().keyFromPrivate(s).getPublic(!0, "hex") : h.publicKey;
  } else {
    if (s.length === 33)
      return t ? hexlify(s) : "0x" + getCurve().keyFromPublic(s).getPublic(!1, "hex");
    if (s.length === 65)
      return t ? "0x" + getCurve().keyFromPublic(s).getPublic(!0, "hex") : hexlify(s);
  }
  return logger$t.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var lib_esm$b = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SigningKey,
  computePublicKey,
  recoverPublicKey
});
const version$f = "transactions/5.7.0", logger$s = new Logger(version$f);
var TransactionTypes;
(function(l) {
  l[l.legacy = 0] = "legacy", l[l.eip2930 = 1] = "eip2930", l[l.eip1559 = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(l) {
  return l === "0x" ? null : getAddress(l);
}
function handleNumber(l) {
  return l === "0x" ? Zero$1 : BigNumber.from(l);
}
const transactionFields = [
  { name: "nonce", maxLength: 32, numeric: !0 },
  { name: "gasPrice", maxLength: 32, numeric: !0 },
  { name: "gasLimit", maxLength: 32, numeric: !0 },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: !0 },
  { name: "data" }
], allowedTransactionKeys$2 = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  type: !0,
  value: !0
};
function computeAddress(l) {
  const t = computePublicKey(l);
  return getAddress(hexDataSlice(keccak256$1(hexDataSlice(t, 1)), 12));
}
function recoverAddress(l, t) {
  return computeAddress(recoverPublicKey(arrayify(l), t));
}
function formatNumber(l, t) {
  const s = stripZeros(BigNumber.from(l).toHexString());
  return s.length > 32 && logger$s.throwArgumentError("invalid length for " + t, "transaction:" + t, l), s;
}
function accessSetify(l, t) {
  return {
    address: getAddress(l),
    storageKeys: (t || []).map((s, h) => (hexDataLength(s) !== 32 && logger$s.throwArgumentError("invalid access list storageKey", `accessList[${l}:${h}]`, s), s.toLowerCase()))
  };
}
function accessListify(l) {
  if (Array.isArray(l))
    return l.map((s, h) => Array.isArray(s) ? (s.length > 2 && logger$s.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${h}]`, s), accessSetify(s[0], s[1])) : accessSetify(s.address, s.storageKeys));
  const t = Object.keys(l).map((s) => {
    const h = l[s].reduce((m, d) => (m[d] = !0, m), {});
    return accessSetify(s, Object.keys(h).sort());
  });
  return t.sort((s, h) => s.address.localeCompare(h.address)), t;
}
function formatAccessList(l) {
  return accessListify(l).map((t) => [t.address, t.storageKeys]);
}
function _serializeEip1559(l, t) {
  if (l.gasPrice != null) {
    const h = BigNumber.from(l.gasPrice), m = BigNumber.from(l.maxFeePerGas || 0);
    h.eq(m) || logger$s.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
      gasPrice: h,
      maxFeePerGas: m
    });
  }
  const s = [
    formatNumber(l.chainId || 0, "chainId"),
    formatNumber(l.nonce || 0, "nonce"),
    formatNumber(l.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(l.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(l.gasLimit || 0, "gasLimit"),
    l.to != null ? getAddress(l.to) : "0x",
    formatNumber(l.value || 0, "value"),
    l.data || "0x",
    formatAccessList(l.accessList || [])
  ];
  if (t) {
    const h = splitSignature(t);
    s.push(formatNumber(h.recoveryParam, "recoveryParam")), s.push(stripZeros(h.r)), s.push(stripZeros(h.s));
  }
  return hexConcat(["0x02", encode$3(s)]);
}
function _serializeEip2930(l, t) {
  const s = [
    formatNumber(l.chainId || 0, "chainId"),
    formatNumber(l.nonce || 0, "nonce"),
    formatNumber(l.gasPrice || 0, "gasPrice"),
    formatNumber(l.gasLimit || 0, "gasLimit"),
    l.to != null ? getAddress(l.to) : "0x",
    formatNumber(l.value || 0, "value"),
    l.data || "0x",
    formatAccessList(l.accessList || [])
  ];
  if (t) {
    const h = splitSignature(t);
    s.push(formatNumber(h.recoveryParam, "recoveryParam")), s.push(stripZeros(h.r)), s.push(stripZeros(h.s));
  }
  return hexConcat(["0x01", encode$3(s)]);
}
function _serialize(l, t) {
  checkProperties(l, allowedTransactionKeys$2);
  const s = [];
  transactionFields.forEach(function(v) {
    let _ = l[v.name] || [];
    const T = {};
    v.numeric && (T.hexPad = "left"), _ = arrayify(hexlify(_, T)), v.length && _.length !== v.length && _.length > 0 && logger$s.throwArgumentError("invalid length for " + v.name, "transaction:" + v.name, _), v.maxLength && (_ = stripZeros(_), _.length > v.maxLength && logger$s.throwArgumentError("invalid length for " + v.name, "transaction:" + v.name, _)), s.push(hexlify(_));
  });
  let h = 0;
  if (l.chainId != null ? (h = l.chainId, typeof h != "number" && logger$s.throwArgumentError("invalid transaction.chainId", "transaction", l)) : t && !isBytesLike(t) && t.v > 28 && (h = Math.floor((t.v - 35) / 2)), h !== 0 && (s.push(hexlify(h)), s.push("0x"), s.push("0x")), !t)
    return encode$3(s);
  const m = splitSignature(t);
  let d = 27 + m.recoveryParam;
  return h !== 0 ? (s.pop(), s.pop(), s.pop(), d += h * 2 + 8, m.v > 28 && m.v !== d && logger$s.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", t)) : m.v !== d && logger$s.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", t), s.push(hexlify(d)), s.push(stripZeros(arrayify(m.r))), s.push(stripZeros(arrayify(m.s))), encode$3(s);
}
function serialize$3(l, t) {
  if (l.type == null || l.type === 0)
    return l.accessList != null && logger$s.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", l), _serialize(l, t);
  switch (l.type) {
    case 1:
      return _serializeEip2930(l, t);
    case 2:
      return _serializeEip1559(l, t);
  }
  return logger$s.throwError(`unsupported transaction type: ${l.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: l.type
  });
}
function _parseEipSignature(l, t, s) {
  try {
    const h = handleNumber(t[0]).toNumber();
    if (h !== 0 && h !== 1)
      throw new Error("bad recid");
    l.v = h;
  } catch {
    logger$s.throwArgumentError("invalid v for transaction type: 1", "v", t[0]);
  }
  l.r = hexZeroPad(t[1], 32), l.s = hexZeroPad(t[2], 32);
  try {
    const h = keccak256$1(s(l));
    l.from = recoverAddress(h, { r: l.r, s: l.s, recoveryParam: l.v });
  } catch {
  }
}
function _parseEip1559(l) {
  const t = decode$4(l.slice(1));
  t.length !== 9 && t.length !== 12 && logger$s.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(l));
  const s = handleNumber(t[2]), h = handleNumber(t[3]), m = {
    type: 2,
    chainId: handleNumber(t[0]).toNumber(),
    nonce: handleNumber(t[1]).toNumber(),
    maxPriorityFeePerGas: s,
    maxFeePerGas: h,
    gasPrice: null,
    gasLimit: handleNumber(t[4]),
    to: handleAddress(t[5]),
    value: handleNumber(t[6]),
    data: t[7],
    accessList: accessListify(t[8])
  };
  return t.length === 9 || (m.hash = keccak256$1(l), _parseEipSignature(m, t.slice(9), _serializeEip1559)), m;
}
function _parseEip2930(l) {
  const t = decode$4(l.slice(1));
  t.length !== 8 && t.length !== 11 && logger$s.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(l));
  const s = {
    type: 1,
    chainId: handleNumber(t[0]).toNumber(),
    nonce: handleNumber(t[1]).toNumber(),
    gasPrice: handleNumber(t[2]),
    gasLimit: handleNumber(t[3]),
    to: handleAddress(t[4]),
    value: handleNumber(t[5]),
    data: t[6],
    accessList: accessListify(t[7])
  };
  return t.length === 8 || (s.hash = keccak256$1(l), _parseEipSignature(s, t.slice(8), _serializeEip2930)), s;
}
function _parse(l) {
  const t = decode$4(l);
  t.length !== 9 && t.length !== 6 && logger$s.throwArgumentError("invalid raw transaction", "rawTransaction", l);
  const s = {
    nonce: handleNumber(t[0]).toNumber(),
    gasPrice: handleNumber(t[1]),
    gasLimit: handleNumber(t[2]),
    to: handleAddress(t[3]),
    value: handleNumber(t[4]),
    data: t[5],
    chainId: 0
  };
  if (t.length === 6)
    return s;
  try {
    s.v = BigNumber.from(t[6]).toNumber();
  } catch {
    return s;
  }
  if (s.r = hexZeroPad(t[7], 32), s.s = hexZeroPad(t[8], 32), BigNumber.from(s.r).isZero() && BigNumber.from(s.s).isZero())
    s.chainId = s.v, s.v = 0;
  else {
    s.chainId = Math.floor((s.v - 35) / 2), s.chainId < 0 && (s.chainId = 0);
    let h = s.v - 27;
    const m = t.slice(0, 6);
    s.chainId !== 0 && (m.push(hexlify(s.chainId)), m.push("0x"), m.push("0x"), h -= s.chainId * 2 + 8);
    const d = keccak256$1(encode$3(m));
    try {
      s.from = recoverAddress(d, { r: hexlify(s.r), s: hexlify(s.s), recoveryParam: h });
    } catch {
    }
    s.hash = keccak256$1(l);
  }
  return s.type = null, s;
}
function parse$1(l) {
  const t = arrayify(l);
  if (t[0] > 127)
    return _parse(t);
  switch (t[0]) {
    case 1:
      return _parseEip2930(t);
    case 2:
      return _parseEip1559(t);
  }
  return logger$s.throwError(`unsupported transaction type: ${t[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: t[0]
  });
}
var lib_esm$a = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get TransactionTypes() {
    return TransactionTypes;
  },
  accessListify,
  computeAddress,
  parse: parse$1,
  recoverAddress,
  serialize: serialize$3
});
const version$e = "contracts/5.7.0";
var __awaiter$i = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$r = new Logger(version$e), allowedTransactionKeys$1 = {
  chainId: !0,
  data: !0,
  from: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0,
  customData: !0,
  ccipReadEnabled: !0
};
function resolveName(l, t) {
  return __awaiter$i(this, void 0, void 0, function* () {
    const s = yield t;
    typeof s != "string" && logger$r.throwArgumentError("invalid address or ENS name", "name", s);
    try {
      return getAddress(s);
    } catch {
    }
    l || logger$r.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resolveName"
    });
    const h = yield l.resolveName(s);
    return h == null && logger$r.throwArgumentError("resolver or addr is not configured for ENS name", "name", s), h;
  });
}
function resolveAddresses(l, t, s) {
  return __awaiter$i(this, void 0, void 0, function* () {
    return Array.isArray(s) ? yield Promise.all(s.map((h, m) => resolveAddresses(l, Array.isArray(t) ? t[m] : t[h.name], h))) : s.type === "address" ? yield resolveName(l, t) : s.type === "tuple" ? yield resolveAddresses(l, t, s.components) : s.baseType === "array" ? Array.isArray(t) ? yield Promise.all(t.map((h) => resolveAddresses(l, h, s.arrayChildren))) : Promise.reject(logger$r.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
      argument: "value",
      value: t
    })) : t;
  });
}
function populateTransaction(l, t, s) {
  return __awaiter$i(this, void 0, void 0, function* () {
    let h = {};
    s.length === t.inputs.length + 1 && typeof s[s.length - 1] == "object" && (h = shallowCopy(s.pop())), logger$r.checkArgumentCount(s.length, t.inputs.length, "passed to contract"), l.signer ? h.from ? h.from = resolveProperties({
      override: resolveName(l.signer, h.from),
      signer: l.signer.getAddress()
    }).then((z) => __awaiter$i(this, void 0, void 0, function* () {
      return getAddress(z.signer) !== z.override && logger$r.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.from"
      }), z.override;
    })) : h.from = l.signer.getAddress() : h.from && (h.from = resolveName(l.provider, h.from));
    const m = yield resolveProperties({
      args: resolveAddresses(l.signer || l.provider, s, t.inputs),
      address: l.resolvedAddress,
      overrides: resolveProperties(h) || {}
    }), d = l.interface.encodeFunctionData(t, m.args), v = {
      data: d,
      to: m.address
    }, _ = m.overrides;
    if (_.nonce != null && (v.nonce = BigNumber.from(_.nonce).toNumber()), _.gasLimit != null && (v.gasLimit = BigNumber.from(_.gasLimit)), _.gasPrice != null && (v.gasPrice = BigNumber.from(_.gasPrice)), _.maxFeePerGas != null && (v.maxFeePerGas = BigNumber.from(_.maxFeePerGas)), _.maxPriorityFeePerGas != null && (v.maxPriorityFeePerGas = BigNumber.from(_.maxPriorityFeePerGas)), _.from != null && (v.from = _.from), _.type != null && (v.type = _.type), _.accessList != null && (v.accessList = accessListify(_.accessList)), v.gasLimit == null && t.gas != null) {
      let z = 21e3;
      const J = arrayify(d);
      for (let Y = 0; Y < J.length; Y++)
        z += 4, J[Y] && (z += 64);
      v.gasLimit = BigNumber.from(t.gas).add(z);
    }
    if (_.value) {
      const z = BigNumber.from(_.value);
      !z.isZero() && !t.payable && logger$r.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.value",
        value: h.value
      }), v.value = z;
    }
    _.customData && (v.customData = shallowCopy(_.customData)), _.ccipReadEnabled && (v.ccipReadEnabled = !!_.ccipReadEnabled), delete h.nonce, delete h.gasLimit, delete h.gasPrice, delete h.from, delete h.value, delete h.type, delete h.accessList, delete h.maxFeePerGas, delete h.maxPriorityFeePerGas, delete h.customData, delete h.ccipReadEnabled;
    const T = Object.keys(h).filter((z) => h[z] != null);
    return T.length && logger$r.throwError(`cannot override ${T.map((z) => JSON.stringify(z)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "overrides",
      overrides: T
    }), v;
  });
}
function buildPopulate(l, t) {
  return function(...s) {
    return populateTransaction(l, t, s);
  };
}
function buildEstimate(l, t) {
  const s = l.signer || l.provider;
  return function(...h) {
    return __awaiter$i(this, void 0, void 0, function* () {
      s || logger$r.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "estimateGas"
      });
      const m = yield populateTransaction(l, t, h);
      return yield s.estimateGas(m);
    });
  };
}
function addContractWait(l, t) {
  const s = t.wait.bind(t);
  t.wait = (h) => s(h).then((m) => (m.events = m.logs.map((d) => {
    let v = deepCopy(d), _ = null;
    try {
      _ = l.interface.parseLog(d);
    } catch {
    }
    return _ && (v.args = _.args, v.decode = (T, z) => l.interface.decodeEventLog(_.eventFragment, T, z), v.event = _.name, v.eventSignature = _.signature), v.removeListener = () => l.provider, v.getBlock = () => l.provider.getBlock(m.blockHash), v.getTransaction = () => l.provider.getTransaction(m.transactionHash), v.getTransactionReceipt = () => Promise.resolve(m), v;
  }), m));
}
function buildCall(l, t, s) {
  const h = l.signer || l.provider;
  return function(...m) {
    return __awaiter$i(this, void 0, void 0, function* () {
      let d;
      if (m.length === t.inputs.length + 1 && typeof m[m.length - 1] == "object") {
        const T = shallowCopy(m.pop());
        T.blockTag != null && (d = yield T.blockTag), delete T.blockTag, m.push(T);
      }
      l.deployTransaction != null && (yield l._deployed(d));
      const v = yield populateTransaction(l, t, m), _ = yield h.call(v, d);
      try {
        let T = l.interface.decodeFunctionResult(t, _);
        return s && t.outputs.length === 1 && (T = T[0]), T;
      } catch (T) {
        throw T.code === Logger.errors.CALL_EXCEPTION && (T.address = l.address, T.args = m, T.transaction = v), T;
      }
    });
  };
}
function buildSend(l, t) {
  return function(...s) {
    return __awaiter$i(this, void 0, void 0, function* () {
      l.signer || logger$r.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction"
      }), l.deployTransaction != null && (yield l._deployed());
      const h = yield populateTransaction(l, t, s), m = yield l.signer.sendTransaction(h);
      return addContractWait(l, m), m;
    });
  };
}
function buildDefault(l, t, s) {
  return t.constant ? buildCall(l, t, s) : buildSend(l, t);
}
function getEventTag$1(l) {
  return l.address && (l.topics == null || l.topics.length === 0) ? "*" : (l.address || "*") + "@" + (l.topics ? l.topics.map((t) => Array.isArray(t) ? t.join("|") : t).join(":") : "");
}
class RunningEvent {
  constructor(t, s) {
    defineReadOnly(this, "tag", t), defineReadOnly(this, "filter", s), this._listeners = [];
  }
  addListener(t, s) {
    this._listeners.push({ listener: t, once: s });
  }
  removeListener(t) {
    let s = !1;
    this._listeners = this._listeners.filter((h) => s || h.listener !== t ? !0 : (s = !0, !1));
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((t) => t.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(t) {
    const s = this.listenerCount();
    return this._listeners = this._listeners.filter((h) => {
      const m = t.slice();
      return setTimeout(() => {
        h.listener.apply(this, m);
      }, 0), !h.once;
    }), s;
  }
  prepareEvent(t) {
  }
  getEmit(t) {
    return [t];
  }
}
class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}
class FragmentRunningEvent extends RunningEvent {
  constructor(t, s, h, m) {
    const d = {
      address: t
    };
    let v = s.getEventTopic(h);
    m ? (v !== m[0] && logger$r.throwArgumentError("topic mismatch", "topics", m), d.topics = m.slice()) : d.topics = [v], super(getEventTag$1(d), d), defineReadOnly(this, "address", t), defineReadOnly(this, "interface", s), defineReadOnly(this, "fragment", h);
  }
  prepareEvent(t) {
    super.prepareEvent(t), t.event = this.fragment.name, t.eventSignature = this.fragment.format(), t.decode = (s, h) => this.interface.decodeEventLog(this.fragment, s, h);
    try {
      t.args = this.interface.decodeEventLog(this.fragment, t.data, t.topics);
    } catch (s) {
      t.args = null, t.decodeError = s;
    }
  }
  getEmit(t) {
    const s = checkResultErrors(t.args);
    if (s.length)
      throw s[0].error;
    const h = (t.args || []).slice();
    return h.push(t), h;
  }
}
class WildcardRunningEvent extends RunningEvent {
  constructor(t, s) {
    super("*", { address: t }), defineReadOnly(this, "address", t), defineReadOnly(this, "interface", s);
  }
  prepareEvent(t) {
    super.prepareEvent(t);
    try {
      const s = this.interface.parseLog(t);
      t.event = s.name, t.eventSignature = s.signature, t.decode = (h, m) => this.interface.decodeEventLog(s.eventFragment, h, m), t.args = s.args;
    } catch {
    }
  }
}
class BaseContract {
  constructor(t, s, h) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(s)), h == null ? (defineReadOnly(this, "provider", null), defineReadOnly(this, "signer", null)) : Signer$1.isSigner(h) ? (defineReadOnly(this, "provider", h.provider || null), defineReadOnly(this, "signer", h)) : Provider$1.isProvider(h) ? (defineReadOnly(this, "provider", h), defineReadOnly(this, "signer", null)) : logger$r.throwArgumentError("invalid signer or provider", "signerOrProvider", h), defineReadOnly(this, "callStatic", {}), defineReadOnly(this, "estimateGas", {}), defineReadOnly(this, "functions", {}), defineReadOnly(this, "populateTransaction", {}), defineReadOnly(this, "filters", {});
    {
      const v = {};
      Object.keys(this.interface.events).forEach((_) => {
        const T = this.interface.events[_];
        defineReadOnly(this.filters, _, (...z) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(T, z)
        })), v[T.name] || (v[T.name] = []), v[T.name].push(_);
      }), Object.keys(v).forEach((_) => {
        const T = v[_];
        T.length === 1 ? defineReadOnly(this.filters, _, this.filters[T[0]]) : logger$r.warn(`Duplicate definition of ${_} (${T.join(", ")})`);
      });
    }
    if (defineReadOnly(this, "_runningEvents", {}), defineReadOnly(this, "_wrappedEmits", {}), t == null && logger$r.throwArgumentError("invalid contract address or ENS name", "addressOrName", t), defineReadOnly(this, "address", t), this.provider)
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, t));
    else
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(t)));
      } catch {
        logger$r.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    this.resolvedAddress.catch((v) => {
    });
    const m = {}, d = {};
    Object.keys(this.interface.functions).forEach((v) => {
      const _ = this.interface.functions[v];
      if (d[v]) {
        logger$r.warn(`Duplicate ABI entry for ${JSON.stringify(v)}`);
        return;
      }
      d[v] = !0;
      {
        const T = _.name;
        m[`%${T}`] || (m[`%${T}`] = []), m[`%${T}`].push(v);
      }
      this[v] == null && defineReadOnly(this, v, buildDefault(this, _, !0)), this.functions[v] == null && defineReadOnly(this.functions, v, buildDefault(this, _, !1)), this.callStatic[v] == null && defineReadOnly(this.callStatic, v, buildCall(this, _, !0)), this.populateTransaction[v] == null && defineReadOnly(this.populateTransaction, v, buildPopulate(this, _)), this.estimateGas[v] == null && defineReadOnly(this.estimateGas, v, buildEstimate(this, _));
    }), Object.keys(m).forEach((v) => {
      const _ = m[v];
      if (_.length > 1)
        return;
      v = v.substring(1);
      const T = _[0];
      try {
        this[v] == null && defineReadOnly(this, v, this[T]);
      } catch {
      }
      this.functions[v] == null && defineReadOnly(this.functions, v, this.functions[T]), this.callStatic[v] == null && defineReadOnly(this.callStatic, v, this.callStatic[T]), this.populateTransaction[v] == null && defineReadOnly(this.populateTransaction, v, this.populateTransaction[T]), this.estimateGas[v] == null && defineReadOnly(this.estimateGas, v, this.estimateGas[T]);
    });
  }
  static getContractAddress(t) {
    return getContractAddress(t);
  }
  static getInterface(t) {
    return Interface.isInterface(t) ? t : new Interface(t);
  }
  deployed() {
    return this._deployed();
  }
  _deployed(t) {
    return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, t).then((s) => (s === "0x" && logger$r.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
      contractAddress: this.address,
      operation: "getDeployed"
    }), this))), this._deployedPromise;
  }
  fallback(t) {
    this.signer || logger$r.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    const s = shallowCopy(t || {});
    return ["from", "to"].forEach(function(h) {
      s[h] != null && logger$r.throwError("cannot override " + h, Logger.errors.UNSUPPORTED_OPERATION, { operation: h });
    }), s.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(s));
  }
  connect(t) {
    typeof t == "string" && (t = new VoidSigner(t, this.provider));
    const s = new this.constructor(this.address, this.interface, t);
    return this.deployTransaction && defineReadOnly(s, "deployTransaction", this.deployTransaction), s;
  }
  attach(t) {
    return new this.constructor(t, this.interface, this.signer || this.provider);
  }
  static isIndexed(t) {
    return Indexed.isIndexed(t);
  }
  _normalizeRunningEvent(t) {
    return this._runningEvents[t.tag] ? this._runningEvents[t.tag] : t;
  }
  _getRunningEvent(t) {
    if (typeof t == "string") {
      if (t === "error")
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      if (t === "event")
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      if (t === "*")
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      const s = this.interface.getEvent(t);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, s));
    }
    if (t.topics && t.topics.length > 0) {
      try {
        const h = t.topics[0];
        if (typeof h != "string")
          throw new Error("invalid topic");
        const m = this.interface.getEvent(h);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, m, t.topics));
      } catch {
      }
      const s = {
        address: this.address,
        topics: t.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag$1(s), s));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(t) {
    if (t.listenerCount() === 0) {
      delete this._runningEvents[t.tag];
      const s = this._wrappedEmits[t.tag];
      s && t.filter && (this.provider.off(t.filter, s), delete this._wrappedEmits[t.tag]);
    }
  }
  _wrapEvent(t, s, h) {
    const m = deepCopy(s);
    return m.removeListener = () => {
      !h || (t.removeListener(h), this._checkRunningEvents(t));
    }, m.getBlock = () => this.provider.getBlock(s.blockHash), m.getTransaction = () => this.provider.getTransaction(s.transactionHash), m.getTransactionReceipt = () => this.provider.getTransactionReceipt(s.transactionHash), t.prepareEvent(m), m;
  }
  _addEventListener(t, s, h) {
    if (this.provider || logger$r.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" }), t.addListener(s, h), this._runningEvents[t.tag] = t, !this._wrappedEmits[t.tag]) {
      const m = (d) => {
        let v = this._wrapEvent(t, d, s);
        if (v.decodeError == null)
          try {
            const _ = t.getEmit(v);
            this.emit(t.filter, ..._);
          } catch (_) {
            v.decodeError = _.error;
          }
        t.filter != null && this.emit("event", v), v.decodeError != null && this.emit("error", v.decodeError, v);
      };
      this._wrappedEmits[t.tag] = m, t.filter != null && this.provider.on(t.filter, m);
    }
  }
  queryFilter(t, s, h) {
    const m = this._getRunningEvent(t), d = shallowCopy(m.filter);
    return typeof s == "string" && isHexString$2(s, 32) ? (h != null && logger$r.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", h), d.blockHash = s) : (d.fromBlock = s != null ? s : 0, d.toBlock = h != null ? h : "latest"), this.provider.getLogs(d).then((v) => v.map((_) => this._wrapEvent(m, _, null)));
  }
  on(t, s) {
    return this._addEventListener(this._getRunningEvent(t), s, !1), this;
  }
  once(t, s) {
    return this._addEventListener(this._getRunningEvent(t), s, !0), this;
  }
  emit(t, ...s) {
    if (!this.provider)
      return !1;
    const h = this._getRunningEvent(t), m = h.run(s) > 0;
    return this._checkRunningEvents(h), m;
  }
  listenerCount(t) {
    return this.provider ? t == null ? Object.keys(this._runningEvents).reduce((s, h) => s + this._runningEvents[h].listenerCount(), 0) : this._getRunningEvent(t).listenerCount() : 0;
  }
  listeners(t) {
    if (!this.provider)
      return [];
    if (t == null) {
      const s = [];
      for (let h in this._runningEvents)
        this._runningEvents[h].listeners().forEach((m) => {
          s.push(m);
        });
      return s;
    }
    return this._getRunningEvent(t).listeners();
  }
  removeAllListeners(t) {
    if (!this.provider)
      return this;
    if (t == null) {
      for (const h in this._runningEvents) {
        const m = this._runningEvents[h];
        m.removeAllListeners(), this._checkRunningEvents(m);
      }
      return this;
    }
    const s = this._getRunningEvent(t);
    return s.removeAllListeners(), this._checkRunningEvents(s), this;
  }
  off(t, s) {
    if (!this.provider)
      return this;
    const h = this._getRunningEvent(t);
    return h.removeListener(s), this._checkRunningEvents(h), this;
  }
  removeListener(t, s) {
    return this.off(t, s);
  }
}
class Contract extends BaseContract {
}
class ContractFactory {
  constructor(t, s, h) {
    let m = null;
    typeof s == "string" ? m = s : isBytes(s) ? m = hexlify(s) : s && typeof s.object == "string" ? m = s.object : m = "!", m.substring(0, 2) !== "0x" && (m = "0x" + m), (!isHexString$2(m) || m.length % 2) && logger$r.throwArgumentError("invalid bytecode", "bytecode", s), h && !Signer$1.isSigner(h) && logger$r.throwArgumentError("invalid signer", "signer", h), defineReadOnly(this, "bytecode", m), defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(t)), defineReadOnly(this, "signer", h || null);
  }
  getDeployTransaction(...t) {
    let s = {};
    if (t.length === this.interface.deploy.inputs.length + 1 && typeof t[t.length - 1] == "object") {
      s = shallowCopy(t.pop());
      for (const h in s)
        if (!allowedTransactionKeys$1[h])
          throw new Error("unknown transaction override " + h);
    }
    return ["data", "from", "to"].forEach((h) => {
      s[h] != null && logger$r.throwError("cannot override " + h, Logger.errors.UNSUPPORTED_OPERATION, { operation: h });
    }), s.value && !BigNumber.from(s.value).isZero() && !this.interface.deploy.payable && logger$r.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "overrides.value",
      value: s.value
    }), logger$r.checkArgumentCount(t.length, this.interface.deploy.inputs.length, " in Contract constructor"), s.data = hexlify(concat([
      this.bytecode,
      this.interface.encodeDeploy(t)
    ])), s;
  }
  deploy(...t) {
    return __awaiter$i(this, void 0, void 0, function* () {
      let s = {};
      t.length === this.interface.deploy.inputs.length + 1 && (s = t.pop()), logger$r.checkArgumentCount(t.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const h = yield resolveAddresses(this.signer, t, this.interface.deploy.inputs);
      h.push(s);
      const m = this.getDeployTransaction(...h), d = yield this.signer.sendTransaction(m), v = getStatic(this.constructor, "getContractAddress")(d), _ = getStatic(this.constructor, "getContract")(v, this.interface, this.signer);
      return addContractWait(_, d), defineReadOnly(_, "deployTransaction", d), _;
    });
  }
  attach(t) {
    return this.constructor.getContract(t, this.interface, this.signer);
  }
  connect(t) {
    return new this.constructor(this.interface, this.bytecode, t);
  }
  static fromSolidity(t, s) {
    t == null && logger$r.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" }), typeof t == "string" && (t = JSON.parse(t));
    const h = t.abi;
    let m = null;
    return t.bytecode ? m = t.bytecode : t.evm && t.evm.bytecode && (m = t.evm.bytecode), new this(h, m, s);
  }
  static getInterface(t) {
    return Contract.getInterface(t);
  }
  static getContractAddress(t) {
    return getContractAddress(t);
  }
  static getContract(t, s, h) {
    return new Contract(t, s, h);
  }
}
class BaseX {
  constructor(t) {
    defineReadOnly(this, "alphabet", t), defineReadOnly(this, "base", t.length), defineReadOnly(this, "_alphabetMap", {}), defineReadOnly(this, "_leader", t.charAt(0));
    for (let s = 0; s < t.length; s++)
      this._alphabetMap[t.charAt(s)] = s;
  }
  encode(t) {
    let s = arrayify(t);
    if (s.length === 0)
      return "";
    let h = [0];
    for (let d = 0; d < s.length; ++d) {
      let v = s[d];
      for (let _ = 0; _ < h.length; ++_)
        v += h[_] << 8, h[_] = v % this.base, v = v / this.base | 0;
      for (; v > 0; )
        h.push(v % this.base), v = v / this.base | 0;
    }
    let m = "";
    for (let d = 0; s[d] === 0 && d < s.length - 1; ++d)
      m += this._leader;
    for (let d = h.length - 1; d >= 0; --d)
      m += this.alphabet[h[d]];
    return m;
  }
  decode(t) {
    if (typeof t != "string")
      throw new TypeError("Expected String");
    let s = [];
    if (t.length === 0)
      return new Uint8Array(s);
    s.push(0);
    for (let h = 0; h < t.length; h++) {
      let m = this._alphabetMap[t[h]];
      if (m === void 0)
        throw new Error("Non-base" + this.base + " character");
      let d = m;
      for (let v = 0; v < s.length; ++v)
        d += s[v] * this.base, s[v] = d & 255, d >>= 8;
      for (; d > 0; )
        s.push(d & 255), d >>= 8;
    }
    for (let h = 0; t[h] === this._leader && h < t.length - 1; ++h)
      s.push(0);
    return arrayify(new Uint8Array(s.reverse()));
  }
}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567"), Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var lib_esm$9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Base32,
  Base58,
  BaseX
}), SupportedAlgorithm;
(function(l) {
  l.sha256 = "sha256", l.sha512 = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));
const version$d = "sha2/5.7.0", logger$q = new Logger(version$d);
function ripemd160(l) {
  return "0x" + hash$1.ripemd160().update(arrayify(l)).digest("hex");
}
function sha256$3(l) {
  return "0x" + hash$1.sha256().update(arrayify(l)).digest("hex");
}
function sha512$1(l) {
  return "0x" + hash$1.sha512().update(arrayify(l)).digest("hex");
}
function computeHmac(l, t, s) {
  return SupportedAlgorithm[l] || logger$q.throwError("unsupported algorithm " + l, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "hmac",
    algorithm: l
  }), "0x" + hash$1.hmac(hash$1[l], arrayify(t)).update(arrayify(s)).digest("hex");
}
var lib_esm$8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get SupportedAlgorithm() {
    return SupportedAlgorithm;
  },
  computeHmac,
  ripemd160,
  sha256: sha256$3,
  sha512: sha512$1
});
function pbkdf2$1(l, t, s, h, m) {
  l = arrayify(l), t = arrayify(t);
  let d, v = 1;
  const _ = new Uint8Array(h), T = new Uint8Array(t.length + 4);
  T.set(t);
  let z, J;
  for (let Y = 1; Y <= v; Y++) {
    T[t.length] = Y >> 24 & 255, T[t.length + 1] = Y >> 16 & 255, T[t.length + 2] = Y >> 8 & 255, T[t.length + 3] = Y & 255;
    let ie = arrayify(computeHmac(m, l, T));
    d || (d = ie.length, J = new Uint8Array(d), v = Math.ceil(h / d), z = h - (v - 1) * d), J.set(ie);
    for (let ce = 1; ce < s; ce++) {
      ie = arrayify(computeHmac(m, l, ie));
      for (let re = 0; re < d; re++)
        J[re] ^= ie[re];
    }
    const ne = (Y - 1) * d, de = Y === v ? z : d;
    _.set(arrayify(J).slice(0, de), ne);
  }
  return hexlify(_);
}
const version$c = "wordlists/5.7.0", logger$p = new Logger(version$c);
class Wordlist {
  constructor(t) {
    logger$p.checkAbstract(new.target, Wordlist), defineReadOnly(this, "locale", t);
  }
  split(t) {
    return t.toLowerCase().split(/ +/g);
  }
  join(t) {
    return t.join(" ");
  }
  static check(t) {
    const s = [];
    for (let h = 0; h < 2048; h++) {
      const m = t.getWord(h);
      if (h !== t.getWordIndex(m))
        return "0x";
      s.push(m);
    }
    return id(s.join(`
`) + `
`);
  }
  static register(t, s) {
    s || (s = t.locale);
  }
}
const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(l) {
  if (wordlist == null && (wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), Wordlist.check(l) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"))
    throw wordlist = null, new Error("BIP39 Wordlist for en (English) FAILED");
}
class LangEn extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(t) {
    return loadWords(this), wordlist[t];
  }
  getWordIndex(t) {
    return loadWords(this), wordlist.indexOf(t);
  }
}
const langEn = new LangEn();
Wordlist.register(langEn);
const wordlists = {
  en: langEn
}, version$b = "hdnode/5.7.0", logger$o = new Logger(version$b), N$2 = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), MasterSecret = toUtf8Bytes("Bitcoin seed"), HardenedBit = 2147483648;
function getUpperMask(l) {
  return (1 << l) - 1 << 8 - l;
}
function getLowerMask(l) {
  return (1 << l) - 1;
}
function bytes32(l) {
  return hexZeroPad(hexlify(l), 32);
}
function base58check(l) {
  return Base58.encode(concat([l, hexDataSlice(sha256$3(sha256$3(l)), 0, 4)]));
}
function getWordlist(l) {
  if (l == null)
    return wordlists.en;
  if (typeof l == "string") {
    const t = wordlists[l];
    return t == null && logger$o.throwArgumentError("unknown locale", "wordlist", l), t;
  }
  return l;
}
const _constructorGuard$1 = {}, defaultPath = "m/44'/60'/0'/0/0";
class HDNode {
  constructor(t, s, h, m, d, v, _, T) {
    if (t !== _constructorGuard$1)
      throw new Error("HDNode constructor cannot be called directly");
    if (s) {
      const z = new SigningKey(s);
      defineReadOnly(this, "privateKey", z.privateKey), defineReadOnly(this, "publicKey", z.compressedPublicKey);
    } else
      defineReadOnly(this, "privateKey", null), defineReadOnly(this, "publicKey", hexlify(h));
    defineReadOnly(this, "parentFingerprint", m), defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256$3(this.publicKey)), 0, 4)), defineReadOnly(this, "address", computeAddress(this.publicKey)), defineReadOnly(this, "chainCode", d), defineReadOnly(this, "index", v), defineReadOnly(this, "depth", _), T == null ? (defineReadOnly(this, "mnemonic", null), defineReadOnly(this, "path", null)) : typeof T == "string" ? (defineReadOnly(this, "mnemonic", null), defineReadOnly(this, "path", T)) : (defineReadOnly(this, "mnemonic", T), defineReadOnly(this, "path", T.path));
  }
  get extendedKey() {
    if (this.depth >= 256)
      throw new Error("Depth too large!");
    return base58check(concat([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify(this.depth),
      this.parentFingerprint,
      hexZeroPad(hexlify(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new HDNode(_constructorGuard$1, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(t) {
    if (t > 4294967295)
      throw new Error("invalid index - " + String(t));
    let s = this.path;
    s && (s += "/" + (t & ~HardenedBit));
    const h = new Uint8Array(37);
    if (t & HardenedBit) {
      if (!this.privateKey)
        throw new Error("cannot derive child of neutered node");
      h.set(arrayify(this.privateKey), 1), s && (s += "'");
    } else
      h.set(arrayify(this.publicKey));
    for (let Y = 24; Y >= 0; Y -= 8)
      h[33 + (Y >> 3)] = t >> 24 - Y & 255;
    const m = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, h)), d = m.slice(0, 32), v = m.slice(32);
    let _ = null, T = null;
    this.privateKey ? _ = bytes32(BigNumber.from(d).add(this.privateKey).mod(N$2)) : T = new SigningKey(hexlify(d))._addPoint(this.publicKey);
    let z = s;
    const J = this.mnemonic;
    return J && (z = Object.freeze({
      phrase: J.phrase,
      path: s,
      locale: J.locale || "en"
    })), new HDNode(_constructorGuard$1, _, T, this.fingerprint, bytes32(v), t, this.depth + 1, z);
  }
  derivePath(t) {
    const s = t.split("/");
    if (s.length === 0 || s[0] === "m" && this.depth !== 0)
      throw new Error("invalid path - " + t);
    s[0] === "m" && s.shift();
    let h = this;
    for (let m = 0; m < s.length; m++) {
      const d = s[m];
      if (d.match(/^[0-9]+'$/)) {
        const v = parseInt(d.substring(0, d.length - 1));
        if (v >= HardenedBit)
          throw new Error("invalid path index - " + d);
        h = h._derive(HardenedBit + v);
      } else if (d.match(/^[0-9]+$/)) {
        const v = parseInt(d);
        if (v >= HardenedBit)
          throw new Error("invalid path index - " + d);
        h = h._derive(v);
      } else
        throw new Error("invalid path component - " + d);
    }
    return h;
  }
  static _fromSeed(t, s) {
    const h = arrayify(t);
    if (h.length < 16 || h.length > 64)
      throw new Error("invalid seed");
    const m = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, h));
    return new HDNode(_constructorGuard$1, bytes32(m.slice(0, 32)), null, "0x00000000", bytes32(m.slice(32)), 0, 0, s);
  }
  static fromMnemonic(t, s, h) {
    return h = getWordlist(h), t = entropyToMnemonic(mnemonicToEntropy(t, h), h), HDNode._fromSeed(mnemonicToSeed(t, s), {
      phrase: t,
      path: "m",
      locale: h.locale
    });
  }
  static fromSeed(t) {
    return HDNode._fromSeed(t, null);
  }
  static fromExtendedKey(t) {
    const s = Base58.decode(t);
    (s.length !== 82 || base58check(s.slice(0, 78)) !== t) && logger$o.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    const h = s[4], m = hexlify(s.slice(5, 9)), d = parseInt(hexlify(s.slice(9, 13)).substring(2), 16), v = hexlify(s.slice(13, 45)), _ = s.slice(45, 78);
    switch (hexlify(s.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard$1, null, hexlify(_), m, v, d, h, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (_[0] !== 0)
          break;
        return new HDNode(_constructorGuard$1, hexlify(_.slice(1)), null, m, v, d, h, null);
    }
    return logger$o.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function mnemonicToSeed(l, t) {
  t || (t = "");
  const s = toUtf8Bytes("mnemonic" + t, UnicodeNormalizationForm.NFKD);
  return pbkdf2$1(toUtf8Bytes(l, UnicodeNormalizationForm.NFKD), s, 2048, 64, "sha512");
}
function mnemonicToEntropy(l, t) {
  t = getWordlist(t), logger$o.checkNormalize();
  const s = t.split(l);
  if (s.length % 3 !== 0)
    throw new Error("invalid mnemonic");
  const h = arrayify(new Uint8Array(Math.ceil(11 * s.length / 8)));
  let m = 0;
  for (let z = 0; z < s.length; z++) {
    let J = t.getWordIndex(s[z].normalize("NFKD"));
    if (J === -1)
      throw new Error("invalid mnemonic");
    for (let Y = 0; Y < 11; Y++)
      J & 1 << 10 - Y && (h[m >> 3] |= 1 << 7 - m % 8), m++;
  }
  const d = 32 * s.length / 3, v = s.length / 3, _ = getUpperMask(v);
  if ((arrayify(sha256$3(h.slice(0, d / 8)))[0] & _) !== (h[h.length - 1] & _))
    throw new Error("invalid checksum");
  return hexlify(h.slice(0, d / 8));
}
function entropyToMnemonic(l, t) {
  if (t = getWordlist(t), l = arrayify(l), l.length % 4 !== 0 || l.length < 16 || l.length > 32)
    throw new Error("invalid entropy");
  const s = [0];
  let h = 11;
  for (let v = 0; v < l.length; v++)
    h > 8 ? (s[s.length - 1] <<= 8, s[s.length - 1] |= l[v], h -= 8) : (s[s.length - 1] <<= h, s[s.length - 1] |= l[v] >> 8 - h, s.push(l[v] & getLowerMask(8 - h)), h += 3);
  const m = l.length / 4, d = arrayify(sha256$3(l))[0] & getUpperMask(m);
  return s[s.length - 1] <<= m, s[s.length - 1] |= d >> 8 - m, t.join(s.map((v) => t.getWord(v)));
}
function isValidMnemonic(l, t) {
  try {
    return mnemonicToEntropy(l, t), !0;
  } catch {
  }
  return !1;
}
function getAccountPath(l) {
  return (typeof l != "number" || l < 0 || l >= HardenedBit || l % 1) && logger$o.throwArgumentError("invalid account index", "index", l), `m/44'/60'/${l}'/0/0`;
}
var lib_esm$7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  HDNode,
  defaultPath,
  entropyToMnemonic,
  getAccountPath,
  isValidMnemonic,
  mnemonicToEntropy,
  mnemonicToSeed
});
const version$a = "random/5.7.0", logger$n = new Logger(version$a);
function getGlobal() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
let crypto$5 = anyGlobal.crypto || anyGlobal.msCrypto;
(!crypto$5 || !crypto$5.getRandomValues) && (logger$n.warn("WARNING: Missing strong random number source"), crypto$5 = {
  getRandomValues: function(l) {
    return logger$n.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "crypto.getRandomValues"
    });
  }
});
function randomBytes$1(l) {
  (l <= 0 || l > 1024 || l % 1 || l != l) && logger$n.throwArgumentError("invalid length", "length", l);
  const t = new Uint8Array(l);
  return crypto$5.getRandomValues(t), arrayify(t);
}
function shuffled(l) {
  l = l.slice();
  for (let t = l.length - 1; t > 0; t--) {
    const s = Math.floor(Math.random() * (t + 1)), h = l[t];
    l[t] = l[s], l[s] = h;
  }
  return l;
}
var lib_esm$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  randomBytes: randomBytes$1,
  shuffled
}), aesJs = { exports: {} };
(function(l, t) {
  (function(s) {
    function h(R) {
      return parseInt(R) === R;
    }
    function m(R) {
      if (!h(R.length))
        return !1;
      for (var y = 0; y < R.length; y++)
        if (!h(R[y]) || R[y] < 0 || R[y] > 255)
          return !1;
      return !0;
    }
    function d(R, y) {
      if (R.buffer && ArrayBuffer.isView(R) && R.name === "Uint8Array")
        return y && (R.slice ? R = R.slice() : R = Array.prototype.slice.call(R)), R;
      if (Array.isArray(R)) {
        if (!m(R))
          throw new Error("Array contains invalid value: " + R);
        return new Uint8Array(R);
      }
      if (h(R.length) && m(R))
        return new Uint8Array(R);
      throw new Error("unsupported array-like object");
    }
    function v(R) {
      return new Uint8Array(R);
    }
    function _(R, y, j, ye, ee) {
      (ye != null || ee != null) && (R.slice ? R = R.slice(ye, ee) : R = Array.prototype.slice.call(R, ye, ee)), y.set(R, j);
    }
    var T = function() {
      function R(j) {
        var ye = [], ee = 0;
        for (j = encodeURI(j); ee < j.length; ) {
          var xe = j.charCodeAt(ee++);
          xe === 37 ? (ye.push(parseInt(j.substr(ee, 2), 16)), ee += 2) : ye.push(xe);
        }
        return d(ye);
      }
      function y(j) {
        for (var ye = [], ee = 0; ee < j.length; ) {
          var xe = j[ee];
          xe < 128 ? (ye.push(String.fromCharCode(xe)), ee++) : xe > 191 && xe < 224 ? (ye.push(String.fromCharCode((xe & 31) << 6 | j[ee + 1] & 63)), ee += 2) : (ye.push(String.fromCharCode((xe & 15) << 12 | (j[ee + 1] & 63) << 6 | j[ee + 2] & 63)), ee += 3);
        }
        return ye.join("");
      }
      return {
        toBytes: R,
        fromBytes: y
      };
    }(), z = function() {
      function R(ye) {
        for (var ee = [], xe = 0; xe < ye.length; xe += 2)
          ee.push(parseInt(ye.substr(xe, 2), 16));
        return ee;
      }
      var y = "0123456789abcdef";
      function j(ye) {
        for (var ee = [], xe = 0; xe < ye.length; xe++) {
          var $e = ye[xe];
          ee.push(y[($e & 240) >> 4] + y[$e & 15]);
        }
        return ee.join("");
      }
      return {
        toBytes: R,
        fromBytes: j
      };
    }(), J = { 16: 10, 24: 12, 32: 14 }, Y = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145], ie = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22], ne = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125], de = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986], ce = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766], re = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126], oe = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436], pe = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890], ae = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935], me = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600], ge = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480], we = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795], Ee = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855], Te = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150], Ke = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function Se(R) {
      for (var y = [], j = 0; j < R.length; j += 4)
        y.push(
          R[j] << 24 | R[j + 1] << 16 | R[j + 2] << 8 | R[j + 3]
        );
      return y;
    }
    var X = function(R) {
      if (!(this instanceof X))
        throw Error("AES must be instanitated with `new`");
      Object.defineProperty(this, "key", {
        value: d(R, !0)
      }), this._prepare();
    };
    X.prototype._prepare = function() {
      var R = J[this.key.length];
      if (R == null)
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      this._Ke = [], this._Kd = [];
      for (var y = 0; y <= R; y++)
        this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
      for (var j = (R + 1) * 4, ye = this.key.length / 4, ee = Se(this.key), xe, y = 0; y < ye; y++)
        xe = y >> 2, this._Ke[xe][y % 4] = ee[y], this._Kd[R - xe][y % 4] = ee[y];
      for (var $e = 0, ke = ye, Ce; ke < j; ) {
        if (Ce = ee[ye - 1], ee[0] ^= ie[Ce >> 16 & 255] << 24 ^ ie[Ce >> 8 & 255] << 16 ^ ie[Ce & 255] << 8 ^ ie[Ce >> 24 & 255] ^ Y[$e] << 24, $e += 1, ye != 8)
          for (var y = 1; y < ye; y++)
            ee[y] ^= ee[y - 1];
        else {
          for (var y = 1; y < ye / 2; y++)
            ee[y] ^= ee[y - 1];
          Ce = ee[ye / 2 - 1], ee[ye / 2] ^= ie[Ce & 255] ^ ie[Ce >> 8 & 255] << 8 ^ ie[Ce >> 16 & 255] << 16 ^ ie[Ce >> 24 & 255] << 24;
          for (var y = ye / 2 + 1; y < ye; y++)
            ee[y] ^= ee[y - 1];
        }
        for (var y = 0, ht, Ue; y < ye && ke < j; )
          ht = ke >> 2, Ue = ke % 4, this._Ke[ht][Ue] = ee[y], this._Kd[R - ht][Ue] = ee[y++], ke++;
      }
      for (var ht = 1; ht < R; ht++)
        for (var Ue = 0; Ue < 4; Ue++)
          Ce = this._Kd[ht][Ue], this._Kd[ht][Ue] = we[Ce >> 24 & 255] ^ Ee[Ce >> 16 & 255] ^ Te[Ce >> 8 & 255] ^ Ke[Ce & 255];
    }, X.prototype.encrypt = function(R) {
      if (R.length != 16)
        throw new Error("invalid plaintext size (must be 16 bytes)");
      for (var y = this._Ke.length - 1, j = [0, 0, 0, 0], ye = Se(R), ee = 0; ee < 4; ee++)
        ye[ee] ^= this._Ke[0][ee];
      for (var xe = 1; xe < y; xe++) {
        for (var ee = 0; ee < 4; ee++)
          j[ee] = de[ye[ee] >> 24 & 255] ^ ce[ye[(ee + 1) % 4] >> 16 & 255] ^ re[ye[(ee + 2) % 4] >> 8 & 255] ^ oe[ye[(ee + 3) % 4] & 255] ^ this._Ke[xe][ee];
        ye = j.slice();
      }
      for (var $e = v(16), ke, ee = 0; ee < 4; ee++)
        ke = this._Ke[y][ee], $e[4 * ee] = (ie[ye[ee] >> 24 & 255] ^ ke >> 24) & 255, $e[4 * ee + 1] = (ie[ye[(ee + 1) % 4] >> 16 & 255] ^ ke >> 16) & 255, $e[4 * ee + 2] = (ie[ye[(ee + 2) % 4] >> 8 & 255] ^ ke >> 8) & 255, $e[4 * ee + 3] = (ie[ye[(ee + 3) % 4] & 255] ^ ke) & 255;
      return $e;
    }, X.prototype.decrypt = function(R) {
      if (R.length != 16)
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      for (var y = this._Kd.length - 1, j = [0, 0, 0, 0], ye = Se(R), ee = 0; ee < 4; ee++)
        ye[ee] ^= this._Kd[0][ee];
      for (var xe = 1; xe < y; xe++) {
        for (var ee = 0; ee < 4; ee++)
          j[ee] = pe[ye[ee] >> 24 & 255] ^ ae[ye[(ee + 3) % 4] >> 16 & 255] ^ me[ye[(ee + 2) % 4] >> 8 & 255] ^ ge[ye[(ee + 1) % 4] & 255] ^ this._Kd[xe][ee];
        ye = j.slice();
      }
      for (var $e = v(16), ke, ee = 0; ee < 4; ee++)
        ke = this._Kd[y][ee], $e[4 * ee] = (ne[ye[ee] >> 24 & 255] ^ ke >> 24) & 255, $e[4 * ee + 1] = (ne[ye[(ee + 3) % 4] >> 16 & 255] ^ ke >> 16) & 255, $e[4 * ee + 2] = (ne[ye[(ee + 2) % 4] >> 8 & 255] ^ ke >> 8) & 255, $e[4 * ee + 3] = (ne[ye[(ee + 1) % 4] & 255] ^ ke) & 255;
      return $e;
    };
    var fe = function(R) {
      if (!(this instanceof fe))
        throw Error("AES must be instanitated with `new`");
      this.description = "Electronic Code Block", this.name = "ecb", this._aes = new X(R);
    };
    fe.prototype.encrypt = function(R) {
      if (R = d(R), R.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var y = v(R.length), j = v(16), ye = 0; ye < R.length; ye += 16)
        _(R, j, 0, ye, ye + 16), j = this._aes.encrypt(j), _(j, y, ye);
      return y;
    }, fe.prototype.decrypt = function(R) {
      if (R = d(R), R.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var y = v(R.length), j = v(16), ye = 0; ye < R.length; ye += 16)
        _(R, j, 0, ye, ye + 16), j = this._aes.decrypt(j), _(j, y, ye);
      return y;
    };
    var k = function(R, y) {
      if (!(this instanceof k))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Block Chaining", this.name = "cbc", !y)
        y = v(16);
      else if (y.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastCipherblock = d(y, !0), this._aes = new X(R);
    };
    k.prototype.encrypt = function(R) {
      if (R = d(R), R.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var y = v(R.length), j = v(16), ye = 0; ye < R.length; ye += 16) {
        _(R, j, 0, ye, ye + 16);
        for (var ee = 0; ee < 16; ee++)
          j[ee] ^= this._lastCipherblock[ee];
        this._lastCipherblock = this._aes.encrypt(j), _(this._lastCipherblock, y, ye);
      }
      return y;
    }, k.prototype.decrypt = function(R) {
      if (R = d(R), R.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var y = v(R.length), j = v(16), ye = 0; ye < R.length; ye += 16) {
        _(R, j, 0, ye, ye + 16), j = this._aes.decrypt(j);
        for (var ee = 0; ee < 16; ee++)
          y[ye + ee] = j[ee] ^ this._lastCipherblock[ee];
        _(R, this._lastCipherblock, 0, ye, ye + 16);
      }
      return y;
    };
    var p = function(R, y, j) {
      if (!(this instanceof p))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Feedback", this.name = "cfb", !y)
        y = v(16);
      else if (y.length != 16)
        throw new Error("invalid initialation vector size (must be 16 size)");
      j || (j = 1), this.segmentSize = j, this._shiftRegister = d(y, !0), this._aes = new X(R);
    };
    p.prototype.encrypt = function(R) {
      if (R.length % this.segmentSize != 0)
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      for (var y = d(R, !0), j, ye = 0; ye < y.length; ye += this.segmentSize) {
        j = this._aes.encrypt(this._shiftRegister);
        for (var ee = 0; ee < this.segmentSize; ee++)
          y[ye + ee] ^= j[ee];
        _(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), _(y, this._shiftRegister, 16 - this.segmentSize, ye, ye + this.segmentSize);
      }
      return y;
    }, p.prototype.decrypt = function(R) {
      if (R.length % this.segmentSize != 0)
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      for (var y = d(R, !0), j, ye = 0; ye < y.length; ye += this.segmentSize) {
        j = this._aes.encrypt(this._shiftRegister);
        for (var ee = 0; ee < this.segmentSize; ee++)
          y[ye + ee] ^= j[ee];
        _(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), _(R, this._shiftRegister, 16 - this.segmentSize, ye, ye + this.segmentSize);
      }
      return y;
    };
    var x = function(R, y) {
      if (!(this instanceof x))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Output Feedback", this.name = "ofb", !y)
        y = v(16);
      else if (y.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastPrecipher = d(y, !0), this._lastPrecipherIndex = 16, this._aes = new X(R);
    };
    x.prototype.encrypt = function(R) {
      for (var y = d(R, !0), j = 0; j < y.length; j++)
        this._lastPrecipherIndex === 16 && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), y[j] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      return y;
    }, x.prototype.decrypt = x.prototype.encrypt;
    var S = function(R) {
      if (!(this instanceof S))
        throw Error("Counter must be instanitated with `new`");
      R !== 0 && !R && (R = 1), typeof R == "number" ? (this._counter = v(16), this.setValue(R)) : this.setBytes(R);
    };
    S.prototype.setValue = function(R) {
      if (typeof R != "number" || parseInt(R) != R)
        throw new Error("invalid counter value (must be an integer)");
      for (var y = 15; y >= 0; --y)
        this._counter[y] = R % 256, R = R >> 8;
    }, S.prototype.setBytes = function(R) {
      if (R = d(R, !0), R.length != 16)
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      this._counter = R;
    }, S.prototype.increment = function() {
      for (var R = 15; R >= 0; R--)
        if (this._counter[R] === 255)
          this._counter[R] = 0;
        else {
          this._counter[R]++;
          break;
        }
    };
    var B = function(R, y) {
      if (!(this instanceof B))
        throw Error("AES must be instanitated with `new`");
      this.description = "Counter", this.name = "ctr", y instanceof S || (y = new S(y)), this._counter = y, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new X(R);
    };
    B.prototype.encrypt = function(R) {
      for (var y = d(R, !0), j = 0; j < y.length; j++)
        this._remainingCounterIndex === 16 && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), y[j] ^= this._remainingCounter[this._remainingCounterIndex++];
      return y;
    }, B.prototype.decrypt = B.prototype.encrypt;
    function L(R) {
      R = d(R, !0);
      var y = 16 - R.length % 16, j = v(R.length + y);
      _(R, j);
      for (var ye = R.length; ye < j.length; ye++)
        j[ye] = y;
      return j;
    }
    function C(R) {
      if (R = d(R, !0), R.length < 16)
        throw new Error("PKCS#7 invalid length");
      var y = R[R.length - 1];
      if (y > 16)
        throw new Error("PKCS#7 padding byte out of range");
      for (var j = R.length - y, ye = 0; ye < y; ye++)
        if (R[j + ye] !== y)
          throw new Error("PKCS#7 invalid padding byte");
      var ee = v(j);
      return _(R, ee, 0, 0, j), ee;
    }
    var G = {
      AES: X,
      Counter: S,
      ModeOfOperation: {
        ecb: fe,
        cbc: k,
        cfb: p,
        ofb: x,
        ctr: B
      },
      utils: {
        hex: z,
        utf8: T
      },
      padding: {
        pkcs7: {
          pad: L,
          strip: C
        }
      },
      _arrayTest: {
        coerceArray: d,
        createArray: v,
        copyArray: _
      }
    };
    l.exports = G;
  })();
})(aesJs);
var aes = aesJs.exports;
const version$9 = "json-wallets/5.7.0";
function looseArrayify(l) {
  return typeof l == "string" && l.substring(0, 2) !== "0x" && (l = "0x" + l), arrayify(l);
}
function zpad(l, t) {
  for (l = String(l); l.length < t; )
    l = "0" + l;
  return l;
}
function getPassword(l) {
  return typeof l == "string" ? toUtf8Bytes(l, UnicodeNormalizationForm.NFKC) : arrayify(l);
}
function searchPath(l, t) {
  let s = l;
  const h = t.toLowerCase().split("/");
  for (let m = 0; m < h.length; m++) {
    let d = null;
    for (const v in s)
      if (v.toLowerCase() === h[m]) {
        d = s[v];
        break;
      }
    if (d === null)
      return null;
    s = d;
  }
  return s;
}
function uuidV4(l) {
  const t = arrayify(l);
  t[6] = t[6] & 15 | 64, t[8] = t[8] & 63 | 128;
  const s = hexlify(t);
  return [
    s.substring(2, 10),
    s.substring(10, 14),
    s.substring(14, 18),
    s.substring(18, 22),
    s.substring(22, 34)
  ].join("-");
}
const logger$m = new Logger(version$9);
class CrowdsaleAccount extends Description {
  isCrowdsaleAccount(t) {
    return !!(t && t._isCrowdsaleAccount);
  }
}
function decrypt$2(l, t) {
  const s = JSON.parse(l);
  t = getPassword(t);
  const h = getAddress(searchPath(s, "ethaddr")), m = looseArrayify(searchPath(s, "encseed"));
  (!m || m.length % 16 !== 0) && logger$m.throwArgumentError("invalid encseed", "json", l);
  const d = arrayify(pbkdf2$1(t, t, 2e3, 32, "sha256")).slice(0, 16), v = m.slice(0, 16), _ = m.slice(16), T = new aes.ModeOfOperation.cbc(d, v), z = aes.padding.pkcs7.strip(arrayify(T.decrypt(_)));
  let J = "";
  for (let ne = 0; ne < z.length; ne++)
    J += String.fromCharCode(z[ne]);
  const Y = toUtf8Bytes(J), ie = keccak256$1(Y);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: !0,
    address: h,
    privateKey: ie
  });
}
function isCrowdsaleWallet(l) {
  let t = null;
  try {
    t = JSON.parse(l);
  } catch {
    return !1;
  }
  return t.encseed && t.ethaddr;
}
function isKeystoreWallet(l) {
  let t = null;
  try {
    t = JSON.parse(l);
  } catch {
    return !1;
  }
  return !(!t.version || parseInt(t.version) !== t.version || parseInt(t.version) !== 3);
}
function getJsonWalletAddress(l) {
  if (isCrowdsaleWallet(l))
    try {
      return getAddress(JSON.parse(l).ethaddr);
    } catch {
      return null;
    }
  if (isKeystoreWallet(l))
    try {
      return getAddress(JSON.parse(l).address);
    } catch {
      return null;
    }
  return null;
}
var scrypt$1 = { exports: {} };
(function(l, t) {
  (function(s) {
    function m(ce) {
      const re = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let oe = 1779033703, pe = 3144134277, ae = 1013904242, me = 2773480762, ge = 1359893119, we = 2600822924, Ee = 528734635, Te = 1541459225;
      const Ke = new Uint32Array(64);
      function Se(B) {
        let L = 0, C = B.length;
        for (; C >= 64; ) {
          let G = oe, R = pe, y = ae, j = me, ye = ge, ee = we, xe = Ee, $e = Te, ke, Ce, ht, Ue, De;
          for (Ce = 0; Ce < 16; Ce++)
            ht = L + Ce * 4, Ke[Ce] = (B[ht] & 255) << 24 | (B[ht + 1] & 255) << 16 | (B[ht + 2] & 255) << 8 | B[ht + 3] & 255;
          for (Ce = 16; Ce < 64; Ce++)
            ke = Ke[Ce - 2], Ue = (ke >>> 17 | ke << 32 - 17) ^ (ke >>> 19 | ke << 32 - 19) ^ ke >>> 10, ke = Ke[Ce - 15], De = (ke >>> 7 | ke << 32 - 7) ^ (ke >>> 18 | ke << 32 - 18) ^ ke >>> 3, Ke[Ce] = (Ue + Ke[Ce - 7] | 0) + (De + Ke[Ce - 16] | 0) | 0;
          for (Ce = 0; Ce < 64; Ce++)
            Ue = (((ye >>> 6 | ye << 32 - 6) ^ (ye >>> 11 | ye << 32 - 11) ^ (ye >>> 25 | ye << 32 - 25)) + (ye & ee ^ ~ye & xe) | 0) + ($e + (re[Ce] + Ke[Ce] | 0) | 0) | 0, De = ((G >>> 2 | G << 32 - 2) ^ (G >>> 13 | G << 32 - 13) ^ (G >>> 22 | G << 32 - 22)) + (G & R ^ G & y ^ R & y) | 0, $e = xe, xe = ee, ee = ye, ye = j + Ue | 0, j = y, y = R, R = G, G = Ue + De | 0;
          oe = oe + G | 0, pe = pe + R | 0, ae = ae + y | 0, me = me + j | 0, ge = ge + ye | 0, we = we + ee | 0, Ee = Ee + xe | 0, Te = Te + $e | 0, L += 64, C -= 64;
        }
      }
      Se(ce);
      let X, fe = ce.length % 64, k = ce.length / 536870912 | 0, p = ce.length << 3, x = fe < 56 ? 56 : 120, S = ce.slice(ce.length - fe, ce.length);
      for (S.push(128), X = fe + 1; X < x; X++)
        S.push(0);
      return S.push(k >>> 24 & 255), S.push(k >>> 16 & 255), S.push(k >>> 8 & 255), S.push(k >>> 0 & 255), S.push(p >>> 24 & 255), S.push(p >>> 16 & 255), S.push(p >>> 8 & 255), S.push(p >>> 0 & 255), Se(S), [
        oe >>> 24 & 255,
        oe >>> 16 & 255,
        oe >>> 8 & 255,
        oe >>> 0 & 255,
        pe >>> 24 & 255,
        pe >>> 16 & 255,
        pe >>> 8 & 255,
        pe >>> 0 & 255,
        ae >>> 24 & 255,
        ae >>> 16 & 255,
        ae >>> 8 & 255,
        ae >>> 0 & 255,
        me >>> 24 & 255,
        me >>> 16 & 255,
        me >>> 8 & 255,
        me >>> 0 & 255,
        ge >>> 24 & 255,
        ge >>> 16 & 255,
        ge >>> 8 & 255,
        ge >>> 0 & 255,
        we >>> 24 & 255,
        we >>> 16 & 255,
        we >>> 8 & 255,
        we >>> 0 & 255,
        Ee >>> 24 & 255,
        Ee >>> 16 & 255,
        Ee >>> 8 & 255,
        Ee >>> 0 & 255,
        Te >>> 24 & 255,
        Te >>> 16 & 255,
        Te >>> 8 & 255,
        Te >>> 0 & 255
      ];
    }
    function d(ce, re, oe) {
      ce = ce.length <= 64 ? ce : m(ce);
      const pe = 64 + re.length + 4, ae = new Array(pe), me = new Array(64);
      let ge, we = [];
      for (ge = 0; ge < 64; ge++)
        ae[ge] = 54;
      for (ge = 0; ge < ce.length; ge++)
        ae[ge] ^= ce[ge];
      for (ge = 0; ge < re.length; ge++)
        ae[64 + ge] = re[ge];
      for (ge = pe - 4; ge < pe; ge++)
        ae[ge] = 0;
      for (ge = 0; ge < 64; ge++)
        me[ge] = 92;
      for (ge = 0; ge < ce.length; ge++)
        me[ge] ^= ce[ge];
      function Ee() {
        for (let Te = pe - 1; Te >= pe - 4; Te--) {
          if (ae[Te]++, ae[Te] <= 255)
            return;
          ae[Te] = 0;
        }
      }
      for (; oe >= 32; )
        Ee(), we = we.concat(m(me.concat(m(ae)))), oe -= 32;
      return oe > 0 && (Ee(), we = we.concat(m(me.concat(m(ae))).slice(0, oe))), we;
    }
    function v(ce, re, oe, pe, ae) {
      let me;
      for (J(ce, (2 * oe - 1) * 16, ae, 0, 16), me = 0; me < 2 * oe; me++)
        z(ce, me * 16, ae, 16), T(ae, pe), J(ae, 0, ce, re + me * 16, 16);
      for (me = 0; me < oe; me++)
        J(ce, re + me * 2 * 16, ce, me * 16, 16);
      for (me = 0; me < oe; me++)
        J(ce, re + (me * 2 + 1) * 16, ce, (me + oe) * 16, 16);
    }
    function _(ce, re) {
      return ce << re | ce >>> 32 - re;
    }
    function T(ce, re) {
      J(ce, 0, re, 0, 16);
      for (let oe = 8; oe > 0; oe -= 2)
        re[4] ^= _(re[0] + re[12], 7), re[8] ^= _(re[4] + re[0], 9), re[12] ^= _(re[8] + re[4], 13), re[0] ^= _(re[12] + re[8], 18), re[9] ^= _(re[5] + re[1], 7), re[13] ^= _(re[9] + re[5], 9), re[1] ^= _(re[13] + re[9], 13), re[5] ^= _(re[1] + re[13], 18), re[14] ^= _(re[10] + re[6], 7), re[2] ^= _(re[14] + re[10], 9), re[6] ^= _(re[2] + re[14], 13), re[10] ^= _(re[6] + re[2], 18), re[3] ^= _(re[15] + re[11], 7), re[7] ^= _(re[3] + re[15], 9), re[11] ^= _(re[7] + re[3], 13), re[15] ^= _(re[11] + re[7], 18), re[1] ^= _(re[0] + re[3], 7), re[2] ^= _(re[1] + re[0], 9), re[3] ^= _(re[2] + re[1], 13), re[0] ^= _(re[3] + re[2], 18), re[6] ^= _(re[5] + re[4], 7), re[7] ^= _(re[6] + re[5], 9), re[4] ^= _(re[7] + re[6], 13), re[5] ^= _(re[4] + re[7], 18), re[11] ^= _(re[10] + re[9], 7), re[8] ^= _(re[11] + re[10], 9), re[9] ^= _(re[8] + re[11], 13), re[10] ^= _(re[9] + re[8], 18), re[12] ^= _(re[15] + re[14], 7), re[13] ^= _(re[12] + re[15], 9), re[14] ^= _(re[13] + re[12], 13), re[15] ^= _(re[14] + re[13], 18);
      for (let oe = 0; oe < 16; ++oe)
        ce[oe] += re[oe];
    }
    function z(ce, re, oe, pe) {
      for (let ae = 0; ae < pe; ae++)
        oe[ae] ^= ce[re + ae];
    }
    function J(ce, re, oe, pe, ae) {
      for (; ae--; )
        oe[pe++] = ce[re++];
    }
    function Y(ce) {
      if (!ce || typeof ce.length != "number")
        return !1;
      for (let re = 0; re < ce.length; re++) {
        const oe = ce[re];
        if (typeof oe != "number" || oe % 1 || oe < 0 || oe >= 256)
          return !1;
      }
      return !0;
    }
    function ie(ce, re) {
      if (typeof ce != "number" || ce % 1)
        throw new Error("invalid " + re);
      return ce;
    }
    function ne(ce, re, oe, pe, ae, me, ge) {
      if (oe = ie(oe, "N"), pe = ie(pe, "r"), ae = ie(ae, "p"), me = ie(me, "dkLen"), oe === 0 || (oe & oe - 1) !== 0)
        throw new Error("N must be power of 2");
      if (oe > 2147483647 / 128 / pe)
        throw new Error("N too large");
      if (pe > 2147483647 / 128 / ae)
        throw new Error("r too large");
      if (!Y(ce))
        throw new Error("password must be an array or buffer");
      if (ce = Array.prototype.slice.call(ce), !Y(re))
        throw new Error("salt must be an array or buffer");
      re = Array.prototype.slice.call(re);
      let we = d(ce, re, ae * 128 * pe);
      const Ee = new Uint32Array(ae * 32 * pe);
      for (let ye = 0; ye < Ee.length; ye++) {
        const ee = ye * 4;
        Ee[ye] = (we[ee + 3] & 255) << 24 | (we[ee + 2] & 255) << 16 | (we[ee + 1] & 255) << 8 | (we[ee + 0] & 255) << 0;
      }
      const Te = new Uint32Array(64 * pe), Ke = new Uint32Array(32 * pe * oe), Se = 32 * pe, X = new Uint32Array(16), fe = new Uint32Array(16), k = ae * oe * 2;
      let p = 0, x = null, S = !1, B = 0, L = 0, C, G;
      const R = ge ? parseInt(1e3 / pe) : 4294967295, y = typeof setImmediate < "u" ? setImmediate : setTimeout, j = function() {
        if (S)
          return ge(new Error("cancelled"), p / k);
        let ye;
        switch (B) {
          case 0:
            G = L * 32 * pe, J(Ee, G, Te, 0, Se), B = 1, C = 0;
          case 1:
            ye = oe - C, ye > R && (ye = R);
            for (let xe = 0; xe < ye; xe++)
              J(Te, 0, Ke, (C + xe) * Se, Se), v(Te, Se, pe, X, fe);
            if (C += ye, p += ye, ge) {
              const xe = parseInt(1e3 * p / k);
              if (xe !== x) {
                if (S = ge(null, p / k), S)
                  break;
                x = xe;
              }
            }
            if (C < oe)
              break;
            C = 0, B = 2;
          case 2:
            ye = oe - C, ye > R && (ye = R);
            for (let xe = 0; xe < ye; xe++) {
              const $e = (2 * pe - 1) * 16, ke = Te[$e] & oe - 1;
              z(Ke, ke * Se, Te, Se), v(Te, Se, pe, X, fe);
            }
            if (C += ye, p += ye, ge) {
              const xe = parseInt(1e3 * p / k);
              if (xe !== x) {
                if (S = ge(null, p / k), S)
                  break;
                x = xe;
              }
            }
            if (C < oe)
              break;
            if (J(Te, 0, Ee, G, Se), L++, L < ae) {
              B = 0;
              break;
            }
            we = [];
            for (let xe = 0; xe < Ee.length; xe++)
              we.push(Ee[xe] >> 0 & 255), we.push(Ee[xe] >> 8 & 255), we.push(Ee[xe] >> 16 & 255), we.push(Ee[xe] >> 24 & 255);
            const ee = d(ce, we, me);
            return ge && ge(null, 1, ee), ee;
        }
        ge && y(j);
      };
      if (!ge)
        for (; ; ) {
          const ye = j();
          if (ye != null)
            return ye;
        }
      j();
    }
    const de = {
      scrypt: function(ce, re, oe, pe, ae, me, ge) {
        return new Promise(function(we, Ee) {
          let Te = 0;
          ge && ge(0), ne(ce, re, oe, pe, ae, me, function(Ke, Se, X) {
            if (Ke)
              Ee(Ke);
            else if (X)
              ge && Te !== 1 && ge(1), we(new Uint8Array(X));
            else if (ge && Se !== Te)
              return Te = Se, ge(Se);
          });
        });
      },
      syncScrypt: function(ce, re, oe, pe, ae, me) {
        return new Uint8Array(ne(ce, re, oe, pe, ae, me));
      }
    };
    l.exports = de;
  })();
})(scrypt$1);
var scrypt = scrypt$1.exports, __awaiter$h = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$l = new Logger(version$9);
function hasMnemonic$1(l) {
  return l != null && l.mnemonic && l.mnemonic.phrase;
}
class KeystoreAccount extends Description {
  isKeystoreAccount(t) {
    return !!(t && t._isKeystoreAccount);
  }
}
function _decrypt(l, t, s) {
  if (searchPath(l, "crypto/cipher") === "aes-128-ctr") {
    const m = looseArrayify(searchPath(l, "crypto/cipherparams/iv")), d = new aes.Counter(m), v = new aes.ModeOfOperation.ctr(t, d);
    return arrayify(v.decrypt(s));
  }
  return null;
}
function _getAccount(l, t) {
  const s = looseArrayify(searchPath(l, "crypto/ciphertext"));
  if (hexlify(keccak256$1(concat([t.slice(16, 32), s]))).substring(2) !== searchPath(l, "crypto/mac").toLowerCase())
    throw new Error("invalid password");
  const m = _decrypt(l, t.slice(0, 16), s);
  m || logger$l.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "decrypt"
  });
  const d = t.slice(32, 64), v = computeAddress(m);
  if (l.address) {
    let T = l.address.toLowerCase();
    if (T.substring(0, 2) !== "0x" && (T = "0x" + T), getAddress(T) !== v)
      throw new Error("address mismatch");
  }
  const _ = {
    _isKeystoreAccount: !0,
    address: v,
    privateKey: hexlify(m)
  };
  if (searchPath(l, "x-ethers/version") === "0.1") {
    const T = looseArrayify(searchPath(l, "x-ethers/mnemonicCiphertext")), z = looseArrayify(searchPath(l, "x-ethers/mnemonicCounter")), J = new aes.Counter(z), Y = new aes.ModeOfOperation.ctr(d, J), ie = searchPath(l, "x-ethers/path") || defaultPath, ne = searchPath(l, "x-ethers/locale") || "en", de = arrayify(Y.decrypt(T));
    try {
      const ce = entropyToMnemonic(de, ne), re = HDNode.fromMnemonic(ce, null, ne).derivePath(ie);
      if (re.privateKey != _.privateKey)
        throw new Error("mnemonic mismatch");
      _.mnemonic = re.mnemonic;
    } catch (ce) {
      if (ce.code !== Logger.errors.INVALID_ARGUMENT || ce.argument !== "wordlist")
        throw ce;
    }
  }
  return new KeystoreAccount(_);
}
function pbkdf2Sync(l, t, s, h, m) {
  return arrayify(pbkdf2$1(l, t, s, h, m));
}
function pbkdf2(l, t, s, h, m) {
  return Promise.resolve(pbkdf2Sync(l, t, s, h, m));
}
function _computeKdfKey(l, t, s, h, m) {
  const d = getPassword(t), v = searchPath(l, "crypto/kdf");
  if (v && typeof v == "string") {
    const _ = function(T, z) {
      return logger$l.throwArgumentError("invalid key-derivation function parameters", T, z);
    };
    if (v.toLowerCase() === "scrypt") {
      const T = looseArrayify(searchPath(l, "crypto/kdfparams/salt")), z = parseInt(searchPath(l, "crypto/kdfparams/n")), J = parseInt(searchPath(l, "crypto/kdfparams/r")), Y = parseInt(searchPath(l, "crypto/kdfparams/p"));
      (!z || !J || !Y) && _("kdf", v), (z & z - 1) !== 0 && _("N", z);
      const ie = parseInt(searchPath(l, "crypto/kdfparams/dklen"));
      return ie !== 32 && _("dklen", ie), h(d, T, z, J, Y, 64, m);
    } else if (v.toLowerCase() === "pbkdf2") {
      const T = looseArrayify(searchPath(l, "crypto/kdfparams/salt"));
      let z = null;
      const J = searchPath(l, "crypto/kdfparams/prf");
      J === "hmac-sha256" ? z = "sha256" : J === "hmac-sha512" ? z = "sha512" : _("prf", J);
      const Y = parseInt(searchPath(l, "crypto/kdfparams/c")), ie = parseInt(searchPath(l, "crypto/kdfparams/dklen"));
      return ie !== 32 && _("dklen", ie), s(d, T, Y, ie, z);
    }
  }
  return logger$l.throwArgumentError("unsupported key-derivation function", "kdf", v);
}
function decryptSync(l, t) {
  const s = JSON.parse(l), h = _computeKdfKey(s, t, pbkdf2Sync, scrypt.syncScrypt);
  return _getAccount(s, h);
}
function decrypt$1(l, t, s) {
  return __awaiter$h(this, void 0, void 0, function* () {
    const h = JSON.parse(l), m = yield _computeKdfKey(h, t, pbkdf2, scrypt.scrypt, s);
    return _getAccount(h, m);
  });
}
function encrypt$1(l, t, s, h) {
  try {
    if (getAddress(l.address) !== computeAddress(l.privateKey))
      throw new Error("address/privateKey mismatch");
    if (hasMnemonic$1(l)) {
      const re = l.mnemonic;
      if (HDNode.fromMnemonic(re.phrase, null, re.locale).derivePath(re.path || defaultPath).privateKey != l.privateKey)
        throw new Error("mnemonic mismatch");
    }
  } catch (re) {
    return Promise.reject(re);
  }
  typeof s == "function" && !h && (h = s, s = {}), s || (s = {});
  const m = arrayify(l.privateKey), d = getPassword(t);
  let v = null, _ = null, T = null;
  if (hasMnemonic$1(l)) {
    const re = l.mnemonic;
    v = arrayify(mnemonicToEntropy(re.phrase, re.locale || "en")), _ = re.path || defaultPath, T = re.locale || "en";
  }
  let z = s.client;
  z || (z = "ethers.js");
  let J = null;
  s.salt ? J = arrayify(s.salt) : J = randomBytes$1(32);
  let Y = null;
  if (s.iv) {
    if (Y = arrayify(s.iv), Y.length !== 16)
      throw new Error("invalid iv");
  } else
    Y = randomBytes$1(16);
  let ie = null;
  if (s.uuid) {
    if (ie = arrayify(s.uuid), ie.length !== 16)
      throw new Error("invalid uuid");
  } else
    ie = randomBytes$1(16);
  let ne = 1 << 17, de = 8, ce = 1;
  return s.scrypt && (s.scrypt.N && (ne = s.scrypt.N), s.scrypt.r && (de = s.scrypt.r), s.scrypt.p && (ce = s.scrypt.p)), scrypt.scrypt(d, J, ne, de, ce, 64, h).then((re) => {
    re = arrayify(re);
    const oe = re.slice(0, 16), pe = re.slice(16, 32), ae = re.slice(32, 64), me = new aes.Counter(Y), ge = new aes.ModeOfOperation.ctr(oe, me), we = arrayify(ge.encrypt(m)), Ee = keccak256$1(concat([pe, we])), Te = {
      address: l.address.substring(2).toLowerCase(),
      id: uuidV4(ie),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(Y).substring(2)
        },
        ciphertext: hexlify(we).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(J).substring(2),
          n: ne,
          dklen: 32,
          p: ce,
          r: de
        },
        mac: Ee.substring(2)
      }
    };
    if (v) {
      const Ke = randomBytes$1(16), Se = new aes.Counter(Ke), X = new aes.ModeOfOperation.ctr(ae, Se), fe = arrayify(X.encrypt(v)), k = new Date(), p = k.getUTCFullYear() + "-" + zpad(k.getUTCMonth() + 1, 2) + "-" + zpad(k.getUTCDate(), 2) + "T" + zpad(k.getUTCHours(), 2) + "-" + zpad(k.getUTCMinutes(), 2) + "-" + zpad(k.getUTCSeconds(), 2) + ".0Z";
      Te["x-ethers"] = {
        client: z,
        gethFilename: "UTC--" + p + "--" + Te.address,
        mnemonicCounter: hexlify(Ke).substring(2),
        mnemonicCiphertext: hexlify(fe).substring(2),
        path: _,
        locale: T,
        version: "0.1"
      };
    }
    return JSON.stringify(Te);
  });
}
function decryptJsonWallet(l, t, s) {
  if (isCrowdsaleWallet(l)) {
    s && s(0);
    const h = decrypt$2(l, t);
    return s && s(1), Promise.resolve(h);
  }
  return isKeystoreWallet(l) ? decrypt$1(l, t, s) : Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(l, t) {
  if (isCrowdsaleWallet(l))
    return decrypt$2(l, t);
  if (isKeystoreWallet(l))
    return decryptSync(l, t);
  throw new Error("invalid JSON wallet");
}
var lib_esm$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  decryptCrowdsale: decrypt$2,
  decryptJsonWallet,
  decryptJsonWalletSync,
  decryptKeystore: decrypt$1,
  decryptKeystoreSync: decryptSync,
  encryptKeystore: encrypt$1,
  getJsonWalletAddress,
  isCrowdsaleWallet,
  isKeystoreWallet
});
const version$8 = "wallet/5.7.0";
var __awaiter$g = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$k = new Logger(version$8);
function isAccount(l) {
  return l != null && isHexString$2(l.privateKey, 32) && l.address != null;
}
function hasMnemonic(l) {
  const t = l.mnemonic;
  return t && t.phrase;
}
let Wallet$1 = class extends Signer$1 {
  constructor(t, s) {
    if (super(), isAccount(t)) {
      const h = new SigningKey(t.privateKey);
      if (defineReadOnly(this, "_signingKey", () => h), defineReadOnly(this, "address", computeAddress(this.publicKey)), this.address !== getAddress(t.address) && logger$k.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), hasMnemonic(t)) {
        const m = t.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: m.phrase,
          path: m.path || defaultPath,
          locale: m.locale || "en"
        }));
        const d = this.mnemonic, v = HDNode.fromMnemonic(d.phrase, null, d.locale).derivePath(d.path);
        computeAddress(v.privateKey) !== this.address && logger$k.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
      } else
        defineReadOnly(this, "_mnemonic", () => null);
    } else {
      if (SigningKey.isSigningKey(t))
        t.curve !== "secp256k1" && logger$k.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), defineReadOnly(this, "_signingKey", () => t);
      else {
        typeof t == "string" && t.match(/^[0-9a-f]*$/i) && t.length === 64 && (t = "0x" + t);
        const h = new SigningKey(t);
        defineReadOnly(this, "_signingKey", () => h);
      }
      defineReadOnly(this, "_mnemonic", () => null), defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    s && !Provider$1.isProvider(s) && logger$k.throwArgumentError("invalid provider", "provider", s), defineReadOnly(this, "provider", s || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(t) {
    return new Wallet$1(this, t);
  }
  signTransaction(t) {
    return resolveProperties(t).then((s) => {
      s.from != null && (getAddress(s.from) !== this.address && logger$k.throwArgumentError("transaction from address mismatch", "transaction.from", t.from), delete s.from);
      const h = this._signingKey().signDigest(keccak256$1(serialize$3(s)));
      return serialize$3(s, h);
    });
  }
  signMessage(t) {
    return __awaiter$g(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(t)));
    });
  }
  _signTypedData(t, s, h) {
    return __awaiter$g(this, void 0, void 0, function* () {
      const m = yield TypedDataEncoder.resolveNames(t, s, h, (d) => (this.provider == null && logger$k.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName",
        value: d
      }), this.provider.resolveName(d)));
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(m.domain, s, m.value)));
    });
  }
  encrypt(t, s, h) {
    if (typeof s == "function" && !h && (h = s, s = {}), h && typeof h != "function")
      throw new Error("invalid callback");
    return s || (s = {}), encrypt$1(this, t, s, h);
  }
  static createRandom(t) {
    let s = randomBytes$1(16);
    t || (t = {}), t.extraEntropy && (s = arrayify(hexDataSlice(keccak256$1(concat([s, t.extraEntropy])), 0, 16)));
    const h = entropyToMnemonic(s, t.locale);
    return Wallet$1.fromMnemonic(h, t.path, t.locale);
  }
  static fromEncryptedJson(t, s, h) {
    return decryptJsonWallet(t, s, h).then((m) => new Wallet$1(m));
  }
  static fromEncryptedJsonSync(t, s) {
    return new Wallet$1(decryptJsonWalletSync(t, s));
  }
  static fromMnemonic(t, s, h) {
    return s || (s = defaultPath), new Wallet$1(HDNode.fromMnemonic(t, null, h).derivePath(s));
  }
};
function verifyMessage(l, t) {
  return recoverAddress(hashMessage(l), t);
}
function verifyTypedData(l, t, s, h) {
  return recoverAddress(TypedDataEncoder.hash(l, t, s), h);
}
var lib_esm$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Wallet: Wallet$1,
  verifyMessage,
  verifyTypedData
});
const version$7 = "networks/5.7.1", logger$j = new Logger(version$7);
function isRenetworkable(l) {
  return l && typeof l.renetwork == "function";
}
function ethDefaultProvider(l) {
  const t = function(s, h) {
    h == null && (h = {});
    const m = [];
    if (s.InfuraProvider && h.infura !== "-")
      try {
        m.push(new s.InfuraProvider(l, h.infura));
      } catch {
      }
    if (s.EtherscanProvider && h.etherscan !== "-")
      try {
        m.push(new s.EtherscanProvider(l, h.etherscan));
      } catch {
      }
    if (s.AlchemyProvider && h.alchemy !== "-")
      try {
        m.push(new s.AlchemyProvider(l, h.alchemy));
      } catch {
      }
    if (s.PocketProvider && h.pocket !== "-") {
      const d = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const v = new s.PocketProvider(l, h.pocket);
        v.network && d.indexOf(v.network.name) === -1 && m.push(v);
      } catch {
      }
    }
    if (s.CloudflareProvider && h.cloudflare !== "-")
      try {
        m.push(new s.CloudflareProvider(l));
      } catch {
      }
    if (s.AnkrProvider && h.ankr !== "-")
      try {
        const d = ["ropsten"], v = new s.AnkrProvider(l, h.ankr);
        v.network && d.indexOf(v.network.name) === -1 && m.push(v);
      } catch {
      }
    if (m.length === 0)
      return null;
    if (s.FallbackProvider) {
      let d = 1;
      return h.quorum != null ? d = h.quorum : l === "homestead" && (d = 2), new s.FallbackProvider(m, d);
    }
    return m[0];
  };
  return t.renetwork = function(s) {
    return ethDefaultProvider(s);
  }, t;
}
function etcDefaultProvider(l, t) {
  const s = function(h, m) {
    return h.JsonRpcProvider ? new h.JsonRpcProvider(l, t) : null;
  };
  return s.renetwork = function(h) {
    return etcDefaultProvider(l, h);
  }, s;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
}, ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
}, classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
}, networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(l) {
  if (l == null)
    return null;
  if (typeof l == "number") {
    for (const h in networks) {
      const m = networks[h];
      if (m.chainId === l)
        return {
          name: m.name,
          chainId: m.chainId,
          ensAddress: m.ensAddress || null,
          _defaultProvider: m._defaultProvider || null
        };
    }
    return {
      chainId: l,
      name: "unknown"
    };
  }
  if (typeof l == "string") {
    const h = networks[l];
    return h == null ? null : {
      name: h.name,
      chainId: h.chainId,
      ensAddress: h.ensAddress,
      _defaultProvider: h._defaultProvider || null
    };
  }
  const t = networks[l.name];
  if (!t)
    return typeof l.chainId != "number" && logger$j.throwArgumentError("invalid network chainId", "network", l), l;
  l.chainId !== 0 && l.chainId !== t.chainId && logger$j.throwArgumentError("network chainId mismatch", "network", l);
  let s = l._defaultProvider || null;
  return s == null && t._defaultProvider && (isRenetworkable(t._defaultProvider) ? s = t._defaultProvider.renetwork(l) : s = t._defaultProvider), {
    name: l.name,
    chainId: t.chainId,
    ensAddress: l.ensAddress || t.ensAddress || null,
    _defaultProvider: s
  };
}
const version$6 = "web/5.7.1";
var __awaiter$f = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
function getUrl(l, t) {
  return __awaiter$f(this, void 0, void 0, function* () {
    t == null && (t = {});
    const s = {
      method: t.method || "GET",
      headers: t.headers || {},
      body: t.body || void 0
    };
    if (t.skipFetchSetup !== !0 && (s.mode = "cors", s.cache = "no-cache", s.credentials = "same-origin", s.redirect = "follow", s.referrer = "client"), t.fetchOptions != null) {
      const v = t.fetchOptions;
      v.mode && (s.mode = v.mode), v.cache && (s.cache = v.cache), v.credentials && (s.credentials = v.credentials), v.redirect && (s.redirect = v.redirect), v.referrer && (s.referrer = v.referrer);
    }
    const h = yield fetch(l, s), m = yield h.arrayBuffer(), d = {};
    return h.headers.forEach ? h.headers.forEach((v, _) => {
      d[_.toLowerCase()] = v;
    }) : h.headers.keys().forEach((v) => {
      d[v.toLowerCase()] = h.headers.get(v);
    }), {
      headers: d,
      statusCode: h.status,
      statusMessage: h.statusText,
      body: arrayify(new Uint8Array(m))
    };
  });
}
var __awaiter$e = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$i = new Logger(version$6);
function staller(l) {
  return new Promise((t) => {
    setTimeout(t, l);
  });
}
function bodyify(l, t) {
  if (l == null)
    return null;
  if (typeof l == "string")
    return l;
  if (isBytesLike(l)) {
    if (t && (t.split("/")[0] === "text" || t.split(";")[0].trim() === "application/json"))
      try {
        return toUtf8String(l);
      } catch {
      }
    return hexlify(l);
  }
  return l;
}
function unpercent(l) {
  return toUtf8Bytes(l.replace(/%([0-9a-f][0-9a-f])/gi, (t, s) => String.fromCharCode(parseInt(s, 16))));
}
function _fetchData(l, t, s) {
  const h = typeof l == "object" && l.throttleLimit != null ? l.throttleLimit : 12;
  logger$i.assertArgument(h > 0 && h % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", h);
  const m = typeof l == "object" ? l.throttleCallback : null, d = typeof l == "object" && typeof l.throttleSlotInterval == "number" ? l.throttleSlotInterval : 100;
  logger$i.assertArgument(d > 0 && d % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", d);
  const v = typeof l == "object" ? !!l.errorPassThrough : !1, _ = {};
  let T = null;
  const z = {
    method: "GET"
  };
  let J = !1, Y = 2 * 60 * 1e3;
  if (typeof l == "string")
    T = l;
  else if (typeof l == "object") {
    if ((l == null || l.url == null) && logger$i.throwArgumentError("missing URL", "connection.url", l), T = l.url, typeof l.timeout == "number" && l.timeout > 0 && (Y = l.timeout), l.headers)
      for (const oe in l.headers)
        _[oe.toLowerCase()] = { key: oe, value: String(l.headers[oe]) }, ["if-none-match", "if-modified-since"].indexOf(oe.toLowerCase()) >= 0 && (J = !0);
    if (z.allowGzip = !!l.allowGzip, l.user != null && l.password != null) {
      T.substring(0, 6) !== "https:" && l.allowInsecureAuthentication !== !0 && logger$i.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url: T, user: l.user, password: "[REDACTED]" });
      const oe = l.user + ":" + l.password;
      _.authorization = {
        key: "Authorization",
        value: "Basic " + encode$2(toUtf8Bytes(oe))
      };
    }
    l.skipFetchSetup != null && (z.skipFetchSetup = !!l.skipFetchSetup), l.fetchOptions != null && (z.fetchOptions = shallowCopy(l.fetchOptions));
  }
  const ie = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), ne = T ? T.match(ie) : null;
  if (ne)
    try {
      const oe = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": ne[1] || "text/plain" },
        body: ne[2] ? decode$3(ne[3]) : unpercent(ne[3])
      };
      let pe = oe.body;
      return s && (pe = s(oe.body, oe)), Promise.resolve(pe);
    } catch (oe) {
      logger$i.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(ne[1], ne[2]),
        error: oe,
        requestBody: null,
        requestMethod: "GET",
        url: T
      });
    }
  t && (z.method = "POST", z.body = t, _["content-type"] == null && (_["content-type"] = { key: "Content-Type", value: "application/octet-stream" }), _["content-length"] == null && (_["content-length"] = { key: "Content-Length", value: String(t.length) }));
  const de = {};
  Object.keys(_).forEach((oe) => {
    const pe = _[oe];
    de[pe.key] = pe.value;
  }), z.headers = de;
  const ce = function() {
    let oe = null;
    return { promise: new Promise(function(me, ge) {
      Y && (oe = setTimeout(() => {
        oe != null && (oe = null, ge(logger$i.makeError("timeout", Logger.errors.TIMEOUT, {
          requestBody: bodyify(z.body, de["content-type"]),
          requestMethod: z.method,
          timeout: Y,
          url: T
        })));
      }, Y));
    }), cancel: function() {
      oe != null && (clearTimeout(oe), oe = null);
    } };
  }(), re = function() {
    return __awaiter$e(this, void 0, void 0, function* () {
      for (let oe = 0; oe < h; oe++) {
        let pe = null;
        try {
          if (pe = yield getUrl(T, z), oe < h) {
            if (pe.statusCode === 301 || pe.statusCode === 302) {
              const me = pe.headers.location || "";
              if (z.method === "GET" && me.match(/^https:/)) {
                T = pe.headers.location;
                continue;
              }
            } else if (pe.statusCode === 429) {
              let me = !0;
              if (m && (me = yield m(oe, T)), me) {
                let ge = 0;
                const we = pe.headers["retry-after"];
                typeof we == "string" && we.match(/^[1-9][0-9]*$/) ? ge = parseInt(we) * 1e3 : ge = d * parseInt(String(Math.random() * Math.pow(2, oe))), yield staller(ge);
                continue;
              }
            }
          }
        } catch (me) {
          pe = me.response, pe == null && (ce.cancel(), logger$i.throwError("missing response", Logger.errors.SERVER_ERROR, {
            requestBody: bodyify(z.body, de["content-type"]),
            requestMethod: z.method,
            serverError: me,
            url: T
          }));
        }
        let ae = pe.body;
        if (J && pe.statusCode === 304 ? ae = null : !v && (pe.statusCode < 200 || pe.statusCode >= 300) && (ce.cancel(), logger$i.throwError("bad response", Logger.errors.SERVER_ERROR, {
          status: pe.statusCode,
          headers: pe.headers,
          body: bodyify(ae, pe.headers ? pe.headers["content-type"] : null),
          requestBody: bodyify(z.body, de["content-type"]),
          requestMethod: z.method,
          url: T
        })), s)
          try {
            const me = yield s(ae, pe);
            return ce.cancel(), me;
          } catch (me) {
            if (me.throttleRetry && oe < h) {
              let ge = !0;
              if (m && (ge = yield m(oe, T)), ge) {
                const we = d * parseInt(String(Math.random() * Math.pow(2, oe)));
                yield staller(we);
                continue;
              }
            }
            ce.cancel(), logger$i.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(ae, pe.headers ? pe.headers["content-type"] : null),
              error: me,
              requestBody: bodyify(z.body, de["content-type"]),
              requestMethod: z.method,
              url: T
            });
          }
        return ce.cancel(), ae;
      }
      return logger$i.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(z.body, de["content-type"]),
        requestMethod: z.method,
        url: T
      });
    });
  }();
  return Promise.race([ce.promise, re]);
}
function fetchJson(l, t, s) {
  let h = (d, v) => {
    let _ = null;
    if (d != null)
      try {
        _ = JSON.parse(toUtf8String(d));
      } catch (T) {
        logger$i.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: d,
          error: T
        });
      }
    return s && (_ = s(_, v)), _;
  }, m = null;
  if (t != null) {
    m = toUtf8Bytes(t);
    const d = typeof l == "string" ? { url: l } : shallowCopy(l);
    d.headers ? Object.keys(d.headers).filter((_) => _.toLowerCase() === "content-type").length !== 0 || (d.headers = shallowCopy(d.headers), d.headers["content-type"] = "application/json") : d.headers = { "content-type": "application/json" }, l = d;
  }
  return _fetchData(l, m, h);
}
function poll(l, t) {
  return t || (t = {}), t = shallowCopy(t), t.floor == null && (t.floor = 0), t.ceiling == null && (t.ceiling = 1e4), t.interval == null && (t.interval = 250), new Promise(function(s, h) {
    let m = null, d = !1;
    const v = () => d ? !1 : (d = !0, m && clearTimeout(m), !0);
    t.timeout && (m = setTimeout(() => {
      v() && h(new Error("timeout"));
    }, t.timeout));
    const _ = t.retryLimit;
    let T = 0;
    function z() {
      return l().then(function(J) {
        if (J !== void 0)
          v() && s(J);
        else if (t.oncePoll)
          t.oncePoll.once("poll", z);
        else if (t.onceBlock)
          t.onceBlock.once("block", z);
        else if (!d) {
          if (T++, T > _) {
            v() && h(new Error("retry limit reached"));
            return;
          }
          let Y = t.interval * parseInt(String(Math.random() * Math.pow(2, T)));
          Y < t.floor && (Y = t.floor), Y > t.ceiling && (Y = t.ceiling), setTimeout(z, Y);
        }
        return null;
      }, function(J) {
        v() && h(J);
      });
    }
    z();
  });
}
var lib_esm$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _fetchData,
  fetchJson,
  poll
}), ALPHABET$1 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (var z$2 = 0; z$2 < ALPHABET$1.length; z$2++) {
  var x$2 = ALPHABET$1.charAt(z$2);
  if (ALPHABET_MAP[x$2] !== void 0)
    throw new TypeError(x$2 + " is ambiguous");
  ALPHABET_MAP[x$2] = z$2;
}
function polymodStep(l) {
  var t = l >> 25;
  return (l & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function prefixChk(l) {
  for (var t = 1, s = 0; s < l.length; ++s) {
    var h = l.charCodeAt(s);
    if (h < 33 || h > 126)
      return "Invalid prefix (" + l + ")";
    t = polymodStep(t) ^ h >> 5;
  }
  for (t = polymodStep(t), s = 0; s < l.length; ++s) {
    var m = l.charCodeAt(s);
    t = polymodStep(t) ^ m & 31;
  }
  return t;
}
function encode$1(l, t, s) {
  if (s = s || 90, l.length + 7 + t.length > s)
    throw new TypeError("Exceeds length limit");
  l = l.toLowerCase();
  var h = prefixChk(l);
  if (typeof h == "string")
    throw new Error(h);
  for (var m = l + "1", d = 0; d < t.length; ++d) {
    var v = t[d];
    if (v >> 5 !== 0)
      throw new Error("Non 5-bit word");
    h = polymodStep(h) ^ v, m += ALPHABET$1.charAt(v);
  }
  for (d = 0; d < 6; ++d)
    h = polymodStep(h);
  for (h ^= 1, d = 0; d < 6; ++d) {
    var _ = h >> (5 - d) * 5 & 31;
    m += ALPHABET$1.charAt(_);
  }
  return m;
}
function __decode(l, t) {
  if (t = t || 90, l.length < 8)
    return l + " too short";
  if (l.length > t)
    return "Exceeds length limit";
  var s = l.toLowerCase(), h = l.toUpperCase();
  if (l !== s && l !== h)
    return "Mixed-case string " + l;
  l = s;
  var m = l.lastIndexOf("1");
  if (m === -1)
    return "No separator character for " + l;
  if (m === 0)
    return "Missing prefix for " + l;
  var d = l.slice(0, m), v = l.slice(m + 1);
  if (v.length < 6)
    return "Data too short";
  var _ = prefixChk(d);
  if (typeof _ == "string")
    return _;
  for (var T = [], z = 0; z < v.length; ++z) {
    var J = v.charAt(z), Y = ALPHABET_MAP[J];
    if (Y === void 0)
      return "Unknown character " + J;
    _ = polymodStep(_) ^ Y, !(z + 6 >= v.length) && T.push(Y);
  }
  return _ !== 1 ? "Invalid checksum for " + l : { prefix: d, words: T };
}
function decodeUnsafe() {
  var l = __decode.apply(null, arguments);
  if (typeof l == "object")
    return l;
}
function decode$2(l) {
  var t = __decode.apply(null, arguments);
  if (typeof t == "object")
    return t;
  throw new Error(t);
}
function convert(l, t, s, h) {
  for (var m = 0, d = 0, v = (1 << s) - 1, _ = [], T = 0; T < l.length; ++T)
    for (m = m << t | l[T], d += t; d >= s; )
      d -= s, _.push(m >> d & v);
  if (h)
    d > 0 && _.push(m << s - d & v);
  else {
    if (d >= t)
      return "Excess padding";
    if (m << s - d & v)
      return "Non-zero padding";
  }
  return _;
}
function toWordsUnsafe(l) {
  var t = convert(l, 8, 5, !0);
  if (Array.isArray(t))
    return t;
}
function toWords(l) {
  var t = convert(l, 8, 5, !0);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
function fromWordsUnsafe(l) {
  var t = convert(l, 5, 8, !1);
  if (Array.isArray(t))
    return t;
}
function fromWords(l) {
  var t = convert(l, 5, 8, !1);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
var bech32 = {
  decodeUnsafe,
  decode: decode$2,
  encode: encode$1,
  toWordsUnsafe,
  toWords,
  fromWordsUnsafe,
  fromWords
};
const version$5 = "providers/5.7.2", logger$h = new Logger(version$5);
class Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const t = {}, s = this.address.bind(this), h = this.bigNumber.bind(this), m = this.blockTag.bind(this), d = this.data.bind(this), v = this.hash.bind(this), _ = this.hex.bind(this), T = this.number.bind(this), z = this.type.bind(this), J = (Y) => this.data(Y, !0);
    return t.transaction = {
      hash: v,
      type: z,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(v, null),
      blockNumber: Formatter.allowNull(T, null),
      transactionIndex: Formatter.allowNull(T, null),
      confirmations: Formatter.allowNull(T, null),
      from: s,
      gasPrice: Formatter.allowNull(h),
      maxPriorityFeePerGas: Formatter.allowNull(h),
      maxFeePerGas: Formatter.allowNull(h),
      gasLimit: h,
      to: Formatter.allowNull(s, null),
      value: h,
      nonce: T,
      data: d,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(T),
      creates: Formatter.allowNull(s, null),
      raw: Formatter.allowNull(d)
    }, t.transactionRequest = {
      from: Formatter.allowNull(s),
      nonce: Formatter.allowNull(T),
      gasLimit: Formatter.allowNull(h),
      gasPrice: Formatter.allowNull(h),
      maxPriorityFeePerGas: Formatter.allowNull(h),
      maxFeePerGas: Formatter.allowNull(h),
      to: Formatter.allowNull(s),
      value: Formatter.allowNull(h),
      data: Formatter.allowNull(J),
      type: Formatter.allowNull(T),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    }, t.receiptLog = {
      transactionIndex: T,
      blockNumber: T,
      transactionHash: v,
      address: s,
      topics: Formatter.arrayOf(v),
      data: d,
      logIndex: T,
      blockHash: v
    }, t.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(s, null),
      transactionIndex: T,
      root: Formatter.allowNull(_),
      gasUsed: h,
      logsBloom: Formatter.allowNull(d),
      blockHash: v,
      transactionHash: v,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: T,
      confirmations: Formatter.allowNull(T, null),
      cumulativeGasUsed: h,
      effectiveGasPrice: Formatter.allowNull(h),
      status: Formatter.allowNull(T),
      type: z
    }, t.block = {
      hash: Formatter.allowNull(v),
      parentHash: v,
      number: T,
      timestamp: T,
      nonce: Formatter.allowNull(_),
      difficulty: this.difficulty.bind(this),
      gasLimit: h,
      gasUsed: h,
      miner: Formatter.allowNull(s),
      extraData: d,
      transactions: Formatter.allowNull(Formatter.arrayOf(v)),
      baseFeePerGas: Formatter.allowNull(h)
    }, t.blockWithTransactions = shallowCopy(t.block), t.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this))), t.filter = {
      fromBlock: Formatter.allowNull(m, void 0),
      toBlock: Formatter.allowNull(m, void 0),
      blockHash: Formatter.allowNull(v, void 0),
      address: Formatter.allowNull(s, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    }, t.filterLog = {
      blockNumber: Formatter.allowNull(T),
      blockHash: Formatter.allowNull(v),
      transactionIndex: T,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address: s,
      data: Formatter.allowFalsish(d, "0x"),
      topics: Formatter.arrayOf(v),
      transactionHash: v,
      logIndex: T
    }, t;
  }
  accessList(t) {
    return accessListify(t || []);
  }
  number(t) {
    return t === "0x" ? 0 : BigNumber.from(t).toNumber();
  }
  type(t) {
    return t === "0x" || t == null ? 0 : BigNumber.from(t).toNumber();
  }
  bigNumber(t) {
    return BigNumber.from(t);
  }
  boolean(t) {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "string") {
      if (t = t.toLowerCase(), t === "true")
        return !0;
      if (t === "false")
        return !1;
    }
    throw new Error("invalid boolean - " + t);
  }
  hex(t, s) {
    return typeof t == "string" && (!s && t.substring(0, 2) !== "0x" && (t = "0x" + t), isHexString$2(t)) ? t.toLowerCase() : logger$h.throwArgumentError("invalid hash", "value", t);
  }
  data(t, s) {
    const h = this.hex(t, s);
    if (h.length % 2 !== 0)
      throw new Error("invalid data; odd-length - " + t);
    return h;
  }
  address(t) {
    return getAddress(t);
  }
  callAddress(t) {
    if (!isHexString$2(t, 32))
      return null;
    const s = getAddress(hexDataSlice(t, 12));
    return s === AddressZero ? null : s;
  }
  contractAddress(t) {
    return getContractAddress(t);
  }
  blockTag(t) {
    if (t == null)
      return "latest";
    if (t === "earliest")
      return "0x0";
    switch (t) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return t;
    }
    if (typeof t == "number" || isHexString$2(t))
      return hexValue(t);
    throw new Error("invalid blockTag");
  }
  hash(t, s) {
    const h = this.hex(t, s);
    return hexDataLength(h) !== 32 ? logger$h.throwArgumentError("invalid hash", "value", t) : h;
  }
  difficulty(t) {
    if (t == null)
      return null;
    const s = BigNumber.from(t);
    try {
      return s.toNumber();
    } catch {
    }
    return null;
  }
  uint256(t) {
    if (!isHexString$2(t))
      throw new Error("invalid uint256");
    return hexZeroPad(t, 32);
  }
  _block(t, s) {
    t.author != null && t.miner == null && (t.miner = t.author);
    const h = t._difficulty != null ? t._difficulty : t.difficulty, m = Formatter.check(s, t);
    return m._difficulty = h == null ? null : BigNumber.from(h), m;
  }
  block(t) {
    return this._block(t, this.formats.block);
  }
  blockWithTransactions(t) {
    return this._block(t, this.formats.blockWithTransactions);
  }
  transactionRequest(t) {
    return Formatter.check(this.formats.transactionRequest, t);
  }
  transactionResponse(t) {
    t.gas != null && t.gasLimit == null && (t.gasLimit = t.gas), t.to && BigNumber.from(t.to).isZero() && (t.to = "0x0000000000000000000000000000000000000000"), t.input != null && t.data == null && (t.data = t.input), t.to == null && t.creates == null && (t.creates = this.contractAddress(t)), (t.type === 1 || t.type === 2) && t.accessList == null && (t.accessList = []);
    const s = Formatter.check(this.formats.transaction, t);
    if (t.chainId != null) {
      let h = t.chainId;
      isHexString$2(h) && (h = BigNumber.from(h).toNumber()), s.chainId = h;
    } else {
      let h = t.networkId;
      h == null && s.v == null && (h = t.chainId), isHexString$2(h) && (h = BigNumber.from(h).toNumber()), typeof h != "number" && s.v != null && (h = (s.v - 35) / 2, h < 0 && (h = 0), h = parseInt(h)), typeof h != "number" && (h = 0), s.chainId = h;
    }
    return s.blockHash && s.blockHash.replace(/0/g, "") === "x" && (s.blockHash = null), s;
  }
  transaction(t) {
    return parse$1(t);
  }
  receiptLog(t) {
    return Formatter.check(this.formats.receiptLog, t);
  }
  receipt(t) {
    const s = Formatter.check(this.formats.receipt, t);
    if (s.root != null)
      if (s.root.length <= 4) {
        const h = BigNumber.from(s.root).toNumber();
        h === 0 || h === 1 ? (s.status != null && s.status !== h && logger$h.throwArgumentError("alt-root-status/status mismatch", "value", { root: s.root, status: s.status }), s.status = h, delete s.root) : logger$h.throwArgumentError("invalid alt-root-status", "value.root", s.root);
      } else
        s.root.length !== 66 && logger$h.throwArgumentError("invalid root hash", "value.root", s.root);
    return s.status != null && (s.byzantium = !0), s;
  }
  topics(t) {
    return Array.isArray(t) ? t.map((s) => this.topics(s)) : t != null ? this.hash(t, !0) : null;
  }
  filter(t) {
    return Formatter.check(this.formats.filter, t);
  }
  filterLog(t) {
    return Formatter.check(this.formats.filterLog, t);
  }
  static check(t, s) {
    const h = {};
    for (const m in t)
      try {
        const d = t[m](s[m]);
        d !== void 0 && (h[m] = d);
      } catch (d) {
        throw d.checkKey = m, d.checkValue = s[m], d;
      }
    return h;
  }
  static allowNull(t, s) {
    return function(h) {
      return h == null ? s : t(h);
    };
  }
  static allowFalsish(t, s) {
    return function(h) {
      return h ? t(h) : s;
    };
  }
  static arrayOf(t) {
    return function(s) {
      if (!Array.isArray(s))
        throw new Error("not an array");
      const h = [];
      return s.forEach(function(m) {
        h.push(t(m));
      }), h;
    };
  }
}
function isCommunityResourcable(l) {
  return l && typeof l.isCommunityResource == "function";
}
function isCommunityResource(l) {
  return isCommunityResourcable(l) && l.isCommunityResource();
}
let throttleMessage = !1;
function showThrottleMessage() {
  throttleMessage || (throttleMessage = !0, console.log("========= NOTICE ========="), console.log("Request-Rate Exceeded  (this message will not be repeated)"), console.log(""), console.log("The default API keys for each service are provided as a highly-throttled,"), console.log("community resource for low-traffic projects and early prototyping."), console.log(""), console.log("While your application will continue to function, we highly recommended"), console.log("signing up for your own API keys to improve performance, increase your"), console.log("request rate/limit and enable other perks, such as metrics and advanced APIs."), console.log(""), console.log("For more details: https://docs.ethers.io/api-keys/"), console.log("=========================="));
}
var __awaiter$d = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$g = new Logger(version$5), MAX_CCIP_REDIRECTS = 10;
function checkTopic(l) {
  return l == null ? "null" : (hexDataLength(l) !== 32 && logger$g.throwArgumentError("invalid topic", "topic", l), l.toLowerCase());
}
function serializeTopics(l) {
  for (l = l.slice(); l.length > 0 && l[l.length - 1] == null; )
    l.pop();
  return l.map((t) => {
    if (Array.isArray(t)) {
      const s = {};
      t.forEach((m) => {
        s[checkTopic(m)] = !0;
      });
      const h = Object.keys(s);
      return h.sort(), h.join("|");
    } else
      return checkTopic(t);
  }).join("&");
}
function deserializeTopics(l) {
  return l === "" ? [] : l.split(/&/g).map((t) => {
    if (t === "")
      return [];
    const s = t.split("|").map((h) => h === "null" ? null : h);
    return s.length === 1 ? s[0] : s;
  });
}
function getEventTag(l) {
  if (typeof l == "string") {
    if (l = l.toLowerCase(), hexDataLength(l) === 32)
      return "tx:" + l;
    if (l.indexOf(":") === -1)
      return l;
  } else {
    if (Array.isArray(l))
      return "filter:*:" + serializeTopics(l);
    if (ForkEvent.isForkEvent(l))
      throw logger$g.warn("not implemented"), new Error("not implemented");
    if (l && typeof l == "object")
      return "filter:" + (l.address || "*") + ":" + serializeTopics(l.topics || []);
  }
  throw new Error("invalid event - " + l);
}
function getTime() {
  return new Date().getTime();
}
function stall$1(l) {
  return new Promise((t) => {
    setTimeout(t, l);
  });
}
const PollableEvents = ["block", "network", "pending", "poll"];
class Event {
  constructor(t, s, h) {
    defineReadOnly(this, "tag", t), defineReadOnly(this, "listener", s), defineReadOnly(this, "once", h), this._lastBlockNumber = -2, this._inflight = !1;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const t = this.tag.split(":");
    return t[0] !== "tx" ? null : t[1];
  }
  get filter() {
    const t = this.tag.split(":");
    if (t[0] !== "filter")
      return null;
    const s = t[1], h = deserializeTopics(t[2]), m = {};
    return h.length > 0 && (m.topics = h), s && s !== "*" && (m.address = s), m;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
}
const coinInfos = {
  0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
  60: { symbol: "eth", ilk: "eth" },
  61: { symbol: "etc", ilk: "eth" },
  700: { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(l) {
  return hexZeroPad(BigNumber.from(l).toHexString(), 32);
}
function base58Encode(l) {
  return Base58.encode(concat([l, hexDataSlice(sha256$3(sha256$3(l)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i"), matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(l, t) {
  try {
    return toUtf8String(_parseBytes(l, t));
  } catch {
  }
  return null;
}
function _parseBytes(l, t) {
  if (l === "0x")
    return null;
  const s = BigNumber.from(hexDataSlice(l, t, t + 32)).toNumber(), h = BigNumber.from(hexDataSlice(l, s, s + 32)).toNumber();
  return hexDataSlice(l, s + 32, s + 32 + h);
}
function getIpfsLink(l) {
  return l.match(/^ipfs:\/\/ipfs\//i) ? l = l.substring(12) : l.match(/^ipfs:\/\//i) ? l = l.substring(7) : logger$g.throwArgumentError("unsupported IPFS format", "link", l), `https://gateway.ipfs.io/ipfs/${l}`;
}
function numPad(l) {
  const t = arrayify(l);
  if (t.length > 32)
    throw new Error("internal; should not happen");
  const s = new Uint8Array(32);
  return s.set(t, 32 - t.length), s;
}
function bytesPad(l) {
  if (l.length % 32 === 0)
    return l;
  const t = new Uint8Array(Math.ceil(l.length / 32) * 32);
  return t.set(l), t;
}
function encodeBytes(l) {
  const t = [];
  let s = 0;
  for (let h = 0; h < l.length; h++)
    t.push(null), s += 32;
  for (let h = 0; h < l.length; h++) {
    const m = arrayify(l[h]);
    t[h] = numPad(s), t.push(numPad(m.length)), t.push(bytesPad(m)), s += 32 + Math.ceil(m.length / 32) * 32;
  }
  return hexConcat(t);
}
class Resolver {
  constructor(t, s, h, m) {
    defineReadOnly(this, "provider", t), defineReadOnly(this, "name", h), defineReadOnly(this, "address", t.formatter.address(s)), defineReadOnly(this, "_resolvedAddress", m);
  }
  supportsWildcard() {
    return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
      to: this.address,
      data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
    }).then((t) => BigNumber.from(t).eq(1)).catch((t) => {
      if (t.code === Logger.errors.CALL_EXCEPTION)
        return !1;
      throw this._supportsEip2544 = null, t;
    })), this._supportsEip2544;
  }
  _fetch(t, s) {
    return __awaiter$d(this, void 0, void 0, function* () {
      const h = {
        to: this.address,
        ccipReadEnabled: !0,
        data: hexConcat([t, namehash(this.name), s || "0x"])
      };
      let m = !1;
      (yield this.supportsWildcard()) && (m = !0, h.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), h.data])]));
      try {
        let d = yield this.provider.call(h);
        return arrayify(d).length % 32 === 4 && logger$g.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
          transaction: h,
          data: d
        }), m && (d = _parseBytes(d, 0)), d;
      } catch (d) {
        if (d.code === Logger.errors.CALL_EXCEPTION)
          return null;
        throw d;
      }
    });
  }
  _fetchBytes(t, s) {
    return __awaiter$d(this, void 0, void 0, function* () {
      const h = yield this._fetch(t, s);
      return h != null ? _parseBytes(h, 0) : null;
    });
  }
  _getAddress(t, s) {
    const h = coinInfos[String(t)];
    if (h == null && logger$g.throwError(`unsupported coin type: ${t}`, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: `getAddress(${t})`
    }), h.ilk === "eth")
      return this.provider.formatter.address(s);
    const m = arrayify(s);
    if (h.p2pkh != null) {
      const d = s.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (d) {
        const v = parseInt(d[1], 16);
        if (d[2].length === v * 2 && v >= 1 && v <= 75)
          return base58Encode(concat([[h.p2pkh], "0x" + d[2]]));
      }
    }
    if (h.p2sh != null) {
      const d = s.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (d) {
        const v = parseInt(d[1], 16);
        if (d[2].length === v * 2 && v >= 1 && v <= 75)
          return base58Encode(concat([[h.p2sh], "0x" + d[2]]));
      }
    }
    if (h.prefix != null) {
      const d = m[1];
      let v = m[0];
      if (v === 0 ? d !== 20 && d !== 32 && (v = -1) : v = -1, v >= 0 && m.length === 2 + d && d >= 1 && d <= 75) {
        const _ = bech32.toWords(m.slice(2));
        return _.unshift(v), bech32.encode(h.prefix, _);
      }
    }
    return null;
  }
  getAddress(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      if (t == null && (t = 60), t === 60)
        try {
          const m = yield this._fetch("0x3b3b57de");
          return m === "0x" || m === HashZero ? null : this.provider.formatter.callAddress(m);
        } catch (m) {
          if (m.code === Logger.errors.CALL_EXCEPTION)
            return null;
          throw m;
        }
      const s = yield this._fetchBytes("0xf1cb7e06", bytes32ify(t));
      if (s == null || s === "0x")
        return null;
      const h = this._getAddress(t, s);
      return h == null && logger$g.throwError("invalid or unsupported coin data", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${t})`,
        coinType: t,
        data: s
      }), h;
    });
  }
  getAvatar() {
    return __awaiter$d(this, void 0, void 0, function* () {
      const t = [{ type: "name", content: this.name }];
      try {
        const s = yield this.getText("avatar");
        if (s == null)
          return null;
        for (let h = 0; h < matchers.length; h++) {
          const m = s.match(matchers[h]);
          if (m == null)
            continue;
          const d = m[1].toLowerCase();
          switch (d) {
            case "https":
              return t.push({ type: "url", content: s }), { linkage: t, url: s };
            case "data":
              return t.push({ type: "data", content: s }), { linkage: t, url: s };
            case "ipfs":
              return t.push({ type: "ipfs", content: s }), { linkage: t, url: getIpfsLink(s) };
            case "erc721":
            case "erc1155": {
              const v = d === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              t.push({ type: d, content: s });
              const _ = this._resolvedAddress || (yield this.getAddress()), T = (m[2] || "").split("/");
              if (T.length !== 2)
                return null;
              const z = yield this.provider.formatter.address(T[0]), J = hexZeroPad(BigNumber.from(T[1]).toHexString(), 32);
              if (d === "erc721") {
                const ce = this.provider.formatter.callAddress(yield this.provider.call({
                  to: z,
                  data: hexConcat(["0x6352211e", J])
                }));
                if (_ !== ce)
                  return null;
                t.push({ type: "owner", content: ce });
              } else if (d === "erc1155") {
                const ce = BigNumber.from(yield this.provider.call({
                  to: z,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(_, 32), J])
                }));
                if (ce.isZero())
                  return null;
                t.push({ type: "balance", content: ce.toString() });
              }
              const Y = {
                to: this.provider.formatter.address(T[0]),
                data: hexConcat([v, J])
              };
              let ie = _parseString(yield this.provider.call(Y), 0);
              if (ie == null)
                return null;
              t.push({ type: "metadata-url-base", content: ie }), d === "erc1155" && (ie = ie.replace("{id}", J.substring(2)), t.push({ type: "metadata-url-expanded", content: ie })), ie.match(/^ipfs:/i) && (ie = getIpfsLink(ie)), t.push({ type: "metadata-url", content: ie });
              const ne = yield fetchJson(ie);
              if (!ne)
                return null;
              t.push({ type: "metadata", content: JSON.stringify(ne) });
              let de = ne.image;
              if (typeof de != "string")
                return null;
              if (!de.match(/^(https:\/\/|data:)/i)) {
                if (de.match(matcherIpfs) == null)
                  return null;
                t.push({ type: "url-ipfs", content: de }), de = getIpfsLink(de);
              }
              return t.push({ type: "url", content: de }), { linkage: t, url: de };
            }
          }
        }
      } catch {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter$d(this, void 0, void 0, function* () {
      const t = yield this._fetchBytes("0xbc1c58d1");
      if (t == null || t === "0x")
        return null;
      const s = t.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (s) {
        const v = parseInt(s[3], 16);
        if (s[4].length === v * 2)
          return "ipfs://" + Base58.encode("0x" + s[1]);
      }
      const h = t.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (h) {
        const v = parseInt(h[3], 16);
        if (h[4].length === v * 2)
          return "ipns://" + Base58.encode("0x" + h[1]);
      }
      const m = t.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (m && m[1].length === 32 * 2)
        return "bzz://" + m[1];
      const d = t.match(/^0x90b2c605([0-9a-f]*)$/);
      if (d && d[1].length === 34 * 2) {
        const v = { "=": "", "+": "-", "/": "_" };
        return "sia://" + encode$2("0x" + d[1]).replace(/[=+\/]/g, (T) => v[T]);
      }
      return logger$g.throwError("invalid or unsupported content hash data", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: t
      });
    });
  }
  getText(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      let s = toUtf8Bytes(t);
      s = concat([bytes32ify(64), bytes32ify(s.length), s]), s.length % 32 !== 0 && (s = concat([s, hexZeroPad("0x", 32 - t.length % 32)]));
      const h = yield this._fetchBytes("0x59d1d43c", hexlify(s));
      return h == null || h === "0x" ? null : toUtf8String(h);
    });
  }
}
let defaultFormatter = null, nextPollId = 1;
class BaseProvider extends Provider$1 {
  constructor(t) {
    if (super(), this._events = [], this._emitted = { block: -2 }, this.disableCcipRead = !1, this.formatter = new.target.getFormatter(), defineReadOnly(this, "anyNetwork", t === "any"), this.anyNetwork && (t = this.detectNetwork()), t instanceof Promise)
      this._networkPromise = t, t.catch((s) => {
      }), this._ready().catch((s) => {
      });
    else {
      const s = getStatic(new.target, "getNetwork")(t);
      s ? (defineReadOnly(this, "_network", s), this.emit("network", s, null)) : logger$g.throwArgumentError("invalid network", "network", t);
    }
    this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$d(this, void 0, void 0, function* () {
      if (this._network == null) {
        let t = null;
        if (this._networkPromise)
          try {
            t = yield this._networkPromise;
          } catch {
          }
        t == null && (t = yield this.detectNetwork()), t || logger$g.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {}), this._network == null && (this.anyNetwork ? this._network = t : defineReadOnly(this, "_network", t), this.emit("network", t, null));
      }
      return this._network;
    });
  }
  get ready() {
    return poll(() => this._ready().then((t) => t, (t) => {
      if (!(t.code === Logger.errors.NETWORK_ERROR && t.event === "noNetwork"))
        throw t;
    }));
  }
  static getFormatter() {
    return defaultFormatter == null && (defaultFormatter = new Formatter()), defaultFormatter;
  }
  static getNetwork(t) {
    return getNetwork(t == null ? "homestead" : t);
  }
  ccipReadFetch(t, s, h) {
    return __awaiter$d(this, void 0, void 0, function* () {
      if (this.disableCcipRead || h.length === 0)
        return null;
      const m = t.to.toLowerCase(), d = s.toLowerCase(), v = [];
      for (let _ = 0; _ < h.length; _++) {
        const T = h[_], z = T.replace("{sender}", m).replace("{data}", d), J = T.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: d, sender: m }), Y = yield fetchJson({ url: z, errorPassThrough: !0 }, J, (ne, de) => (ne.status = de.statusCode, ne));
        if (Y.data)
          return Y.data;
        const ie = Y.message || "unknown error";
        if (Y.status >= 400 && Y.status < 500)
          return logger$g.throwError(`response not found during CCIP fetch: ${ie}`, Logger.errors.SERVER_ERROR, { url: T, errorMessage: ie });
        v.push(ie);
      }
      return logger$g.throwError(`error encountered during CCIP fetch: ${v.map((_) => JSON.stringify(_)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls: h,
        errorMessages: v
      });
    });
  }
  _getInternalBlockNumber(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      if (yield this._ready(), t > 0)
        for (; this._internalBlockNumber; ) {
          const m = this._internalBlockNumber;
          try {
            const d = yield m;
            if (getTime() - d.respTime <= t)
              return d.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === m)
              break;
          }
        }
      const s = getTime(), h = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((m) => null, (m) => m)
      }).then(({ blockNumber: m, networkError: d }) => {
        if (d)
          throw this._internalBlockNumber === h && (this._internalBlockNumber = null), d;
        const v = getTime();
        return m = BigNumber.from(m).toNumber(), m < this._maxInternalBlockNumber && (m = this._maxInternalBlockNumber), this._maxInternalBlockNumber = m, this._setFastBlockNumber(m), { blockNumber: m, reqTime: s, respTime: v };
      });
      return this._internalBlockNumber = h, h.catch((m) => {
        this._internalBlockNumber === h && (this._internalBlockNumber = null);
      }), (yield h).blockNumber;
    });
  }
  poll() {
    return __awaiter$d(this, void 0, void 0, function* () {
      const t = nextPollId++, s = [];
      let h = null;
      try {
        h = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (m) {
        this.emit("error", m);
        return;
      }
      if (this._setFastBlockNumber(h), this.emit("poll", t, h), h === this._lastBlockNumber) {
        this.emit("didPoll", t);
        return;
      }
      if (this._emitted.block === -2 && (this._emitted.block = h - 1), Math.abs(this._emitted.block - h) > 1e3)
        logger$g.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${h})`), this.emit("error", logger$g.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber: h,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        })), this.emit("block", h);
      else
        for (let m = this._emitted.block + 1; m <= h; m++)
          this.emit("block", m);
      this._emitted.block !== h && (this._emitted.block = h, Object.keys(this._emitted).forEach((m) => {
        if (m === "block")
          return;
        const d = this._emitted[m];
        d !== "pending" && h - d > 12 && delete this._emitted[m];
      })), this._lastBlockNumber === -2 && (this._lastBlockNumber = h - 1), this._events.forEach((m) => {
        switch (m.type) {
          case "tx": {
            const d = m.hash;
            let v = this.getTransactionReceipt(d).then((_) => (!_ || _.blockNumber == null || (this._emitted["t:" + d] = _.blockNumber, this.emit(d, _)), null)).catch((_) => {
              this.emit("error", _);
            });
            s.push(v);
            break;
          }
          case "filter": {
            if (!m._inflight) {
              m._inflight = !0, m._lastBlockNumber === -2 && (m._lastBlockNumber = h - 1);
              const d = m.filter;
              d.fromBlock = m._lastBlockNumber + 1, d.toBlock = h;
              const v = d.toBlock - this._maxFilterBlockRange;
              v > d.fromBlock && (d.fromBlock = v), d.fromBlock < 0 && (d.fromBlock = 0);
              const _ = this.getLogs(d).then((T) => {
                m._inflight = !1, T.length !== 0 && T.forEach((z) => {
                  z.blockNumber > m._lastBlockNumber && (m._lastBlockNumber = z.blockNumber), this._emitted["b:" + z.blockHash] = z.blockNumber, this._emitted["t:" + z.transactionHash] = z.blockNumber, this.emit(d, z);
                });
              }).catch((T) => {
                this.emit("error", T), m._inflight = !1;
              });
              s.push(_);
            }
            break;
          }
        }
      }), this._lastBlockNumber = h, Promise.all(s).then(() => {
        this.emit("didPoll", t);
      }).catch((m) => {
        this.emit("error", m);
      });
    });
  }
  resetEventsBlock(t) {
    this._lastBlockNumber = t - 1, this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return __awaiter$d(this, void 0, void 0, function* () {
      return logger$g.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$d(this, void 0, void 0, function* () {
      const t = yield this._ready(), s = yield this.detectNetwork();
      if (t.chainId !== s.chainId) {
        if (this.anyNetwork)
          return this._network = s, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", s, t), yield stall$1(0), this._network;
        const h = logger$g.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network: t,
          detectedNetwork: s
        });
        throw this.emit("error", h), h;
      }
      return t;
    });
  }
  get blockNumber() {
    return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((t) => {
      this._setFastBlockNumber(t);
    }, (t) => {
    }), this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(t) {
    t && !this._poller ? (this._poller = setInterval(() => {
      this.poll();
    }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
      this.poll(), this._bootstrapPoll = setTimeout(() => {
        this._poller || this.poll(), this._bootstrapPoll = null;
      }, this.pollingInterval);
    }, 0))) : !t && this._poller && (clearInterval(this._poller), this._poller = null);
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(t) {
    if (typeof t != "number" || t <= 0 || parseInt(String(t)) != t)
      throw new Error("invalid polling interval");
    this._pollingInterval = t, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
      this.poll();
    }, this._pollingInterval));
  }
  _getFastBlockNumber() {
    const t = getTime();
    return t - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = t, this._fastBlockNumberPromise = this.getBlockNumber().then((s) => ((this._fastBlockNumber == null || s > this._fastBlockNumber) && (this._fastBlockNumber = s), this._fastBlockNumber))), this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(t) {
    this._fastBlockNumber != null && t < this._fastBlockNumber || (this._fastQueryDate = getTime(), (this._fastBlockNumber == null || t > this._fastBlockNumber) && (this._fastBlockNumber = t, this._fastBlockNumberPromise = Promise.resolve(t)));
  }
  waitForTransaction(t, s, h) {
    return __awaiter$d(this, void 0, void 0, function* () {
      return this._waitForTransaction(t, s == null ? 1 : s, h || 0, null);
    });
  }
  _waitForTransaction(t, s, h, m) {
    return __awaiter$d(this, void 0, void 0, function* () {
      const d = yield this.getTransactionReceipt(t);
      return (d ? d.confirmations : 0) >= s ? d : new Promise((v, _) => {
        const T = [];
        let z = !1;
        const J = function() {
          return z ? !0 : (z = !0, T.forEach((ie) => {
            ie();
          }), !1);
        }, Y = (ie) => {
          ie.confirmations < s || J() || v(ie);
        };
        if (this.on(t, Y), T.push(() => {
          this.removeListener(t, Y);
        }), m) {
          let ie = m.startBlock, ne = null;
          const de = (ce) => __awaiter$d(this, void 0, void 0, function* () {
            z || (yield stall$1(1e3), this.getTransactionCount(m.from).then((re) => __awaiter$d(this, void 0, void 0, function* () {
              if (!z) {
                if (re <= m.nonce)
                  ie = ce;
                else {
                  {
                    const oe = yield this.getTransaction(t);
                    if (oe && oe.blockNumber != null)
                      return;
                  }
                  for (ne == null && (ne = ie - 3, ne < m.startBlock && (ne = m.startBlock)); ne <= ce; ) {
                    if (z)
                      return;
                    const oe = yield this.getBlockWithTransactions(ne);
                    for (let pe = 0; pe < oe.transactions.length; pe++) {
                      const ae = oe.transactions[pe];
                      if (ae.hash === t)
                        return;
                      if (ae.from === m.from && ae.nonce === m.nonce) {
                        if (z)
                          return;
                        const me = yield this.waitForTransaction(ae.hash, s);
                        if (J())
                          return;
                        let ge = "replaced";
                        ae.data === m.data && ae.to === m.to && ae.value.eq(m.value) ? ge = "repriced" : ae.data === "0x" && ae.from === ae.to && ae.value.isZero() && (ge = "cancelled"), _(logger$g.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                          cancelled: ge === "replaced" || ge === "cancelled",
                          reason: ge,
                          replacement: this._wrapTransaction(ae),
                          hash: t,
                          receipt: me
                        }));
                        return;
                      }
                    }
                    ne++;
                  }
                }
                z || this.once("block", de);
              }
            }), (re) => {
              z || this.once("block", de);
            }));
          });
          if (z)
            return;
          this.once("block", de), T.push(() => {
            this.removeListener("block", de);
          });
        }
        if (typeof h == "number" && h > 0) {
          const ie = setTimeout(() => {
            J() || _(logger$g.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout: h }));
          }, h);
          ie.unref && ie.unref(), T.push(() => {
            clearTimeout(ie);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$d(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(t);
      } catch (s) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result: t,
          error: s
        });
      }
    });
  }
  getBalance(t, s) {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const h = yield resolveProperties({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(s)
      }), m = yield this.perform("getBalance", h);
      try {
        return BigNumber.from(m);
      } catch (d) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params: h,
          result: m,
          error: d
        });
      }
    });
  }
  getTransactionCount(t, s) {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const h = yield resolveProperties({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(s)
      }), m = yield this.perform("getTransactionCount", h);
      try {
        return BigNumber.from(m).toNumber();
      } catch (d) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params: h,
          result: m,
          error: d
        });
      }
    });
  }
  getCode(t, s) {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const h = yield resolveProperties({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(s)
      }), m = yield this.perform("getCode", h);
      try {
        return hexlify(m);
      } catch (d) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params: h,
          result: m,
          error: d
        });
      }
    });
  }
  getStorageAt(t, s, h) {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const m = yield resolveProperties({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(h),
        position: Promise.resolve(s).then((v) => hexValue(v))
      }), d = yield this.perform("getStorageAt", m);
      try {
        return hexlify(d);
      } catch (v) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params: m,
          result: d,
          error: v
        });
      }
    });
  }
  _wrapTransaction(t, s, h) {
    if (s != null && hexDataLength(s) !== 32)
      throw new Error("invalid response - sendTransaction");
    const m = t;
    return s != null && t.hash !== s && logger$g.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: t.hash, returnedHash: s }), m.wait = (d, v) => __awaiter$d(this, void 0, void 0, function* () {
      d == null && (d = 1), v == null && (v = 0);
      let _;
      d !== 0 && h != null && (_ = {
        data: t.data,
        from: t.from,
        nonce: t.nonce,
        to: t.to,
        value: t.value,
        startBlock: h
      });
      const T = yield this._waitForTransaction(t.hash, d, v, _);
      return T == null && d === 0 ? null : (this._emitted["t:" + t.hash] = T.blockNumber, T.status === 0 && logger$g.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
        transactionHash: t.hash,
        transaction: t,
        receipt: T
      }), T);
    }), m;
  }
  sendTransaction(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const s = yield Promise.resolve(t).then((d) => hexlify(d)), h = this.formatter.transaction(t);
      h.confirmations == null && (h.confirmations = 0);
      const m = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const d = yield this.perform("sendTransaction", { signedTransaction: s });
        return this._wrapTransaction(h, d, m);
      } catch (d) {
        throw d.transaction = h, d.transactionHash = h.hash, d;
      }
    });
  }
  _getTransactionRequest(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      const s = yield t, h = {};
      return ["from", "to"].forEach((m) => {
        s[m] != null && (h[m] = Promise.resolve(s[m]).then((d) => d ? this._getAddress(d) : null));
      }), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((m) => {
        s[m] != null && (h[m] = Promise.resolve(s[m]).then((d) => d ? BigNumber.from(d) : null));
      }), ["type"].forEach((m) => {
        s[m] != null && (h[m] = Promise.resolve(s[m]).then((d) => d != null ? d : null));
      }), s.accessList && (h.accessList = this.formatter.accessList(s.accessList)), ["data"].forEach((m) => {
        s[m] != null && (h[m] = Promise.resolve(s[m]).then((d) => d ? hexlify(d) : null));
      }), this.formatter.transactionRequest(yield resolveProperties(h));
    });
  }
  _getFilter(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      t = yield t;
      const s = {};
      return t.address != null && (s.address = this._getAddress(t.address)), ["blockHash", "topics"].forEach((h) => {
        t[h] != null && (s[h] = t[h]);
      }), ["fromBlock", "toBlock"].forEach((h) => {
        t[h] != null && (s[h] = this._getBlockTag(t[h]));
      }), this.formatter.filter(yield resolveProperties(s));
    });
  }
  _call(t, s, h) {
    return __awaiter$d(this, void 0, void 0, function* () {
      h >= MAX_CCIP_REDIRECTS && logger$g.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
        redirects: h,
        transaction: t
      });
      const m = t.to, d = yield this.perform("call", { transaction: t, blockTag: s });
      if (h >= 0 && s === "latest" && m != null && d.substring(0, 10) === "0x556f1830" && hexDataLength(d) % 32 === 4)
        try {
          const v = hexDataSlice(d, 4), _ = hexDataSlice(v, 0, 32);
          BigNumber.from(_).eq(m) || logger$g.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: t,
            data: d
          });
          const T = [], z = BigNumber.from(hexDataSlice(v, 32, 64)).toNumber(), J = BigNumber.from(hexDataSlice(v, z, z + 32)).toNumber(), Y = hexDataSlice(v, z + 32);
          for (let oe = 0; oe < J; oe++) {
            const pe = _parseString(Y, oe * 32);
            pe == null && logger$g.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: t,
              data: d
            }), T.push(pe);
          }
          const ie = _parseBytes(v, 64);
          BigNumber.from(hexDataSlice(v, 100, 128)).isZero() || logger$g.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: t,
            data: d
          });
          const ne = hexDataSlice(v, 96, 100), de = _parseBytes(v, 128), ce = yield this.ccipReadFetch(t, ie, T);
          ce == null && logger$g.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: t,
            data: d
          });
          const re = {
            to: m,
            data: hexConcat([ne, encodeBytes([ce, de])])
          };
          return this._call(re, s, h + 1);
        } catch (v) {
          if (v.code === Logger.errors.SERVER_ERROR)
            throw v;
        }
      try {
        return hexlify(d);
      } catch (v) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction: t, blockTag: s },
          result: d,
          error: v
        });
      }
    });
  }
  call(t, s) {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const h = yield resolveProperties({
        transaction: this._getTransactionRequest(t),
        blockTag: this._getBlockTag(s),
        ccipReadEnabled: Promise.resolve(t.ccipReadEnabled)
      });
      return this._call(h.transaction, h.blockTag, h.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const s = yield resolveProperties({
        transaction: this._getTransactionRequest(t)
      }), h = yield this.perform("estimateGas", s);
      try {
        return BigNumber.from(h);
      } catch (m) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params: s,
          result: h,
          error: m
        });
      }
    });
  }
  _getAddress(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      t = yield t, typeof t != "string" && logger$g.throwArgumentError("invalid address or ENS name", "name", t);
      const s = yield this.resolveName(t);
      return s == null && logger$g.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `resolveName(${JSON.stringify(t)})`
      }), s;
    });
  }
  _getBlock(t, s) {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork(), t = yield t;
      let h = -128;
      const m = {
        includeTransactions: !!s
      };
      if (isHexString$2(t, 32))
        m.blockHash = t;
      else
        try {
          m.blockTag = yield this._getBlockTag(t), isHexString$2(m.blockTag) && (h = parseInt(m.blockTag.substring(2), 16));
        } catch {
          logger$g.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", t);
        }
      return poll(() => __awaiter$d(this, void 0, void 0, function* () {
        const d = yield this.perform("getBlock", m);
        if (d == null)
          return m.blockHash != null && this._emitted["b:" + m.blockHash] == null || m.blockTag != null && h > this._emitted.block ? null : void 0;
        if (s) {
          let v = null;
          for (let T = 0; T < d.transactions.length; T++) {
            const z = d.transactions[T];
            if (z.blockNumber == null)
              z.confirmations = 0;
            else if (z.confirmations == null) {
              v == null && (v = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
              let J = v - z.blockNumber + 1;
              J <= 0 && (J = 1), z.confirmations = J;
            }
          }
          const _ = this.formatter.blockWithTransactions(d);
          return _.transactions = _.transactions.map((T) => this._wrapTransaction(T)), _;
        }
        return this.formatter.block(d);
      }), { oncePoll: this });
    });
  }
  getBlock(t) {
    return this._getBlock(t, !1);
  }
  getBlockWithTransactions(t) {
    return this._getBlock(t, !0);
  }
  getTransaction(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork(), t = yield t;
      const s = { transactionHash: this.formatter.hash(t, !0) };
      return poll(() => __awaiter$d(this, void 0, void 0, function* () {
        const h = yield this.perform("getTransaction", s);
        if (h == null)
          return this._emitted["t:" + t] == null ? null : void 0;
        const m = this.formatter.transactionResponse(h);
        if (m.blockNumber == null)
          m.confirmations = 0;
        else if (m.confirmations == null) {
          let v = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - m.blockNumber + 1;
          v <= 0 && (v = 1), m.confirmations = v;
        }
        return this._wrapTransaction(m);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork(), t = yield t;
      const s = { transactionHash: this.formatter.hash(t, !0) };
      return poll(() => __awaiter$d(this, void 0, void 0, function* () {
        const h = yield this.perform("getTransactionReceipt", s);
        if (h == null)
          return this._emitted["t:" + t] == null ? null : void 0;
        if (h.blockHash == null)
          return;
        const m = this.formatter.receipt(h);
        if (m.blockNumber == null)
          m.confirmations = 0;
        else if (m.confirmations == null) {
          let v = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - m.blockNumber + 1;
          v <= 0 && (v = 1), m.confirmations = v;
        }
        return m;
      }), { oncePoll: this });
    });
  }
  getLogs(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const s = yield resolveProperties({ filter: this._getFilter(t) }), h = yield this.perform("getLogs", s);
      return h.forEach((m) => {
        m.removed == null && (m.removed = !1);
      }), Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(h);
    });
  }
  getEtherPrice() {
    return __awaiter$d(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      if (t = yield t, typeof t == "number" && t < 0) {
        t % 1 && logger$g.throwArgumentError("invalid BlockTag", "blockTag", t);
        let s = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        return s += t, s < 0 && (s = 0), this.formatter.blockTag(s);
      }
      return this.formatter.blockTag(t);
    });
  }
  getResolver(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      let s = t;
      for (; ; ) {
        if (s === "" || s === "." || t !== "eth" && s === "eth")
          return null;
        const h = yield this._getResolver(s, "getResolver");
        if (h != null) {
          const m = new Resolver(this, h, t);
          return s !== t && !(yield m.supportsWildcard()) ? null : m;
        }
        s = s.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(t, s) {
    return __awaiter$d(this, void 0, void 0, function* () {
      s == null && (s = "ENS");
      const h = yield this.getNetwork();
      h.ensAddress || logger$g.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation: s, network: h.name });
      try {
        const m = yield this.call({
          to: h.ensAddress,
          data: "0x0178b8bf" + namehash(t).substring(2)
        });
        return this.formatter.callAddress(m);
      } catch {
      }
      return null;
    });
  }
  resolveName(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      t = yield t;
      try {
        return Promise.resolve(this.formatter.address(t));
      } catch (h) {
        if (isHexString$2(t))
          throw h;
      }
      typeof t != "string" && logger$g.throwArgumentError("invalid ENS name", "name", t);
      const s = yield this.getResolver(t);
      return s ? yield s.getAddress() : null;
    });
  }
  lookupAddress(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      t = yield t, t = this.formatter.address(t);
      const s = t.substring(2).toLowerCase() + ".addr.reverse", h = yield this._getResolver(s, "lookupAddress");
      if (h == null)
        return null;
      const m = _parseString(yield this.call({
        to: h,
        data: "0x691f3431" + namehash(s).substring(2)
      }), 0);
      return (yield this.resolveName(m)) != t ? null : m;
    });
  }
  getAvatar(t) {
    return __awaiter$d(this, void 0, void 0, function* () {
      let s = null;
      if (isHexString$2(t)) {
        const d = this.formatter.address(t).substring(2).toLowerCase() + ".addr.reverse", v = yield this._getResolver(d, "getAvatar");
        if (!v)
          return null;
        s = new Resolver(this, v, d);
        try {
          const _ = yield s.getAvatar();
          if (_)
            return _.url;
        } catch (_) {
          if (_.code !== Logger.errors.CALL_EXCEPTION)
            throw _;
        }
        try {
          const _ = _parseString(yield this.call({
            to: v,
            data: "0x691f3431" + namehash(d).substring(2)
          }), 0);
          s = yield this.getResolver(_);
        } catch (_) {
          if (_.code !== Logger.errors.CALL_EXCEPTION)
            throw _;
          return null;
        }
      } else if (s = yield this.getResolver(t), !s)
        return null;
      const h = yield s.getAvatar();
      return h == null ? null : h.url;
    });
  }
  perform(t, s) {
    return logger$g.throwError(t + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: t });
  }
  _startEvent(t) {
    this.polling = this._events.filter((s) => s.pollable()).length > 0;
  }
  _stopEvent(t) {
    this.polling = this._events.filter((s) => s.pollable()).length > 0;
  }
  _addEventListener(t, s, h) {
    const m = new Event(getEventTag(t), s, h);
    return this._events.push(m), this._startEvent(m), this;
  }
  on(t, s) {
    return this._addEventListener(t, s, !1);
  }
  once(t, s) {
    return this._addEventListener(t, s, !0);
  }
  emit(t, ...s) {
    let h = !1, m = [], d = getEventTag(t);
    return this._events = this._events.filter((v) => v.tag !== d ? !0 : (setTimeout(() => {
      v.listener.apply(this, s);
    }, 0), h = !0, v.once ? (m.push(v), !1) : !0)), m.forEach((v) => {
      this._stopEvent(v);
    }), h;
  }
  listenerCount(t) {
    if (!t)
      return this._events.length;
    let s = getEventTag(t);
    return this._events.filter((h) => h.tag === s).length;
  }
  listeners(t) {
    if (t == null)
      return this._events.map((h) => h.listener);
    let s = getEventTag(t);
    return this._events.filter((h) => h.tag === s).map((h) => h.listener);
  }
  off(t, s) {
    if (s == null)
      return this.removeAllListeners(t);
    const h = [];
    let m = !1, d = getEventTag(t);
    return this._events = this._events.filter((v) => v.tag !== d || v.listener != s || m ? !0 : (m = !0, h.push(v), !1)), h.forEach((v) => {
      this._stopEvent(v);
    }), this;
  }
  removeAllListeners(t) {
    let s = [];
    if (t == null)
      s = this._events, this._events = [];
    else {
      const h = getEventTag(t);
      this._events = this._events.filter((m) => m.tag !== h ? !0 : (s.push(m), !1));
    }
    return s.forEach((h) => {
      this._stopEvent(h);
    }), this;
  }
}
var __awaiter$c = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$f = new Logger(version$5), errorGas = ["call", "estimateGas"];
function spelunk(l, t) {
  if (l == null)
    return null;
  if (typeof l.message == "string" && l.message.match("reverted")) {
    const s = isHexString$2(l.data) ? l.data : null;
    if (!t || s)
      return { message: l.message, data: s };
  }
  if (typeof l == "object") {
    for (const s in l) {
      const h = spelunk(l[s], t);
      if (h)
        return h;
    }
    return null;
  }
  if (typeof l == "string")
    try {
      return spelunk(JSON.parse(l), t);
    } catch {
    }
  return null;
}
function checkError$1(l, t, s) {
  const h = s.transaction || s.signedTransaction;
  if (l === "call") {
    const d = spelunk(t, !0);
    if (d)
      return d.data;
    logger$f.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction: h,
      error: t
    });
  }
  if (l === "estimateGas") {
    let d = spelunk(t.body, !1);
    d == null && (d = spelunk(t, !1)), d && logger$f.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      reason: d.message,
      method: l,
      transaction: h,
      error: t
    });
  }
  let m = t.message;
  throw t.code === Logger.errors.SERVER_ERROR && t.error && typeof t.error.message == "string" ? m = t.error.message : typeof t.body == "string" ? m = t.body : typeof t.responseText == "string" && (m = t.responseText), m = (m || "").toLowerCase(), m.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && logger$f.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
    error: t,
    method: l,
    transaction: h
  }), m.match(/nonce (is )?too low/i) && logger$f.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
    error: t,
    method: l,
    transaction: h
  }), m.match(/replacement transaction underpriced|transaction gas price.*too low/i) && logger$f.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
    error: t,
    method: l,
    transaction: h
  }), m.match(/only replay-protected/i) && logger$f.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
    error: t,
    method: l,
    transaction: h
  }), errorGas.indexOf(l) >= 0 && m.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && logger$f.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
    error: t,
    method: l,
    transaction: h
  }), t;
}
function timer(l) {
  return new Promise(function(t) {
    setTimeout(t, l);
  });
}
function getResult$1(l) {
  if (l.error) {
    const t = new Error(l.error.message);
    throw t.code = l.error.code, t.data = l.error.data, t;
  }
  return l.result;
}
function getLowerCase(l) {
  return l && l.toLowerCase();
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer$1 {
  constructor(t, s, h) {
    if (super(), t !== _constructorGuard)
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    defineReadOnly(this, "provider", s), h == null && (h = 0), typeof h == "string" ? (defineReadOnly(this, "_address", this.provider.formatter.address(h)), defineReadOnly(this, "_index", null)) : typeof h == "number" ? (defineReadOnly(this, "_index", h), defineReadOnly(this, "_address", null)) : logger$f.throwArgumentError("invalid address or index", "addressOrIndex", h);
  }
  connect(t) {
    return logger$f.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then((t) => (t.length <= this._index && logger$f.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "getAddress"
    }), this.provider.formatter.address(t[this._index])));
  }
  sendUncheckedTransaction(t) {
    t = shallowCopy(t);
    const s = this.getAddress().then((h) => (h && (h = h.toLowerCase()), h));
    if (t.gasLimit == null) {
      const h = shallowCopy(t);
      h.from = s, t.gasLimit = this.provider.estimateGas(h);
    }
    return t.to != null && (t.to = Promise.resolve(t.to).then((h) => __awaiter$c(this, void 0, void 0, function* () {
      if (h == null)
        return null;
      const m = yield this.provider.resolveName(h);
      return m == null && logger$f.throwArgumentError("provided ENS name resolves to null", "tx.to", h), m;
    }))), resolveProperties({
      tx: resolveProperties(t),
      sender: s
    }).then(({ tx: h, sender: m }) => {
      h.from != null ? h.from.toLowerCase() !== m && logger$f.throwArgumentError("from address mismatch", "transaction", t) : h.from = m;
      const d = this.provider.constructor.hexlifyTransaction(h, { from: !0 });
      return this.provider.send("eth_sendTransaction", [d]).then((v) => v, (v) => (typeof v.message == "string" && v.message.match(/user denied/i) && logger$f.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
        action: "sendTransaction",
        transaction: h
      }), checkError$1("sendTransaction", v, d)));
    });
  }
  signTransaction(t) {
    return logger$f.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(t) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const s = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), h = yield this.sendUncheckedTransaction(t);
      try {
        return yield poll(() => __awaiter$c(this, void 0, void 0, function* () {
          const m = yield this.provider.getTransaction(h);
          if (m !== null)
            return this.provider._wrapTransaction(m, h, s);
        }), { oncePoll: this.provider });
      } catch (m) {
        throw m.transactionHash = h, m;
      }
    });
  }
  signMessage(t) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const s = typeof t == "string" ? toUtf8Bytes(t) : t, h = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(s), h.toLowerCase()]);
      } catch (m) {
        throw typeof m.message == "string" && m.message.match(/user denied/i) && logger$f.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
          action: "signMessage",
          from: h,
          messageData: t
        }), m;
      }
    });
  }
  _legacySignMessage(t) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const s = typeof t == "string" ? toUtf8Bytes(t) : t, h = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [h.toLowerCase(), hexlify(s)]);
      } catch (m) {
        throw typeof m.message == "string" && m.message.match(/user denied/i) && logger$f.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
          action: "_legacySignMessage",
          from: h,
          messageData: t
        }), m;
      }
    });
  }
  _signTypedData(t, s, h) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const m = yield TypedDataEncoder.resolveNames(t, s, h, (v) => this.provider.resolveName(v)), d = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          d.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(m.domain, s, m.value))
        ]);
      } catch (v) {
        throw typeof v.message == "string" && v.message.match(/user denied/i) && logger$f.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
          action: "_signTypedData",
          from: d,
          messageData: { domain: m.domain, types: s, value: m.value }
        }), v;
      }
    });
  }
  unlock(t) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const s = this.provider, h = yield this.getAddress();
      return s.send("personal_unlockAccount", [h.toLowerCase(), t, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(t) {
    return this.sendUncheckedTransaction(t).then((s) => ({
      hash: s,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (h) => this.provider.waitForTransaction(s, h)
    }));
  }
}
const allowedTransactionKeys = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0
};
class JsonRpcProvider extends BaseProvider {
  constructor(t, s) {
    let h = s;
    h == null && (h = new Promise((m, d) => {
      setTimeout(() => {
        this.detectNetwork().then((v) => {
          m(v);
        }, (v) => {
          d(v);
        });
      }, 0);
    })), super(h), t || (t = getStatic(this.constructor, "defaultUrl")()), typeof t == "string" ? defineReadOnly(this, "connection", Object.freeze({
      url: t
    })) : defineReadOnly(this, "connection", Object.freeze(shallowCopy(t))), this._nextId = 42;
  }
  get _cache() {
    return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
      this._cache.detectNetwork = null;
    }, 0)), this._cache.detectNetwork;
  }
  _uncachedDetectNetwork() {
    return __awaiter$c(this, void 0, void 0, function* () {
      yield timer(0);
      let t = null;
      try {
        t = yield this.send("eth_chainId", []);
      } catch {
        try {
          t = yield this.send("net_version", []);
        } catch {
        }
      }
      if (t != null) {
        const s = getStatic(this.constructor, "getNetwork");
        try {
          return s(BigNumber.from(t).toNumber());
        } catch (h) {
          return logger$f.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId: t,
            event: "invalidNetwork",
            serverError: h
          });
        }
      }
      return logger$f.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(t) {
    return new JsonRpcSigner(_constructorGuard, this, t);
  }
  getUncheckedSigner(t) {
    return this.getSigner(t).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((t) => t.map((s) => this.formatter.address(s)));
  }
  send(t, s) {
    const h = {
      method: t,
      params: s,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(h),
      provider: this
    });
    const m = ["eth_chainId", "eth_blockNumber"].indexOf(t) >= 0;
    if (m && this._cache[t])
      return this._cache[t];
    const d = fetchJson(this.connection, JSON.stringify(h), getResult$1).then((v) => (this.emit("debug", {
      action: "response",
      request: h,
      response: v,
      provider: this
    }), v), (v) => {
      throw this.emit("debug", {
        action: "response",
        error: v,
        request: h,
        provider: this
      }), v;
    });
    return m && (this._cache[t] = d, setTimeout(() => {
      this._cache[t] = null;
    }, 0)), d;
  }
  prepareRequest(t, s) {
    switch (t) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(s.address), s.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(s.address), s.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(s.address), s.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(s.address), hexZeroPad(s.position, 32), s.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [s.signedTransaction]];
      case "getBlock":
        return s.blockTag ? ["eth_getBlockByNumber", [s.blockTag, !!s.includeTransactions]] : s.blockHash ? ["eth_getBlockByHash", [s.blockHash, !!s.includeTransactions]] : null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [s.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [s.transactionHash]];
      case "call":
        return ["eth_call", [getStatic(this.constructor, "hexlifyTransaction")(s.transaction, { from: !0 }), s.blockTag]];
      case "estimateGas":
        return ["eth_estimateGas", [getStatic(this.constructor, "hexlifyTransaction")(s.transaction, { from: !0 })]];
      case "getLogs":
        return s.filter && s.filter.address != null && (s.filter.address = getLowerCase(s.filter.address)), ["eth_getLogs", [s.filter]];
    }
    return null;
  }
  perform(t, s) {
    return __awaiter$c(this, void 0, void 0, function* () {
      if (t === "call" || t === "estimateGas") {
        const m = s.transaction;
        if (m && m.type != null && BigNumber.from(m.type).isZero() && m.maxFeePerGas == null && m.maxPriorityFeePerGas == null) {
          const d = yield this.getFeeData();
          d.maxFeePerGas == null && d.maxPriorityFeePerGas == null && (s = shallowCopy(s), s.transaction = shallowCopy(m), delete s.transaction.type);
        }
      }
      const h = this.prepareRequest(t, s);
      h == null && logger$f.throwError(t + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: t });
      try {
        return yield this.send(h[0], h[1]);
      } catch (m) {
        return checkError$1(t, m, s);
      }
    });
  }
  _startEvent(t) {
    t.tag === "pending" && this._startPending(), super._startEvent(t);
  }
  _startPending() {
    if (this._pendingFilter != null)
      return;
    const t = this, s = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = s, s.then(function(h) {
      function m() {
        t.send("eth_getFilterChanges", [h]).then(function(d) {
          if (t._pendingFilter != s)
            return null;
          let v = Promise.resolve();
          return d.forEach(function(_) {
            t._emitted["t:" + _.toLowerCase()] = "pending", v = v.then(function() {
              return t.getTransaction(_).then(function(T) {
                return t.emit("pending", T), null;
              });
            });
          }), v.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (t._pendingFilter != s) {
            t.send("eth_uninstallFilter", [h]);
            return;
          }
          return setTimeout(function() {
            m();
          }, 0), null;
        }).catch((d) => {
        });
      }
      return m(), h;
    }).catch((h) => {
    });
  }
  _stopEvent(t) {
    t.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(t);
  }
  static hexlifyTransaction(t, s) {
    const h = shallowCopy(allowedTransactionKeys);
    if (s)
      for (const d in s)
        s[d] && (h[d] = !0);
    checkProperties(t, h);
    const m = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(d) {
      if (t[d] == null)
        return;
      const v = hexValue(BigNumber.from(t[d]));
      d === "gasLimit" && (d = "gas"), m[d] = v;
    }), ["from", "to", "data"].forEach(function(d) {
      t[d] != null && (m[d] = hexlify(t[d]));
    }), t.accessList && (m.accessList = accessListify(t.accessList)), m;
  }
}
let WS$1 = null;
try {
  if (WS$1 = WebSocket, WS$1 == null)
    throw new Error("inject please");
} catch {
  const t = new Logger(version$5);
  WS$1 = function() {
    t.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}
var __awaiter$b = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$e = new Logger(version$5);
let NextId = 1;
class WebSocketProvider extends JsonRpcProvider {
  constructor(t, s) {
    s === "any" && logger$e.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "network:any"
    }), typeof t == "string" ? super(t, s) : super("_websocket", s), this._pollingInterval = -1, this._wsReady = !1, typeof t == "string" ? defineReadOnly(this, "_websocket", new WS$1(this.connection.url)) : defineReadOnly(this, "_websocket", t), defineReadOnly(this, "_requests", {}), defineReadOnly(this, "_subs", {}), defineReadOnly(this, "_subIds", {}), defineReadOnly(this, "_detectNetwork", super.detectNetwork()), this.websocket.onopen = () => {
      this._wsReady = !0, Object.keys(this._requests).forEach((m) => {
        this.websocket.send(this._requests[m].payload);
      });
    }, this.websocket.onmessage = (m) => {
      const d = m.data, v = JSON.parse(d);
      if (v.id != null) {
        const _ = String(v.id), T = this._requests[_];
        if (delete this._requests[_], v.result !== void 0)
          T.callback(null, v.result), this.emit("debug", {
            action: "response",
            request: JSON.parse(T.payload),
            response: v.result,
            provider: this
          });
        else {
          let z = null;
          v.error ? (z = new Error(v.error.message || "unknown error"), defineReadOnly(z, "code", v.error.code || null), defineReadOnly(z, "response", d)) : z = new Error("unknown error"), T.callback(z, void 0), this.emit("debug", {
            action: "response",
            error: z,
            request: JSON.parse(T.payload),
            provider: this
          });
        }
      } else if (v.method === "eth_subscription") {
        const _ = this._subs[v.params.subscription];
        _ && _.processFunc(v.params.result);
      } else
        console.warn("this should not happen");
    };
    const h = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    h.unref && h.unref();
  }
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(t) {
    logger$e.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(t) {
    logger$e.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(t) {
    !t || logger$e.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(t, s) {
    const h = NextId++;
    return new Promise((m, d) => {
      function v(T, z) {
        return T ? d(T) : m(z);
      }
      const _ = JSON.stringify({
        method: t,
        params: s,
        id: h,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(_),
        provider: this
      }), this._requests[String(h)] = { callback: v, payload: _ }, this._wsReady && this.websocket.send(_);
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(t, s, h) {
    return __awaiter$b(this, void 0, void 0, function* () {
      let m = this._subIds[t];
      m == null && (m = Promise.all(s).then((v) => this.send("eth_subscribe", v)), this._subIds[t] = m);
      const d = yield m;
      this._subs[d] = { tag: t, processFunc: h };
    });
  }
  _startEvent(t) {
    switch (t.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (s) => {
          const h = BigNumber.from(s.number).toNumber();
          this._emitted.block = h, this.emit("block", h);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (s) => {
          this.emit("pending", s);
        });
        break;
      case "filter":
        this._subscribe(t.tag, ["logs", this._getFilter(t.filter)], (s) => {
          s.removed == null && (s.removed = !1), this.emit(t.filter, this.formatter.filterLog(s));
        });
        break;
      case "tx": {
        const s = (h) => {
          const m = h.hash;
          this.getTransactionReceipt(m).then((d) => {
            !d || this.emit(m, d);
          });
        };
        s(t), this._subscribe("tx", ["newHeads"], (h) => {
          this._events.filter((m) => m.type === "tx").forEach(s);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", t);
        break;
    }
  }
  _stopEvent(t) {
    let s = t.tag;
    if (t.type === "tx") {
      if (this._events.filter((m) => m.type === "tx").length)
        return;
      s = "tx";
    } else if (this.listenerCount(t.event))
      return;
    const h = this._subIds[s];
    !h || (delete this._subIds[s], h.then((m) => {
      !this._subs[m] || (delete this._subs[m], this.send("eth_unsubscribe", [m]));
    }));
  }
  destroy() {
    return __awaiter$b(this, void 0, void 0, function* () {
      this.websocket.readyState === WS$1.CONNECTING && (yield new Promise((t) => {
        this.websocket.onopen = function() {
          t(!0);
        }, this.websocket.onerror = function() {
          t(!1);
        };
      })), this.websocket.close(1e3);
    });
  }
}
var __awaiter$a = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$d = new Logger(version$5);
class StaticJsonRpcProvider extends JsonRpcProvider {
  detectNetwork() {
    const t = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter$a(this, void 0, void 0, function* () {
      let s = this.network;
      return s == null && (s = yield t.detectNetwork.call(this), s || logger$d.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {}), this._network == null && (defineReadOnly(this, "_network", s), this.emit("network", s, null))), s;
    });
  }
}
class UrlJsonRpcProvider extends StaticJsonRpcProvider {
  constructor(t, s) {
    logger$d.checkAbstract(new.target, UrlJsonRpcProvider), t = getStatic(new.target, "getNetwork")(t), s = getStatic(new.target, "getApiKey")(s);
    const h = getStatic(new.target, "getUrl")(t, s);
    super(h, t), typeof s == "string" ? defineReadOnly(this, "apiKey", s) : s != null && Object.keys(s).forEach((m) => {
      defineReadOnly(this, m, s[m]);
    });
  }
  _startPending() {
    logger$d.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return !1;
  }
  getSigner(t) {
    return logger$d.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  static getApiKey(t) {
    return t;
  }
  static getUrl(t, s) {
    return logger$d.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
}
const logger$c = new Logger(version$5), defaultApiKey$2 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class AlchemyWebSocketProvider extends WebSocketProvider {
  constructor(t, s) {
    const h = new AlchemyProvider(t, s), m = h.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(m, h.network), defineReadOnly(this, "apiKey", h.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey$2;
  }
}
class AlchemyProvider extends UrlJsonRpcProvider {
  static getWebSocketProvider(t, s) {
    return new AlchemyWebSocketProvider(t, s);
  }
  static getApiKey(t) {
    return t == null ? defaultApiKey$2 : (t && typeof t != "string" && logger$c.throwArgumentError("invalid apiKey", "apiKey", t), t);
  }
  static getUrl(t, s) {
    let h = null;
    switch (t.name) {
      case "homestead":
        h = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "goerli":
        h = "eth-goerli.g.alchemy.com/v2/";
        break;
      case "matic":
        h = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        h = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        h = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-goerli":
        h = "arb-goerli.g.alchemy.com/v2/";
        break;
      case "optimism":
        h = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-goerli":
        h = "opt-goerli.g.alchemy.com/v2/";
        break;
      default:
        logger$c.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: !0,
      url: "https://" + h + s,
      throttleCallback: (m, d) => (s === defaultApiKey$2 && showThrottleMessage(), Promise.resolve(!0))
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey$2;
  }
}
const logger$b = new Logger(version$5), defaultApiKey$1 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(l) {
  switch (l) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return logger$b.throwArgumentError("unsupported network", "name", l);
}
class AnkrProvider extends UrlJsonRpcProvider {
  isCommunityResource() {
    return this.apiKey === defaultApiKey$1;
  }
  static getApiKey(t) {
    return t == null ? defaultApiKey$1 : t;
  }
  static getUrl(t, s) {
    s == null && (s = defaultApiKey$1);
    const h = {
      allowGzip: !0,
      url: "https://" + getHost(t.name) + s,
      throttleCallback: (m, d) => (s.apiKey === defaultApiKey$1 && showThrottleMessage(), Promise.resolve(!0))
    };
    return s.projectSecret != null && (h.user = "", h.password = s.projectSecret), h;
  }
}
var __awaiter$9 = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$a = new Logger(version$5);
class CloudflareProvider extends UrlJsonRpcProvider {
  static getApiKey(t) {
    return t != null && logger$a.throwArgumentError("apiKey not supported for cloudflare", "apiKey", t), null;
  }
  static getUrl(t, s) {
    let h = null;
    switch (t.name) {
      case "homestead":
        h = "https://cloudflare-eth.com/";
        break;
      default:
        logger$a.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return h;
  }
  perform(t, s) {
    const h = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter$9(this, void 0, void 0, function* () {
      return t === "getBlockNumber" ? (yield h.perform.call(this, "getBlock", { blockTag: "latest" })).number : h.perform.call(this, t, s);
    });
  }
}
var __awaiter$8 = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$9 = new Logger(version$5);
function getTransactionPostData(l) {
  const t = {};
  for (let s in l) {
    if (l[s] == null)
      continue;
    let h = l[s];
    s === "type" && h === 0 || ({ type: !0, gasLimit: !0, gasPrice: !0, maxFeePerGs: !0, maxPriorityFeePerGas: !0, nonce: !0, value: !0 }[s] ? h = hexValue(hexlify(h)) : s === "accessList" ? h = "[" + accessListify(h).map((m) => `{address:"${m.address}",storageKeys:["${m.storageKeys.join('","')}"]}`).join(",") + "]" : h = hexlify(h), t[s] = h);
  }
  return t;
}
function getResult(l) {
  if (l.status == 0 && (l.message === "No records found" || l.message === "No transactions found"))
    return l.result;
  if (l.status != 1 || typeof l.message != "string" || !l.message.match(/^OK/)) {
    const t = new Error("invalid response");
    throw t.result = JSON.stringify(l), (l.result || "").toLowerCase().indexOf("rate limit") >= 0 && (t.throttleRetry = !0), t;
  }
  return l.result;
}
function getJsonResult(l) {
  if (l && l.status == 0 && l.message == "NOTOK" && (l.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const t = new Error("throttled response");
    throw t.result = JSON.stringify(l), t.throttleRetry = !0, t;
  }
  if (l.jsonrpc != "2.0") {
    const t = new Error("invalid response");
    throw t.result = JSON.stringify(l), t;
  }
  if (l.error) {
    const t = new Error(l.error.message || "unknown error");
    throw l.error.code && (t.code = l.error.code), l.error.data && (t.data = l.error.data), t;
  }
  return l.result;
}
function checkLogTag(l) {
  if (l === "pending")
    throw new Error("pending not supported");
  return l === "latest" ? l : parseInt(l.substring(2), 16);
}
function checkError(l, t, s) {
  if (l === "call" && t.code === Logger.errors.SERVER_ERROR) {
    const m = t.error;
    if (m && (m.message.match(/reverted/i) || m.message.match(/VM execution error/i))) {
      let d = m.data;
      if (d && (d = "0x" + d.replace(/^.*0x/i, "")), isHexString$2(d))
        return d;
      logger$9.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error: t,
        data: "0x"
      });
    }
  }
  let h = t.message;
  throw t.code === Logger.errors.SERVER_ERROR && (t.error && typeof t.error.message == "string" ? h = t.error.message : typeof t.body == "string" ? h = t.body : typeof t.responseText == "string" && (h = t.responseText)), h = (h || "").toLowerCase(), h.match(/insufficient funds/) && logger$9.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
    error: t,
    method: l,
    transaction: s
  }), h.match(/same hash was already imported|transaction nonce is too low|nonce too low/) && logger$9.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
    error: t,
    method: l,
    transaction: s
  }), h.match(/another transaction with same nonce/) && logger$9.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
    error: t,
    method: l,
    transaction: s
  }), h.match(/execution failed due to an exception|execution reverted/) && logger$9.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
    error: t,
    method: l,
    transaction: s
  }), t;
}
class EtherscanProvider extends BaseProvider {
  constructor(t, s) {
    super(t), defineReadOnly(this, "baseUrl", this.getBaseUrl()), defineReadOnly(this, "apiKey", s || null);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "matic":
        return "https://api.polygonscan.com";
      case "maticmum":
        return "https://api-testnet.polygonscan.com";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
    }
    return logger$9.throwArgumentError("unsupported network", "network", this.network.name);
  }
  getUrl(t, s) {
    const h = Object.keys(s).reduce((d, v) => {
      const _ = s[v];
      return _ != null && (d += `&${v}=${_}`), d;
    }, ""), m = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${t}${h}${m}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(t, s) {
    return s.module = t, s.apikey = this.apiKey, s;
  }
  fetch(t, s, h) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const m = h ? this.getPostUrl() : this.getUrl(t, s), d = h ? this.getPostData(t, s) : null, v = t === "proxy" ? getJsonResult : getResult;
      this.emit("debug", {
        action: "request",
        request: m,
        provider: this
      });
      const _ = {
        url: m,
        throttleSlotInterval: 1e3,
        throttleCallback: (J, Y) => (this.isCommunityResource() && showThrottleMessage(), Promise.resolve(!0))
      };
      let T = null;
      d && (_.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" }, T = Object.keys(d).map((J) => `${J}=${d[J]}`).join("&"));
      const z = yield fetchJson(_, T, v || getJsonResult);
      return this.emit("debug", {
        action: "response",
        request: m,
        response: deepCopy(z),
        provider: this
      }), z;
    });
  }
  detectNetwork() {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(t, s) {
    const h = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter$8(this, void 0, void 0, function* () {
      switch (t) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: s.address,
            tag: s.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: s.address,
            tag: s.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: s.address,
            tag: s.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: s.address,
            position: s.position,
            tag: s.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: s.signedTransaction
          }, !0).catch((m) => checkError("sendTransaction", m, s.signedTransaction));
        case "getBlock":
          if (s.blockTag)
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: s.blockTag,
              boolean: s.includeTransactions ? "true" : "false"
            });
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: s.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: s.transactionHash
          });
        case "call": {
          if (s.blockTag !== "latest")
            throw new Error("EtherscanProvider does not support blockTag for call");
          const m = getTransactionPostData(s.transaction);
          m.module = "proxy", m.action = "eth_call";
          try {
            return yield this.fetch("proxy", m, !0);
          } catch (d) {
            return checkError("call", d, s.transaction);
          }
        }
        case "estimateGas": {
          const m = getTransactionPostData(s.transaction);
          m.module = "proxy", m.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", m, !0);
          } catch (d) {
            return checkError("estimateGas", d, s.transaction);
          }
        }
        case "getLogs": {
          const m = { action: "getLogs" };
          if (s.filter.fromBlock && (m.fromBlock = checkLogTag(s.filter.fromBlock)), s.filter.toBlock && (m.toBlock = checkLogTag(s.filter.toBlock)), s.filter.address && (m.address = s.filter.address), s.filter.topics && s.filter.topics.length > 0 && (s.filter.topics.length > 1 && logger$9.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: s.filter.topics }), s.filter.topics.length === 1)) {
            const _ = s.filter.topics[0];
            (typeof _ != "string" || _.length !== 66) && logger$9.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0: _ }), m.topic0 = _;
          }
          const d = yield this.fetch("logs", m);
          let v = {};
          for (let _ = 0; _ < d.length; _++) {
            const T = d[_];
            if (T.blockHash == null) {
              if (v[T.blockNumber] == null) {
                const z = yield this.getBlock(T.blockNumber);
                z && (v[T.blockNumber] = z.hash);
              }
              T.blockHash = v[T.blockNumber];
            }
          }
          return d;
        }
        case "getEtherPrice":
          return this.network.name !== "homestead" ? 0 : parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
      }
      return h.perform.call(this, t, s);
    });
  }
  getHistory(t, s, h) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const m = {
        action: "txlist",
        address: yield this.resolveName(t),
        startblock: s == null ? 0 : s,
        endblock: h == null ? 99999999 : h,
        sort: "asc"
      };
      return (yield this.fetch("account", m)).map((v) => {
        ["contractAddress", "to"].forEach(function(T) {
          v[T] == "" && delete v[T];
        }), v.creates == null && v.contractAddress != null && (v.creates = v.contractAddress);
        const _ = this.formatter.transactionResponse(v);
        return v.timeStamp && (_.timestamp = parseInt(v.timeStamp)), _;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
}
var __awaiter$7 = function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
const logger$8 = new Logger(version$5);
function now() {
  return new Date().getTime();
}
function checkNetworks(l) {
  let t = null;
  for (let s = 0; s < l.length; s++) {
    const h = l[s];
    if (h == null)
      return null;
    t ? t.name === h.name && t.chainId === h.chainId && (t.ensAddress === h.ensAddress || t.ensAddress == null && h.ensAddress == null) || logger$8.throwArgumentError("provider mismatch", "networks", l) : t = h;
  }
  return t;
}
function median(l, t) {
  l = l.slice().sort();
  const s = Math.floor(l.length / 2);
  if (l.length % 2)
    return l[s];
  const h = l[s - 1], m = l[s];
  return t != null && Math.abs(h - m) > t ? null : (h + m) / 2;
}
function serialize$2(l) {
  if (l === null)
    return "null";
  if (typeof l == "number" || typeof l == "boolean")
    return JSON.stringify(l);
  if (typeof l == "string")
    return l;
  if (BigNumber.isBigNumber(l))
    return l.toString();
  if (Array.isArray(l))
    return JSON.stringify(l.map((t) => serialize$2(t)));
  if (typeof l == "object") {
    const t = Object.keys(l);
    return t.sort(), "{" + t.map((s) => {
      let h = l[s];
      return typeof h == "function" ? h = "[function]" : h = serialize$2(h), JSON.stringify(s) + ":" + h;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof l);
}
let nextRid = 1;
function stall(l) {
  let t = null, s = null, h = new Promise((v) => {
    t = function() {
      s && (clearTimeout(s), s = null), v();
    }, s = setTimeout(t, l);
  });
  const m = (v) => (h = h.then(v), h);
  function d() {
    return h;
  }
  return { cancel: t, getPromise: d, wait: m };
}
const ForwardErrors = [
  Logger.errors.CALL_EXCEPTION,
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED,
  Logger.errors.UNPREDICTABLE_GAS_LIMIT
], ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(l, t) {
  const s = {
    weight: l.weight
  };
  return Object.defineProperty(s, "provider", { get: () => l.provider }), l.start && (s.start = l.start), t && (s.duration = t - l.start), l.done && (l.error ? s.error = l.error : s.result = l.result || null), s;
}
function normalizedTally(l, t) {
  return function(s) {
    const h = {};
    s.forEach((d) => {
      const v = l(d.result);
      h[v] || (h[v] = { count: 0, result: d.result }), h[v].count++;
    });
    const m = Object.keys(h);
    for (let d = 0; d < m.length; d++) {
      const v = h[m[d]];
      if (v.count >= t)
        return v.result;
    }
  };
}
function getProcessFunc(l, t, s) {
  let h = serialize$2;
  switch (t) {
    case "getBlockNumber":
      return function(m) {
        const d = m.map((_) => _.result);
        let v = median(m.map((_) => _.result), 2);
        if (v != null)
          return v = Math.ceil(v), d.indexOf(v + 1) >= 0 && v++, v >= l._highestBlockNumber && (l._highestBlockNumber = v), l._highestBlockNumber;
      };
    case "getGasPrice":
      return function(m) {
        const d = m.map((v) => v.result);
        return d.sort(), d[Math.floor(d.length / 2)];
      };
    case "getEtherPrice":
      return function(m) {
        return median(m.map((d) => d.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      h = function(m) {
        return m == null ? null : (m = shallowCopy(m), m.confirmations = -1, serialize$2(m));
      };
      break;
    case "getBlock":
      s.includeTransactions ? h = function(m) {
        return m == null ? null : (m = shallowCopy(m), m.transactions = m.transactions.map((d) => (d = shallowCopy(d), d.confirmations = -1, d)), serialize$2(m));
      } : h = function(m) {
        return m == null ? null : serialize$2(m);
      };
      break;
    default:
      throw new Error("unknown method: " + t);
  }
  return normalizedTally(h, l.quorum);
}
function waitForSync(l, t) {
  return __awaiter$7(this, void 0, void 0, function* () {
    const s = l.provider;
    return s.blockNumber != null && s.blockNumber >= t || t === -1 ? s : poll(() => new Promise((h, m) => {
      setTimeout(function() {
        return s.blockNumber >= t ? h(s) : l.cancelled ? h(null) : h(void 0);
      }, 0);
    }), { oncePoll: s });
  });
}
function getRunner(l, t, s, h) {
  return __awaiter$7(this, void 0, void 0, function* () {
    let m = l.provider;
    switch (s) {
      case "getBlockNumber":
      case "getGasPrice":
        return m[s]();
      case "getEtherPrice":
        if (m.getEtherPrice)
          return m.getEtherPrice();
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        return h.blockTag && isHexString$2(h.blockTag) && (m = yield waitForSync(l, t)), m[s](h.address, h.blockTag || "latest");
      case "getStorageAt":
        return h.blockTag && isHexString$2(h.blockTag) && (m = yield waitForSync(l, t)), m.getStorageAt(h.address, h.position, h.blockTag || "latest");
      case "getBlock":
        return h.blockTag && isHexString$2(h.blockTag) && (m = yield waitForSync(l, t)), m[h.includeTransactions ? "getBlockWithTransactions" : "getBlock"](h.blockTag || h.blockHash);
      case "call":
      case "estimateGas":
        return h.blockTag && isHexString$2(h.blockTag) && (m = yield waitForSync(l, t)), s === "call" && h.blockTag ? m[s](h.transaction, h.blockTag) : m[s](h.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return m[s](h.transactionHash);
      case "getLogs": {
        let d = h.filter;
        return (d.fromBlock && isHexString$2(d.fromBlock) || d.toBlock && isHexString$2(d.toBlock)) && (m = yield waitForSync(l, t)), m.getLogs(d);
      }
    }
    return logger$8.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
      method: s,
      params: h
    });
  });
}
class FallbackProvider extends BaseProvider {
  constructor(t, s) {
    t.length === 0 && logger$8.throwArgumentError("missing providers", "providers", t);
    const h = t.map((v, _) => {
      if (Provider$1.isProvider(v)) {
        const J = isCommunityResource(v) ? 2e3 : 750;
        return Object.freeze({ provider: v, weight: 1, stallTimeout: J, priority: 1 });
      }
      const T = shallowCopy(v);
      T.priority == null && (T.priority = 1), T.stallTimeout == null && (T.stallTimeout = isCommunityResource(v) ? 2e3 : 750), T.weight == null && (T.weight = 1);
      const z = T.weight;
      return (z % 1 || z > 512 || z < 1) && logger$8.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${_}].weight`, z), Object.freeze(T);
    }), m = h.reduce((v, _) => v + _.weight, 0);
    s == null ? s = m / 2 : s > m && logger$8.throwArgumentError("quorum will always fail; larger than total weight", "quorum", s);
    let d = checkNetworks(h.map((v) => v.provider.network));
    d == null && (d = new Promise((v, _) => {
      setTimeout(() => {
        this.detectNetwork().then(v, _);
      }, 0);
    })), super(d), defineReadOnly(this, "providerConfigs", Object.freeze(h)), defineReadOnly(this, "quorum", s), this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter$7(this, void 0, void 0, function* () {
      const t = yield Promise.all(this.providerConfigs.map((s) => s.provider.getNetwork()));
      return checkNetworks(t);
    });
  }
  perform(t, s) {
    return __awaiter$7(this, void 0, void 0, function* () {
      if (t === "sendTransaction") {
        const T = yield Promise.all(this.providerConfigs.map((z) => z.provider.sendTransaction(s.signedTransaction).then((J) => J.hash, (J) => J)));
        for (let z = 0; z < T.length; z++) {
          const J = T[z];
          if (typeof J == "string")
            return J;
        }
        throw T[0];
      }
      this._highestBlockNumber === -1 && t !== "getBlockNumber" && (yield this.getBlockNumber());
      const h = getProcessFunc(this, t, s), m = shuffled(this.providerConfigs.map(shallowCopy));
      m.sort((T, z) => T.priority - z.priority);
      const d = this._highestBlockNumber;
      let v = 0, _ = !0;
      for (; ; ) {
        const T = now();
        let z = m.filter((ne) => ne.runner && T - ne.start < ne.stallTimeout).reduce((ne, de) => ne + de.weight, 0);
        for (; z < this.quorum && v < m.length; ) {
          const ne = m[v++], de = nextRid++;
          ne.start = now(), ne.staller = stall(ne.stallTimeout), ne.staller.wait(() => {
            ne.staller = null;
          }), ne.runner = getRunner(ne, d, t, s).then((ce) => {
            ne.done = !0, ne.result = ce, this.listenerCount("debug") && this.emit("debug", {
              action: "request",
              rid: de,
              backend: exposeDebugConfig(ne, now()),
              request: { method: t, params: deepCopy(s) },
              provider: this
            });
          }, (ce) => {
            ne.done = !0, ne.error = ce, this.listenerCount("debug") && this.emit("debug", {
              action: "request",
              rid: de,
              backend: exposeDebugConfig(ne, now()),
              request: { method: t, params: deepCopy(s) },
              provider: this
            });
          }), this.listenerCount("debug") && this.emit("debug", {
            action: "request",
            rid: de,
            backend: exposeDebugConfig(ne, null),
            request: { method: t, params: deepCopy(s) },
            provider: this
          }), z += ne.weight;
        }
        const J = [];
        m.forEach((ne) => {
          ne.done || !ne.runner || (J.push(ne.runner), ne.staller && J.push(ne.staller.getPromise()));
        }), J.length && (yield Promise.race(J));
        const Y = m.filter((ne) => ne.done && ne.error == null);
        if (Y.length >= this.quorum) {
          const ne = h(Y);
          if (ne !== void 0)
            return m.forEach((de) => {
              de.staller && de.staller.cancel(), de.cancelled = !0;
            }), ne;
          _ || (yield stall(100).getPromise()), _ = !1;
        }
        const ie = m.reduce((ne, de) => {
          if (!de.done || de.error == null)
            return ne;
          const ce = de.error.code;
          return ForwardErrors.indexOf(ce) >= 0 && (ne[ce] || (ne[ce] = { error: de.error, weight: 0 }), ne[ce].weight += de.weight), ne;
        }, {});
        if (Object.keys(ie).forEach((ne) => {
          const de = ie[ne];
          if (de.weight < this.quorum)
            return;
          m.forEach((oe) => {
            oe.staller && oe.staller.cancel(), oe.cancelled = !0;
          });
          const ce = de.error, re = {};
          ForwardProperties.forEach((oe) => {
            ce[oe] != null && (re[oe] = ce[oe]);
          }), logger$8.throwError(ce.reason || ce.message, ne, re);
        }), m.filter((ne) => !ne.done).length === 0)
          break;
      }
      return m.forEach((T) => {
        T.staller && T.staller.cancel(), T.cancelled = !0;
      }), logger$8.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
        method: t,
        params: s,
        results: m.map((T) => exposeDebugConfig(T)),
        provider: this
      });
    });
  }
}
const IpcProvider = null, logger$7 = new Logger(version$5), defaultProjectId = "84842078b09946638c03157f83405213";
class InfuraWebSocketProvider extends WebSocketProvider {
  constructor(t, s) {
    const h = new InfuraProvider(t, s), m = h.connection;
    m.password && logger$7.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "InfuraProvider.getWebSocketProvider()"
    });
    const d = m.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(d, t), defineReadOnly(this, "apiKey", h.projectId), defineReadOnly(this, "projectId", h.projectId), defineReadOnly(this, "projectSecret", h.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}
class InfuraProvider extends UrlJsonRpcProvider {
  static getWebSocketProvider(t, s) {
    return new InfuraWebSocketProvider(t, s);
  }
  static getApiKey(t) {
    const s = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    return t == null || (typeof t == "string" ? s.projectId = t : t.projectSecret != null ? (logger$7.assertArgument(typeof t.projectId == "string", "projectSecret requires a projectId", "projectId", t.projectId), logger$7.assertArgument(typeof t.projectSecret == "string", "invalid projectSecret", "projectSecret", "[REDACTED]"), s.projectId = t.projectId, s.projectSecret = t.projectSecret) : t.projectId && (s.projectId = t.projectId), s.apiKey = s.projectId), s;
  }
  static getUrl(t, s) {
    let h = null;
    switch (t ? t.name : "unknown") {
      case "homestead":
        h = "mainnet.infura.io";
        break;
      case "goerli":
        h = "goerli.infura.io";
        break;
      case "sepolia":
        h = "sepolia.infura.io";
        break;
      case "matic":
        h = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        h = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        h = "optimism-mainnet.infura.io";
        break;
      case "optimism-goerli":
        h = "optimism-goerli.infura.io";
        break;
      case "arbitrum":
        h = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-goerli":
        h = "arbitrum-goerli.infura.io";
        break;
      default:
        logger$7.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: t
        });
    }
    const m = {
      allowGzip: !0,
      url: "https://" + h + "/v3/" + s.projectId,
      throttleCallback: (d, v) => (s.projectId === defaultProjectId && showThrottleMessage(), Promise.resolve(!0))
    };
    return s.projectSecret != null && (m.user = "", m.password = s.projectSecret), m;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}
class JsonRpcBatchProvider extends JsonRpcProvider {
  send(t, s) {
    const h = {
      method: t,
      params: s,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this._pendingBatch == null && (this._pendingBatch = []);
    const m = { request: h, resolve: null, reject: null }, d = new Promise((v, _) => {
      m.resolve = v, m.reject = _;
    });
    return this._pendingBatch.push(m), this._pendingBatchAggregator || (this._pendingBatchAggregator = setTimeout(() => {
      const v = this._pendingBatch;
      this._pendingBatch = null, this._pendingBatchAggregator = null;
      const _ = v.map((T) => T.request);
      return this.emit("debug", {
        action: "requestBatch",
        request: deepCopy(_),
        provider: this
      }), fetchJson(this.connection, JSON.stringify(_)).then((T) => {
        this.emit("debug", {
          action: "response",
          request: _,
          response: T,
          provider: this
        }), v.forEach((z, J) => {
          const Y = T[J];
          if (Y.error) {
            const ie = new Error(Y.error.message);
            ie.code = Y.error.code, ie.data = Y.error.data, z.reject(ie);
          } else
            z.resolve(Y.result);
        });
      }, (T) => {
        this.emit("debug", {
          action: "response",
          error: T,
          request: _,
          provider: this
        }), v.forEach((z) => {
          z.reject(T);
        });
      });
    }, 10)), d;
  }
}
const logger$6 = new Logger(version$5), defaultApiKey = "ETHERS_JS_SHARED";
class NodesmithProvider extends UrlJsonRpcProvider {
  static getApiKey(t) {
    return t && typeof t != "string" && logger$6.throwArgumentError("invalid apiKey", "apiKey", t), t || defaultApiKey;
  }
  static getUrl(t, s) {
    logger$6.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let h = null;
    switch (t.name) {
      case "homestead":
        h = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        h = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        h = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        h = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        h = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger$6.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return h + "?apiKey=" + s;
  }
}
const logger$5 = new Logger(version$5), defaultApplicationId = "62e1ad51b37b8e00394bda3b";
class PocketProvider extends UrlJsonRpcProvider {
  static getApiKey(t) {
    const s = {
      applicationId: null,
      loadBalancer: !0,
      applicationSecretKey: null
    };
    return t == null ? s.applicationId = defaultApplicationId : typeof t == "string" ? s.applicationId = t : t.applicationSecretKey != null ? (s.applicationId = t.applicationId, s.applicationSecretKey = t.applicationSecretKey) : t.applicationId ? s.applicationId = t.applicationId : logger$5.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", t), s;
  }
  static getUrl(t, s) {
    let h = null;
    switch (t ? t.name : "unknown") {
      case "goerli":
        h = "eth-goerli.gateway.pokt.network";
        break;
      case "homestead":
        h = "eth-mainnet.gateway.pokt.network";
        break;
      case "kovan":
        h = "poa-kovan.gateway.pokt.network";
        break;
      case "matic":
        h = "poly-mainnet.gateway.pokt.network";
        break;
      case "maticmum":
        h = "polygon-mumbai-rpc.gateway.pokt.network";
        break;
      case "rinkeby":
        h = "eth-rinkeby.gateway.pokt.network";
        break;
      case "ropsten":
        h = "eth-ropsten.gateway.pokt.network";
        break;
      default:
        logger$5.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: t
        });
    }
    const m = `https://${h}/v1/lb/${s.applicationId}`, d = { headers: {}, url: m };
    return s.applicationSecretKey != null && (d.user = "", d.password = s.applicationSecretKey), d;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
}
const logger$4 = new Logger(version$5);
let _nextId = 1;
function buildWeb3LegacyFetcher(l, t) {
  const s = "Web3LegacyFetcher";
  return function(h, m) {
    const d = {
      method: h,
      params: m,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((v, _) => {
      this.emit("debug", {
        action: "request",
        fetcher: s,
        request: deepCopy(d),
        provider: this
      }), t(d, (T, z) => {
        if (T)
          return this.emit("debug", {
            action: "response",
            fetcher: s,
            error: T,
            request: d,
            provider: this
          }), _(T);
        if (this.emit("debug", {
          action: "response",
          fetcher: s,
          request: d,
          response: z,
          provider: this
        }), z.error) {
          const J = new Error(z.error.message);
          return J.code = z.error.code, J.data = z.error.data, _(J);
        }
        v(z.result);
      });
    });
  };
}
function buildEip1193Fetcher(l) {
  return function(t, s) {
    s == null && (s = []);
    const h = { method: t, params: s };
    return this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(h),
      provider: this
    }), l.request(h).then((m) => (this.emit("debug", {
      action: "response",
      fetcher: "Eip1193Fetcher",
      request: h,
      response: m,
      provider: this
    }), m), (m) => {
      throw this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: h,
        error: m,
        provider: this
      }), m;
    });
  };
}
class Web3Provider extends JsonRpcProvider {
  constructor(t, s) {
    t == null && logger$4.throwArgumentError("missing provider", "provider", t);
    let h = null, m = null, d = null;
    typeof t == "function" ? (h = "unknown:", m = t) : (h = t.host || t.path || "", !h && t.isMetaMask && (h = "metamask"), d = t, t.request ? (h === "" && (h = "eip-1193:"), m = buildEip1193Fetcher(t)) : t.sendAsync ? m = buildWeb3LegacyFetcher(t, t.sendAsync.bind(t)) : t.send ? m = buildWeb3LegacyFetcher(t, t.send.bind(t)) : logger$4.throwArgumentError("unsupported provider", "provider", t), h || (h = "unknown:")), super(h, s), defineReadOnly(this, "jsonRpcFetchFunc", m), defineReadOnly(this, "provider", d);
  }
  send(t, s) {
    return this.jsonRpcFetchFunc(t, s);
  }
}
const logger$3 = new Logger(version$5);
function getDefaultProvider(l, t) {
  if (l == null && (l = "homestead"), typeof l == "string") {
    const h = l.match(/^(ws|http)s?:/i);
    if (h)
      switch (h[1].toLowerCase()) {
        case "http":
        case "https":
          return new JsonRpcProvider(l);
        case "ws":
        case "wss":
          return new WebSocketProvider(l);
        default:
          logger$3.throwArgumentError("unsupported URL scheme", "network", l);
      }
  }
  const s = getNetwork(l);
  return (!s || !s._defaultProvider) && logger$3.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
    operation: "getDefaultProvider",
    network: l
  }), s._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    AnkrProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, t);
}
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AlchemyProvider,
  AlchemyWebSocketProvider,
  AnkrProvider,
  BaseProvider,
  CloudflareProvider,
  EtherscanProvider,
  FallbackProvider,
  Formatter,
  InfuraProvider,
  InfuraWebSocketProvider,
  IpcProvider,
  JsonRpcBatchProvider,
  JsonRpcProvider,
  JsonRpcSigner,
  NodesmithProvider,
  PocketProvider,
  Provider: Provider$1,
  Resolver,
  StaticJsonRpcProvider,
  UrlJsonRpcProvider,
  Web3Provider,
  WebSocketProvider,
  getDefaultProvider,
  getNetwork,
  isCommunityResourcable,
  isCommunityResource,
  showThrottleMessage
});
const version$4 = "solidity/5.7.0", regexBytes = new RegExp("^bytes([0-9]+)$"), regexNumber = new RegExp("^(u?int)([0-9]*)$"), regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$"), Zeros = "0000000000000000000000000000000000000000000000000000000000000000", logger$2 = new Logger(version$4);
function _pack(l, t, s) {
  switch (l) {
    case "address":
      return s ? zeroPad(t, 32) : arrayify(t);
    case "string":
      return toUtf8Bytes(t);
    case "bytes":
      return arrayify(t);
    case "bool":
      return t = t ? "0x01" : "0x00", s ? zeroPad(t, 32) : arrayify(t);
  }
  let h = l.match(regexNumber);
  if (h) {
    let m = parseInt(h[2] || "256");
    return (h[2] && String(m) !== h[2] || m % 8 !== 0 || m === 0 || m > 256) && logger$2.throwArgumentError("invalid number type", "type", l), s && (m = 256), t = BigNumber.from(t).toTwos(m), zeroPad(t, m / 8);
  }
  if (h = l.match(regexBytes), h) {
    const m = parseInt(h[1]);
    return (String(m) !== h[1] || m === 0 || m > 32) && logger$2.throwArgumentError("invalid bytes type", "type", l), arrayify(t).byteLength !== m && logger$2.throwArgumentError(`invalid value for ${l}`, "value", t), s ? arrayify((t + Zeros).substring(0, 66)) : t;
  }
  if (h = l.match(regexArray), h && Array.isArray(t)) {
    const m = h[1];
    parseInt(h[2] || String(t.length)) != t.length && logger$2.throwArgumentError(`invalid array length for ${l}`, "value", t);
    const v = [];
    return t.forEach(function(_) {
      v.push(_pack(m, _, !0));
    }), concat(v);
  }
  return logger$2.throwArgumentError("invalid type", "type", l);
}
function pack(l, t) {
  l.length != t.length && logger$2.throwArgumentError("wrong number of values; expected ${ types.length }", "values", t);
  const s = [];
  return l.forEach(function(h, m) {
    s.push(_pack(h, t[m]));
  }), hexlify(concat(s));
}
function keccak256(l, t) {
  return keccak256$1(pack(l, t));
}
function sha256$2(l, t) {
  return sha256$3(pack(l, t));
}
var lib_esm$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  keccak256,
  pack,
  sha256: sha256$2
});
const version$3 = "units/5.7.0", logger$1 = new Logger(version$3), names$1 = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function commify(l) {
  const t = String(l).split(".");
  (t.length > 2 || !t[0].match(/^-?[0-9]*$/) || t[1] && !t[1].match(/^[0-9]*$/) || l === "." || l === "-.") && logger$1.throwArgumentError("invalid value", "value", l);
  let s = t[0], h = "";
  for (s.substring(0, 1) === "-" && (h = "-", s = s.substring(1)); s.substring(0, 1) === "0"; )
    s = s.substring(1);
  s === "" && (s = "0");
  let m = "";
  for (t.length === 2 && (m = "." + (t[1] || "0")); m.length > 2 && m[m.length - 1] === "0"; )
    m = m.substring(0, m.length - 1);
  const d = [];
  for (; s.length; )
    if (s.length <= 3) {
      d.unshift(s);
      break;
    } else {
      const v = s.length - 3;
      d.unshift(s.substring(v)), s = s.substring(0, v);
    }
  return h + d.join(",") + m;
}
function formatUnits(l, t) {
  if (typeof t == "string") {
    const s = names$1.indexOf(t);
    s !== -1 && (t = 3 * s);
  }
  return formatFixed(l, t != null ? t : 18);
}
function parseUnits(l, t) {
  if (typeof l != "string" && logger$1.throwArgumentError("value must be a string", "value", l), typeof t == "string") {
    const s = names$1.indexOf(t);
    s !== -1 && (t = 3 * s);
  }
  return parseFixed(l, t != null ? t : 18);
}
function formatEther(l) {
  return formatUnits(l, 18);
}
function parseEther(l) {
  return parseUnits(l, 18);
}
var lib_esm$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  commify,
  formatEther,
  formatUnits,
  parseEther,
  parseUnits
}), utils$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AbiCoder,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  FormatTypes,
  Fragment,
  FunctionFragment,
  HDNode,
  Indexed,
  Interface,
  LogDescription,
  Logger,
  ParamType,
  RLP: lib_esm$h,
  SigningKey,
  get SupportedAlgorithm() {
    return SupportedAlgorithm;
  },
  TransactionDescription,
  get TransactionTypes() {
    return TransactionTypes;
  },
  get UnicodeNormalizationForm() {
    return UnicodeNormalizationForm;
  },
  Utf8ErrorFuncs,
  get Utf8ErrorReason() {
    return Utf8ErrorReason;
  },
  _TypedDataEncoder: TypedDataEncoder,
  _fetchData,
  _toEscapedUtf8String,
  accessListify,
  arrayify,
  base58: Base58,
  base64: lib_esm$e,
  checkProperties,
  checkResultErrors,
  commify,
  computeAddress,
  computeHmac,
  computePublicKey,
  concat,
  deepCopy,
  defaultAbiCoder,
  defaultPath,
  defineReadOnly,
  dnsEncode,
  entropyToMnemonic,
  fetchJson,
  formatBytes32String,
  formatEther,
  formatUnits,
  getAccountPath,
  getAddress,
  getContractAddress,
  getCreate2Address,
  getIcapAddress,
  getJsonWalletAddress,
  getStatic,
  hashMessage,
  hexConcat,
  hexDataLength,
  hexDataSlice,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  hexlify,
  id,
  isAddress,
  isBytes,
  isBytesLike,
  isHexString: isHexString$2,
  isValidMnemonic,
  isValidName,
  joinSignature,
  keccak256: keccak256$1,
  mnemonicToEntropy,
  mnemonicToSeed,
  namehash,
  nameprep,
  parseBytes32String,
  parseEther,
  parseTransaction: parse$1,
  parseUnits,
  poll,
  randomBytes: randomBytes$1,
  recoverAddress,
  recoverPublicKey,
  resolveProperties,
  ripemd160,
  serializeTransaction: serialize$3,
  sha256: sha256$3,
  sha512: sha512$1,
  shallowCopy,
  shuffled,
  solidityKeccak256: keccak256,
  solidityPack: pack,
  soliditySha256: sha256$2,
  splitSignature,
  stripZeros,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String,
  verifyMessage,
  verifyTypedData,
  zeroPad
});
const version$2 = "ethers/5.7.2", logger = new Logger(version$2);
var ethers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BaseContract,
  BigNumber,
  Contract,
  ContractFactory,
  FixedNumber,
  Signer: Signer$1,
  VoidSigner,
  Wallet: Wallet$1,
  Wordlist,
  constants: index$2,
  get errors() {
    return ErrorCode;
  },
  getDefaultProvider,
  logger,
  providers: index$1,
  utils: utils$6,
  version: version$2,
  wordlists
});
try {
  const l = window;
  l._ethers == null && (l._ethers = ethers);
} catch {
}
var lib_esm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BaseContract,
  BigNumber,
  Contract,
  ContractFactory,
  FixedNumber,
  Signer: Signer$1,
  VoidSigner,
  Wallet: Wallet$1,
  Wordlist,
  constants: index$2,
  get errors() {
    return ErrorCode;
  },
  ethers,
  getDefaultProvider,
  logger,
  providers: index$1,
  utils: utils$6,
  version: version$2,
  wordlists
}), ConnectorNames = /* @__PURE__ */ ((l) => (l.Undefined = "", l.Injected = "Injected", l.WalletConnect = "WalletConnect", l.FaceWallet = "FaceWallet", l))(ConnectorNames || {}), cjs$4 = {}, cjs$3 = {};
Object.defineProperty(cjs$3, "__esModule", { value: !0 });
cjs$3.getLocalStorage = cjs$3.getLocalStorageOrThrow = cjs$3.getCrypto = cjs$3.getCryptoOrThrow = cjs$3.getLocation = cjs$3.getLocationOrThrow = cjs$3.getNavigator = cjs$3.getNavigatorOrThrow = cjs$3.getDocument = cjs$3.getDocumentOrThrow = cjs$3.getFromWindowOrThrow = cjs$3.getFromWindow = void 0;
function getFromWindow$2(l) {
  let t;
  return typeof window < "u" && typeof window[l] < "u" && (t = window[l]), t;
}
cjs$3.getFromWindow = getFromWindow$2;
function getFromWindowOrThrow$2(l) {
  const t = getFromWindow$2(l);
  if (!t)
    throw new Error(`${l} is not defined in Window`);
  return t;
}
cjs$3.getFromWindowOrThrow = getFromWindowOrThrow$2;
function getDocumentOrThrow$2() {
  return getFromWindowOrThrow$2("document");
}
cjs$3.getDocumentOrThrow = getDocumentOrThrow$2;
function getDocument$2() {
  return getFromWindow$2("document");
}
cjs$3.getDocument = getDocument$2;
function getNavigatorOrThrow$2() {
  return getFromWindowOrThrow$2("navigator");
}
cjs$3.getNavigatorOrThrow = getNavigatorOrThrow$2;
function getNavigator$2() {
  return getFromWindow$2("navigator");
}
cjs$3.getNavigator = getNavigator$2;
function getLocationOrThrow$2() {
  return getFromWindowOrThrow$2("location");
}
cjs$3.getLocationOrThrow = getLocationOrThrow$2;
function getLocation$2() {
  return getFromWindow$2("location");
}
cjs$3.getLocation = getLocation$2;
function getCryptoOrThrow$2() {
  return getFromWindowOrThrow$2("crypto");
}
cjs$3.getCryptoOrThrow = getCryptoOrThrow$2;
function getCrypto$2() {
  return getFromWindow$2("crypto");
}
cjs$3.getCrypto = getCrypto$2;
function getLocalStorageOrThrow$2() {
  return getFromWindowOrThrow$2("localStorage");
}
cjs$3.getLocalStorageOrThrow = getLocalStorageOrThrow$2;
function getLocalStorage$2() {
  return getFromWindow$2("localStorage");
}
cjs$3.getLocalStorage = getLocalStorage$2;
Object.defineProperty(cjs$4, "__esModule", { value: !0 });
cjs$4.getWindowMetadata = void 0;
const window_getters_1 = cjs$3;
function getWindowMetadata() {
  let l, t;
  try {
    l = window_getters_1.getDocumentOrThrow(), t = window_getters_1.getLocationOrThrow();
  } catch {
    return null;
  }
  function s() {
    const Y = l.getElementsByTagName("link"), ie = [];
    for (let ne = 0; ne < Y.length; ne++) {
      const de = Y[ne], ce = de.getAttribute("rel");
      if (ce && ce.toLowerCase().indexOf("icon") > -1) {
        const re = de.getAttribute("href");
        if (re)
          if (re.toLowerCase().indexOf("https:") === -1 && re.toLowerCase().indexOf("http:") === -1 && re.indexOf("//") !== 0) {
            let oe = t.protocol + "//" + t.host;
            if (re.indexOf("/") === 0)
              oe += re;
            else {
              const pe = t.pathname.split("/");
              pe.pop();
              const ae = pe.join("/");
              oe += ae + "/" + re;
            }
            ie.push(oe);
          } else if (re.indexOf("//") === 0) {
            const oe = t.protocol + re;
            ie.push(oe);
          } else
            ie.push(re);
      }
    }
    return ie;
  }
  function h(...Y) {
    const ie = l.getElementsByTagName("meta");
    for (let ne = 0; ne < ie.length; ne++) {
      const de = ie[ne], ce = ["itemprop", "property", "name"].map((re) => de.getAttribute(re)).filter((re) => re ? Y.includes(re) : !1);
      if (ce.length && ce) {
        const re = de.getAttribute("content");
        if (re)
          return re;
      }
    }
    return "";
  }
  function m() {
    let Y = h("name", "og:site_name", "og:title", "twitter:title");
    return Y || (Y = l.title), Y;
  }
  function d() {
    return h("description", "og:description", "twitter:description", "keywords");
  }
  const v = m(), _ = d(), T = t.origin, z = s();
  return {
    description: _,
    url: T,
    icons: z,
    name: v
  };
}
cjs$4.getWindowMetadata = getWindowMetadata;
var cjs$2 = {};
Object.defineProperty(cjs$2, "__esModule", { value: !0 });
cjs$2.getLocalStorage = cjs$2.getLocalStorageOrThrow = cjs$2.getCrypto = cjs$2.getCryptoOrThrow = cjs$2.getLocation = cjs$2.getLocationOrThrow = cjs$2.getNavigator = cjs$2.getNavigatorOrThrow = cjs$2.getDocument = cjs$2.getDocumentOrThrow = cjs$2.getFromWindowOrThrow = getFromWindow_1 = cjs$2.getFromWindow = void 0;
function getFromWindow$1(l) {
  let t;
  return typeof window < "u" && typeof window[l] < "u" && (t = window[l]), t;
}
var getFromWindow_1 = cjs$2.getFromWindow = getFromWindow$1;
function getFromWindowOrThrow$1(l) {
  const t = getFromWindow$1(l);
  if (!t)
    throw new Error(`${l} is not defined in Window`);
  return t;
}
cjs$2.getFromWindowOrThrow = getFromWindowOrThrow$1;
function getDocumentOrThrow$1() {
  return getFromWindowOrThrow$1("document");
}
cjs$2.getDocumentOrThrow = getDocumentOrThrow$1;
function getDocument$1() {
  return getFromWindow$1("document");
}
cjs$2.getDocument = getDocument$1;
function getNavigatorOrThrow$1() {
  return getFromWindowOrThrow$1("navigator");
}
cjs$2.getNavigatorOrThrow = getNavigatorOrThrow$1;
function getNavigator$1() {
  return getFromWindow$1("navigator");
}
cjs$2.getNavigator = getNavigator$1;
function getLocationOrThrow$1() {
  return getFromWindowOrThrow$1("location");
}
cjs$2.getLocationOrThrow = getLocationOrThrow$1;
function getLocation$1() {
  return getFromWindow$1("location");
}
cjs$2.getLocation = getLocation$1;
function getCryptoOrThrow$1() {
  return getFromWindowOrThrow$1("crypto");
}
cjs$2.getCryptoOrThrow = getCryptoOrThrow$1;
function getCrypto$1() {
  return getFromWindow$1("crypto");
}
cjs$2.getCrypto = getCrypto$1;
function getLocalStorageOrThrow$1() {
  return getFromWindowOrThrow$1("localStorage");
}
cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow$1;
function getLocalStorage$1() {
  return getFromWindow$1("localStorage");
}
cjs$2.getLocalStorage = getLocalStorage$1;
const getFromWindow = getFromWindow_1;
var bn$3 = { exports: {} };
(function(l) {
  (function(t, s) {
    function h(Se, X) {
      if (!Se)
        throw new Error(X || "Assertion failed");
    }
    function m(Se, X) {
      Se.super_ = X;
      var fe = function() {
      };
      fe.prototype = X.prototype, Se.prototype = new fe(), Se.prototype.constructor = Se;
    }
    function d(Se, X, fe) {
      if (d.isBN(Se))
        return Se;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Se !== null && ((X === "le" || X === "be") && (fe = X, X = 10), this._init(Se || 0, X || 10, fe || "be"));
    }
    typeof t == "object" ? t.exports = d : s.BN = d, d.BN = d, d.wordSize = 26;
    var v;
    try {
      v = require$$0$5.Buffer;
    } catch {
    }
    d.isBN = function(X) {
      return X instanceof d ? !0 : X !== null && typeof X == "object" && X.constructor.wordSize === d.wordSize && Array.isArray(X.words);
    }, d.max = function(X, fe) {
      return X.cmp(fe) > 0 ? X : fe;
    }, d.min = function(X, fe) {
      return X.cmp(fe) < 0 ? X : fe;
    }, d.prototype._init = function(X, fe, k) {
      if (typeof X == "number")
        return this._initNumber(X, fe, k);
      if (typeof X == "object")
        return this._initArray(X, fe, k);
      fe === "hex" && (fe = 16), h(fe === (fe | 0) && fe >= 2 && fe <= 36), X = X.toString().replace(/\s+/g, "");
      var p = 0;
      X[0] === "-" && p++, fe === 16 ? this._parseHex(X, p) : this._parseBase(X, fe, p), X[0] === "-" && (this.negative = 1), this.strip(), k === "le" && this._initArray(this.toArray(), fe, k);
    }, d.prototype._initNumber = function(X, fe, k) {
      X < 0 && (this.negative = 1, X = -X), X < 67108864 ? (this.words = [X & 67108863], this.length = 1) : X < 4503599627370496 ? (this.words = [
        X & 67108863,
        X / 67108864 & 67108863
      ], this.length = 2) : (h(X < 9007199254740992), this.words = [
        X & 67108863,
        X / 67108864 & 67108863,
        1
      ], this.length = 3), k === "le" && this._initArray(this.toArray(), fe, k);
    }, d.prototype._initArray = function(X, fe, k) {
      if (h(typeof X.length == "number"), X.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(X.length / 3), this.words = new Array(this.length);
      for (var p = 0; p < this.length; p++)
        this.words[p] = 0;
      var x, S, B = 0;
      if (k === "be")
        for (p = X.length - 1, x = 0; p >= 0; p -= 3)
          S = X[p] | X[p - 1] << 8 | X[p - 2] << 16, this.words[x] |= S << B & 67108863, this.words[x + 1] = S >>> 26 - B & 67108863, B += 24, B >= 26 && (B -= 26, x++);
      else if (k === "le")
        for (p = 0, x = 0; p < X.length; p += 3)
          S = X[p] | X[p + 1] << 8 | X[p + 2] << 16, this.words[x] |= S << B & 67108863, this.words[x + 1] = S >>> 26 - B & 67108863, B += 24, B >= 26 && (B -= 26, x++);
      return this.strip();
    };
    function _(Se, X, fe) {
      for (var k = 0, p = Math.min(Se.length, fe), x = X; x < p; x++) {
        var S = Se.charCodeAt(x) - 48;
        k <<= 4, S >= 49 && S <= 54 ? k |= S - 49 + 10 : S >= 17 && S <= 22 ? k |= S - 17 + 10 : k |= S & 15;
      }
      return k;
    }
    d.prototype._parseHex = function(X, fe) {
      this.length = Math.ceil((X.length - fe) / 6), this.words = new Array(this.length);
      for (var k = 0; k < this.length; k++)
        this.words[k] = 0;
      var p, x, S = 0;
      for (k = X.length - 6, p = 0; k >= fe; k -= 6)
        x = _(X, k, k + 6), this.words[p] |= x << S & 67108863, this.words[p + 1] |= x >>> 26 - S & 4194303, S += 24, S >= 26 && (S -= 26, p++);
      k + 6 !== fe && (x = _(X, fe, k + 6), this.words[p] |= x << S & 67108863, this.words[p + 1] |= x >>> 26 - S & 4194303), this.strip();
    };
    function T(Se, X, fe, k) {
      for (var p = 0, x = Math.min(Se.length, fe), S = X; S < x; S++) {
        var B = Se.charCodeAt(S) - 48;
        p *= k, B >= 49 ? p += B - 49 + 10 : B >= 17 ? p += B - 17 + 10 : p += B;
      }
      return p;
    }
    d.prototype._parseBase = function(X, fe, k) {
      this.words = [0], this.length = 1;
      for (var p = 0, x = 1; x <= 67108863; x *= fe)
        p++;
      p--, x = x / fe | 0;
      for (var S = X.length - k, B = S % p, L = Math.min(S, S - B) + k, C = 0, G = k; G < L; G += p)
        C = T(X, G, G + p, fe), this.imuln(x), this.words[0] + C < 67108864 ? this.words[0] += C : this._iaddn(C);
      if (B !== 0) {
        var R = 1;
        for (C = T(X, G, X.length, fe), G = 0; G < B; G++)
          R *= fe;
        this.imuln(R), this.words[0] + C < 67108864 ? this.words[0] += C : this._iaddn(C);
      }
    }, d.prototype.copy = function(X) {
      X.words = new Array(this.length);
      for (var fe = 0; fe < this.length; fe++)
        X.words[fe] = this.words[fe];
      X.length = this.length, X.negative = this.negative, X.red = this.red;
    }, d.prototype.clone = function() {
      var X = new d(null);
      return this.copy(X), X;
    }, d.prototype._expand = function(X) {
      for (; this.length < X; )
        this.words[this.length++] = 0;
      return this;
    }, d.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, d.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, d.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var z = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], J = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Y = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    d.prototype.toString = function(X, fe) {
      X = X || 10, fe = fe | 0 || 1;
      var k;
      if (X === 16 || X === "hex") {
        k = "";
        for (var p = 0, x = 0, S = 0; S < this.length; S++) {
          var B = this.words[S], L = ((B << p | x) & 16777215).toString(16);
          x = B >>> 24 - p & 16777215, x !== 0 || S !== this.length - 1 ? k = z[6 - L.length] + L + k : k = L + k, p += 2, p >= 26 && (p -= 26, S--);
        }
        for (x !== 0 && (k = x.toString(16) + k); k.length % fe !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      if (X === (X | 0) && X >= 2 && X <= 36) {
        var C = J[X], G = Y[X];
        k = "";
        var R = this.clone();
        for (R.negative = 0; !R.isZero(); ) {
          var y = R.modn(G).toString(X);
          R = R.idivn(G), R.isZero() ? k = y + k : k = z[C - y.length] + y + k;
        }
        for (this.isZero() && (k = "0" + k); k.length % fe !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      h(!1, "Base should be between 2 and 36");
    }, d.prototype.toNumber = function() {
      var X = this.words[0];
      return this.length === 2 ? X += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? X += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && h(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -X : X;
    }, d.prototype.toJSON = function() {
      return this.toString(16);
    }, d.prototype.toBuffer = function(X, fe) {
      return h(typeof v < "u"), this.toArrayLike(v, X, fe);
    }, d.prototype.toArray = function(X, fe) {
      return this.toArrayLike(Array, X, fe);
    }, d.prototype.toArrayLike = function(X, fe, k) {
      var p = this.byteLength(), x = k || Math.max(1, p);
      h(p <= x, "byte array longer than desired length"), h(x > 0, "Requested array length <= 0"), this.strip();
      var S = fe === "le", B = new X(x), L, C, G = this.clone();
      if (S) {
        for (C = 0; !G.isZero(); C++)
          L = G.andln(255), G.iushrn(8), B[C] = L;
        for (; C < x; C++)
          B[C] = 0;
      } else {
        for (C = 0; C < x - p; C++)
          B[C] = 0;
        for (C = 0; !G.isZero(); C++)
          L = G.andln(255), G.iushrn(8), B[x - C - 1] = L;
      }
      return B;
    }, Math.clz32 ? d.prototype._countBits = function(X) {
      return 32 - Math.clz32(X);
    } : d.prototype._countBits = function(X) {
      var fe = X, k = 0;
      return fe >= 4096 && (k += 13, fe >>>= 13), fe >= 64 && (k += 7, fe >>>= 7), fe >= 8 && (k += 4, fe >>>= 4), fe >= 2 && (k += 2, fe >>>= 2), k + fe;
    }, d.prototype._zeroBits = function(X) {
      if (X === 0)
        return 26;
      var fe = X, k = 0;
      return (fe & 8191) === 0 && (k += 13, fe >>>= 13), (fe & 127) === 0 && (k += 7, fe >>>= 7), (fe & 15) === 0 && (k += 4, fe >>>= 4), (fe & 3) === 0 && (k += 2, fe >>>= 2), (fe & 1) === 0 && k++, k;
    }, d.prototype.bitLength = function() {
      var X = this.words[this.length - 1], fe = this._countBits(X);
      return (this.length - 1) * 26 + fe;
    };
    function ie(Se) {
      for (var X = new Array(Se.bitLength()), fe = 0; fe < X.length; fe++) {
        var k = fe / 26 | 0, p = fe % 26;
        X[fe] = (Se.words[k] & 1 << p) >>> p;
      }
      return X;
    }
    d.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var X = 0, fe = 0; fe < this.length; fe++) {
        var k = this._zeroBits(this.words[fe]);
        if (X += k, k !== 26)
          break;
      }
      return X;
    }, d.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, d.prototype.toTwos = function(X) {
      return this.negative !== 0 ? this.abs().inotn(X).iaddn(1) : this.clone();
    }, d.prototype.fromTwos = function(X) {
      return this.testn(X - 1) ? this.notn(X).iaddn(1).ineg() : this.clone();
    }, d.prototype.isNeg = function() {
      return this.negative !== 0;
    }, d.prototype.neg = function() {
      return this.clone().ineg();
    }, d.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, d.prototype.iuor = function(X) {
      for (; this.length < X.length; )
        this.words[this.length++] = 0;
      for (var fe = 0; fe < X.length; fe++)
        this.words[fe] = this.words[fe] | X.words[fe];
      return this.strip();
    }, d.prototype.ior = function(X) {
      return h((this.negative | X.negative) === 0), this.iuor(X);
    }, d.prototype.or = function(X) {
      return this.length > X.length ? this.clone().ior(X) : X.clone().ior(this);
    }, d.prototype.uor = function(X) {
      return this.length > X.length ? this.clone().iuor(X) : X.clone().iuor(this);
    }, d.prototype.iuand = function(X) {
      var fe;
      this.length > X.length ? fe = X : fe = this;
      for (var k = 0; k < fe.length; k++)
        this.words[k] = this.words[k] & X.words[k];
      return this.length = fe.length, this.strip();
    }, d.prototype.iand = function(X) {
      return h((this.negative | X.negative) === 0), this.iuand(X);
    }, d.prototype.and = function(X) {
      return this.length > X.length ? this.clone().iand(X) : X.clone().iand(this);
    }, d.prototype.uand = function(X) {
      return this.length > X.length ? this.clone().iuand(X) : X.clone().iuand(this);
    }, d.prototype.iuxor = function(X) {
      var fe, k;
      this.length > X.length ? (fe = this, k = X) : (fe = X, k = this);
      for (var p = 0; p < k.length; p++)
        this.words[p] = fe.words[p] ^ k.words[p];
      if (this !== fe)
        for (; p < fe.length; p++)
          this.words[p] = fe.words[p];
      return this.length = fe.length, this.strip();
    }, d.prototype.ixor = function(X) {
      return h((this.negative | X.negative) === 0), this.iuxor(X);
    }, d.prototype.xor = function(X) {
      return this.length > X.length ? this.clone().ixor(X) : X.clone().ixor(this);
    }, d.prototype.uxor = function(X) {
      return this.length > X.length ? this.clone().iuxor(X) : X.clone().iuxor(this);
    }, d.prototype.inotn = function(X) {
      h(typeof X == "number" && X >= 0);
      var fe = Math.ceil(X / 26) | 0, k = X % 26;
      this._expand(fe), k > 0 && fe--;
      for (var p = 0; p < fe; p++)
        this.words[p] = ~this.words[p] & 67108863;
      return k > 0 && (this.words[p] = ~this.words[p] & 67108863 >> 26 - k), this.strip();
    }, d.prototype.notn = function(X) {
      return this.clone().inotn(X);
    }, d.prototype.setn = function(X, fe) {
      h(typeof X == "number" && X >= 0);
      var k = X / 26 | 0, p = X % 26;
      return this._expand(k + 1), fe ? this.words[k] = this.words[k] | 1 << p : this.words[k] = this.words[k] & ~(1 << p), this.strip();
    }, d.prototype.iadd = function(X) {
      var fe;
      if (this.negative !== 0 && X.negative === 0)
        return this.negative = 0, fe = this.isub(X), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && X.negative !== 0)
        return X.negative = 0, fe = this.isub(X), X.negative = 1, fe._normSign();
      var k, p;
      this.length > X.length ? (k = this, p = X) : (k = X, p = this);
      for (var x = 0, S = 0; S < p.length; S++)
        fe = (k.words[S] | 0) + (p.words[S] | 0) + x, this.words[S] = fe & 67108863, x = fe >>> 26;
      for (; x !== 0 && S < k.length; S++)
        fe = (k.words[S] | 0) + x, this.words[S] = fe & 67108863, x = fe >>> 26;
      if (this.length = k.length, x !== 0)
        this.words[this.length] = x, this.length++;
      else if (k !== this)
        for (; S < k.length; S++)
          this.words[S] = k.words[S];
      return this;
    }, d.prototype.add = function(X) {
      var fe;
      return X.negative !== 0 && this.negative === 0 ? (X.negative = 0, fe = this.sub(X), X.negative ^= 1, fe) : X.negative === 0 && this.negative !== 0 ? (this.negative = 0, fe = X.sub(this), this.negative = 1, fe) : this.length > X.length ? this.clone().iadd(X) : X.clone().iadd(this);
    }, d.prototype.isub = function(X) {
      if (X.negative !== 0) {
        X.negative = 0;
        var fe = this.iadd(X);
        return X.negative = 1, fe._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(X), this.negative = 1, this._normSign();
      var k = this.cmp(X);
      if (k === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var p, x;
      k > 0 ? (p = this, x = X) : (p = X, x = this);
      for (var S = 0, B = 0; B < x.length; B++)
        fe = (p.words[B] | 0) - (x.words[B] | 0) + S, S = fe >> 26, this.words[B] = fe & 67108863;
      for (; S !== 0 && B < p.length; B++)
        fe = (p.words[B] | 0) + S, S = fe >> 26, this.words[B] = fe & 67108863;
      if (S === 0 && B < p.length && p !== this)
        for (; B < p.length; B++)
          this.words[B] = p.words[B];
      return this.length = Math.max(this.length, B), p !== this && (this.negative = 1), this.strip();
    }, d.prototype.sub = function(X) {
      return this.clone().isub(X);
    };
    function ne(Se, X, fe) {
      fe.negative = X.negative ^ Se.negative;
      var k = Se.length + X.length | 0;
      fe.length = k, k = k - 1 | 0;
      var p = Se.words[0] | 0, x = X.words[0] | 0, S = p * x, B = S & 67108863, L = S / 67108864 | 0;
      fe.words[0] = B;
      for (var C = 1; C < k; C++) {
        for (var G = L >>> 26, R = L & 67108863, y = Math.min(C, X.length - 1), j = Math.max(0, C - Se.length + 1); j <= y; j++) {
          var ye = C - j | 0;
          p = Se.words[ye] | 0, x = X.words[j] | 0, S = p * x + R, G += S / 67108864 | 0, R = S & 67108863;
        }
        fe.words[C] = R | 0, L = G | 0;
      }
      return L !== 0 ? fe.words[C] = L | 0 : fe.length--, fe.strip();
    }
    var de = function(X, fe, k) {
      var p = X.words, x = fe.words, S = k.words, B = 0, L, C, G, R = p[0] | 0, y = R & 8191, j = R >>> 13, ye = p[1] | 0, ee = ye & 8191, xe = ye >>> 13, $e = p[2] | 0, ke = $e & 8191, Ce = $e >>> 13, ht = p[3] | 0, Ue = ht & 8191, De = ht >>> 13, wt = p[4] | 0, He = wt & 8191, Ze = wt >>> 13, Ie = p[5] | 0, ue = Ie & 8191, he = Ie >>> 13, Ne = p[6] | 0, Be = Ne & 8191, Oe = Ne >>> 13, it = p[7] | 0, Ve = it & 8191, Ye = it >>> 13, Pt = p[8] | 0, et = Pt & 8191, Q = Pt >>> 13, W = p[9] | 0, V = W & 8191, se = W >>> 13, Ae = x[0] | 0, _e = Ae & 8191, Re = Ae >>> 13, mt = x[1] | 0, We = mt & 8191, ze = mt >>> 13, kt = x[2] | 0, je = kt & 8191, ot = kt >>> 13, Vt = x[3] | 0, ct = Vt & 8191, ut = Vt >>> 13, Zt = x[4] | 0, rt = Zt & 8191, nt = Zt >>> 13, Gt = x[5] | 0, st = Gt & 8191, at = Gt >>> 13, Jt = x[6] | 0, lt = Jt & 8191, tt = Jt >>> 13, Yt = x[7] | 0, le = Yt & 8191, be = Yt >>> 13, Me = x[8] | 0, te = Me & 8191, ve = Me >>> 13, qe = x[9] | 0, Pe = qe & 8191, Le = qe >>> 13;
      k.negative = X.negative ^ fe.negative, k.length = 19, L = Math.imul(y, _e), C = Math.imul(y, Re), C = C + Math.imul(j, _e) | 0, G = Math.imul(j, Re);
      var pt = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, L = Math.imul(ee, _e), C = Math.imul(ee, Re), C = C + Math.imul(xe, _e) | 0, G = Math.imul(xe, Re), L = L + Math.imul(y, We) | 0, C = C + Math.imul(y, ze) | 0, C = C + Math.imul(j, We) | 0, G = G + Math.imul(j, ze) | 0;
      var Je = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, L = Math.imul(ke, _e), C = Math.imul(ke, Re), C = C + Math.imul(Ce, _e) | 0, G = Math.imul(Ce, Re), L = L + Math.imul(ee, We) | 0, C = C + Math.imul(ee, ze) | 0, C = C + Math.imul(xe, We) | 0, G = G + Math.imul(xe, ze) | 0, L = L + Math.imul(y, je) | 0, C = C + Math.imul(y, ot) | 0, C = C + Math.imul(j, je) | 0, G = G + Math.imul(j, ot) | 0;
      var Ge = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, L = Math.imul(Ue, _e), C = Math.imul(Ue, Re), C = C + Math.imul(De, _e) | 0, G = Math.imul(De, Re), L = L + Math.imul(ke, We) | 0, C = C + Math.imul(ke, ze) | 0, C = C + Math.imul(Ce, We) | 0, G = G + Math.imul(Ce, ze) | 0, L = L + Math.imul(ee, je) | 0, C = C + Math.imul(ee, ot) | 0, C = C + Math.imul(xe, je) | 0, G = G + Math.imul(xe, ot) | 0, L = L + Math.imul(y, ct) | 0, C = C + Math.imul(y, ut) | 0, C = C + Math.imul(j, ct) | 0, G = G + Math.imul(j, ut) | 0;
      var $t = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, L = Math.imul(He, _e), C = Math.imul(He, Re), C = C + Math.imul(Ze, _e) | 0, G = Math.imul(Ze, Re), L = L + Math.imul(Ue, We) | 0, C = C + Math.imul(Ue, ze) | 0, C = C + Math.imul(De, We) | 0, G = G + Math.imul(De, ze) | 0, L = L + Math.imul(ke, je) | 0, C = C + Math.imul(ke, ot) | 0, C = C + Math.imul(Ce, je) | 0, G = G + Math.imul(Ce, ot) | 0, L = L + Math.imul(ee, ct) | 0, C = C + Math.imul(ee, ut) | 0, C = C + Math.imul(xe, ct) | 0, G = G + Math.imul(xe, ut) | 0, L = L + Math.imul(y, rt) | 0, C = C + Math.imul(y, nt) | 0, C = C + Math.imul(j, rt) | 0, G = G + Math.imul(j, nt) | 0;
      var bt = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, L = Math.imul(ue, _e), C = Math.imul(ue, Re), C = C + Math.imul(he, _e) | 0, G = Math.imul(he, Re), L = L + Math.imul(He, We) | 0, C = C + Math.imul(He, ze) | 0, C = C + Math.imul(Ze, We) | 0, G = G + Math.imul(Ze, ze) | 0, L = L + Math.imul(Ue, je) | 0, C = C + Math.imul(Ue, ot) | 0, C = C + Math.imul(De, je) | 0, G = G + Math.imul(De, ot) | 0, L = L + Math.imul(ke, ct) | 0, C = C + Math.imul(ke, ut) | 0, C = C + Math.imul(Ce, ct) | 0, G = G + Math.imul(Ce, ut) | 0, L = L + Math.imul(ee, rt) | 0, C = C + Math.imul(ee, nt) | 0, C = C + Math.imul(xe, rt) | 0, G = G + Math.imul(xe, nt) | 0, L = L + Math.imul(y, st) | 0, C = C + Math.imul(y, at) | 0, C = C + Math.imul(j, st) | 0, G = G + Math.imul(j, at) | 0;
      var Mt = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, L = Math.imul(Be, _e), C = Math.imul(Be, Re), C = C + Math.imul(Oe, _e) | 0, G = Math.imul(Oe, Re), L = L + Math.imul(ue, We) | 0, C = C + Math.imul(ue, ze) | 0, C = C + Math.imul(he, We) | 0, G = G + Math.imul(he, ze) | 0, L = L + Math.imul(He, je) | 0, C = C + Math.imul(He, ot) | 0, C = C + Math.imul(Ze, je) | 0, G = G + Math.imul(Ze, ot) | 0, L = L + Math.imul(Ue, ct) | 0, C = C + Math.imul(Ue, ut) | 0, C = C + Math.imul(De, ct) | 0, G = G + Math.imul(De, ut) | 0, L = L + Math.imul(ke, rt) | 0, C = C + Math.imul(ke, nt) | 0, C = C + Math.imul(Ce, rt) | 0, G = G + Math.imul(Ce, nt) | 0, L = L + Math.imul(ee, st) | 0, C = C + Math.imul(ee, at) | 0, C = C + Math.imul(xe, st) | 0, G = G + Math.imul(xe, at) | 0, L = L + Math.imul(y, lt) | 0, C = C + Math.imul(y, tt) | 0, C = C + Math.imul(j, lt) | 0, G = G + Math.imul(j, tt) | 0;
      var Rt = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, L = Math.imul(Ve, _e), C = Math.imul(Ve, Re), C = C + Math.imul(Ye, _e) | 0, G = Math.imul(Ye, Re), L = L + Math.imul(Be, We) | 0, C = C + Math.imul(Be, ze) | 0, C = C + Math.imul(Oe, We) | 0, G = G + Math.imul(Oe, ze) | 0, L = L + Math.imul(ue, je) | 0, C = C + Math.imul(ue, ot) | 0, C = C + Math.imul(he, je) | 0, G = G + Math.imul(he, ot) | 0, L = L + Math.imul(He, ct) | 0, C = C + Math.imul(He, ut) | 0, C = C + Math.imul(Ze, ct) | 0, G = G + Math.imul(Ze, ut) | 0, L = L + Math.imul(Ue, rt) | 0, C = C + Math.imul(Ue, nt) | 0, C = C + Math.imul(De, rt) | 0, G = G + Math.imul(De, nt) | 0, L = L + Math.imul(ke, st) | 0, C = C + Math.imul(ke, at) | 0, C = C + Math.imul(Ce, st) | 0, G = G + Math.imul(Ce, at) | 0, L = L + Math.imul(ee, lt) | 0, C = C + Math.imul(ee, tt) | 0, C = C + Math.imul(xe, lt) | 0, G = G + Math.imul(xe, tt) | 0, L = L + Math.imul(y, le) | 0, C = C + Math.imul(y, be) | 0, C = C + Math.imul(j, le) | 0, G = G + Math.imul(j, be) | 0;
      var Tt = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, L = Math.imul(et, _e), C = Math.imul(et, Re), C = C + Math.imul(Q, _e) | 0, G = Math.imul(Q, Re), L = L + Math.imul(Ve, We) | 0, C = C + Math.imul(Ve, ze) | 0, C = C + Math.imul(Ye, We) | 0, G = G + Math.imul(Ye, ze) | 0, L = L + Math.imul(Be, je) | 0, C = C + Math.imul(Be, ot) | 0, C = C + Math.imul(Oe, je) | 0, G = G + Math.imul(Oe, ot) | 0, L = L + Math.imul(ue, ct) | 0, C = C + Math.imul(ue, ut) | 0, C = C + Math.imul(he, ct) | 0, G = G + Math.imul(he, ut) | 0, L = L + Math.imul(He, rt) | 0, C = C + Math.imul(He, nt) | 0, C = C + Math.imul(Ze, rt) | 0, G = G + Math.imul(Ze, nt) | 0, L = L + Math.imul(Ue, st) | 0, C = C + Math.imul(Ue, at) | 0, C = C + Math.imul(De, st) | 0, G = G + Math.imul(De, at) | 0, L = L + Math.imul(ke, lt) | 0, C = C + Math.imul(ke, tt) | 0, C = C + Math.imul(Ce, lt) | 0, G = G + Math.imul(Ce, tt) | 0, L = L + Math.imul(ee, le) | 0, C = C + Math.imul(ee, be) | 0, C = C + Math.imul(xe, le) | 0, G = G + Math.imul(xe, be) | 0, L = L + Math.imul(y, te) | 0, C = C + Math.imul(y, ve) | 0, C = C + Math.imul(j, te) | 0, G = G + Math.imul(j, ve) | 0;
      var Nt = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, L = Math.imul(V, _e), C = Math.imul(V, Re), C = C + Math.imul(se, _e) | 0, G = Math.imul(se, Re), L = L + Math.imul(et, We) | 0, C = C + Math.imul(et, ze) | 0, C = C + Math.imul(Q, We) | 0, G = G + Math.imul(Q, ze) | 0, L = L + Math.imul(Ve, je) | 0, C = C + Math.imul(Ve, ot) | 0, C = C + Math.imul(Ye, je) | 0, G = G + Math.imul(Ye, ot) | 0, L = L + Math.imul(Be, ct) | 0, C = C + Math.imul(Be, ut) | 0, C = C + Math.imul(Oe, ct) | 0, G = G + Math.imul(Oe, ut) | 0, L = L + Math.imul(ue, rt) | 0, C = C + Math.imul(ue, nt) | 0, C = C + Math.imul(he, rt) | 0, G = G + Math.imul(he, nt) | 0, L = L + Math.imul(He, st) | 0, C = C + Math.imul(He, at) | 0, C = C + Math.imul(Ze, st) | 0, G = G + Math.imul(Ze, at) | 0, L = L + Math.imul(Ue, lt) | 0, C = C + Math.imul(Ue, tt) | 0, C = C + Math.imul(De, lt) | 0, G = G + Math.imul(De, tt) | 0, L = L + Math.imul(ke, le) | 0, C = C + Math.imul(ke, be) | 0, C = C + Math.imul(Ce, le) | 0, G = G + Math.imul(Ce, be) | 0, L = L + Math.imul(ee, te) | 0, C = C + Math.imul(ee, ve) | 0, C = C + Math.imul(xe, te) | 0, G = G + Math.imul(xe, ve) | 0, L = L + Math.imul(y, Pe) | 0, C = C + Math.imul(y, Le) | 0, C = C + Math.imul(j, Pe) | 0, G = G + Math.imul(j, Le) | 0;
      var It = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, L = Math.imul(V, We), C = Math.imul(V, ze), C = C + Math.imul(se, We) | 0, G = Math.imul(se, ze), L = L + Math.imul(et, je) | 0, C = C + Math.imul(et, ot) | 0, C = C + Math.imul(Q, je) | 0, G = G + Math.imul(Q, ot) | 0, L = L + Math.imul(Ve, ct) | 0, C = C + Math.imul(Ve, ut) | 0, C = C + Math.imul(Ye, ct) | 0, G = G + Math.imul(Ye, ut) | 0, L = L + Math.imul(Be, rt) | 0, C = C + Math.imul(Be, nt) | 0, C = C + Math.imul(Oe, rt) | 0, G = G + Math.imul(Oe, nt) | 0, L = L + Math.imul(ue, st) | 0, C = C + Math.imul(ue, at) | 0, C = C + Math.imul(he, st) | 0, G = G + Math.imul(he, at) | 0, L = L + Math.imul(He, lt) | 0, C = C + Math.imul(He, tt) | 0, C = C + Math.imul(Ze, lt) | 0, G = G + Math.imul(Ze, tt) | 0, L = L + Math.imul(Ue, le) | 0, C = C + Math.imul(Ue, be) | 0, C = C + Math.imul(De, le) | 0, G = G + Math.imul(De, be) | 0, L = L + Math.imul(ke, te) | 0, C = C + Math.imul(ke, ve) | 0, C = C + Math.imul(Ce, te) | 0, G = G + Math.imul(Ce, ve) | 0, L = L + Math.imul(ee, Pe) | 0, C = C + Math.imul(ee, Le) | 0, C = C + Math.imul(xe, Pe) | 0, G = G + Math.imul(xe, Le) | 0;
      var Ct = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, L = Math.imul(V, je), C = Math.imul(V, ot), C = C + Math.imul(se, je) | 0, G = Math.imul(se, ot), L = L + Math.imul(et, ct) | 0, C = C + Math.imul(et, ut) | 0, C = C + Math.imul(Q, ct) | 0, G = G + Math.imul(Q, ut) | 0, L = L + Math.imul(Ve, rt) | 0, C = C + Math.imul(Ve, nt) | 0, C = C + Math.imul(Ye, rt) | 0, G = G + Math.imul(Ye, nt) | 0, L = L + Math.imul(Be, st) | 0, C = C + Math.imul(Be, at) | 0, C = C + Math.imul(Oe, st) | 0, G = G + Math.imul(Oe, at) | 0, L = L + Math.imul(ue, lt) | 0, C = C + Math.imul(ue, tt) | 0, C = C + Math.imul(he, lt) | 0, G = G + Math.imul(he, tt) | 0, L = L + Math.imul(He, le) | 0, C = C + Math.imul(He, be) | 0, C = C + Math.imul(Ze, le) | 0, G = G + Math.imul(Ze, be) | 0, L = L + Math.imul(Ue, te) | 0, C = C + Math.imul(Ue, ve) | 0, C = C + Math.imul(De, te) | 0, G = G + Math.imul(De, ve) | 0, L = L + Math.imul(ke, Pe) | 0, C = C + Math.imul(ke, Le) | 0, C = C + Math.imul(Ce, Pe) | 0, G = G + Math.imul(Ce, Le) | 0;
      var Bt = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, L = Math.imul(V, ct), C = Math.imul(V, ut), C = C + Math.imul(se, ct) | 0, G = Math.imul(se, ut), L = L + Math.imul(et, rt) | 0, C = C + Math.imul(et, nt) | 0, C = C + Math.imul(Q, rt) | 0, G = G + Math.imul(Q, nt) | 0, L = L + Math.imul(Ve, st) | 0, C = C + Math.imul(Ve, at) | 0, C = C + Math.imul(Ye, st) | 0, G = G + Math.imul(Ye, at) | 0, L = L + Math.imul(Be, lt) | 0, C = C + Math.imul(Be, tt) | 0, C = C + Math.imul(Oe, lt) | 0, G = G + Math.imul(Oe, tt) | 0, L = L + Math.imul(ue, le) | 0, C = C + Math.imul(ue, be) | 0, C = C + Math.imul(he, le) | 0, G = G + Math.imul(he, be) | 0, L = L + Math.imul(He, te) | 0, C = C + Math.imul(He, ve) | 0, C = C + Math.imul(Ze, te) | 0, G = G + Math.imul(Ze, ve) | 0, L = L + Math.imul(Ue, Pe) | 0, C = C + Math.imul(Ue, Le) | 0, C = C + Math.imul(De, Pe) | 0, G = G + Math.imul(De, Le) | 0;
      var _t = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, L = Math.imul(V, rt), C = Math.imul(V, nt), C = C + Math.imul(se, rt) | 0, G = Math.imul(se, nt), L = L + Math.imul(et, st) | 0, C = C + Math.imul(et, at) | 0, C = C + Math.imul(Q, st) | 0, G = G + Math.imul(Q, at) | 0, L = L + Math.imul(Ve, lt) | 0, C = C + Math.imul(Ve, tt) | 0, C = C + Math.imul(Ye, lt) | 0, G = G + Math.imul(Ye, tt) | 0, L = L + Math.imul(Be, le) | 0, C = C + Math.imul(Be, be) | 0, C = C + Math.imul(Oe, le) | 0, G = G + Math.imul(Oe, be) | 0, L = L + Math.imul(ue, te) | 0, C = C + Math.imul(ue, ve) | 0, C = C + Math.imul(he, te) | 0, G = G + Math.imul(he, ve) | 0, L = L + Math.imul(He, Pe) | 0, C = C + Math.imul(He, Le) | 0, C = C + Math.imul(Ze, Pe) | 0, G = G + Math.imul(Ze, Le) | 0;
      var St = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, L = Math.imul(V, st), C = Math.imul(V, at), C = C + Math.imul(se, st) | 0, G = Math.imul(se, at), L = L + Math.imul(et, lt) | 0, C = C + Math.imul(et, tt) | 0, C = C + Math.imul(Q, lt) | 0, G = G + Math.imul(Q, tt) | 0, L = L + Math.imul(Ve, le) | 0, C = C + Math.imul(Ve, be) | 0, C = C + Math.imul(Ye, le) | 0, G = G + Math.imul(Ye, be) | 0, L = L + Math.imul(Be, te) | 0, C = C + Math.imul(Be, ve) | 0, C = C + Math.imul(Oe, te) | 0, G = G + Math.imul(Oe, ve) | 0, L = L + Math.imul(ue, Pe) | 0, C = C + Math.imul(ue, Le) | 0, C = C + Math.imul(he, Pe) | 0, G = G + Math.imul(he, Le) | 0;
      var vt = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, L = Math.imul(V, lt), C = Math.imul(V, tt), C = C + Math.imul(se, lt) | 0, G = Math.imul(se, tt), L = L + Math.imul(et, le) | 0, C = C + Math.imul(et, be) | 0, C = C + Math.imul(Q, le) | 0, G = G + Math.imul(Q, be) | 0, L = L + Math.imul(Ve, te) | 0, C = C + Math.imul(Ve, ve) | 0, C = C + Math.imul(Ye, te) | 0, G = G + Math.imul(Ye, ve) | 0, L = L + Math.imul(Be, Pe) | 0, C = C + Math.imul(Be, Le) | 0, C = C + Math.imul(Oe, Pe) | 0, G = G + Math.imul(Oe, Le) | 0;
      var At = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, L = Math.imul(V, le), C = Math.imul(V, be), C = C + Math.imul(se, le) | 0, G = Math.imul(se, be), L = L + Math.imul(et, te) | 0, C = C + Math.imul(et, ve) | 0, C = C + Math.imul(Q, te) | 0, G = G + Math.imul(Q, ve) | 0, L = L + Math.imul(Ve, Pe) | 0, C = C + Math.imul(Ve, Le) | 0, C = C + Math.imul(Ye, Pe) | 0, G = G + Math.imul(Ye, Le) | 0;
      var Et = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, L = Math.imul(V, te), C = Math.imul(V, ve), C = C + Math.imul(se, te) | 0, G = Math.imul(se, ve), L = L + Math.imul(et, Pe) | 0, C = C + Math.imul(et, Le) | 0, C = C + Math.imul(Q, Pe) | 0, G = G + Math.imul(Q, Le) | 0;
      var yt = (B + L | 0) + ((C & 8191) << 13) | 0;
      B = (G + (C >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, L = Math.imul(V, Pe), C = Math.imul(V, Le), C = C + Math.imul(se, Pe) | 0, G = Math.imul(se, Le);
      var Xe = (B + L | 0) + ((C & 8191) << 13) | 0;
      return B = (G + (C >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, S[0] = pt, S[1] = Je, S[2] = Ge, S[3] = $t, S[4] = bt, S[5] = Mt, S[6] = Rt, S[7] = Tt, S[8] = Nt, S[9] = It, S[10] = Ct, S[11] = Bt, S[12] = _t, S[13] = St, S[14] = vt, S[15] = At, S[16] = Et, S[17] = yt, S[18] = Xe, B !== 0 && (S[19] = B, k.length++), k;
    };
    Math.imul || (de = ne);
    function ce(Se, X, fe) {
      fe.negative = X.negative ^ Se.negative, fe.length = Se.length + X.length;
      for (var k = 0, p = 0, x = 0; x < fe.length - 1; x++) {
        var S = p;
        p = 0;
        for (var B = k & 67108863, L = Math.min(x, X.length - 1), C = Math.max(0, x - Se.length + 1); C <= L; C++) {
          var G = x - C, R = Se.words[G] | 0, y = X.words[C] | 0, j = R * y, ye = j & 67108863;
          S = S + (j / 67108864 | 0) | 0, ye = ye + B | 0, B = ye & 67108863, S = S + (ye >>> 26) | 0, p += S >>> 26, S &= 67108863;
        }
        fe.words[x] = B, k = S, S = p;
      }
      return k !== 0 ? fe.words[x] = k : fe.length--, fe.strip();
    }
    function re(Se, X, fe) {
      var k = new oe();
      return k.mulp(Se, X, fe);
    }
    d.prototype.mulTo = function(X, fe) {
      var k, p = this.length + X.length;
      return this.length === 10 && X.length === 10 ? k = de(this, X, fe) : p < 63 ? k = ne(this, X, fe) : p < 1024 ? k = ce(this, X, fe) : k = re(this, X, fe), k;
    };
    function oe(Se, X) {
      this.x = Se, this.y = X;
    }
    oe.prototype.makeRBT = function(X) {
      for (var fe = new Array(X), k = d.prototype._countBits(X) - 1, p = 0; p < X; p++)
        fe[p] = this.revBin(p, k, X);
      return fe;
    }, oe.prototype.revBin = function(X, fe, k) {
      if (X === 0 || X === k - 1)
        return X;
      for (var p = 0, x = 0; x < fe; x++)
        p |= (X & 1) << fe - x - 1, X >>= 1;
      return p;
    }, oe.prototype.permute = function(X, fe, k, p, x, S) {
      for (var B = 0; B < S; B++)
        p[B] = fe[X[B]], x[B] = k[X[B]];
    }, oe.prototype.transform = function(X, fe, k, p, x, S) {
      this.permute(S, X, fe, k, p, x);
      for (var B = 1; B < x; B <<= 1)
        for (var L = B << 1, C = Math.cos(2 * Math.PI / L), G = Math.sin(2 * Math.PI / L), R = 0; R < x; R += L)
          for (var y = C, j = G, ye = 0; ye < B; ye++) {
            var ee = k[R + ye], xe = p[R + ye], $e = k[R + ye + B], ke = p[R + ye + B], Ce = y * $e - j * ke;
            ke = y * ke + j * $e, $e = Ce, k[R + ye] = ee + $e, p[R + ye] = xe + ke, k[R + ye + B] = ee - $e, p[R + ye + B] = xe - ke, ye !== L && (Ce = C * y - G * j, j = C * j + G * y, y = Ce);
          }
    }, oe.prototype.guessLen13b = function(X, fe) {
      var k = Math.max(fe, X) | 1, p = k & 1, x = 0;
      for (k = k / 2 | 0; k; k = k >>> 1)
        x++;
      return 1 << x + 1 + p;
    }, oe.prototype.conjugate = function(X, fe, k) {
      if (!(k <= 1))
        for (var p = 0; p < k / 2; p++) {
          var x = X[p];
          X[p] = X[k - p - 1], X[k - p - 1] = x, x = fe[p], fe[p] = -fe[k - p - 1], fe[k - p - 1] = -x;
        }
    }, oe.prototype.normalize13b = function(X, fe) {
      for (var k = 0, p = 0; p < fe / 2; p++) {
        var x = Math.round(X[2 * p + 1] / fe) * 8192 + Math.round(X[2 * p] / fe) + k;
        X[p] = x & 67108863, x < 67108864 ? k = 0 : k = x / 67108864 | 0;
      }
      return X;
    }, oe.prototype.convert13b = function(X, fe, k, p) {
      for (var x = 0, S = 0; S < fe; S++)
        x = x + (X[S] | 0), k[2 * S] = x & 8191, x = x >>> 13, k[2 * S + 1] = x & 8191, x = x >>> 13;
      for (S = 2 * fe; S < p; ++S)
        k[S] = 0;
      h(x === 0), h((x & -8192) === 0);
    }, oe.prototype.stub = function(X) {
      for (var fe = new Array(X), k = 0; k < X; k++)
        fe[k] = 0;
      return fe;
    }, oe.prototype.mulp = function(X, fe, k) {
      var p = 2 * this.guessLen13b(X.length, fe.length), x = this.makeRBT(p), S = this.stub(p), B = new Array(p), L = new Array(p), C = new Array(p), G = new Array(p), R = new Array(p), y = new Array(p), j = k.words;
      j.length = p, this.convert13b(X.words, X.length, B, p), this.convert13b(fe.words, fe.length, G, p), this.transform(B, S, L, C, p, x), this.transform(G, S, R, y, p, x);
      for (var ye = 0; ye < p; ye++) {
        var ee = L[ye] * R[ye] - C[ye] * y[ye];
        C[ye] = L[ye] * y[ye] + C[ye] * R[ye], L[ye] = ee;
      }
      return this.conjugate(L, C, p), this.transform(L, C, j, S, p, x), this.conjugate(j, S, p), this.normalize13b(j, p), k.negative = X.negative ^ fe.negative, k.length = X.length + fe.length, k.strip();
    }, d.prototype.mul = function(X) {
      var fe = new d(null);
      return fe.words = new Array(this.length + X.length), this.mulTo(X, fe);
    }, d.prototype.mulf = function(X) {
      var fe = new d(null);
      return fe.words = new Array(this.length + X.length), re(this, X, fe);
    }, d.prototype.imul = function(X) {
      return this.clone().mulTo(X, this);
    }, d.prototype.imuln = function(X) {
      h(typeof X == "number"), h(X < 67108864);
      for (var fe = 0, k = 0; k < this.length; k++) {
        var p = (this.words[k] | 0) * X, x = (p & 67108863) + (fe & 67108863);
        fe >>= 26, fe += p / 67108864 | 0, fe += x >>> 26, this.words[k] = x & 67108863;
      }
      return fe !== 0 && (this.words[k] = fe, this.length++), this;
    }, d.prototype.muln = function(X) {
      return this.clone().imuln(X);
    }, d.prototype.sqr = function() {
      return this.mul(this);
    }, d.prototype.isqr = function() {
      return this.imul(this.clone());
    }, d.prototype.pow = function(X) {
      var fe = ie(X);
      if (fe.length === 0)
        return new d(1);
      for (var k = this, p = 0; p < fe.length && fe[p] === 0; p++, k = k.sqr())
        ;
      if (++p < fe.length)
        for (var x = k.sqr(); p < fe.length; p++, x = x.sqr())
          fe[p] !== 0 && (k = k.mul(x));
      return k;
    }, d.prototype.iushln = function(X) {
      h(typeof X == "number" && X >= 0);
      var fe = X % 26, k = (X - fe) / 26, p = 67108863 >>> 26 - fe << 26 - fe, x;
      if (fe !== 0) {
        var S = 0;
        for (x = 0; x < this.length; x++) {
          var B = this.words[x] & p, L = (this.words[x] | 0) - B << fe;
          this.words[x] = L | S, S = B >>> 26 - fe;
        }
        S && (this.words[x] = S, this.length++);
      }
      if (k !== 0) {
        for (x = this.length - 1; x >= 0; x--)
          this.words[x + k] = this.words[x];
        for (x = 0; x < k; x++)
          this.words[x] = 0;
        this.length += k;
      }
      return this.strip();
    }, d.prototype.ishln = function(X) {
      return h(this.negative === 0), this.iushln(X);
    }, d.prototype.iushrn = function(X, fe, k) {
      h(typeof X == "number" && X >= 0);
      var p;
      fe ? p = (fe - fe % 26) / 26 : p = 0;
      var x = X % 26, S = Math.min((X - x) / 26, this.length), B = 67108863 ^ 67108863 >>> x << x, L = k;
      if (p -= S, p = Math.max(0, p), L) {
        for (var C = 0; C < S; C++)
          L.words[C] = this.words[C];
        L.length = S;
      }
      if (S !== 0)
        if (this.length > S)
          for (this.length -= S, C = 0; C < this.length; C++)
            this.words[C] = this.words[C + S];
        else
          this.words[0] = 0, this.length = 1;
      var G = 0;
      for (C = this.length - 1; C >= 0 && (G !== 0 || C >= p); C--) {
        var R = this.words[C] | 0;
        this.words[C] = G << 26 - x | R >>> x, G = R & B;
      }
      return L && G !== 0 && (L.words[L.length++] = G), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, d.prototype.ishrn = function(X, fe, k) {
      return h(this.negative === 0), this.iushrn(X, fe, k);
    }, d.prototype.shln = function(X) {
      return this.clone().ishln(X);
    }, d.prototype.ushln = function(X) {
      return this.clone().iushln(X);
    }, d.prototype.shrn = function(X) {
      return this.clone().ishrn(X);
    }, d.prototype.ushrn = function(X) {
      return this.clone().iushrn(X);
    }, d.prototype.testn = function(X) {
      h(typeof X == "number" && X >= 0);
      var fe = X % 26, k = (X - fe) / 26, p = 1 << fe;
      if (this.length <= k)
        return !1;
      var x = this.words[k];
      return !!(x & p);
    }, d.prototype.imaskn = function(X) {
      h(typeof X == "number" && X >= 0);
      var fe = X % 26, k = (X - fe) / 26;
      if (h(this.negative === 0, "imaskn works only with positive numbers"), this.length <= k)
        return this;
      if (fe !== 0 && k++, this.length = Math.min(k, this.length), fe !== 0) {
        var p = 67108863 ^ 67108863 >>> fe << fe;
        this.words[this.length - 1] &= p;
      }
      return this.strip();
    }, d.prototype.maskn = function(X) {
      return this.clone().imaskn(X);
    }, d.prototype.iaddn = function(X) {
      return h(typeof X == "number"), h(X < 67108864), X < 0 ? this.isubn(-X) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < X ? (this.words[0] = X - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(X), this.negative = 1, this) : this._iaddn(X);
    }, d.prototype._iaddn = function(X) {
      this.words[0] += X;
      for (var fe = 0; fe < this.length && this.words[fe] >= 67108864; fe++)
        this.words[fe] -= 67108864, fe === this.length - 1 ? this.words[fe + 1] = 1 : this.words[fe + 1]++;
      return this.length = Math.max(this.length, fe + 1), this;
    }, d.prototype.isubn = function(X) {
      if (h(typeof X == "number"), h(X < 67108864), X < 0)
        return this.iaddn(-X);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(X), this.negative = 1, this;
      if (this.words[0] -= X, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var fe = 0; fe < this.length && this.words[fe] < 0; fe++)
          this.words[fe] += 67108864, this.words[fe + 1] -= 1;
      return this.strip();
    }, d.prototype.addn = function(X) {
      return this.clone().iaddn(X);
    }, d.prototype.subn = function(X) {
      return this.clone().isubn(X);
    }, d.prototype.iabs = function() {
      return this.negative = 0, this;
    }, d.prototype.abs = function() {
      return this.clone().iabs();
    }, d.prototype._ishlnsubmul = function(X, fe, k) {
      var p = X.length + k, x;
      this._expand(p);
      var S, B = 0;
      for (x = 0; x < X.length; x++) {
        S = (this.words[x + k] | 0) + B;
        var L = (X.words[x] | 0) * fe;
        S -= L & 67108863, B = (S >> 26) - (L / 67108864 | 0), this.words[x + k] = S & 67108863;
      }
      for (; x < this.length - k; x++)
        S = (this.words[x + k] | 0) + B, B = S >> 26, this.words[x + k] = S & 67108863;
      if (B === 0)
        return this.strip();
      for (h(B === -1), B = 0, x = 0; x < this.length; x++)
        S = -(this.words[x] | 0) + B, B = S >> 26, this.words[x] = S & 67108863;
      return this.negative = 1, this.strip();
    }, d.prototype._wordDiv = function(X, fe) {
      var k = this.length - X.length, p = this.clone(), x = X, S = x.words[x.length - 1] | 0, B = this._countBits(S);
      k = 26 - B, k !== 0 && (x = x.ushln(k), p.iushln(k), S = x.words[x.length - 1] | 0);
      var L = p.length - x.length, C;
      if (fe !== "mod") {
        C = new d(null), C.length = L + 1, C.words = new Array(C.length);
        for (var G = 0; G < C.length; G++)
          C.words[G] = 0;
      }
      var R = p.clone()._ishlnsubmul(x, 1, L);
      R.negative === 0 && (p = R, C && (C.words[L] = 1));
      for (var y = L - 1; y >= 0; y--) {
        var j = (p.words[x.length + y] | 0) * 67108864 + (p.words[x.length + y - 1] | 0);
        for (j = Math.min(j / S | 0, 67108863), p._ishlnsubmul(x, j, y); p.negative !== 0; )
          j--, p.negative = 0, p._ishlnsubmul(x, 1, y), p.isZero() || (p.negative ^= 1);
        C && (C.words[y] = j);
      }
      return C && C.strip(), p.strip(), fe !== "div" && k !== 0 && p.iushrn(k), {
        div: C || null,
        mod: p
      };
    }, d.prototype.divmod = function(X, fe, k) {
      if (h(!X.isZero()), this.isZero())
        return {
          div: new d(0),
          mod: new d(0)
        };
      var p, x, S;
      return this.negative !== 0 && X.negative === 0 ? (S = this.neg().divmod(X, fe), fe !== "mod" && (p = S.div.neg()), fe !== "div" && (x = S.mod.neg(), k && x.negative !== 0 && x.iadd(X)), {
        div: p,
        mod: x
      }) : this.negative === 0 && X.negative !== 0 ? (S = this.divmod(X.neg(), fe), fe !== "mod" && (p = S.div.neg()), {
        div: p,
        mod: S.mod
      }) : (this.negative & X.negative) !== 0 ? (S = this.neg().divmod(X.neg(), fe), fe !== "div" && (x = S.mod.neg(), k && x.negative !== 0 && x.isub(X)), {
        div: S.div,
        mod: x
      }) : X.length > this.length || this.cmp(X) < 0 ? {
        div: new d(0),
        mod: this
      } : X.length === 1 ? fe === "div" ? {
        div: this.divn(X.words[0]),
        mod: null
      } : fe === "mod" ? {
        div: null,
        mod: new d(this.modn(X.words[0]))
      } : {
        div: this.divn(X.words[0]),
        mod: new d(this.modn(X.words[0]))
      } : this._wordDiv(X, fe);
    }, d.prototype.div = function(X) {
      return this.divmod(X, "div", !1).div;
    }, d.prototype.mod = function(X) {
      return this.divmod(X, "mod", !1).mod;
    }, d.prototype.umod = function(X) {
      return this.divmod(X, "mod", !0).mod;
    }, d.prototype.divRound = function(X) {
      var fe = this.divmod(X);
      if (fe.mod.isZero())
        return fe.div;
      var k = fe.div.negative !== 0 ? fe.mod.isub(X) : fe.mod, p = X.ushrn(1), x = X.andln(1), S = k.cmp(p);
      return S < 0 || x === 1 && S === 0 ? fe.div : fe.div.negative !== 0 ? fe.div.isubn(1) : fe.div.iaddn(1);
    }, d.prototype.modn = function(X) {
      h(X <= 67108863);
      for (var fe = (1 << 26) % X, k = 0, p = this.length - 1; p >= 0; p--)
        k = (fe * k + (this.words[p] | 0)) % X;
      return k;
    }, d.prototype.idivn = function(X) {
      h(X <= 67108863);
      for (var fe = 0, k = this.length - 1; k >= 0; k--) {
        var p = (this.words[k] | 0) + fe * 67108864;
        this.words[k] = p / X | 0, fe = p % X;
      }
      return this.strip();
    }, d.prototype.divn = function(X) {
      return this.clone().idivn(X);
    }, d.prototype.egcd = function(X) {
      h(X.negative === 0), h(!X.isZero());
      var fe = this, k = X.clone();
      fe.negative !== 0 ? fe = fe.umod(X) : fe = fe.clone();
      for (var p = new d(1), x = new d(0), S = new d(0), B = new d(1), L = 0; fe.isEven() && k.isEven(); )
        fe.iushrn(1), k.iushrn(1), ++L;
      for (var C = k.clone(), G = fe.clone(); !fe.isZero(); ) {
        for (var R = 0, y = 1; (fe.words[0] & y) === 0 && R < 26; ++R, y <<= 1)
          ;
        if (R > 0)
          for (fe.iushrn(R); R-- > 0; )
            (p.isOdd() || x.isOdd()) && (p.iadd(C), x.isub(G)), p.iushrn(1), x.iushrn(1);
        for (var j = 0, ye = 1; (k.words[0] & ye) === 0 && j < 26; ++j, ye <<= 1)
          ;
        if (j > 0)
          for (k.iushrn(j); j-- > 0; )
            (S.isOdd() || B.isOdd()) && (S.iadd(C), B.isub(G)), S.iushrn(1), B.iushrn(1);
        fe.cmp(k) >= 0 ? (fe.isub(k), p.isub(S), x.isub(B)) : (k.isub(fe), S.isub(p), B.isub(x));
      }
      return {
        a: S,
        b: B,
        gcd: k.iushln(L)
      };
    }, d.prototype._invmp = function(X) {
      h(X.negative === 0), h(!X.isZero());
      var fe = this, k = X.clone();
      fe.negative !== 0 ? fe = fe.umod(X) : fe = fe.clone();
      for (var p = new d(1), x = new d(0), S = k.clone(); fe.cmpn(1) > 0 && k.cmpn(1) > 0; ) {
        for (var B = 0, L = 1; (fe.words[0] & L) === 0 && B < 26; ++B, L <<= 1)
          ;
        if (B > 0)
          for (fe.iushrn(B); B-- > 0; )
            p.isOdd() && p.iadd(S), p.iushrn(1);
        for (var C = 0, G = 1; (k.words[0] & G) === 0 && C < 26; ++C, G <<= 1)
          ;
        if (C > 0)
          for (k.iushrn(C); C-- > 0; )
            x.isOdd() && x.iadd(S), x.iushrn(1);
        fe.cmp(k) >= 0 ? (fe.isub(k), p.isub(x)) : (k.isub(fe), x.isub(p));
      }
      var R;
      return fe.cmpn(1) === 0 ? R = p : R = x, R.cmpn(0) < 0 && R.iadd(X), R;
    }, d.prototype.gcd = function(X) {
      if (this.isZero())
        return X.abs();
      if (X.isZero())
        return this.abs();
      var fe = this.clone(), k = X.clone();
      fe.negative = 0, k.negative = 0;
      for (var p = 0; fe.isEven() && k.isEven(); p++)
        fe.iushrn(1), k.iushrn(1);
      do {
        for (; fe.isEven(); )
          fe.iushrn(1);
        for (; k.isEven(); )
          k.iushrn(1);
        var x = fe.cmp(k);
        if (x < 0) {
          var S = fe;
          fe = k, k = S;
        } else if (x === 0 || k.cmpn(1) === 0)
          break;
        fe.isub(k);
      } while (!0);
      return k.iushln(p);
    }, d.prototype.invm = function(X) {
      return this.egcd(X).a.umod(X);
    }, d.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, d.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, d.prototype.andln = function(X) {
      return this.words[0] & X;
    }, d.prototype.bincn = function(X) {
      h(typeof X == "number");
      var fe = X % 26, k = (X - fe) / 26, p = 1 << fe;
      if (this.length <= k)
        return this._expand(k + 1), this.words[k] |= p, this;
      for (var x = p, S = k; x !== 0 && S < this.length; S++) {
        var B = this.words[S] | 0;
        B += x, x = B >>> 26, B &= 67108863, this.words[S] = B;
      }
      return x !== 0 && (this.words[S] = x, this.length++), this;
    }, d.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, d.prototype.cmpn = function(X) {
      var fe = X < 0;
      if (this.negative !== 0 && !fe)
        return -1;
      if (this.negative === 0 && fe)
        return 1;
      this.strip();
      var k;
      if (this.length > 1)
        k = 1;
      else {
        fe && (X = -X), h(X <= 67108863, "Number is too big");
        var p = this.words[0] | 0;
        k = p === X ? 0 : p < X ? -1 : 1;
      }
      return this.negative !== 0 ? -k | 0 : k;
    }, d.prototype.cmp = function(X) {
      if (this.negative !== 0 && X.negative === 0)
        return -1;
      if (this.negative === 0 && X.negative !== 0)
        return 1;
      var fe = this.ucmp(X);
      return this.negative !== 0 ? -fe | 0 : fe;
    }, d.prototype.ucmp = function(X) {
      if (this.length > X.length)
        return 1;
      if (this.length < X.length)
        return -1;
      for (var fe = 0, k = this.length - 1; k >= 0; k--) {
        var p = this.words[k] | 0, x = X.words[k] | 0;
        if (p !== x) {
          p < x ? fe = -1 : p > x && (fe = 1);
          break;
        }
      }
      return fe;
    }, d.prototype.gtn = function(X) {
      return this.cmpn(X) === 1;
    }, d.prototype.gt = function(X) {
      return this.cmp(X) === 1;
    }, d.prototype.gten = function(X) {
      return this.cmpn(X) >= 0;
    }, d.prototype.gte = function(X) {
      return this.cmp(X) >= 0;
    }, d.prototype.ltn = function(X) {
      return this.cmpn(X) === -1;
    }, d.prototype.lt = function(X) {
      return this.cmp(X) === -1;
    }, d.prototype.lten = function(X) {
      return this.cmpn(X) <= 0;
    }, d.prototype.lte = function(X) {
      return this.cmp(X) <= 0;
    }, d.prototype.eqn = function(X) {
      return this.cmpn(X) === 0;
    }, d.prototype.eq = function(X) {
      return this.cmp(X) === 0;
    }, d.red = function(X) {
      return new Te(X);
    }, d.prototype.toRed = function(X) {
      return h(!this.red, "Already a number in reduction context"), h(this.negative === 0, "red works only with positives"), X.convertTo(this)._forceRed(X);
    }, d.prototype.fromRed = function() {
      return h(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, d.prototype._forceRed = function(X) {
      return this.red = X, this;
    }, d.prototype.forceRed = function(X) {
      return h(!this.red, "Already a number in reduction context"), this._forceRed(X);
    }, d.prototype.redAdd = function(X) {
      return h(this.red, "redAdd works only with red numbers"), this.red.add(this, X);
    }, d.prototype.redIAdd = function(X) {
      return h(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, X);
    }, d.prototype.redSub = function(X) {
      return h(this.red, "redSub works only with red numbers"), this.red.sub(this, X);
    }, d.prototype.redISub = function(X) {
      return h(this.red, "redISub works only with red numbers"), this.red.isub(this, X);
    }, d.prototype.redShl = function(X) {
      return h(this.red, "redShl works only with red numbers"), this.red.shl(this, X);
    }, d.prototype.redMul = function(X) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, X), this.red.mul(this, X);
    }, d.prototype.redIMul = function(X) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, X), this.red.imul(this, X);
    }, d.prototype.redSqr = function() {
      return h(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, d.prototype.redISqr = function() {
      return h(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, d.prototype.redSqrt = function() {
      return h(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, d.prototype.redInvm = function() {
      return h(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, d.prototype.redNeg = function() {
      return h(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, d.prototype.redPow = function(X) {
      return h(this.red && !X.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, X);
    };
    var pe = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function ae(Se, X) {
      this.name = Se, this.p = new d(X, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ae.prototype._tmp = function() {
      var X = new d(null);
      return X.words = new Array(Math.ceil(this.n / 13)), X;
    }, ae.prototype.ireduce = function(X) {
      var fe = X, k;
      do
        this.split(fe, this.tmp), fe = this.imulK(fe), fe = fe.iadd(this.tmp), k = fe.bitLength();
      while (k > this.n);
      var p = k < this.n ? -1 : fe.ucmp(this.p);
      return p === 0 ? (fe.words[0] = 0, fe.length = 1) : p > 0 ? fe.isub(this.p) : fe.strip(), fe;
    }, ae.prototype.split = function(X, fe) {
      X.iushrn(this.n, 0, fe);
    }, ae.prototype.imulK = function(X) {
      return X.imul(this.k);
    };
    function me() {
      ae.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    m(me, ae), me.prototype.split = function(X, fe) {
      for (var k = 4194303, p = Math.min(X.length, 9), x = 0; x < p; x++)
        fe.words[x] = X.words[x];
      if (fe.length = p, X.length <= 9) {
        X.words[0] = 0, X.length = 1;
        return;
      }
      var S = X.words[9];
      for (fe.words[fe.length++] = S & k, x = 10; x < X.length; x++) {
        var B = X.words[x] | 0;
        X.words[x - 10] = (B & k) << 4 | S >>> 22, S = B;
      }
      S >>>= 22, X.words[x - 10] = S, S === 0 && X.length > 10 ? X.length -= 10 : X.length -= 9;
    }, me.prototype.imulK = function(X) {
      X.words[X.length] = 0, X.words[X.length + 1] = 0, X.length += 2;
      for (var fe = 0, k = 0; k < X.length; k++) {
        var p = X.words[k] | 0;
        fe += p * 977, X.words[k] = fe & 67108863, fe = p * 64 + (fe / 67108864 | 0);
      }
      return X.words[X.length - 1] === 0 && (X.length--, X.words[X.length - 1] === 0 && X.length--), X;
    };
    function ge() {
      ae.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    m(ge, ae);
    function we() {
      ae.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    m(we, ae);
    function Ee() {
      ae.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    m(Ee, ae), Ee.prototype.imulK = function(X) {
      for (var fe = 0, k = 0; k < X.length; k++) {
        var p = (X.words[k] | 0) * 19 + fe, x = p & 67108863;
        p >>>= 26, X.words[k] = x, fe = p;
      }
      return fe !== 0 && (X.words[X.length++] = fe), X;
    }, d._prime = function(X) {
      if (pe[X])
        return pe[X];
      var fe;
      if (X === "k256")
        fe = new me();
      else if (X === "p224")
        fe = new ge();
      else if (X === "p192")
        fe = new we();
      else if (X === "p25519")
        fe = new Ee();
      else
        throw new Error("Unknown prime " + X);
      return pe[X] = fe, fe;
    };
    function Te(Se) {
      if (typeof Se == "string") {
        var X = d._prime(Se);
        this.m = X.p, this.prime = X;
      } else
        h(Se.gtn(1), "modulus must be greater than 1"), this.m = Se, this.prime = null;
    }
    Te.prototype._verify1 = function(X) {
      h(X.negative === 0, "red works only with positives"), h(X.red, "red works only with red numbers");
    }, Te.prototype._verify2 = function(X, fe) {
      h((X.negative | fe.negative) === 0, "red works only with positives"), h(
        X.red && X.red === fe.red,
        "red works only with red numbers"
      );
    }, Te.prototype.imod = function(X) {
      return this.prime ? this.prime.ireduce(X)._forceRed(this) : X.umod(this.m)._forceRed(this);
    }, Te.prototype.neg = function(X) {
      return X.isZero() ? X.clone() : this.m.sub(X)._forceRed(this);
    }, Te.prototype.add = function(X, fe) {
      this._verify2(X, fe);
      var k = X.add(fe);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k._forceRed(this);
    }, Te.prototype.iadd = function(X, fe) {
      this._verify2(X, fe);
      var k = X.iadd(fe);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k;
    }, Te.prototype.sub = function(X, fe) {
      this._verify2(X, fe);
      var k = X.sub(fe);
      return k.cmpn(0) < 0 && k.iadd(this.m), k._forceRed(this);
    }, Te.prototype.isub = function(X, fe) {
      this._verify2(X, fe);
      var k = X.isub(fe);
      return k.cmpn(0) < 0 && k.iadd(this.m), k;
    }, Te.prototype.shl = function(X, fe) {
      return this._verify1(X), this.imod(X.ushln(fe));
    }, Te.prototype.imul = function(X, fe) {
      return this._verify2(X, fe), this.imod(X.imul(fe));
    }, Te.prototype.mul = function(X, fe) {
      return this._verify2(X, fe), this.imod(X.mul(fe));
    }, Te.prototype.isqr = function(X) {
      return this.imul(X, X.clone());
    }, Te.prototype.sqr = function(X) {
      return this.mul(X, X);
    }, Te.prototype.sqrt = function(X) {
      if (X.isZero())
        return X.clone();
      var fe = this.m.andln(3);
      if (h(fe % 2 === 1), fe === 3) {
        var k = this.m.add(new d(1)).iushrn(2);
        return this.pow(X, k);
      }
      for (var p = this.m.subn(1), x = 0; !p.isZero() && p.andln(1) === 0; )
        x++, p.iushrn(1);
      h(!p.isZero());
      var S = new d(1).toRed(this), B = S.redNeg(), L = this.m.subn(1).iushrn(1), C = this.m.bitLength();
      for (C = new d(2 * C * C).toRed(this); this.pow(C, L).cmp(B) !== 0; )
        C.redIAdd(B);
      for (var G = this.pow(C, p), R = this.pow(X, p.addn(1).iushrn(1)), y = this.pow(X, p), j = x; y.cmp(S) !== 0; ) {
        for (var ye = y, ee = 0; ye.cmp(S) !== 0; ee++)
          ye = ye.redSqr();
        h(ee < j);
        var xe = this.pow(G, new d(1).iushln(j - ee - 1));
        R = R.redMul(xe), G = xe.redSqr(), y = y.redMul(G), j = ee;
      }
      return R;
    }, Te.prototype.invm = function(X) {
      var fe = X._invmp(this.m);
      return fe.negative !== 0 ? (fe.negative = 0, this.imod(fe).redNeg()) : this.imod(fe);
    }, Te.prototype.pow = function(X, fe) {
      if (fe.isZero())
        return new d(1).toRed(this);
      if (fe.cmpn(1) === 0)
        return X.clone();
      var k = 4, p = new Array(1 << k);
      p[0] = new d(1).toRed(this), p[1] = X;
      for (var x = 2; x < p.length; x++)
        p[x] = this.mul(p[x - 1], X);
      var S = p[0], B = 0, L = 0, C = fe.bitLength() % 26;
      for (C === 0 && (C = 26), x = fe.length - 1; x >= 0; x--) {
        for (var G = fe.words[x], R = C - 1; R >= 0; R--) {
          var y = G >> R & 1;
          if (S !== p[0] && (S = this.sqr(S)), y === 0 && B === 0) {
            L = 0;
            continue;
          }
          B <<= 1, B |= y, L++, !(L !== k && (x !== 0 || R !== 0)) && (S = this.mul(S, p[B]), L = 0, B = 0);
        }
        C = 26;
      }
      return S;
    }, Te.prototype.convertTo = function(X) {
      var fe = X.umod(this.m);
      return fe === X ? fe.clone() : fe;
    }, Te.prototype.convertFrom = function(X) {
      var fe = X.clone();
      return fe.red = null, fe;
    }, d.mont = function(X) {
      return new Ke(X);
    };
    function Ke(Se) {
      Te.call(this, Se), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    m(Ke, Te), Ke.prototype.convertTo = function(X) {
      return this.imod(X.ushln(this.shift));
    }, Ke.prototype.convertFrom = function(X) {
      var fe = this.imod(X.mul(this.rinv));
      return fe.red = null, fe;
    }, Ke.prototype.imul = function(X, fe) {
      if (X.isZero() || fe.isZero())
        return X.words[0] = 0, X.length = 1, X;
      var k = X.imul(fe), p = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), x = k.isub(p).iushrn(this.shift), S = x;
      return x.cmp(this.m) >= 0 ? S = x.isub(this.m) : x.cmpn(0) < 0 && (S = x.iadd(this.m)), S._forceRed(this);
    }, Ke.prototype.mul = function(X, fe) {
      if (X.isZero() || fe.isZero())
        return new d(0)._forceRed(this);
      var k = X.mul(fe), p = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), x = k.isub(p).iushrn(this.shift), S = x;
      return x.cmp(this.m) >= 0 ? S = x.isub(this.m) : x.cmpn(0) < 0 && (S = x.iadd(this.m)), S._forceRed(this);
    }, Ke.prototype.invm = function(X) {
      var fe = this.imod(X._invmp(this.m).mul(this.r2));
      return fe._forceRed(this);
    };
  })(l, commonjsGlobal);
})(bn$3);
bn$3.exports;
var cjs$1 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(l, t) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(s, h) {
    s.__proto__ = h;
  } || function(s, h) {
    for (var m in h)
      h.hasOwnProperty(m) && (s[m] = h[m]);
  }, extendStatics(l, t);
};
function __extends$3(l, t) {
  extendStatics(l, t);
  function s() {
    this.constructor = l;
  }
  l.prototype = t === null ? Object.create(t) : (s.prototype = t.prototype, new s());
}
var __assign$1 = function() {
  return __assign$1 = Object.assign || function(t) {
    for (var s, h = 1, m = arguments.length; h < m; h++) {
      s = arguments[h];
      for (var d in s)
        Object.prototype.hasOwnProperty.call(s, d) && (t[d] = s[d]);
    }
    return t;
  }, __assign$1.apply(this, arguments);
};
function __rest(l, t) {
  var s = {};
  for (var h in l)
    Object.prototype.hasOwnProperty.call(l, h) && t.indexOf(h) < 0 && (s[h] = l[h]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var m = 0, h = Object.getOwnPropertySymbols(l); m < h.length; m++)
      t.indexOf(h[m]) < 0 && Object.prototype.propertyIsEnumerable.call(l, h[m]) && (s[h[m]] = l[h[m]]);
  return s;
}
function __decorate$1(l, t, s, h) {
  var m = arguments.length, d = m < 3 ? t : h === null ? h = Object.getOwnPropertyDescriptor(t, s) : h, v;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    d = Reflect.decorate(l, t, s, h);
  else
    for (var _ = l.length - 1; _ >= 0; _--)
      (v = l[_]) && (d = (m < 3 ? v(d) : m > 3 ? v(t, s, d) : v(t, s)) || d);
  return m > 3 && d && Object.defineProperty(t, s, d), d;
}
function __param(l, t) {
  return function(s, h) {
    t(s, h, l);
  };
}
function __metadata(l, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(l, t);
}
function __awaiter$6(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
}
function __generator(l, t) {
  var s = { label: 0, sent: function() {
    if (d[0] & 1)
      throw d[1];
    return d[1];
  }, trys: [], ops: [] }, h, m, d, v;
  return v = { next: _(0), throw: _(1), return: _(2) }, typeof Symbol == "function" && (v[Symbol.iterator] = function() {
    return this;
  }), v;
  function _(z) {
    return function(J) {
      return T([z, J]);
    };
  }
  function T(z) {
    if (h)
      throw new TypeError("Generator is already executing.");
    for (; s; )
      try {
        if (h = 1, m && (d = z[0] & 2 ? m.return : z[0] ? m.throw || ((d = m.return) && d.call(m), 0) : m.next) && !(d = d.call(m, z[1])).done)
          return d;
        switch (m = 0, d && (z = [z[0] & 2, d.value]), z[0]) {
          case 0:
          case 1:
            d = z;
            break;
          case 4:
            return s.label++, { value: z[1], done: !1 };
          case 5:
            s.label++, m = z[1], z = [0];
            continue;
          case 7:
            z = s.ops.pop(), s.trys.pop();
            continue;
          default:
            if (d = s.trys, !(d = d.length > 0 && d[d.length - 1]) && (z[0] === 6 || z[0] === 2)) {
              s = 0;
              continue;
            }
            if (z[0] === 3 && (!d || z[1] > d[0] && z[1] < d[3])) {
              s.label = z[1];
              break;
            }
            if (z[0] === 6 && s.label < d[1]) {
              s.label = d[1], d = z;
              break;
            }
            if (d && s.label < d[2]) {
              s.label = d[2], s.ops.push(z);
              break;
            }
            d[2] && s.ops.pop(), s.trys.pop();
            continue;
        }
        z = t.call(l, s);
      } catch (J) {
        z = [6, J], m = 0;
      } finally {
        h = d = 0;
      }
    if (z[0] & 5)
      throw z[1];
    return { value: z[0] ? z[1] : void 0, done: !0 };
  }
}
function __createBinding$2(l, t, s, h) {
  h === void 0 && (h = s), l[h] = t[s];
}
function __exportStar(l, t) {
  for (var s in l)
    s !== "default" && !t.hasOwnProperty(s) && (t[s] = l[s]);
}
function __values(l) {
  var t = typeof Symbol == "function" && Symbol.iterator, s = t && l[t], h = 0;
  if (s)
    return s.call(l);
  if (l && typeof l.length == "number")
    return {
      next: function() {
        return l && h >= l.length && (l = void 0), { value: l && l[h++], done: !l };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(l, t) {
  var s = typeof Symbol == "function" && l[Symbol.iterator];
  if (!s)
    return l;
  var h = s.call(l), m, d = [], v;
  try {
    for (; (t === void 0 || t-- > 0) && !(m = h.next()).done; )
      d.push(m.value);
  } catch (_) {
    v = { error: _ };
  } finally {
    try {
      m && !m.done && (s = h.return) && s.call(h);
    } finally {
      if (v)
        throw v.error;
    }
  }
  return d;
}
function __spread() {
  for (var l = [], t = 0; t < arguments.length; t++)
    l = l.concat(__read(arguments[t]));
  return l;
}
function __spreadArrays() {
  for (var l = 0, t = 0, s = arguments.length; t < s; t++)
    l += arguments[t].length;
  for (var h = Array(l), m = 0, t = 0; t < s; t++)
    for (var d = arguments[t], v = 0, _ = d.length; v < _; v++, m++)
      h[m] = d[v];
  return h;
}
function __await(l) {
  return this instanceof __await ? (this.v = l, this) : new __await(l);
}
function __asyncGenerator(l, t, s) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var h = s.apply(l, t || []), m, d = [];
  return m = {}, v("next"), v("throw"), v("return"), m[Symbol.asyncIterator] = function() {
    return this;
  }, m;
  function v(ie) {
    h[ie] && (m[ie] = function(ne) {
      return new Promise(function(de, ce) {
        d.push([ie, ne, de, ce]) > 1 || _(ie, ne);
      });
    });
  }
  function _(ie, ne) {
    try {
      T(h[ie](ne));
    } catch (de) {
      Y(d[0][3], de);
    }
  }
  function T(ie) {
    ie.value instanceof __await ? Promise.resolve(ie.value.v).then(z, J) : Y(d[0][2], ie);
  }
  function z(ie) {
    _("next", ie);
  }
  function J(ie) {
    _("throw", ie);
  }
  function Y(ie, ne) {
    ie(ne), d.shift(), d.length && _(d[0][0], d[0][1]);
  }
}
function __asyncDelegator(l) {
  var t, s;
  return t = {}, h("next"), h("throw", function(m) {
    throw m;
  }), h("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function h(m, d) {
    t[m] = l[m] ? function(v) {
      return (s = !s) ? { value: __await(l[m](v)), done: m === "return" } : d ? d(v) : v;
    } : d;
  }
}
function __asyncValues(l) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = l[Symbol.asyncIterator], s;
  return t ? t.call(l) : (l = typeof __values == "function" ? __values(l) : l[Symbol.iterator](), s = {}, h("next"), h("throw"), h("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s);
  function h(d) {
    s[d] = l[d] && function(v) {
      return new Promise(function(_, T) {
        v = l[d](v), m(_, T, v.done, v.value);
      });
    };
  }
  function m(d, v, _, T) {
    Promise.resolve(T).then(function(z) {
      d({ value: z, done: _ });
    }, v);
  }
}
function __makeTemplateObject(l, t) {
  return Object.defineProperty ? Object.defineProperty(l, "raw", { value: t }) : l.raw = t, l;
}
function __importStar$2(l) {
  if (l && l.__esModule)
    return l;
  var t = {};
  if (l != null)
    for (var s in l)
      Object.hasOwnProperty.call(l, s) && (t[s] = l[s]);
  return t.default = l, t;
}
function __importDefault$4(l) {
  return l && l.__esModule ? l : { default: l };
}
function __classPrivateFieldGet(l, t) {
  if (!t.has(l))
    throw new TypeError("attempted to get private field on non-instance");
  return t.get(l);
}
function __classPrivateFieldSet(l, t, s) {
  if (!t.has(l))
    throw new TypeError("attempted to set private field on non-instance");
  return t.set(l, s), s;
}
var tslib_es6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get __assign() {
    return __assign$1;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter: __awaiter$6,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding: __createBinding$2,
  __decorate: __decorate$1,
  __exportStar,
  __extends: __extends$3,
  __generator,
  __importDefault: __importDefault$4,
  __importStar: __importStar$2,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}), require$$0$4 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6), crypto$4 = {}, hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto)
    return crypto$4;
  hasRequiredCrypto = 1, Object.defineProperty(crypto$4, "__esModule", { value: !0 }), crypto$4.isBrowserCryptoAvailable = crypto$4.getSubtleCrypto = crypto$4.getBrowerCrypto = void 0;
  function l() {
    return (commonjsGlobal == null ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal == null ? void 0 : commonjsGlobal.msCrypto) || {};
  }
  crypto$4.getBrowerCrypto = l;
  function t() {
    const h = l();
    return h.subtle || h.webkitSubtle;
  }
  crypto$4.getSubtleCrypto = t;
  function s() {
    return !!l() && !!t();
  }
  return crypto$4.isBrowserCryptoAvailable = s, crypto$4;
}
var env$1 = {}, hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv)
    return env$1;
  hasRequiredEnv = 1, Object.defineProperty(env$1, "__esModule", { value: !0 }), env$1.isBrowser = env$1.isNode = env$1.isReactNative = void 0;
  function l() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  env$1.isReactNative = l;
  function t() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  env$1.isNode = t;
  function s() {
    return !l() && !t();
  }
  return env$1.isBrowser = s, env$1;
}
(function(l) {
  Object.defineProperty(l, "__esModule", { value: !0 });
  const t = require$$0$4;
  t.__exportStar(requireCrypto(), l), t.__exportStar(requireEnv(), l);
})(cjs$1);
var queryString = {}, strictUriEncode = (l) => encodeURIComponent(l).replace(/[!'()*]/g, (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`), token = "%[a-f0-9]{2}", singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi"), multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(l, t) {
  try {
    return [decodeURIComponent(l.join(""))];
  } catch {
  }
  if (l.length === 1)
    return l;
  t = t || 1;
  var s = l.slice(0, t), h = l.slice(t);
  return Array.prototype.concat.call([], decodeComponents(s), decodeComponents(h));
}
function decode$1(l) {
  try {
    return decodeURIComponent(l);
  } catch {
    for (var t = l.match(singleMatcher) || [], s = 1; s < t.length; s++)
      l = decodeComponents(t, s).join(""), t = l.match(singleMatcher) || [];
    return l;
  }
}
function customDecodeURIComponent(l) {
  for (var t = {
    "%FE%FF": "\uFFFD\uFFFD",
    "%FF%FE": "\uFFFD\uFFFD"
  }, s = multiMatcher.exec(l); s; ) {
    try {
      t[s[0]] = decodeURIComponent(s[0]);
    } catch {
      var h = decode$1(s[0]);
      h !== s[0] && (t[s[0]] = h);
    }
    s = multiMatcher.exec(l);
  }
  t["%C2"] = "\uFFFD";
  for (var m = Object.keys(t), d = 0; d < m.length; d++) {
    var v = m[d];
    l = l.replace(new RegExp(v, "g"), t[v]);
  }
  return l;
}
var decodeUriComponent = function(l) {
  if (typeof l != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof l + "`");
  try {
    return l = l.replace(/\+/g, " "), decodeURIComponent(l);
  } catch {
    return customDecodeURIComponent(l);
  }
}, splitOnFirst = (l, t) => {
  if (!(typeof l == "string" && typeof t == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (t === "")
    return [l];
  const s = l.indexOf(t);
  return s === -1 ? [l] : [
    l.slice(0, s),
    l.slice(s + t.length)
  ];
};
(function(l) {
  const t = strictUriEncode, s = decodeUriComponent, h = splitOnFirst, m = (re) => re == null;
  function d(re) {
    switch (re.arrayFormat) {
      case "index":
        return (oe) => (pe, ae) => {
          const me = pe.length;
          return ae === void 0 || re.skipNull && ae === null || re.skipEmptyString && ae === "" ? pe : ae === null ? [...pe, [T(oe, re), "[", me, "]"].join("")] : [
            ...pe,
            [T(oe, re), "[", T(me, re), "]=", T(ae, re)].join("")
          ];
        };
      case "bracket":
        return (oe) => (pe, ae) => ae === void 0 || re.skipNull && ae === null || re.skipEmptyString && ae === "" ? pe : ae === null ? [...pe, [T(oe, re), "[]"].join("")] : [...pe, [T(oe, re), "[]=", T(ae, re)].join("")];
      case "comma":
      case "separator":
        return (oe) => (pe, ae) => ae == null || ae.length === 0 ? pe : pe.length === 0 ? [[T(oe, re), "=", T(ae, re)].join("")] : [[pe, T(ae, re)].join(re.arrayFormatSeparator)];
      default:
        return (oe) => (pe, ae) => ae === void 0 || re.skipNull && ae === null || re.skipEmptyString && ae === "" ? pe : ae === null ? [...pe, T(oe, re)] : [...pe, [T(oe, re), "=", T(ae, re)].join("")];
    }
  }
  function v(re) {
    let oe;
    switch (re.arrayFormat) {
      case "index":
        return (pe, ae, me) => {
          if (oe = /\[(\d*)\]$/.exec(pe), pe = pe.replace(/\[\d*\]$/, ""), !oe) {
            me[pe] = ae;
            return;
          }
          me[pe] === void 0 && (me[pe] = {}), me[pe][oe[1]] = ae;
        };
      case "bracket":
        return (pe, ae, me) => {
          if (oe = /(\[\])$/.exec(pe), pe = pe.replace(/\[\]$/, ""), !oe) {
            me[pe] = ae;
            return;
          }
          if (me[pe] === void 0) {
            me[pe] = [ae];
            return;
          }
          me[pe] = [].concat(me[pe], ae);
        };
      case "comma":
      case "separator":
        return (pe, ae, me) => {
          const we = typeof ae == "string" && ae.split("").indexOf(re.arrayFormatSeparator) > -1 ? ae.split(re.arrayFormatSeparator).map((Ee) => z(Ee, re)) : ae === null ? ae : z(ae, re);
          me[pe] = we;
        };
      default:
        return (pe, ae, me) => {
          if (me[pe] === void 0) {
            me[pe] = ae;
            return;
          }
          me[pe] = [].concat(me[pe], ae);
        };
    }
  }
  function _(re) {
    if (typeof re != "string" || re.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function T(re, oe) {
    return oe.encode ? oe.strict ? t(re) : encodeURIComponent(re) : re;
  }
  function z(re, oe) {
    return oe.decode ? s(re) : re;
  }
  function J(re) {
    return Array.isArray(re) ? re.sort() : typeof re == "object" ? J(Object.keys(re)).sort((oe, pe) => Number(oe) - Number(pe)).map((oe) => re[oe]) : re;
  }
  function Y(re) {
    const oe = re.indexOf("#");
    return oe !== -1 && (re = re.slice(0, oe)), re;
  }
  function ie(re) {
    let oe = "";
    const pe = re.indexOf("#");
    return pe !== -1 && (oe = re.slice(pe)), oe;
  }
  function ne(re) {
    re = Y(re);
    const oe = re.indexOf("?");
    return oe === -1 ? "" : re.slice(oe + 1);
  }
  function de(re, oe) {
    return oe.parseNumbers && !Number.isNaN(Number(re)) && typeof re == "string" && re.trim() !== "" ? re = Number(re) : oe.parseBooleans && re !== null && (re.toLowerCase() === "true" || re.toLowerCase() === "false") && (re = re.toLowerCase() === "true"), re;
  }
  function ce(re, oe) {
    oe = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, oe), _(oe.arrayFormatSeparator);
    const pe = v(oe), ae = /* @__PURE__ */ Object.create(null);
    if (typeof re != "string" || (re = re.trim().replace(/^[?#&]/, ""), !re))
      return ae;
    for (const me of re.split("&")) {
      let [ge, we] = h(oe.decode ? me.replace(/\+/g, " ") : me, "=");
      we = we === void 0 ? null : ["comma", "separator"].includes(oe.arrayFormat) ? we : z(we, oe), pe(z(ge, oe), we, ae);
    }
    for (const me of Object.keys(ae)) {
      const ge = ae[me];
      if (typeof ge == "object" && ge !== null)
        for (const we of Object.keys(ge))
          ge[we] = de(ge[we], oe);
      else
        ae[me] = de(ge, oe);
    }
    return oe.sort === !1 ? ae : (oe.sort === !0 ? Object.keys(ae).sort() : Object.keys(ae).sort(oe.sort)).reduce((me, ge) => {
      const we = ae[ge];
      return Boolean(we) && typeof we == "object" && !Array.isArray(we) ? me[ge] = J(we) : me[ge] = we, me;
    }, /* @__PURE__ */ Object.create(null));
  }
  l.extract = ne, l.parse = ce, l.stringify = (re, oe) => {
    if (!re)
      return "";
    oe = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, oe), _(oe.arrayFormatSeparator);
    const pe = (we) => oe.skipNull && m(re[we]) || oe.skipEmptyString && re[we] === "", ae = d(oe), me = {};
    for (const we of Object.keys(re))
      pe(we) || (me[we] = re[we]);
    const ge = Object.keys(me);
    return oe.sort !== !1 && ge.sort(oe.sort), ge.map((we) => {
      const Ee = re[we];
      return Ee === void 0 ? "" : Ee === null ? T(we, oe) : Array.isArray(Ee) ? Ee.reduce(ae(we), []).join("&") : T(we, oe) + "=" + T(Ee, oe);
    }).filter((we) => we.length > 0).join("&");
  }, l.parseUrl = (re, oe) => {
    oe = Object.assign({
      decode: !0
    }, oe);
    const [pe, ae] = h(re, "#");
    return Object.assign(
      {
        url: pe.split("?")[0] || "",
        query: ce(ne(re), oe)
      },
      oe && oe.parseFragmentIdentifier && ae ? { fragmentIdentifier: z(ae, oe) } : {}
    );
  }, l.stringifyUrl = (re, oe) => {
    oe = Object.assign({
      encode: !0,
      strict: !0
    }, oe);
    const pe = Y(re.url).split("?")[0] || "", ae = l.extract(re.url), me = l.parse(ae, { sort: !1 }), ge = Object.assign(me, re.query);
    let we = l.stringify(ge, oe);
    we && (we = `?${we}`);
    let Ee = ie(re.url);
    return re.fragmentIdentifier && (Ee = `#${T(re.fragmentIdentifier, oe)}`), `${pe}${we}${Ee}`;
  };
})(queryString);
typeof global.WebSocket < "u" ? global.WebSocket : require("ws");
const alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
alphanumerical.split("").map((l) => `https://${l}.bridge.walletconnect.org`);
var browser$4 = {}, canPromise$1 = function() {
  return typeof Promise == "function" && Promise.prototype && Promise.prototype.then;
}, qrcode = {}, typedarrayBuffer = {}, toString = {}.toString, isarray = Array.isArray || function(l) {
  return toString.call(l) == "[object Array]";
}, isArray$1 = isarray;
function typedArraySupport() {
  try {
    var l = new Uint8Array(1);
    return l.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
      return 42;
    } }, l.foo() === 42;
  } catch {
    return !1;
  }
}
Buffer$2.TYPED_ARRAY_SUPPORT = typedArraySupport();
var K_MAX_LENGTH = Buffer$2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
function Buffer$2(l, t, s) {
  return !Buffer$2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$2) ? new Buffer$2(l, t, s) : typeof l == "number" ? allocUnsafe(this, l) : from(this, l, t, s);
}
Buffer$2.TYPED_ARRAY_SUPPORT && (Buffer$2.prototype.__proto__ = Uint8Array.prototype, Buffer$2.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && Buffer$2[Symbol.species] === Buffer$2 && Object.defineProperty(Buffer$2, Symbol.species, {
  value: null,
  configurable: !0,
  enumerable: !1,
  writable: !1
}));
function checked(l) {
  if (l >= K_MAX_LENGTH)
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
  return l | 0;
}
function isnan(l) {
  return l !== l;
}
function createBuffer(l, t) {
  var s;
  return Buffer$2.TYPED_ARRAY_SUPPORT ? (s = new Uint8Array(t), s.__proto__ = Buffer$2.prototype) : (s = l, s === null && (s = new Buffer$2(t)), s.length = t), s;
}
function allocUnsafe(l, t) {
  var s = createBuffer(l, t < 0 ? 0 : checked(t) | 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT)
    for (var h = 0; h < t; ++h)
      s[h] = 0;
  return s;
}
function fromString(l, t) {
  var s = byteLength$1(t) | 0, h = createBuffer(l, s), m = h.write(t);
  return m !== s && (h = h.slice(0, m)), h;
}
function fromArrayLike(l, t) {
  for (var s = t.length < 0 ? 0 : checked(t.length) | 0, h = createBuffer(l, s), m = 0; m < s; m += 1)
    h[m] = t[m] & 255;
  return h;
}
function fromArrayBuffer(l, t, s, h) {
  if (s < 0 || t.byteLength < s)
    throw new RangeError("'offset' is out of bounds");
  if (t.byteLength < s + (h || 0))
    throw new RangeError("'length' is out of bounds");
  var m;
  return s === void 0 && h === void 0 ? m = new Uint8Array(t) : h === void 0 ? m = new Uint8Array(t, s) : m = new Uint8Array(t, s, h), Buffer$2.TYPED_ARRAY_SUPPORT ? m.__proto__ = Buffer$2.prototype : m = fromArrayLike(l, m), m;
}
function fromObject(l, t) {
  if (Buffer$2.isBuffer(t)) {
    var s = checked(t.length) | 0, h = createBuffer(l, s);
    return h.length === 0 || t.copy(h, 0, 0, s), h;
  }
  if (t) {
    if (typeof ArrayBuffer < "u" && t.buffer instanceof ArrayBuffer || "length" in t)
      return typeof t.length != "number" || isnan(t.length) ? createBuffer(l, 0) : fromArrayLike(l, t);
    if (t.type === "Buffer" && Array.isArray(t.data))
      return fromArrayLike(l, t.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function utf8ToBytes$1(l, t) {
  t = t || 1 / 0;
  for (var s, h = l.length, m = null, d = [], v = 0; v < h; ++v) {
    if (s = l.charCodeAt(v), s > 55295 && s < 57344) {
      if (!m) {
        if (s > 56319) {
          (t -= 3) > -1 && d.push(239, 191, 189);
          continue;
        } else if (v + 1 === h) {
          (t -= 3) > -1 && d.push(239, 191, 189);
          continue;
        }
        m = s;
        continue;
      }
      if (s < 56320) {
        (t -= 3) > -1 && d.push(239, 191, 189), m = s;
        continue;
      }
      s = (m - 55296 << 10 | s - 56320) + 65536;
    } else
      m && (t -= 3) > -1 && d.push(239, 191, 189);
    if (m = null, s < 128) {
      if ((t -= 1) < 0)
        break;
      d.push(s);
    } else if (s < 2048) {
      if ((t -= 2) < 0)
        break;
      d.push(
        s >> 6 | 192,
        s & 63 | 128
      );
    } else if (s < 65536) {
      if ((t -= 3) < 0)
        break;
      d.push(
        s >> 12 | 224,
        s >> 6 & 63 | 128,
        s & 63 | 128
      );
    } else if (s < 1114112) {
      if ((t -= 4) < 0)
        break;
      d.push(
        s >> 18 | 240,
        s >> 12 & 63 | 128,
        s >> 6 & 63 | 128,
        s & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return d;
}
function byteLength$1(l) {
  if (Buffer$2.isBuffer(l))
    return l.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(l) || l instanceof ArrayBuffer))
    return l.byteLength;
  typeof l != "string" && (l = "" + l);
  var t = l.length;
  return t === 0 ? 0 : utf8ToBytes$1(l).length;
}
function blitBuffer(l, t, s, h) {
  for (var m = 0; m < h && !(m + s >= t.length || m >= l.length); ++m)
    t[m + s] = l[m];
  return m;
}
function utf8Write(l, t, s, h) {
  return blitBuffer(utf8ToBytes$1(t, l.length - s), l, s, h);
}
function from(l, t, s, h) {
  if (typeof t == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && t instanceof ArrayBuffer ? fromArrayBuffer(l, t, s, h) : typeof t == "string" ? fromString(l, t) : fromObject(l, t);
}
Buffer$2.prototype.write = function(t, s, h) {
  s === void 0 ? (h = this.length, s = 0) : h === void 0 && typeof s == "string" ? (h = this.length, s = 0) : isFinite(s) && (s = s | 0, isFinite(h) ? h = h | 0 : h = void 0);
  var m = this.length - s;
  if ((h === void 0 || h > m) && (h = m), t.length > 0 && (h < 0 || s < 0) || s > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  return utf8Write(this, t, s, h);
};
Buffer$2.prototype.slice = function(t, s) {
  var h = this.length;
  t = ~~t, s = s === void 0 ? h : ~~s, t < 0 ? (t += h, t < 0 && (t = 0)) : t > h && (t = h), s < 0 ? (s += h, s < 0 && (s = 0)) : s > h && (s = h), s < t && (s = t);
  var m;
  if (Buffer$2.TYPED_ARRAY_SUPPORT)
    m = this.subarray(t, s), m.__proto__ = Buffer$2.prototype;
  else {
    var d = s - t;
    m = new Buffer$2(d, void 0);
    for (var v = 0; v < d; ++v)
      m[v] = this[v + t];
  }
  return m;
};
Buffer$2.prototype.copy = function(t, s, h, m) {
  if (h || (h = 0), !m && m !== 0 && (m = this.length), s >= t.length && (s = t.length), s || (s = 0), m > 0 && m < h && (m = h), m === h || t.length === 0 || this.length === 0)
    return 0;
  if (s < 0)
    throw new RangeError("targetStart out of bounds");
  if (h < 0 || h >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (m < 0)
    throw new RangeError("sourceEnd out of bounds");
  m > this.length && (m = this.length), t.length - s < m - h && (m = t.length - s + h);
  var d = m - h, v;
  if (this === t && h < s && s < m)
    for (v = d - 1; v >= 0; --v)
      t[v + s] = this[v + h];
  else if (d < 1e3 || !Buffer$2.TYPED_ARRAY_SUPPORT)
    for (v = 0; v < d; ++v)
      t[v + s] = this[v + h];
  else
    Uint8Array.prototype.set.call(
      t,
      this.subarray(h, h + d),
      s
    );
  return d;
};
Buffer$2.prototype.fill = function(t, s, h) {
  if (typeof t == "string") {
    if (typeof s == "string" ? (s = 0, h = this.length) : typeof h == "string" && (h = this.length), t.length === 1) {
      var m = t.charCodeAt(0);
      m < 256 && (t = m);
    }
  } else
    typeof t == "number" && (t = t & 255);
  if (s < 0 || this.length < s || this.length < h)
    throw new RangeError("Out of range index");
  if (h <= s)
    return this;
  s = s >>> 0, h = h === void 0 ? this.length : h >>> 0, t || (t = 0);
  var d;
  if (typeof t == "number")
    for (d = s; d < h; ++d)
      this[d] = t;
  else {
    var v = Buffer$2.isBuffer(t) ? t : new Buffer$2(t), _ = v.length;
    for (d = 0; d < h - s; ++d)
      this[d + s] = v[d % _];
  }
  return this;
};
Buffer$2.concat = function(t, s) {
  if (!isArray$1(t))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (t.length === 0)
    return createBuffer(null, 0);
  var h;
  if (s === void 0)
    for (s = 0, h = 0; h < t.length; ++h)
      s += t[h].length;
  var m = allocUnsafe(null, s), d = 0;
  for (h = 0; h < t.length; ++h) {
    var v = t[h];
    if (!Buffer$2.isBuffer(v))
      throw new TypeError('"list" argument must be an Array of Buffers');
    v.copy(m, d), d += v.length;
  }
  return m;
};
Buffer$2.byteLength = byteLength$1;
Buffer$2.prototype._isBuffer = !0;
Buffer$2.isBuffer = function(t) {
  return !!(t != null && t._isBuffer);
};
typedarrayBuffer.alloc = function(l) {
  var t = new Buffer$2(l);
  return t.fill(0), t;
};
typedarrayBuffer.from = function(l) {
  return new Buffer$2(l);
};
var utils$5 = {}, toSJISFunction, CODEWORDS_COUNT = [
  0,
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
utils$5.getSymbolSize = function(t) {
  if (!t)
    throw new Error('"version" cannot be null or undefined');
  if (t < 1 || t > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return t * 4 + 17;
};
utils$5.getSymbolTotalCodewords = function(t) {
  return CODEWORDS_COUNT[t];
};
utils$5.getBCHDigit = function(l) {
  for (var t = 0; l !== 0; )
    t++, l >>>= 1;
  return t;
};
utils$5.setToSJISFunction = function(t) {
  if (typeof t != "function")
    throw new Error('"toSJISFunc" is not a valid function.');
  toSJISFunction = t;
};
utils$5.isKanjiModeEnabled = function() {
  return typeof toSJISFunction < "u";
};
utils$5.toSJIS = function(t) {
  return toSJISFunction(t);
};
var errorCorrectionLevel = {};
(function(l) {
  l.L = { bit: 1 }, l.M = { bit: 0 }, l.Q = { bit: 3 }, l.H = { bit: 2 };
  function t(s) {
    if (typeof s != "string")
      throw new Error("Param is not a string");
    var h = s.toLowerCase();
    switch (h) {
      case "l":
      case "low":
        return l.L;
      case "m":
      case "medium":
        return l.M;
      case "q":
      case "quartile":
        return l.Q;
      case "h":
      case "high":
        return l.H;
      default:
        throw new Error("Unknown EC Level: " + s);
    }
  }
  l.isValid = function(h) {
    return h && typeof h.bit < "u" && h.bit >= 0 && h.bit < 4;
  }, l.from = function(h, m) {
    if (l.isValid(h))
      return h;
    try {
      return t(h);
    } catch {
      return m;
    }
  };
})(errorCorrectionLevel);
function BitBuffer$1() {
  this.buffer = [], this.length = 0;
}
BitBuffer$1.prototype = {
  get: function(l) {
    var t = Math.floor(l / 8);
    return (this.buffer[t] >>> 7 - l % 8 & 1) === 1;
  },
  put: function(l, t) {
    for (var s = 0; s < t; s++)
      this.putBit((l >>> t - s - 1 & 1) === 1);
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(l) {
    var t = Math.floor(this.length / 8);
    this.buffer.length <= t && this.buffer.push(0), l && (this.buffer[t] |= 128 >>> this.length % 8), this.length++;
  }
};
var bitBuffer = BitBuffer$1, BufferUtil$4 = typedarrayBuffer;
function BitMatrix$1(l) {
  if (!l || l < 1)
    throw new Error("BitMatrix size must be defined and greater than 0");
  this.size = l, this.data = BufferUtil$4.alloc(l * l), this.reservedBit = BufferUtil$4.alloc(l * l);
}
BitMatrix$1.prototype.set = function(l, t, s, h) {
  var m = l * this.size + t;
  this.data[m] = s, h && (this.reservedBit[m] = !0);
};
BitMatrix$1.prototype.get = function(l, t) {
  return this.data[l * this.size + t];
};
BitMatrix$1.prototype.xor = function(l, t, s) {
  this.data[l * this.size + t] ^= s;
};
BitMatrix$1.prototype.isReserved = function(l, t) {
  return this.reservedBit[l * this.size + t];
};
var bitMatrix = BitMatrix$1, alignmentPattern = {};
(function(l) {
  var t = utils$5.getSymbolSize;
  l.getRowColCoords = function(h) {
    if (h === 1)
      return [];
    for (var m = Math.floor(h / 7) + 2, d = t(h), v = d === 145 ? 26 : Math.ceil((d - 13) / (2 * m - 2)) * 2, _ = [d - 7], T = 1; T < m - 1; T++)
      _[T] = _[T - 1] - v;
    return _.push(6), _.reverse();
  }, l.getPositions = function(h) {
    for (var m = [], d = l.getRowColCoords(h), v = d.length, _ = 0; _ < v; _++)
      for (var T = 0; T < v; T++)
        _ === 0 && T === 0 || _ === 0 && T === v - 1 || _ === v - 1 && T === 0 || m.push([d[_], d[T]]);
    return m;
  };
})(alignmentPattern);
var finderPattern = {}, getSymbolSize = utils$5.getSymbolSize, FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function(t) {
  var s = getSymbolSize(t);
  return [
    [0, 0],
    [s - FINDER_PATTERN_SIZE, 0],
    [0, s - FINDER_PATTERN_SIZE]
  ];
};
var maskPattern = {};
(function(l) {
  l.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  var t = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  l.isValid = function(m) {
    return m != null && m !== "" && !isNaN(m) && m >= 0 && m <= 7;
  }, l.from = function(m) {
    return l.isValid(m) ? parseInt(m, 10) : void 0;
  }, l.getPenaltyN1 = function(m) {
    for (var d = m.size, v = 0, _ = 0, T = 0, z = null, J = null, Y = 0; Y < d; Y++) {
      _ = T = 0, z = J = null;
      for (var ie = 0; ie < d; ie++) {
        var ne = m.get(Y, ie);
        ne === z ? _++ : (_ >= 5 && (v += t.N1 + (_ - 5)), z = ne, _ = 1), ne = m.get(ie, Y), ne === J ? T++ : (T >= 5 && (v += t.N1 + (T - 5)), J = ne, T = 1);
      }
      _ >= 5 && (v += t.N1 + (_ - 5)), T >= 5 && (v += t.N1 + (T - 5));
    }
    return v;
  }, l.getPenaltyN2 = function(m) {
    for (var d = m.size, v = 0, _ = 0; _ < d - 1; _++)
      for (var T = 0; T < d - 1; T++) {
        var z = m.get(_, T) + m.get(_, T + 1) + m.get(_ + 1, T) + m.get(_ + 1, T + 1);
        (z === 4 || z === 0) && v++;
      }
    return v * t.N2;
  }, l.getPenaltyN3 = function(m) {
    for (var d = m.size, v = 0, _ = 0, T = 0, z = 0; z < d; z++) {
      _ = T = 0;
      for (var J = 0; J < d; J++)
        _ = _ << 1 & 2047 | m.get(z, J), J >= 10 && (_ === 1488 || _ === 93) && v++, T = T << 1 & 2047 | m.get(J, z), J >= 10 && (T === 1488 || T === 93) && v++;
    }
    return v * t.N3;
  }, l.getPenaltyN4 = function(m) {
    for (var d = 0, v = m.data.length, _ = 0; _ < v; _++)
      d += m.data[_];
    var T = Math.abs(Math.ceil(d * 100 / v / 5) - 10);
    return T * t.N4;
  };
  function s(h, m, d) {
    switch (h) {
      case l.Patterns.PATTERN000:
        return (m + d) % 2 === 0;
      case l.Patterns.PATTERN001:
        return m % 2 === 0;
      case l.Patterns.PATTERN010:
        return d % 3 === 0;
      case l.Patterns.PATTERN011:
        return (m + d) % 3 === 0;
      case l.Patterns.PATTERN100:
        return (Math.floor(m / 2) + Math.floor(d / 3)) % 2 === 0;
      case l.Patterns.PATTERN101:
        return m * d % 2 + m * d % 3 === 0;
      case l.Patterns.PATTERN110:
        return (m * d % 2 + m * d % 3) % 2 === 0;
      case l.Patterns.PATTERN111:
        return (m * d % 3 + (m + d) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + h);
    }
  }
  l.applyMask = function(m, d) {
    for (var v = d.size, _ = 0; _ < v; _++)
      for (var T = 0; T < v; T++)
        d.isReserved(T, _) || d.xor(T, _, s(m, T, _));
  }, l.getBestMask = function(m, d) {
    for (var v = Object.keys(l.Patterns).length, _ = 0, T = 1 / 0, z = 0; z < v; z++) {
      d(z), l.applyMask(z, m);
      var J = l.getPenaltyN1(m) + l.getPenaltyN2(m) + l.getPenaltyN3(m) + l.getPenaltyN4(m);
      l.applyMask(z, m), J < T && (T = J, _ = z);
    }
    return _;
  };
})(maskPattern);
var errorCorrectionCode = {}, ECLevel$1 = errorCorrectionLevel, EC_BLOCKS_TABLE = [
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
], EC_CODEWORDS_TABLE = [
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
errorCorrectionCode.getBlocksCount = function(t, s) {
  switch (s) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(t - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(t - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(t - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(t - 1) * 4 + 3];
    default:
      return;
  }
};
errorCorrectionCode.getTotalCodewordsCount = function(t, s) {
  switch (s) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(t - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(t - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(t - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(t - 1) * 4 + 3];
    default:
      return;
  }
};
var polynomial = {}, galoisField = {}, BufferUtil$3 = typedarrayBuffer, EXP_TABLE = BufferUtil$3.alloc(512), LOG_TABLE = BufferUtil$3.alloc(256);
(function() {
  for (var t = 1, s = 0; s < 255; s++)
    EXP_TABLE[s] = t, LOG_TABLE[t] = s, t <<= 1, t & 256 && (t ^= 285);
  for (s = 255; s < 512; s++)
    EXP_TABLE[s] = EXP_TABLE[s - 255];
})();
galoisField.log = function(t) {
  if (t < 1)
    throw new Error("log(" + t + ")");
  return LOG_TABLE[t];
};
galoisField.exp = function(t) {
  return EXP_TABLE[t];
};
galoisField.mul = function(t, s) {
  return t === 0 || s === 0 ? 0 : EXP_TABLE[LOG_TABLE[t] + LOG_TABLE[s]];
};
(function(l) {
  var t = typedarrayBuffer, s = galoisField;
  l.mul = function(m, d) {
    for (var v = t.alloc(m.length + d.length - 1), _ = 0; _ < m.length; _++)
      for (var T = 0; T < d.length; T++)
        v[_ + T] ^= s.mul(m[_], d[T]);
    return v;
  }, l.mod = function(m, d) {
    for (var v = t.from(m); v.length - d.length >= 0; ) {
      for (var _ = v[0], T = 0; T < d.length; T++)
        v[T] ^= s.mul(d[T], _);
      for (var z = 0; z < v.length && v[z] === 0; )
        z++;
      v = v.slice(z);
    }
    return v;
  }, l.generateECPolynomial = function(m) {
    for (var d = t.from([1]), v = 0; v < m; v++)
      d = l.mul(d, [1, s.exp(v)]);
    return d;
  };
})(polynomial);
var buffer$2 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$3 = 0, len = code.length; i$3 < len; ++i$3)
  lookup[i$3] = code[i$3], revLookup[code.charCodeAt(i$3)] = i$3;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(l) {
  var t = l.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var s = l.indexOf("=");
  s === -1 && (s = t);
  var h = s === t ? 0 : 4 - s % 4;
  return [s, h];
}
function byteLength(l) {
  var t = getLens(l), s = t[0], h = t[1];
  return (s + h) * 3 / 4 - h;
}
function _byteLength(l, t, s) {
  return (t + s) * 3 / 4 - s;
}
function toByteArray(l) {
  var t, s = getLens(l), h = s[0], m = s[1], d = new Arr(_byteLength(l, h, m)), v = 0, _ = m > 0 ? h - 4 : h, T;
  for (T = 0; T < _; T += 4)
    t = revLookup[l.charCodeAt(T)] << 18 | revLookup[l.charCodeAt(T + 1)] << 12 | revLookup[l.charCodeAt(T + 2)] << 6 | revLookup[l.charCodeAt(T + 3)], d[v++] = t >> 16 & 255, d[v++] = t >> 8 & 255, d[v++] = t & 255;
  return m === 2 && (t = revLookup[l.charCodeAt(T)] << 2 | revLookup[l.charCodeAt(T + 1)] >> 4, d[v++] = t & 255), m === 1 && (t = revLookup[l.charCodeAt(T)] << 10 | revLookup[l.charCodeAt(T + 1)] << 4 | revLookup[l.charCodeAt(T + 2)] >> 2, d[v++] = t >> 8 & 255, d[v++] = t & 255), d;
}
function tripletToBase64(l) {
  return lookup[l >> 18 & 63] + lookup[l >> 12 & 63] + lookup[l >> 6 & 63] + lookup[l & 63];
}
function encodeChunk(l, t, s) {
  for (var h, m = [], d = t; d < s; d += 3)
    h = (l[d] << 16 & 16711680) + (l[d + 1] << 8 & 65280) + (l[d + 2] & 255), m.push(tripletToBase64(h));
  return m.join("");
}
function fromByteArray(l) {
  for (var t, s = l.length, h = s % 3, m = [], d = 16383, v = 0, _ = s - h; v < _; v += d)
    m.push(encodeChunk(l, v, v + d > _ ? _ : v + d));
  return h === 1 ? (t = l[s - 1], m.push(
    lookup[t >> 2] + lookup[t << 4 & 63] + "=="
  )) : h === 2 && (t = (l[s - 2] << 8) + l[s - 1], m.push(
    lookup[t >> 10] + lookup[t >> 4 & 63] + lookup[t << 2 & 63] + "="
  )), m.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(l, t, s, h, m) {
  var d, v, _ = m * 8 - h - 1, T = (1 << _) - 1, z = T >> 1, J = -7, Y = s ? m - 1 : 0, ie = s ? -1 : 1, ne = l[t + Y];
  for (Y += ie, d = ne & (1 << -J) - 1, ne >>= -J, J += _; J > 0; d = d * 256 + l[t + Y], Y += ie, J -= 8)
    ;
  for (v = d & (1 << -J) - 1, d >>= -J, J += h; J > 0; v = v * 256 + l[t + Y], Y += ie, J -= 8)
    ;
  if (d === 0)
    d = 1 - z;
  else {
    if (d === T)
      return v ? NaN : (ne ? -1 : 1) * (1 / 0);
    v = v + Math.pow(2, h), d = d - z;
  }
  return (ne ? -1 : 1) * v * Math.pow(2, d - h);
};
ieee754.write = function(l, t, s, h, m, d) {
  var v, _, T, z = d * 8 - m - 1, J = (1 << z) - 1, Y = J >> 1, ie = m === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ne = h ? 0 : d - 1, de = h ? 1 : -1, ce = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (_ = isNaN(t) ? 1 : 0, v = J) : (v = Math.floor(Math.log(t) / Math.LN2), t * (T = Math.pow(2, -v)) < 1 && (v--, T *= 2), v + Y >= 1 ? t += ie / T : t += ie * Math.pow(2, 1 - Y), t * T >= 2 && (v++, T /= 2), v + Y >= J ? (_ = 0, v = J) : v + Y >= 1 ? (_ = (t * T - 1) * Math.pow(2, m), v = v + Y) : (_ = t * Math.pow(2, Y - 1) * Math.pow(2, m), v = 0)); m >= 8; l[s + ne] = _ & 255, ne += de, _ /= 256, m -= 8)
    ;
  for (v = v << m | _, z += m; z > 0; l[s + ne] = v & 255, ne += de, v /= 256, z -= 8)
    ;
  l[s + ne - de] |= ce * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(l) {
  var t = base64Js, s = ieee754, h = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  l.Buffer = _, l.SlowBuffer = pe, l.INSPECT_MAX_BYTES = 50;
  var m = 2147483647;
  l.kMaxLength = m, _.TYPED_ARRAY_SUPPORT = d(), !_.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function d() {
    try {
      var Ie = new Uint8Array(1), ue = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(ue, Uint8Array.prototype), Object.setPrototypeOf(Ie, ue), Ie.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(_.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (!!_.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(_.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (!!_.isBuffer(this))
        return this.byteOffset;
    }
  });
  function v(Ie) {
    if (Ie > m)
      throw new RangeError('The value "' + Ie + '" is invalid for option "size"');
    var ue = new Uint8Array(Ie);
    return Object.setPrototypeOf(ue, _.prototype), ue;
  }
  function _(Ie, ue, he) {
    if (typeof Ie == "number") {
      if (typeof ue == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Y(Ie);
    }
    return T(Ie, ue, he);
  }
  _.poolSize = 8192;
  function T(Ie, ue, he) {
    if (typeof Ie == "string")
      return ie(Ie, ue);
    if (ArrayBuffer.isView(Ie))
      return de(Ie);
    if (Ie == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ie
      );
    if (wt(Ie, ArrayBuffer) || Ie && wt(Ie.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (wt(Ie, SharedArrayBuffer) || Ie && wt(Ie.buffer, SharedArrayBuffer)))
      return ce(Ie, ue, he);
    if (typeof Ie == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var Ne = Ie.valueOf && Ie.valueOf();
    if (Ne != null && Ne !== Ie)
      return _.from(Ne, ue, he);
    var Be = re(Ie);
    if (Be)
      return Be;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Ie[Symbol.toPrimitive] == "function")
      return _.from(
        Ie[Symbol.toPrimitive]("string"),
        ue,
        he
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ie
    );
  }
  _.from = function(Ie, ue, he) {
    return T(Ie, ue, he);
  }, Object.setPrototypeOf(_.prototype, Uint8Array.prototype), Object.setPrototypeOf(_, Uint8Array);
  function z(Ie) {
    if (typeof Ie != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Ie < 0)
      throw new RangeError('The value "' + Ie + '" is invalid for option "size"');
  }
  function J(Ie, ue, he) {
    return z(Ie), Ie <= 0 ? v(Ie) : ue !== void 0 ? typeof he == "string" ? v(Ie).fill(ue, he) : v(Ie).fill(ue) : v(Ie);
  }
  _.alloc = function(Ie, ue, he) {
    return J(Ie, ue, he);
  };
  function Y(Ie) {
    return z(Ie), v(Ie < 0 ? 0 : oe(Ie) | 0);
  }
  _.allocUnsafe = function(Ie) {
    return Y(Ie);
  }, _.allocUnsafeSlow = function(Ie) {
    return Y(Ie);
  };
  function ie(Ie, ue) {
    if ((typeof ue != "string" || ue === "") && (ue = "utf8"), !_.isEncoding(ue))
      throw new TypeError("Unknown encoding: " + ue);
    var he = ae(Ie, ue) | 0, Ne = v(he), Be = Ne.write(Ie, ue);
    return Be !== he && (Ne = Ne.slice(0, Be)), Ne;
  }
  function ne(Ie) {
    for (var ue = Ie.length < 0 ? 0 : oe(Ie.length) | 0, he = v(ue), Ne = 0; Ne < ue; Ne += 1)
      he[Ne] = Ie[Ne] & 255;
    return he;
  }
  function de(Ie) {
    if (wt(Ie, Uint8Array)) {
      var ue = new Uint8Array(Ie);
      return ce(ue.buffer, ue.byteOffset, ue.byteLength);
    }
    return ne(Ie);
  }
  function ce(Ie, ue, he) {
    if (ue < 0 || Ie.byteLength < ue)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Ie.byteLength < ue + (he || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var Ne;
    return ue === void 0 && he === void 0 ? Ne = new Uint8Array(Ie) : he === void 0 ? Ne = new Uint8Array(Ie, ue) : Ne = new Uint8Array(Ie, ue, he), Object.setPrototypeOf(Ne, _.prototype), Ne;
  }
  function re(Ie) {
    if (_.isBuffer(Ie)) {
      var ue = oe(Ie.length) | 0, he = v(ue);
      return he.length === 0 || Ie.copy(he, 0, 0, ue), he;
    }
    if (Ie.length !== void 0)
      return typeof Ie.length != "number" || He(Ie.length) ? v(0) : ne(Ie);
    if (Ie.type === "Buffer" && Array.isArray(Ie.data))
      return ne(Ie.data);
  }
  function oe(Ie) {
    if (Ie >= m)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + m.toString(16) + " bytes");
    return Ie | 0;
  }
  function pe(Ie) {
    return +Ie != Ie && (Ie = 0), _.alloc(+Ie);
  }
  _.isBuffer = function(ue) {
    return ue != null && ue._isBuffer === !0 && ue !== _.prototype;
  }, _.compare = function(ue, he) {
    if (wt(ue, Uint8Array) && (ue = _.from(ue, ue.offset, ue.byteLength)), wt(he, Uint8Array) && (he = _.from(he, he.offset, he.byteLength)), !_.isBuffer(ue) || !_.isBuffer(he))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (ue === he)
      return 0;
    for (var Ne = ue.length, Be = he.length, Oe = 0, it = Math.min(Ne, Be); Oe < it; ++Oe)
      if (ue[Oe] !== he[Oe]) {
        Ne = ue[Oe], Be = he[Oe];
        break;
      }
    return Ne < Be ? -1 : Be < Ne ? 1 : 0;
  }, _.isEncoding = function(ue) {
    switch (String(ue).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, _.concat = function(ue, he) {
    if (!Array.isArray(ue))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (ue.length === 0)
      return _.alloc(0);
    var Ne;
    if (he === void 0)
      for (he = 0, Ne = 0; Ne < ue.length; ++Ne)
        he += ue[Ne].length;
    var Be = _.allocUnsafe(he), Oe = 0;
    for (Ne = 0; Ne < ue.length; ++Ne) {
      var it = ue[Ne];
      if (wt(it, Uint8Array))
        Oe + it.length > Be.length ? _.from(it).copy(Be, Oe) : Uint8Array.prototype.set.call(
          Be,
          it,
          Oe
        );
      else if (_.isBuffer(it))
        it.copy(Be, Oe);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Oe += it.length;
    }
    return Be;
  };
  function ae(Ie, ue) {
    if (_.isBuffer(Ie))
      return Ie.length;
    if (ArrayBuffer.isView(Ie) || wt(Ie, ArrayBuffer))
      return Ie.byteLength;
    if (typeof Ie != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Ie
      );
    var he = Ie.length, Ne = arguments.length > 2 && arguments[2] === !0;
    if (!Ne && he === 0)
      return 0;
    for (var Be = !1; ; )
      switch (ue) {
        case "ascii":
        case "latin1":
        case "binary":
          return he;
        case "utf8":
        case "utf-8":
          return ke(Ie).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return he * 2;
        case "hex":
          return he >>> 1;
        case "base64":
          return Ue(Ie).length;
        default:
          if (Be)
            return Ne ? -1 : ke(Ie).length;
          ue = ("" + ue).toLowerCase(), Be = !0;
      }
  }
  _.byteLength = ae;
  function me(Ie, ue, he) {
    var Ne = !1;
    if ((ue === void 0 || ue < 0) && (ue = 0), ue > this.length || ((he === void 0 || he > this.length) && (he = this.length), he <= 0) || (he >>>= 0, ue >>>= 0, he <= ue))
      return "";
    for (Ie || (Ie = "utf8"); ; )
      switch (Ie) {
        case "hex":
          return C(this, ue, he);
        case "utf8":
        case "utf-8":
          return p(this, ue, he);
        case "ascii":
          return B(this, ue, he);
        case "latin1":
        case "binary":
          return L(this, ue, he);
        case "base64":
          return k(this, ue, he);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return G(this, ue, he);
        default:
          if (Ne)
            throw new TypeError("Unknown encoding: " + Ie);
          Ie = (Ie + "").toLowerCase(), Ne = !0;
      }
  }
  _.prototype._isBuffer = !0;
  function ge(Ie, ue, he) {
    var Ne = Ie[ue];
    Ie[ue] = Ie[he], Ie[he] = Ne;
  }
  _.prototype.swap16 = function() {
    var ue = this.length;
    if (ue % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var he = 0; he < ue; he += 2)
      ge(this, he, he + 1);
    return this;
  }, _.prototype.swap32 = function() {
    var ue = this.length;
    if (ue % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var he = 0; he < ue; he += 4)
      ge(this, he, he + 3), ge(this, he + 1, he + 2);
    return this;
  }, _.prototype.swap64 = function() {
    var ue = this.length;
    if (ue % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var he = 0; he < ue; he += 8)
      ge(this, he, he + 7), ge(this, he + 1, he + 6), ge(this, he + 2, he + 5), ge(this, he + 3, he + 4);
    return this;
  }, _.prototype.toString = function() {
    var ue = this.length;
    return ue === 0 ? "" : arguments.length === 0 ? p(this, 0, ue) : me.apply(this, arguments);
  }, _.prototype.toLocaleString = _.prototype.toString, _.prototype.equals = function(ue) {
    if (!_.isBuffer(ue))
      throw new TypeError("Argument must be a Buffer");
    return this === ue ? !0 : _.compare(this, ue) === 0;
  }, _.prototype.inspect = function() {
    var ue = "", he = l.INSPECT_MAX_BYTES;
    return ue = this.toString("hex", 0, he).replace(/(.{2})/g, "$1 ").trim(), this.length > he && (ue += " ... "), "<Buffer " + ue + ">";
  }, h && (_.prototype[h] = _.prototype.inspect), _.prototype.compare = function(ue, he, Ne, Be, Oe) {
    if (wt(ue, Uint8Array) && (ue = _.from(ue, ue.offset, ue.byteLength)), !_.isBuffer(ue))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ue
      );
    if (he === void 0 && (he = 0), Ne === void 0 && (Ne = ue ? ue.length : 0), Be === void 0 && (Be = 0), Oe === void 0 && (Oe = this.length), he < 0 || Ne > ue.length || Be < 0 || Oe > this.length)
      throw new RangeError("out of range index");
    if (Be >= Oe && he >= Ne)
      return 0;
    if (Be >= Oe)
      return -1;
    if (he >= Ne)
      return 1;
    if (he >>>= 0, Ne >>>= 0, Be >>>= 0, Oe >>>= 0, this === ue)
      return 0;
    for (var it = Oe - Be, Ve = Ne - he, Ye = Math.min(it, Ve), Pt = this.slice(Be, Oe), et = ue.slice(he, Ne), Q = 0; Q < Ye; ++Q)
      if (Pt[Q] !== et[Q]) {
        it = Pt[Q], Ve = et[Q];
        break;
      }
    return it < Ve ? -1 : Ve < it ? 1 : 0;
  };
  function we(Ie, ue, he, Ne, Be) {
    if (Ie.length === 0)
      return -1;
    if (typeof he == "string" ? (Ne = he, he = 0) : he > 2147483647 ? he = 2147483647 : he < -2147483648 && (he = -2147483648), he = +he, He(he) && (he = Be ? 0 : Ie.length - 1), he < 0 && (he = Ie.length + he), he >= Ie.length) {
      if (Be)
        return -1;
      he = Ie.length - 1;
    } else if (he < 0)
      if (Be)
        he = 0;
      else
        return -1;
    if (typeof ue == "string" && (ue = _.from(ue, Ne)), _.isBuffer(ue))
      return ue.length === 0 ? -1 : Ee(Ie, ue, he, Ne, Be);
    if (typeof ue == "number")
      return ue = ue & 255, typeof Uint8Array.prototype.indexOf == "function" ? Be ? Uint8Array.prototype.indexOf.call(Ie, ue, he) : Uint8Array.prototype.lastIndexOf.call(Ie, ue, he) : Ee(Ie, [ue], he, Ne, Be);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Ee(Ie, ue, he, Ne, Be) {
    var Oe = 1, it = Ie.length, Ve = ue.length;
    if (Ne !== void 0 && (Ne = String(Ne).toLowerCase(), Ne === "ucs2" || Ne === "ucs-2" || Ne === "utf16le" || Ne === "utf-16le")) {
      if (Ie.length < 2 || ue.length < 2)
        return -1;
      Oe = 2, it /= 2, Ve /= 2, he /= 2;
    }
    function Ye(V, se) {
      return Oe === 1 ? V[se] : V.readUInt16BE(se * Oe);
    }
    var Pt;
    if (Be) {
      var et = -1;
      for (Pt = he; Pt < it; Pt++)
        if (Ye(Ie, Pt) === Ye(ue, et === -1 ? 0 : Pt - et)) {
          if (et === -1 && (et = Pt), Pt - et + 1 === Ve)
            return et * Oe;
        } else
          et !== -1 && (Pt -= Pt - et), et = -1;
    } else
      for (he + Ve > it && (he = it - Ve), Pt = he; Pt >= 0; Pt--) {
        for (var Q = !0, W = 0; W < Ve; W++)
          if (Ye(Ie, Pt + W) !== Ye(ue, W)) {
            Q = !1;
            break;
          }
        if (Q)
          return Pt;
      }
    return -1;
  }
  _.prototype.includes = function(ue, he, Ne) {
    return this.indexOf(ue, he, Ne) !== -1;
  }, _.prototype.indexOf = function(ue, he, Ne) {
    return we(this, ue, he, Ne, !0);
  }, _.prototype.lastIndexOf = function(ue, he, Ne) {
    return we(this, ue, he, Ne, !1);
  };
  function Te(Ie, ue, he, Ne) {
    he = Number(he) || 0;
    var Be = Ie.length - he;
    Ne ? (Ne = Number(Ne), Ne > Be && (Ne = Be)) : Ne = Be;
    var Oe = ue.length;
    Ne > Oe / 2 && (Ne = Oe / 2);
    for (var it = 0; it < Ne; ++it) {
      var Ve = parseInt(ue.substr(it * 2, 2), 16);
      if (He(Ve))
        return it;
      Ie[he + it] = Ve;
    }
    return it;
  }
  function Ke(Ie, ue, he, Ne) {
    return De(ke(ue, Ie.length - he), Ie, he, Ne);
  }
  function Se(Ie, ue, he, Ne) {
    return De(Ce(ue), Ie, he, Ne);
  }
  function X(Ie, ue, he, Ne) {
    return De(Ue(ue), Ie, he, Ne);
  }
  function fe(Ie, ue, he, Ne) {
    return De(ht(ue, Ie.length - he), Ie, he, Ne);
  }
  _.prototype.write = function(ue, he, Ne, Be) {
    if (he === void 0)
      Be = "utf8", Ne = this.length, he = 0;
    else if (Ne === void 0 && typeof he == "string")
      Be = he, Ne = this.length, he = 0;
    else if (isFinite(he))
      he = he >>> 0, isFinite(Ne) ? (Ne = Ne >>> 0, Be === void 0 && (Be = "utf8")) : (Be = Ne, Ne = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var Oe = this.length - he;
    if ((Ne === void 0 || Ne > Oe) && (Ne = Oe), ue.length > 0 && (Ne < 0 || he < 0) || he > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Be || (Be = "utf8");
    for (var it = !1; ; )
      switch (Be) {
        case "hex":
          return Te(this, ue, he, Ne);
        case "utf8":
        case "utf-8":
          return Ke(this, ue, he, Ne);
        case "ascii":
        case "latin1":
        case "binary":
          return Se(this, ue, he, Ne);
        case "base64":
          return X(this, ue, he, Ne);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return fe(this, ue, he, Ne);
        default:
          if (it)
            throw new TypeError("Unknown encoding: " + Be);
          Be = ("" + Be).toLowerCase(), it = !0;
      }
  }, _.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function k(Ie, ue, he) {
    return ue === 0 && he === Ie.length ? t.fromByteArray(Ie) : t.fromByteArray(Ie.slice(ue, he));
  }
  function p(Ie, ue, he) {
    he = Math.min(Ie.length, he);
    for (var Ne = [], Be = ue; Be < he; ) {
      var Oe = Ie[Be], it = null, Ve = Oe > 239 ? 4 : Oe > 223 ? 3 : Oe > 191 ? 2 : 1;
      if (Be + Ve <= he) {
        var Ye, Pt, et, Q;
        switch (Ve) {
          case 1:
            Oe < 128 && (it = Oe);
            break;
          case 2:
            Ye = Ie[Be + 1], (Ye & 192) === 128 && (Q = (Oe & 31) << 6 | Ye & 63, Q > 127 && (it = Q));
            break;
          case 3:
            Ye = Ie[Be + 1], Pt = Ie[Be + 2], (Ye & 192) === 128 && (Pt & 192) === 128 && (Q = (Oe & 15) << 12 | (Ye & 63) << 6 | Pt & 63, Q > 2047 && (Q < 55296 || Q > 57343) && (it = Q));
            break;
          case 4:
            Ye = Ie[Be + 1], Pt = Ie[Be + 2], et = Ie[Be + 3], (Ye & 192) === 128 && (Pt & 192) === 128 && (et & 192) === 128 && (Q = (Oe & 15) << 18 | (Ye & 63) << 12 | (Pt & 63) << 6 | et & 63, Q > 65535 && Q < 1114112 && (it = Q));
        }
      }
      it === null ? (it = 65533, Ve = 1) : it > 65535 && (it -= 65536, Ne.push(it >>> 10 & 1023 | 55296), it = 56320 | it & 1023), Ne.push(it), Be += Ve;
    }
    return S(Ne);
  }
  var x = 4096;
  function S(Ie) {
    var ue = Ie.length;
    if (ue <= x)
      return String.fromCharCode.apply(String, Ie);
    for (var he = "", Ne = 0; Ne < ue; )
      he += String.fromCharCode.apply(
        String,
        Ie.slice(Ne, Ne += x)
      );
    return he;
  }
  function B(Ie, ue, he) {
    var Ne = "";
    he = Math.min(Ie.length, he);
    for (var Be = ue; Be < he; ++Be)
      Ne += String.fromCharCode(Ie[Be] & 127);
    return Ne;
  }
  function L(Ie, ue, he) {
    var Ne = "";
    he = Math.min(Ie.length, he);
    for (var Be = ue; Be < he; ++Be)
      Ne += String.fromCharCode(Ie[Be]);
    return Ne;
  }
  function C(Ie, ue, he) {
    var Ne = Ie.length;
    (!ue || ue < 0) && (ue = 0), (!he || he < 0 || he > Ne) && (he = Ne);
    for (var Be = "", Oe = ue; Oe < he; ++Oe)
      Be += Ze[Ie[Oe]];
    return Be;
  }
  function G(Ie, ue, he) {
    for (var Ne = Ie.slice(ue, he), Be = "", Oe = 0; Oe < Ne.length - 1; Oe += 2)
      Be += String.fromCharCode(Ne[Oe] + Ne[Oe + 1] * 256);
    return Be;
  }
  _.prototype.slice = function(ue, he) {
    var Ne = this.length;
    ue = ~~ue, he = he === void 0 ? Ne : ~~he, ue < 0 ? (ue += Ne, ue < 0 && (ue = 0)) : ue > Ne && (ue = Ne), he < 0 ? (he += Ne, he < 0 && (he = 0)) : he > Ne && (he = Ne), he < ue && (he = ue);
    var Be = this.subarray(ue, he);
    return Object.setPrototypeOf(Be, _.prototype), Be;
  };
  function R(Ie, ue, he) {
    if (Ie % 1 !== 0 || Ie < 0)
      throw new RangeError("offset is not uint");
    if (Ie + ue > he)
      throw new RangeError("Trying to access beyond buffer length");
  }
  _.prototype.readUintLE = _.prototype.readUIntLE = function(ue, he, Ne) {
    ue = ue >>> 0, he = he >>> 0, Ne || R(ue, he, this.length);
    for (var Be = this[ue], Oe = 1, it = 0; ++it < he && (Oe *= 256); )
      Be += this[ue + it] * Oe;
    return Be;
  }, _.prototype.readUintBE = _.prototype.readUIntBE = function(ue, he, Ne) {
    ue = ue >>> 0, he = he >>> 0, Ne || R(ue, he, this.length);
    for (var Be = this[ue + --he], Oe = 1; he > 0 && (Oe *= 256); )
      Be += this[ue + --he] * Oe;
    return Be;
  }, _.prototype.readUint8 = _.prototype.readUInt8 = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 1, this.length), this[ue];
  }, _.prototype.readUint16LE = _.prototype.readUInt16LE = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 2, this.length), this[ue] | this[ue + 1] << 8;
  }, _.prototype.readUint16BE = _.prototype.readUInt16BE = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 2, this.length), this[ue] << 8 | this[ue + 1];
  }, _.prototype.readUint32LE = _.prototype.readUInt32LE = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 4, this.length), (this[ue] | this[ue + 1] << 8 | this[ue + 2] << 16) + this[ue + 3] * 16777216;
  }, _.prototype.readUint32BE = _.prototype.readUInt32BE = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 4, this.length), this[ue] * 16777216 + (this[ue + 1] << 16 | this[ue + 2] << 8 | this[ue + 3]);
  }, _.prototype.readIntLE = function(ue, he, Ne) {
    ue = ue >>> 0, he = he >>> 0, Ne || R(ue, he, this.length);
    for (var Be = this[ue], Oe = 1, it = 0; ++it < he && (Oe *= 256); )
      Be += this[ue + it] * Oe;
    return Oe *= 128, Be >= Oe && (Be -= Math.pow(2, 8 * he)), Be;
  }, _.prototype.readIntBE = function(ue, he, Ne) {
    ue = ue >>> 0, he = he >>> 0, Ne || R(ue, he, this.length);
    for (var Be = he, Oe = 1, it = this[ue + --Be]; Be > 0 && (Oe *= 256); )
      it += this[ue + --Be] * Oe;
    return Oe *= 128, it >= Oe && (it -= Math.pow(2, 8 * he)), it;
  }, _.prototype.readInt8 = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 1, this.length), this[ue] & 128 ? (255 - this[ue] + 1) * -1 : this[ue];
  }, _.prototype.readInt16LE = function(ue, he) {
    ue = ue >>> 0, he || R(ue, 2, this.length);
    var Ne = this[ue] | this[ue + 1] << 8;
    return Ne & 32768 ? Ne | 4294901760 : Ne;
  }, _.prototype.readInt16BE = function(ue, he) {
    ue = ue >>> 0, he || R(ue, 2, this.length);
    var Ne = this[ue + 1] | this[ue] << 8;
    return Ne & 32768 ? Ne | 4294901760 : Ne;
  }, _.prototype.readInt32LE = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 4, this.length), this[ue] | this[ue + 1] << 8 | this[ue + 2] << 16 | this[ue + 3] << 24;
  }, _.prototype.readInt32BE = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 4, this.length), this[ue] << 24 | this[ue + 1] << 16 | this[ue + 2] << 8 | this[ue + 3];
  }, _.prototype.readFloatLE = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 4, this.length), s.read(this, ue, !0, 23, 4);
  }, _.prototype.readFloatBE = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 4, this.length), s.read(this, ue, !1, 23, 4);
  }, _.prototype.readDoubleLE = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 8, this.length), s.read(this, ue, !0, 52, 8);
  }, _.prototype.readDoubleBE = function(ue, he) {
    return ue = ue >>> 0, he || R(ue, 8, this.length), s.read(this, ue, !1, 52, 8);
  };
  function y(Ie, ue, he, Ne, Be, Oe) {
    if (!_.isBuffer(Ie))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (ue > Be || ue < Oe)
      throw new RangeError('"value" argument is out of bounds');
    if (he + Ne > Ie.length)
      throw new RangeError("Index out of range");
  }
  _.prototype.writeUintLE = _.prototype.writeUIntLE = function(ue, he, Ne, Be) {
    if (ue = +ue, he = he >>> 0, Ne = Ne >>> 0, !Be) {
      var Oe = Math.pow(2, 8 * Ne) - 1;
      y(this, ue, he, Ne, Oe, 0);
    }
    var it = 1, Ve = 0;
    for (this[he] = ue & 255; ++Ve < Ne && (it *= 256); )
      this[he + Ve] = ue / it & 255;
    return he + Ne;
  }, _.prototype.writeUintBE = _.prototype.writeUIntBE = function(ue, he, Ne, Be) {
    if (ue = +ue, he = he >>> 0, Ne = Ne >>> 0, !Be) {
      var Oe = Math.pow(2, 8 * Ne) - 1;
      y(this, ue, he, Ne, Oe, 0);
    }
    var it = Ne - 1, Ve = 1;
    for (this[he + it] = ue & 255; --it >= 0 && (Ve *= 256); )
      this[he + it] = ue / Ve & 255;
    return he + Ne;
  }, _.prototype.writeUint8 = _.prototype.writeUInt8 = function(ue, he, Ne) {
    return ue = +ue, he = he >>> 0, Ne || y(this, ue, he, 1, 255, 0), this[he] = ue & 255, he + 1;
  }, _.prototype.writeUint16LE = _.prototype.writeUInt16LE = function(ue, he, Ne) {
    return ue = +ue, he = he >>> 0, Ne || y(this, ue, he, 2, 65535, 0), this[he] = ue & 255, this[he + 1] = ue >>> 8, he + 2;
  }, _.prototype.writeUint16BE = _.prototype.writeUInt16BE = function(ue, he, Ne) {
    return ue = +ue, he = he >>> 0, Ne || y(this, ue, he, 2, 65535, 0), this[he] = ue >>> 8, this[he + 1] = ue & 255, he + 2;
  }, _.prototype.writeUint32LE = _.prototype.writeUInt32LE = function(ue, he, Ne) {
    return ue = +ue, he = he >>> 0, Ne || y(this, ue, he, 4, 4294967295, 0), this[he + 3] = ue >>> 24, this[he + 2] = ue >>> 16, this[he + 1] = ue >>> 8, this[he] = ue & 255, he + 4;
  }, _.prototype.writeUint32BE = _.prototype.writeUInt32BE = function(ue, he, Ne) {
    return ue = +ue, he = he >>> 0, Ne || y(this, ue, he, 4, 4294967295, 0), this[he] = ue >>> 24, this[he + 1] = ue >>> 16, this[he + 2] = ue >>> 8, this[he + 3] = ue & 255, he + 4;
  }, _.prototype.writeIntLE = function(ue, he, Ne, Be) {
    if (ue = +ue, he = he >>> 0, !Be) {
      var Oe = Math.pow(2, 8 * Ne - 1);
      y(this, ue, he, Ne, Oe - 1, -Oe);
    }
    var it = 0, Ve = 1, Ye = 0;
    for (this[he] = ue & 255; ++it < Ne && (Ve *= 256); )
      ue < 0 && Ye === 0 && this[he + it - 1] !== 0 && (Ye = 1), this[he + it] = (ue / Ve >> 0) - Ye & 255;
    return he + Ne;
  }, _.prototype.writeIntBE = function(ue, he, Ne, Be) {
    if (ue = +ue, he = he >>> 0, !Be) {
      var Oe = Math.pow(2, 8 * Ne - 1);
      y(this, ue, he, Ne, Oe - 1, -Oe);
    }
    var it = Ne - 1, Ve = 1, Ye = 0;
    for (this[he + it] = ue & 255; --it >= 0 && (Ve *= 256); )
      ue < 0 && Ye === 0 && this[he + it + 1] !== 0 && (Ye = 1), this[he + it] = (ue / Ve >> 0) - Ye & 255;
    return he + Ne;
  }, _.prototype.writeInt8 = function(ue, he, Ne) {
    return ue = +ue, he = he >>> 0, Ne || y(this, ue, he, 1, 127, -128), ue < 0 && (ue = 255 + ue + 1), this[he] = ue & 255, he + 1;
  }, _.prototype.writeInt16LE = function(ue, he, Ne) {
    return ue = +ue, he = he >>> 0, Ne || y(this, ue, he, 2, 32767, -32768), this[he] = ue & 255, this[he + 1] = ue >>> 8, he + 2;
  }, _.prototype.writeInt16BE = function(ue, he, Ne) {
    return ue = +ue, he = he >>> 0, Ne || y(this, ue, he, 2, 32767, -32768), this[he] = ue >>> 8, this[he + 1] = ue & 255, he + 2;
  }, _.prototype.writeInt32LE = function(ue, he, Ne) {
    return ue = +ue, he = he >>> 0, Ne || y(this, ue, he, 4, 2147483647, -2147483648), this[he] = ue & 255, this[he + 1] = ue >>> 8, this[he + 2] = ue >>> 16, this[he + 3] = ue >>> 24, he + 4;
  }, _.prototype.writeInt32BE = function(ue, he, Ne) {
    return ue = +ue, he = he >>> 0, Ne || y(this, ue, he, 4, 2147483647, -2147483648), ue < 0 && (ue = 4294967295 + ue + 1), this[he] = ue >>> 24, this[he + 1] = ue >>> 16, this[he + 2] = ue >>> 8, this[he + 3] = ue & 255, he + 4;
  };
  function j(Ie, ue, he, Ne, Be, Oe) {
    if (he + Ne > Ie.length)
      throw new RangeError("Index out of range");
    if (he < 0)
      throw new RangeError("Index out of range");
  }
  function ye(Ie, ue, he, Ne, Be) {
    return ue = +ue, he = he >>> 0, Be || j(Ie, ue, he, 4), s.write(Ie, ue, he, Ne, 23, 4), he + 4;
  }
  _.prototype.writeFloatLE = function(ue, he, Ne) {
    return ye(this, ue, he, !0, Ne);
  }, _.prototype.writeFloatBE = function(ue, he, Ne) {
    return ye(this, ue, he, !1, Ne);
  };
  function ee(Ie, ue, he, Ne, Be) {
    return ue = +ue, he = he >>> 0, Be || j(Ie, ue, he, 8), s.write(Ie, ue, he, Ne, 52, 8), he + 8;
  }
  _.prototype.writeDoubleLE = function(ue, he, Ne) {
    return ee(this, ue, he, !0, Ne);
  }, _.prototype.writeDoubleBE = function(ue, he, Ne) {
    return ee(this, ue, he, !1, Ne);
  }, _.prototype.copy = function(ue, he, Ne, Be) {
    if (!_.isBuffer(ue))
      throw new TypeError("argument should be a Buffer");
    if (Ne || (Ne = 0), !Be && Be !== 0 && (Be = this.length), he >= ue.length && (he = ue.length), he || (he = 0), Be > 0 && Be < Ne && (Be = Ne), Be === Ne || ue.length === 0 || this.length === 0)
      return 0;
    if (he < 0)
      throw new RangeError("targetStart out of bounds");
    if (Ne < 0 || Ne >= this.length)
      throw new RangeError("Index out of range");
    if (Be < 0)
      throw new RangeError("sourceEnd out of bounds");
    Be > this.length && (Be = this.length), ue.length - he < Be - Ne && (Be = ue.length - he + Ne);
    var Oe = Be - Ne;
    return this === ue && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(he, Ne, Be) : Uint8Array.prototype.set.call(
      ue,
      this.subarray(Ne, Be),
      he
    ), Oe;
  }, _.prototype.fill = function(ue, he, Ne, Be) {
    if (typeof ue == "string") {
      if (typeof he == "string" ? (Be = he, he = 0, Ne = this.length) : typeof Ne == "string" && (Be = Ne, Ne = this.length), Be !== void 0 && typeof Be != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Be == "string" && !_.isEncoding(Be))
        throw new TypeError("Unknown encoding: " + Be);
      if (ue.length === 1) {
        var Oe = ue.charCodeAt(0);
        (Be === "utf8" && Oe < 128 || Be === "latin1") && (ue = Oe);
      }
    } else
      typeof ue == "number" ? ue = ue & 255 : typeof ue == "boolean" && (ue = Number(ue));
    if (he < 0 || this.length < he || this.length < Ne)
      throw new RangeError("Out of range index");
    if (Ne <= he)
      return this;
    he = he >>> 0, Ne = Ne === void 0 ? this.length : Ne >>> 0, ue || (ue = 0);
    var it;
    if (typeof ue == "number")
      for (it = he; it < Ne; ++it)
        this[it] = ue;
    else {
      var Ve = _.isBuffer(ue) ? ue : _.from(ue, Be), Ye = Ve.length;
      if (Ye === 0)
        throw new TypeError('The value "' + ue + '" is invalid for argument "value"');
      for (it = 0; it < Ne - he; ++it)
        this[it + he] = Ve[it % Ye];
    }
    return this;
  };
  var xe = /[^+/0-9A-Za-z-_]/g;
  function $e(Ie) {
    if (Ie = Ie.split("=")[0], Ie = Ie.trim().replace(xe, ""), Ie.length < 2)
      return "";
    for (; Ie.length % 4 !== 0; )
      Ie = Ie + "=";
    return Ie;
  }
  function ke(Ie, ue) {
    ue = ue || 1 / 0;
    for (var he, Ne = Ie.length, Be = null, Oe = [], it = 0; it < Ne; ++it) {
      if (he = Ie.charCodeAt(it), he > 55295 && he < 57344) {
        if (!Be) {
          if (he > 56319) {
            (ue -= 3) > -1 && Oe.push(239, 191, 189);
            continue;
          } else if (it + 1 === Ne) {
            (ue -= 3) > -1 && Oe.push(239, 191, 189);
            continue;
          }
          Be = he;
          continue;
        }
        if (he < 56320) {
          (ue -= 3) > -1 && Oe.push(239, 191, 189), Be = he;
          continue;
        }
        he = (Be - 55296 << 10 | he - 56320) + 65536;
      } else
        Be && (ue -= 3) > -1 && Oe.push(239, 191, 189);
      if (Be = null, he < 128) {
        if ((ue -= 1) < 0)
          break;
        Oe.push(he);
      } else if (he < 2048) {
        if ((ue -= 2) < 0)
          break;
        Oe.push(
          he >> 6 | 192,
          he & 63 | 128
        );
      } else if (he < 65536) {
        if ((ue -= 3) < 0)
          break;
        Oe.push(
          he >> 12 | 224,
          he >> 6 & 63 | 128,
          he & 63 | 128
        );
      } else if (he < 1114112) {
        if ((ue -= 4) < 0)
          break;
        Oe.push(
          he >> 18 | 240,
          he >> 12 & 63 | 128,
          he >> 6 & 63 | 128,
          he & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Oe;
  }
  function Ce(Ie) {
    for (var ue = [], he = 0; he < Ie.length; ++he)
      ue.push(Ie.charCodeAt(he) & 255);
    return ue;
  }
  function ht(Ie, ue) {
    for (var he, Ne, Be, Oe = [], it = 0; it < Ie.length && !((ue -= 2) < 0); ++it)
      he = Ie.charCodeAt(it), Ne = he >> 8, Be = he % 256, Oe.push(Be), Oe.push(Ne);
    return Oe;
  }
  function Ue(Ie) {
    return t.toByteArray($e(Ie));
  }
  function De(Ie, ue, he, Ne) {
    for (var Be = 0; Be < Ne && !(Be + he >= ue.length || Be >= Ie.length); ++Be)
      ue[Be + he] = Ie[Be];
    return Be;
  }
  function wt(Ie, ue) {
    return Ie instanceof ue || Ie != null && Ie.constructor != null && Ie.constructor.name != null && Ie.constructor.name === ue.name;
  }
  function He(Ie) {
    return Ie !== Ie;
  }
  var Ze = function() {
    for (var Ie = "0123456789abcdef", ue = new Array(256), he = 0; he < 16; ++he)
      for (var Ne = he * 16, Be = 0; Be < 16; ++Be)
        ue[Ne + Be] = Ie[he] + Ie[Be];
    return ue;
  }();
})(buffer$2);
var BufferUtil$2 = typedarrayBuffer, Polynomial = polynomial, Buffer$1 = buffer$2.Buffer;
function ReedSolomonEncoder$1(l) {
  this.genPoly = void 0, this.degree = l, this.degree && this.initialize(this.degree);
}
ReedSolomonEncoder$1.prototype.initialize = function(t) {
  this.degree = t, this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$1.prototype.encode = function(t) {
  if (!this.genPoly)
    throw new Error("Encoder not initialized");
  var s = BufferUtil$2.alloc(this.degree), h = Buffer$1.concat([t, s], t.length + this.degree), m = Polynomial.mod(h, this.genPoly), d = this.degree - m.length;
  if (d > 0) {
    var v = BufferUtil$2.alloc(this.degree);
    return m.copy(v, d), v;
  }
  return m;
};
var reedSolomonEncoder = ReedSolomonEncoder$1, version$1 = {}, mode = {}, versionCheck = {};
versionCheck.isValid = function(t) {
  return !isNaN(t) && t >= 1 && t <= 40;
};
var regex = {}, numeric = "[0-9]+", alphanumeric = "[A-Z $%*+\\-./:]+", kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + `)(?:.|[\r
]))+`;
regex.KANJI = new RegExp(kanji, "g");
regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
regex.BYTE = new RegExp(byte, "g");
regex.NUMERIC = new RegExp(numeric, "g");
regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
var TEST_KANJI = new RegExp("^" + kanji + "$"), TEST_NUMERIC = new RegExp("^" + numeric + "$"), TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex.testKanji = function(t) {
  return TEST_KANJI.test(t);
};
regex.testNumeric = function(t) {
  return TEST_NUMERIC.test(t);
};
regex.testAlphanumeric = function(t) {
  return TEST_ALPHANUMERIC.test(t);
};
(function(l) {
  var t = versionCheck, s = regex;
  l.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  }, l.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  }, l.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  }, l.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  }, l.MIXED = {
    bit: -1
  }, l.getCharCountIndicator = function(d, v) {
    if (!d.ccBits)
      throw new Error("Invalid mode: " + d);
    if (!t.isValid(v))
      throw new Error("Invalid version: " + v);
    return v >= 1 && v < 10 ? d.ccBits[0] : v < 27 ? d.ccBits[1] : d.ccBits[2];
  }, l.getBestModeForData = function(d) {
    return s.testNumeric(d) ? l.NUMERIC : s.testAlphanumeric(d) ? l.ALPHANUMERIC : s.testKanji(d) ? l.KANJI : l.BYTE;
  }, l.toString = function(d) {
    if (d && d.id)
      return d.id;
    throw new Error("Invalid mode");
  }, l.isValid = function(d) {
    return d && d.bit && d.ccBits;
  };
  function h(m) {
    if (typeof m != "string")
      throw new Error("Param is not a string");
    var d = m.toLowerCase();
    switch (d) {
      case "numeric":
        return l.NUMERIC;
      case "alphanumeric":
        return l.ALPHANUMERIC;
      case "kanji":
        return l.KANJI;
      case "byte":
        return l.BYTE;
      default:
        throw new Error("Unknown mode: " + m);
    }
  }
  l.from = function(d, v) {
    if (l.isValid(d))
      return d;
    try {
      return h(d);
    } catch {
      return v;
    }
  };
})(mode);
(function(l) {
  var t = utils$5, s = errorCorrectionCode, h = errorCorrectionLevel, m = mode, d = versionCheck, v = isarray, _ = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0, T = t.getBCHDigit(_);
  function z(ne, de, ce) {
    for (var re = 1; re <= 40; re++)
      if (de <= l.getCapacity(re, ce, ne))
        return re;
  }
  function J(ne, de) {
    return m.getCharCountIndicator(ne, de) + 4;
  }
  function Y(ne, de) {
    var ce = 0;
    return ne.forEach(function(re) {
      var oe = J(re.mode, de);
      ce += oe + re.getBitsLength();
    }), ce;
  }
  function ie(ne, de) {
    for (var ce = 1; ce <= 40; ce++) {
      var re = Y(ne, ce);
      if (re <= l.getCapacity(ce, de, m.MIXED))
        return ce;
    }
  }
  l.from = function(de, ce) {
    return d.isValid(de) ? parseInt(de, 10) : ce;
  }, l.getCapacity = function(de, ce, re) {
    if (!d.isValid(de))
      throw new Error("Invalid QR Code version");
    typeof re > "u" && (re = m.BYTE);
    var oe = t.getSymbolTotalCodewords(de), pe = s.getTotalCodewordsCount(de, ce), ae = (oe - pe) * 8;
    if (re === m.MIXED)
      return ae;
    var me = ae - J(re, de);
    switch (re) {
      case m.NUMERIC:
        return Math.floor(me / 10 * 3);
      case m.ALPHANUMERIC:
        return Math.floor(me / 11 * 2);
      case m.KANJI:
        return Math.floor(me / 13);
      case m.BYTE:
      default:
        return Math.floor(me / 8);
    }
  }, l.getBestVersionForData = function(de, ce) {
    var re, oe = h.from(ce, h.M);
    if (v(de)) {
      if (de.length > 1)
        return ie(de, oe);
      if (de.length === 0)
        return 1;
      re = de[0];
    } else
      re = de;
    return z(re.mode, re.getLength(), oe);
  }, l.getEncodedBits = function(de) {
    if (!d.isValid(de) || de < 7)
      throw new Error("Invalid QR Code version");
    for (var ce = de << 12; t.getBCHDigit(ce) - T >= 0; )
      ce ^= _ << t.getBCHDigit(ce) - T;
    return de << 12 | ce;
  };
})(version$1);
var formatInfo = {}, Utils$3 = utils$5, G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0, G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1, G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function(t, s) {
  for (var h = t.bit << 3 | s, m = h << 10; Utils$3.getBCHDigit(m) - G15_BCH >= 0; )
    m ^= G15 << Utils$3.getBCHDigit(m) - G15_BCH;
  return (h << 10 | m) ^ G15_MASK;
};
var segments = {}, Mode$4 = mode;
function NumericData(l) {
  this.mode = Mode$4.NUMERIC, this.data = l.toString();
}
NumericData.getBitsLength = function(t) {
  return 10 * Math.floor(t / 3) + (t % 3 ? t % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function(t) {
  var s, h, m;
  for (s = 0; s + 3 <= this.data.length; s += 3)
    h = this.data.substr(s, 3), m = parseInt(h, 10), t.put(m, 10);
  var d = this.data.length - s;
  d > 0 && (h = this.data.substr(s), m = parseInt(h, 10), t.put(m, d * 3 + 1));
};
var numericData = NumericData, Mode$3 = mode, ALPHA_NUM_CHARS = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function AlphanumericData(l) {
  this.mode = Mode$3.ALPHANUMERIC, this.data = l;
}
AlphanumericData.getBitsLength = function(t) {
  return 11 * Math.floor(t / 2) + 6 * (t % 2);
};
AlphanumericData.prototype.getLength = function() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function(t) {
  var s;
  for (s = 0; s + 2 <= this.data.length; s += 2) {
    var h = ALPHA_NUM_CHARS.indexOf(this.data[s]) * 45;
    h += ALPHA_NUM_CHARS.indexOf(this.data[s + 1]), t.put(h, 11);
  }
  this.data.length % 2 && t.put(ALPHA_NUM_CHARS.indexOf(this.data[s]), 6);
};
var alphanumericData = AlphanumericData, BufferUtil$1 = typedarrayBuffer, Mode$2 = mode;
function ByteData(l) {
  this.mode = Mode$2.BYTE, this.data = BufferUtil$1.from(l);
}
ByteData.getBitsLength = function(t) {
  return t * 8;
};
ByteData.prototype.getLength = function() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(l) {
  for (var t = 0, s = this.data.length; t < s; t++)
    l.put(this.data[t], 8);
};
var byteData = ByteData, Mode$1 = mode, Utils$2 = utils$5;
function KanjiData(l) {
  this.mode = Mode$1.KANJI, this.data = l;
}
KanjiData.getBitsLength = function(t) {
  return t * 13;
};
KanjiData.prototype.getLength = function() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(l) {
  var t;
  for (t = 0; t < this.data.length; t++) {
    var s = Utils$2.toSJIS(this.data[t]);
    if (s >= 33088 && s <= 40956)
      s -= 33088;
    else if (s >= 57408 && s <= 60351)
      s -= 49472;
    else
      throw new Error(
        "Invalid SJIS character: " + this.data[t] + `
Make sure your charset is UTF-8`
      );
    s = (s >>> 8 & 255) * 192 + (s & 255), l.put(s, 13);
  }
};
var kanjiData = KanjiData, dijkstra = { exports: {} };
(function(l) {
  var t = {
    single_source_shortest_paths: function(s, h, m) {
      var d = {}, v = {};
      v[h] = 0;
      var _ = t.PriorityQueue.make();
      _.push(h, 0);
      for (var T, z, J, Y, ie, ne, de, ce, re; !_.empty(); ) {
        T = _.pop(), z = T.value, Y = T.cost, ie = s[z] || {};
        for (J in ie)
          ie.hasOwnProperty(J) && (ne = ie[J], de = Y + ne, ce = v[J], re = typeof v[J] > "u", (re || ce > de) && (v[J] = de, _.push(J, de), d[J] = z));
      }
      if (typeof m < "u" && typeof v[m] > "u") {
        var oe = ["Could not find a path from ", h, " to ", m, "."].join("");
        throw new Error(oe);
      }
      return d;
    },
    extract_shortest_path_from_predecessor_list: function(s, h) {
      for (var m = [], d = h; d; )
        m.push(d), s[d], d = s[d];
      return m.reverse(), m;
    },
    find_path: function(s, h, m) {
      var d = t.single_source_shortest_paths(s, h, m);
      return t.extract_shortest_path_from_predecessor_list(
        d,
        m
      );
    },
    PriorityQueue: {
      make: function(s) {
        var h = t.PriorityQueue, m = {}, d;
        s = s || {};
        for (d in h)
          h.hasOwnProperty(d) && (m[d] = h[d]);
        return m.queue = [], m.sorter = s.sorter || h.default_sorter, m;
      },
      default_sorter: function(s, h) {
        return s.cost - h.cost;
      },
      push: function(s, h) {
        var m = { value: s, cost: h };
        this.queue.push(m), this.queue.sort(this.sorter);
      },
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  l.exports = t;
})(dijkstra);
(function(l) {
  var t = mode, s = numericData, h = alphanumericData, m = byteData, d = kanjiData, v = regex, _ = utils$5, T = dijkstra.exports;
  function z(oe) {
    return unescape(encodeURIComponent(oe)).length;
  }
  function J(oe, pe, ae) {
    for (var me = [], ge; (ge = oe.exec(ae)) !== null; )
      me.push({
        data: ge[0],
        index: ge.index,
        mode: pe,
        length: ge[0].length
      });
    return me;
  }
  function Y(oe) {
    var pe = J(v.NUMERIC, t.NUMERIC, oe), ae = J(v.ALPHANUMERIC, t.ALPHANUMERIC, oe), me, ge;
    _.isKanjiModeEnabled() ? (me = J(v.BYTE, t.BYTE, oe), ge = J(v.KANJI, t.KANJI, oe)) : (me = J(v.BYTE_KANJI, t.BYTE, oe), ge = []);
    var we = pe.concat(ae, me, ge);
    return we.sort(function(Ee, Te) {
      return Ee.index - Te.index;
    }).map(function(Ee) {
      return {
        data: Ee.data,
        mode: Ee.mode,
        length: Ee.length
      };
    });
  }
  function ie(oe, pe) {
    switch (pe) {
      case t.NUMERIC:
        return s.getBitsLength(oe);
      case t.ALPHANUMERIC:
        return h.getBitsLength(oe);
      case t.KANJI:
        return d.getBitsLength(oe);
      case t.BYTE:
        return m.getBitsLength(oe);
    }
  }
  function ne(oe) {
    return oe.reduce(function(pe, ae) {
      var me = pe.length - 1 >= 0 ? pe[pe.length - 1] : null;
      return me && me.mode === ae.mode ? (pe[pe.length - 1].data += ae.data, pe) : (pe.push(ae), pe);
    }, []);
  }
  function de(oe) {
    for (var pe = [], ae = 0; ae < oe.length; ae++) {
      var me = oe[ae];
      switch (me.mode) {
        case t.NUMERIC:
          pe.push([
            me,
            { data: me.data, mode: t.ALPHANUMERIC, length: me.length },
            { data: me.data, mode: t.BYTE, length: me.length }
          ]);
          break;
        case t.ALPHANUMERIC:
          pe.push([
            me,
            { data: me.data, mode: t.BYTE, length: me.length }
          ]);
          break;
        case t.KANJI:
          pe.push([
            me,
            { data: me.data, mode: t.BYTE, length: z(me.data) }
          ]);
          break;
        case t.BYTE:
          pe.push([
            { data: me.data, mode: t.BYTE, length: z(me.data) }
          ]);
      }
    }
    return pe;
  }
  function ce(oe, pe) {
    for (var ae = {}, me = { start: {} }, ge = ["start"], we = 0; we < oe.length; we++) {
      for (var Ee = oe[we], Te = [], Ke = 0; Ke < Ee.length; Ke++) {
        var Se = Ee[Ke], X = "" + we + Ke;
        Te.push(X), ae[X] = { node: Se, lastCount: 0 }, me[X] = {};
        for (var fe = 0; fe < ge.length; fe++) {
          var k = ge[fe];
          ae[k] && ae[k].node.mode === Se.mode ? (me[k][X] = ie(ae[k].lastCount + Se.length, Se.mode) - ie(ae[k].lastCount, Se.mode), ae[k].lastCount += Se.length) : (ae[k] && (ae[k].lastCount = Se.length), me[k][X] = ie(Se.length, Se.mode) + 4 + t.getCharCountIndicator(Se.mode, pe));
        }
      }
      ge = Te;
    }
    for (fe = 0; fe < ge.length; fe++)
      me[ge[fe]].end = 0;
    return { map: me, table: ae };
  }
  function re(oe, pe) {
    var ae, me = t.getBestModeForData(oe);
    if (ae = t.from(pe, me), ae !== t.BYTE && ae.bit < me.bit)
      throw new Error('"' + oe + '" cannot be encoded with mode ' + t.toString(ae) + `.
 Suggested mode is: ` + t.toString(me));
    switch (ae === t.KANJI && !_.isKanjiModeEnabled() && (ae = t.BYTE), ae) {
      case t.NUMERIC:
        return new s(oe);
      case t.ALPHANUMERIC:
        return new h(oe);
      case t.KANJI:
        return new d(oe);
      case t.BYTE:
        return new m(oe);
    }
  }
  l.fromArray = function(pe) {
    return pe.reduce(function(ae, me) {
      return typeof me == "string" ? ae.push(re(me, null)) : me.data && ae.push(re(me.data, me.mode)), ae;
    }, []);
  }, l.fromString = function(pe, ae) {
    for (var me = Y(pe, _.isKanjiModeEnabled()), ge = de(me), we = ce(ge, ae), Ee = T.find_path(we.map, "start", "end"), Te = [], Ke = 1; Ke < Ee.length - 1; Ke++)
      Te.push(we.table[Ee[Ke]].node);
    return l.fromArray(ne(Te));
  }, l.rawSplit = function(pe) {
    return l.fromArray(
      Y(pe, _.isKanjiModeEnabled())
    );
  };
})(segments);
var BufferUtil = typedarrayBuffer, Utils$1 = utils$5, ECLevel = errorCorrectionLevel, BitBuffer = bitBuffer, BitMatrix = bitMatrix, AlignmentPattern = alignmentPattern, FinderPattern = finderPattern, MaskPattern = maskPattern, ECCode = errorCorrectionCode, ReedSolomonEncoder = reedSolomonEncoder, Version = version$1, FormatInfo = formatInfo, Mode = mode, Segments = segments, isArray = isarray;
function setupFinderPattern(l, t) {
  for (var s = l.size, h = FinderPattern.getPositions(t), m = 0; m < h.length; m++)
    for (var d = h[m][0], v = h[m][1], _ = -1; _ <= 7; _++)
      if (!(d + _ <= -1 || s <= d + _))
        for (var T = -1; T <= 7; T++)
          v + T <= -1 || s <= v + T || (_ >= 0 && _ <= 6 && (T === 0 || T === 6) || T >= 0 && T <= 6 && (_ === 0 || _ === 6) || _ >= 2 && _ <= 4 && T >= 2 && T <= 4 ? l.set(d + _, v + T, !0, !0) : l.set(d + _, v + T, !1, !0));
}
function setupTimingPattern(l) {
  for (var t = l.size, s = 8; s < t - 8; s++) {
    var h = s % 2 === 0;
    l.set(s, 6, h, !0), l.set(6, s, h, !0);
  }
}
function setupAlignmentPattern(l, t) {
  for (var s = AlignmentPattern.getPositions(t), h = 0; h < s.length; h++)
    for (var m = s[h][0], d = s[h][1], v = -2; v <= 2; v++)
      for (var _ = -2; _ <= 2; _++)
        v === -2 || v === 2 || _ === -2 || _ === 2 || v === 0 && _ === 0 ? l.set(m + v, d + _, !0, !0) : l.set(m + v, d + _, !1, !0);
}
function setupVersionInfo(l, t) {
  for (var s = l.size, h = Version.getEncodedBits(t), m, d, v, _ = 0; _ < 18; _++)
    m = Math.floor(_ / 3), d = _ % 3 + s - 8 - 3, v = (h >> _ & 1) === 1, l.set(m, d, v, !0), l.set(d, m, v, !0);
}
function setupFormatInfo(l, t, s) {
  var h = l.size, m = FormatInfo.getEncodedBits(t, s), d, v;
  for (d = 0; d < 15; d++)
    v = (m >> d & 1) === 1, d < 6 ? l.set(d, 8, v, !0) : d < 8 ? l.set(d + 1, 8, v, !0) : l.set(h - 15 + d, 8, v, !0), d < 8 ? l.set(8, h - d - 1, v, !0) : d < 9 ? l.set(8, 15 - d - 1 + 1, v, !0) : l.set(8, 15 - d - 1, v, !0);
  l.set(h - 8, 8, 1, !0);
}
function setupData(l, t) {
  for (var s = l.size, h = -1, m = s - 1, d = 7, v = 0, _ = s - 1; _ > 0; _ -= 2)
    for (_ === 6 && _--; ; ) {
      for (var T = 0; T < 2; T++)
        if (!l.isReserved(m, _ - T)) {
          var z = !1;
          v < t.length && (z = (t[v] >>> d & 1) === 1), l.set(m, _ - T, z), d--, d === -1 && (v++, d = 7);
        }
      if (m += h, m < 0 || s <= m) {
        m -= h, h = -h;
        break;
      }
    }
}
function createData(l, t, s) {
  var h = new BitBuffer();
  s.forEach(function(z) {
    h.put(z.mode.bit, 4), h.put(z.getLength(), Mode.getCharCountIndicator(z.mode, l)), z.write(h);
  });
  var m = Utils$1.getSymbolTotalCodewords(l), d = ECCode.getTotalCodewordsCount(l, t), v = (m - d) * 8;
  for (h.getLengthInBits() + 4 <= v && h.put(0, 4); h.getLengthInBits() % 8 !== 0; )
    h.putBit(0);
  for (var _ = (v - h.getLengthInBits()) / 8, T = 0; T < _; T++)
    h.put(T % 2 ? 17 : 236, 8);
  return createCodewords(h, l, t);
}
function createCodewords(l, t, s) {
  for (var h = Utils$1.getSymbolTotalCodewords(t), m = ECCode.getTotalCodewordsCount(t, s), d = h - m, v = ECCode.getBlocksCount(t, s), _ = h % v, T = v - _, z = Math.floor(h / v), J = Math.floor(d / v), Y = J + 1, ie = z - J, ne = new ReedSolomonEncoder(ie), de = 0, ce = new Array(v), re = new Array(v), oe = 0, pe = BufferUtil.from(l.buffer), ae = 0; ae < v; ae++) {
    var me = ae < T ? J : Y;
    ce[ae] = pe.slice(de, de + me), re[ae] = ne.encode(ce[ae]), de += me, oe = Math.max(oe, me);
  }
  var ge = BufferUtil.alloc(h), we = 0, Ee, Te;
  for (Ee = 0; Ee < oe; Ee++)
    for (Te = 0; Te < v; Te++)
      Ee < ce[Te].length && (ge[we++] = ce[Te][Ee]);
  for (Ee = 0; Ee < ie; Ee++)
    for (Te = 0; Te < v; Te++)
      ge[we++] = re[Te][Ee];
  return ge;
}
function createSymbol(l, t, s, h) {
  var m;
  if (isArray(l))
    m = Segments.fromArray(l);
  else if (typeof l == "string") {
    var d = t;
    if (!d) {
      var v = Segments.rawSplit(l);
      d = Version.getBestVersionForData(
        v,
        s
      );
    }
    m = Segments.fromString(l, d || 40);
  } else
    throw new Error("Invalid data");
  var _ = Version.getBestVersionForData(
    m,
    s
  );
  if (!_)
    throw new Error("The amount of data is too big to be stored in a QR Code");
  if (!t)
    t = _;
  else if (t < _)
    throw new Error(
      `
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + _ + `.
`
    );
  var T = createData(t, s, m), z = Utils$1.getSymbolSize(t), J = new BitMatrix(z);
  return setupFinderPattern(J, t), setupTimingPattern(J), setupAlignmentPattern(J, t), setupFormatInfo(J, s, 0), t >= 7 && setupVersionInfo(J, t), setupData(J, T), isNaN(h) && (h = MaskPattern.getBestMask(
    J,
    setupFormatInfo.bind(null, J, s)
  )), MaskPattern.applyMask(h, J), setupFormatInfo(J, s, h), {
    modules: J,
    version: t,
    errorCorrectionLevel: s,
    maskPattern: h,
    segments: m
  };
}
qrcode.create = function(t, s) {
  if (typeof t > "u" || t === "")
    throw new Error("No input text");
  var h = ECLevel.M, m, d;
  return typeof s < "u" && (h = ECLevel.from(s.errorCorrectionLevel, ECLevel.M), m = Version.from(s.version), d = MaskPattern.from(s.maskPattern), s.toSJISFunc && Utils$1.setToSJISFunction(s.toSJISFunc)), createSymbol(t, m, h, d);
};
var canvas = {}, utils$4 = {};
(function(l) {
  function t(s) {
    if (typeof s == "number" && (s = s.toString()), typeof s != "string")
      throw new Error("Color should be defined as hex string");
    var h = s.slice().replace("#", "").split("");
    if (h.length < 3 || h.length === 5 || h.length > 8)
      throw new Error("Invalid hex color: " + s);
    (h.length === 3 || h.length === 4) && (h = Array.prototype.concat.apply([], h.map(function(d) {
      return [d, d];
    }))), h.length === 6 && h.push("F", "F");
    var m = parseInt(h.join(""), 16);
    return {
      r: m >> 24 & 255,
      g: m >> 16 & 255,
      b: m >> 8 & 255,
      a: m & 255,
      hex: "#" + h.slice(0, 6).join("")
    };
  }
  l.getOptions = function(h) {
    h || (h = {}), h.color || (h.color = {});
    var m = typeof h.margin > "u" || h.margin === null || h.margin < 0 ? 4 : h.margin, d = h.width && h.width >= 21 ? h.width : void 0, v = h.scale || 4;
    return {
      width: d,
      scale: d ? 4 : v,
      margin: m,
      color: {
        dark: t(h.color.dark || "#000000ff"),
        light: t(h.color.light || "#ffffffff")
      },
      type: h.type,
      rendererOpts: h.rendererOpts || {}
    };
  }, l.getScale = function(h, m) {
    return m.width && m.width >= h + m.margin * 2 ? m.width / (h + m.margin * 2) : m.scale;
  }, l.getImageWidth = function(h, m) {
    var d = l.getScale(h, m);
    return Math.floor((h + m.margin * 2) * d);
  }, l.qrToImageData = function(h, m, d) {
    for (var v = m.modules.size, _ = m.modules.data, T = l.getScale(v, d), z = Math.floor((v + d.margin * 2) * T), J = d.margin * T, Y = [d.color.light, d.color.dark], ie = 0; ie < z; ie++)
      for (var ne = 0; ne < z; ne++) {
        var de = (ie * z + ne) * 4, ce = d.color.light;
        if (ie >= J && ne >= J && ie < z - J && ne < z - J) {
          var re = Math.floor((ie - J) / T), oe = Math.floor((ne - J) / T);
          ce = Y[_[re * v + oe] ? 1 : 0];
        }
        h[de++] = ce.r, h[de++] = ce.g, h[de++] = ce.b, h[de] = ce.a;
      }
  };
})(utils$4);
(function(l) {
  var t = utils$4;
  function s(m, d, v) {
    m.clearRect(0, 0, d.width, d.height), d.style || (d.style = {}), d.height = v, d.width = v, d.style.height = v + "px", d.style.width = v + "px";
  }
  function h() {
    try {
      return document.createElement("canvas");
    } catch {
      throw new Error("You need to specify a canvas element");
    }
  }
  l.render = function(d, v, _) {
    var T = _, z = v;
    typeof T > "u" && (!v || !v.getContext) && (T = v, v = void 0), v || (z = h()), T = t.getOptions(T);
    var J = t.getImageWidth(d.modules.size, T), Y = z.getContext("2d"), ie = Y.createImageData(J, J);
    return t.qrToImageData(ie.data, d, T), s(Y, z, J), Y.putImageData(ie, 0, 0), z;
  }, l.renderToDataURL = function(d, v, _) {
    var T = _;
    typeof T > "u" && (!v || !v.getContext) && (T = v, v = void 0), T || (T = {});
    var z = l.render(d, v, T), J = T.type || "image/png", Y = T.rendererOpts || {};
    return z.toDataURL(J, Y.quality);
  };
})(canvas);
var svgTag = {}, Utils = utils$4;
function getColorAttrib(l, t) {
  var s = l.a / 255, h = t + '="' + l.hex + '"';
  return s < 1 ? h + " " + t + '-opacity="' + s.toFixed(2).slice(1) + '"' : h;
}
function svgCmd(l, t, s) {
  var h = l + t;
  return typeof s < "u" && (h += " " + s), h;
}
function qrToPath(l, t, s) {
  for (var h = "", m = 0, d = !1, v = 0, _ = 0; _ < l.length; _++) {
    var T = Math.floor(_ % t), z = Math.floor(_ / t);
    !T && !d && (d = !0), l[_] ? (v++, _ > 0 && T > 0 && l[_ - 1] || (h += d ? svgCmd("M", T + s, 0.5 + z + s) : svgCmd("m", m, 0), m = 0, d = !1), T + 1 < t && l[_ + 1] || (h += svgCmd("h", v), v = 0)) : m++;
  }
  return h;
}
svgTag.render = function(t, s, h) {
  var m = Utils.getOptions(s), d = t.modules.size, v = t.modules.data, _ = d + m.margin * 2, T = m.color.light.a ? "<path " + getColorAttrib(m.color.light, "fill") + ' d="M0 0h' + _ + "v" + _ + 'H0z"/>' : "", z = "<path " + getColorAttrib(m.color.dark, "stroke") + ' d="' + qrToPath(v, d, m.margin) + '"/>', J = 'viewBox="0 0 ' + _ + " " + _ + '"', Y = m.width ? 'width="' + m.width + '" height="' + m.width + '" ' : "", ie = '<svg xmlns="http://www.w3.org/2000/svg" ' + Y + J + ' shape-rendering="crispEdges">' + T + z + `</svg>
`;
  return typeof h == "function" && h(null, ie), ie;
};
var canPromise = canPromise$1, QRCode$1 = qrcode, CanvasRenderer = canvas, SvgRenderer = svgTag;
function renderCanvas(l, t, s, h, m) {
  var d = [].slice.call(arguments, 1), v = d.length, _ = typeof d[v - 1] == "function";
  if (!_ && !canPromise())
    throw new Error("Callback required as last argument");
  if (_) {
    if (v < 2)
      throw new Error("Too few arguments provided");
    v === 2 ? (m = s, s = t, t = h = void 0) : v === 3 && (t.getContext && typeof m > "u" ? (m = h, h = void 0) : (m = h, h = s, s = t, t = void 0));
  } else {
    if (v < 1)
      throw new Error("Too few arguments provided");
    return v === 1 ? (s = t, t = h = void 0) : v === 2 && !t.getContext && (h = s, s = t, t = void 0), new Promise(function(z, J) {
      try {
        var Y = QRCode$1.create(s, h);
        z(l(Y, t, h));
      } catch (ie) {
        J(ie);
      }
    });
  }
  try {
    var T = QRCode$1.create(s, h);
    m(null, l(T, t, h));
  } catch (z) {
    m(z);
  }
}
browser$4.create = QRCode$1.create;
browser$4.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
browser$4.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
browser$4.toString = renderCanvas.bind(null, function(l, t, s) {
  return SvgRenderer.render(l, s);
});
var toggleSelection = function() {
  var l = document.getSelection();
  if (!l.rangeCount)
    return function() {
    };
  for (var t = document.activeElement, s = [], h = 0; h < l.rangeCount; h++)
    s.push(l.getRangeAt(h));
  switch (t.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      t.blur();
      break;
    default:
      t = null;
      break;
  }
  return l.removeAllRanges(), function() {
    l.type === "Caret" && l.removeAllRanges(), l.rangeCount || s.forEach(function(m) {
      l.addRange(m);
    }), t && t.focus();
  };
}, deselectCurrent = toggleSelection, clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, defaultMessage = "Copy to clipboard: #{key}, Enter";
function format$1(l) {
  var t = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return l.replace(/#{\s*key\s*}/g, t);
}
function copy$1(l, t) {
  var s, h, m, d, v, _, T = !1;
  t || (t = {}), s = t.debug || !1;
  try {
    m = deselectCurrent(), d = document.createRange(), v = document.getSelection(), _ = document.createElement("span"), _.textContent = l, _.ariaHidden = "true", _.style.all = "unset", _.style.position = "fixed", _.style.top = 0, _.style.clip = "rect(0, 0, 0, 0)", _.style.whiteSpace = "pre", _.style.webkitUserSelect = "text", _.style.MozUserSelect = "text", _.style.msUserSelect = "text", _.style.userSelect = "text", _.addEventListener("copy", function(J) {
      if (J.stopPropagation(), t.format)
        if (J.preventDefault(), typeof J.clipboardData > "u") {
          s && console.warn("unable to use e.clipboardData"), s && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var Y = clipboardToIE11Formatting[t.format] || clipboardToIE11Formatting.default;
          window.clipboardData.setData(Y, l);
        } else
          J.clipboardData.clearData(), J.clipboardData.setData(t.format, l);
      t.onCopy && (J.preventDefault(), t.onCopy(J.clipboardData));
    }), document.body.appendChild(_), d.selectNodeContents(_), v.addRange(d);
    var z = document.execCommand("copy");
    if (!z)
      throw new Error("copy command was unsuccessful");
    T = !0;
  } catch (J) {
    s && console.error("unable to copy using execCommand: ", J), s && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(t.format || "text", l), t.onCopy && t.onCopy(window.clipboardData), T = !0;
    } catch (Y) {
      s && console.error("unable to copy using clipboardData: ", Y), s && console.error("falling back to prompt"), h = format$1("message" in t ? t.message : defaultMessage), window.prompt(h, l);
    }
  } finally {
    v && (typeof v.removeRange == "function" ? v.removeRange(d) : v.removeAllRanges()), _ && document.body.removeChild(_), m();
  }
  return T;
}
var copyToClipboard = copy$1, n, u$1, i$2, t$1, r$1, e$1 = {}, c$1 = [], s$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function a$1(l, t) {
  for (var s in t)
    l[s] = t[s];
  return l;
}
function v$1(l) {
  var t = l.parentNode;
  t && t.removeChild(l);
}
function h$1(l, t, s) {
  var h, m = arguments, d = {};
  for (h in t)
    h !== "key" && h !== "ref" && (d[h] = t[h]);
  if (arguments.length > 3)
    for (s = [s], h = 3; h < arguments.length; h++)
      s.push(m[h]);
  if (s != null && (d.children = s), typeof l == "function" && l.defaultProps != null)
    for (h in l.defaultProps)
      d[h] === void 0 && (d[h] = l.defaultProps[h]);
  return p$1(l, d, t && t.key, t && t.ref, null);
}
function p$1(l, t, s, h, m) {
  var d = { type: l, props: t, key: s, ref: h, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: m };
  return m == null && (d.__v = d), n.vnode && n.vnode(d), d;
}
function d$1(l) {
  return l.children;
}
function m$1(l, t) {
  this.props = l, this.context = t;
}
function w$2(l, t) {
  if (t == null)
    return l.__ ? w$2(l.__, l.__.__k.indexOf(l) + 1) : null;
  for (var s; t < l.__k.length; t++)
    if ((s = l.__k[t]) != null && s.__e != null)
      return s.__e;
  return typeof l.type == "function" ? w$2(l) : null;
}
function k$1(l) {
  var t, s;
  if ((l = l.__) != null && l.__c != null) {
    for (l.__e = l.__c.base = null, t = 0; t < l.__k.length; t++)
      if ((s = l.__k[t]) != null && s.__e != null) {
        l.__e = l.__c.base = s.__e;
        break;
      }
    return k$1(l);
  }
}
function g$1(l) {
  (!l.__d && (l.__d = !0) && u$1.push(l) && !i$2++ || r$1 !== n.debounceRendering) && ((r$1 = n.debounceRendering) || t$1)(_$2);
}
function _$2() {
  for (var l; i$2 = u$1.length; )
    l = u$1.sort(function(t, s) {
      return t.__v.__b - s.__v.__b;
    }), u$1 = [], l.some(function(t) {
      var s, h, m, d, v, _, T;
      t.__d && (_ = (v = (s = t).__v).__e, (T = s.__P) && (h = [], (m = a$1({}, v)).__v = m, d = A$2(T, v, m, s.__n, T.ownerSVGElement !== void 0, null, h, _ == null ? w$2(v) : _), T$2(h, v), d != _ && k$1(v)));
    });
}
function b(l, t, s, h, m, d, v, _, T) {
  var z, J, Y, ie, ne, de, ce, re = s && s.__k || c$1, oe = re.length;
  if (_ == e$1 && (_ = d != null ? d[0] : oe ? w$2(s, 0) : null), z = 0, t.__k = x$1(t.__k, function(pe) {
    if (pe != null) {
      if (pe.__ = t, pe.__b = t.__b + 1, (Y = re[z]) === null || Y && pe.key == Y.key && pe.type === Y.type)
        re[z] = void 0;
      else
        for (J = 0; J < oe; J++) {
          if ((Y = re[J]) && pe.key == Y.key && pe.type === Y.type) {
            re[J] = void 0;
            break;
          }
          Y = null;
        }
      if (ie = A$2(l, pe, Y = Y || e$1, h, m, d, v, _, T), (J = pe.ref) && Y.ref != J && (ce || (ce = []), Y.ref && ce.push(Y.ref, null, pe), ce.push(J, pe.__c || ie, pe)), ie != null) {
        var ae;
        if (de == null && (de = ie), pe.__d !== void 0)
          ae = pe.__d, pe.__d = void 0;
        else if (d == Y || ie != _ || ie.parentNode == null) {
          e:
            if (_ == null || _.parentNode !== l)
              l.appendChild(ie), ae = null;
            else {
              for (ne = _, J = 0; (ne = ne.nextSibling) && J < oe; J += 2)
                if (ne == ie)
                  break e;
              l.insertBefore(ie, _), ae = _;
            }
          t.type == "option" && (l.value = "");
        }
        _ = ae !== void 0 ? ae : ie.nextSibling, typeof t.type == "function" && (t.__d = _);
      } else
        _ && Y.__e == _ && _.parentNode != l && (_ = w$2(Y));
    }
    return z++, pe;
  }), t.__e = de, d != null && typeof t.type != "function")
    for (z = d.length; z--; )
      d[z] != null && v$1(d[z]);
  for (z = oe; z--; )
    re[z] != null && D$1(re[z], re[z]);
  if (ce)
    for (z = 0; z < ce.length; z++)
      j$1(ce[z], ce[++z], ce[++z]);
}
function x$1(l, t, s) {
  if (s == null && (s = []), l == null || typeof l == "boolean")
    t && s.push(t(null));
  else if (Array.isArray(l))
    for (var h = 0; h < l.length; h++)
      x$1(l[h], t, s);
  else
    s.push(t ? t(typeof l == "string" || typeof l == "number" ? p$1(null, l, null, null, l) : l.__e != null || l.__c != null ? p$1(l.type, l.props, l.key, null, l.__v) : l) : l);
  return s;
}
function P$1(l, t, s, h, m) {
  var d;
  for (d in s)
    d === "children" || d === "key" || d in t || N$1(l, d, null, s[d], h);
  for (d in t)
    m && typeof t[d] != "function" || d === "children" || d === "key" || d === "value" || d === "checked" || s[d] === t[d] || N$1(l, d, t[d], s[d], h);
}
function C$1(l, t, s) {
  t[0] === "-" ? l.setProperty(t, s) : l[t] = typeof s == "number" && s$1.test(t) === !1 ? s + "px" : s == null ? "" : s;
}
function N$1(l, t, s, h, m) {
  var d, v, _, T, z;
  if (m ? t === "className" && (t = "class") : t === "class" && (t = "className"), t === "style")
    if (d = l.style, typeof s == "string")
      d.cssText = s;
    else {
      if (typeof h == "string" && (d.cssText = "", h = null), h)
        for (T in h)
          s && T in s || C$1(d, T, "");
      if (s)
        for (z in s)
          h && s[z] === h[z] || C$1(d, z, s[z]);
    }
  else
    t[0] === "o" && t[1] === "n" ? (v = t !== (t = t.replace(/Capture$/, "")), _ = t.toLowerCase(), t = (_ in l ? _ : t).slice(2), s ? (h || l.addEventListener(t, z$1, v), (l.l || (l.l = {}))[t] = s) : l.removeEventListener(t, z$1, v)) : t !== "list" && t !== "tagName" && t !== "form" && t !== "type" && t !== "size" && !m && t in l ? l[t] = s == null ? "" : s : typeof s != "function" && t !== "dangerouslySetInnerHTML" && (t !== (t = t.replace(/^xlink:?/, "")) ? s == null || s === !1 ? l.removeAttributeNS("http://www.w3.org/1999/xlink", t.toLowerCase()) : l.setAttributeNS("http://www.w3.org/1999/xlink", t.toLowerCase(), s) : s == null || s === !1 && !/^ar/.test(t) ? l.removeAttribute(t) : l.setAttribute(t, s));
}
function z$1(l) {
  this.l[l.type](n.event ? n.event(l) : l);
}
function A$2(l, t, s, h, m, d, v, _, T) {
  var z, J, Y, ie, ne, de, ce, re, oe, pe, ae = t.type;
  if (t.constructor !== void 0)
    return null;
  (z = n.__b) && z(t);
  try {
    e:
      if (typeof ae == "function") {
        if (re = t.props, oe = (z = ae.contextType) && h[z.__c], pe = z ? oe ? oe.props.value : z.__ : h, s.__c ? ce = (J = t.__c = s.__c).__ = J.__E : ("prototype" in ae && ae.prototype.render ? t.__c = J = new ae(re, pe) : (t.__c = J = new m$1(re, pe), J.constructor = ae, J.render = E$2), oe && oe.sub(J), J.props = re, J.state || (J.state = {}), J.context = pe, J.__n = h, Y = J.__d = !0, J.__h = []), J.__s == null && (J.__s = J.state), ae.getDerivedStateFromProps != null && (J.__s == J.state && (J.__s = a$1({}, J.__s)), a$1(J.__s, ae.getDerivedStateFromProps(re, J.__s))), ie = J.props, ne = J.state, Y)
          ae.getDerivedStateFromProps == null && J.componentWillMount != null && J.componentWillMount(), J.componentDidMount != null && J.__h.push(J.componentDidMount);
        else {
          if (ae.getDerivedStateFromProps == null && re !== ie && J.componentWillReceiveProps != null && J.componentWillReceiveProps(re, pe), !J.__e && J.shouldComponentUpdate != null && J.shouldComponentUpdate(re, J.__s, pe) === !1 || t.__v === s.__v && !J.__) {
            for (J.props = re, J.state = J.__s, t.__v !== s.__v && (J.__d = !1), J.__v = t, t.__e = s.__e, t.__k = s.__k, J.__h.length && v.push(J), z = 0; z < t.__k.length; z++)
              t.__k[z] && (t.__k[z].__ = t);
            break e;
          }
          J.componentWillUpdate != null && J.componentWillUpdate(re, J.__s, pe), J.componentDidUpdate != null && J.__h.push(function() {
            J.componentDidUpdate(ie, ne, de);
          });
        }
        J.context = pe, J.props = re, J.state = J.__s, (z = n.__r) && z(t), J.__d = !1, J.__v = t, J.__P = l, z = J.render(J.props, J.state, J.context), t.__k = z != null && z.type == d$1 && z.key == null ? z.props.children : Array.isArray(z) ? z : [z], J.getChildContext != null && (h = a$1(a$1({}, h), J.getChildContext())), Y || J.getSnapshotBeforeUpdate == null || (de = J.getSnapshotBeforeUpdate(ie, ne)), b(l, t, s, h, m, d, v, _, T), J.base = t.__e, J.__h.length && v.push(J), ce && (J.__E = J.__ = null), J.__e = !1;
      } else
        d == null && t.__v === s.__v ? (t.__k = s.__k, t.__e = s.__e) : t.__e = $$1(s.__e, t, s, h, m, d, v, T);
    (z = n.diffed) && z(t);
  } catch (me) {
    t.__v = null, n.__e(me, t, s);
  }
  return t.__e;
}
function T$2(l, t) {
  n.__c && n.__c(t, l), l.some(function(s) {
    try {
      l = s.__h, s.__h = [], l.some(function(h) {
        h.call(s);
      });
    } catch (h) {
      n.__e(h, s.__v);
    }
  });
}
function $$1(l, t, s, h, m, d, v, _) {
  var T, z, J, Y, ie, ne = s.props, de = t.props;
  if (m = t.type === "svg" || m, d != null) {
    for (T = 0; T < d.length; T++)
      if ((z = d[T]) != null && ((t.type === null ? z.nodeType === 3 : z.localName === t.type) || l == z)) {
        l = z, d[T] = null;
        break;
      }
  }
  if (l == null) {
    if (t.type === null)
      return document.createTextNode(de);
    l = m ? document.createElementNS("http://www.w3.org/2000/svg", t.type) : document.createElement(t.type, de.is && { is: de.is }), d = null, _ = !1;
  }
  if (t.type === null)
    ne !== de && l.data != de && (l.data = de);
  else {
    if (d != null && (d = c$1.slice.call(l.childNodes)), J = (ne = s.props || e$1).dangerouslySetInnerHTML, Y = de.dangerouslySetInnerHTML, !_) {
      if (ne === e$1)
        for (ne = {}, ie = 0; ie < l.attributes.length; ie++)
          ne[l.attributes[ie].name] = l.attributes[ie].value;
      (Y || J) && (Y && J && Y.__html == J.__html || (l.innerHTML = Y && Y.__html || ""));
    }
    P$1(l, de, ne, m, _), Y ? t.__k = [] : (t.__k = t.props.children, b(l, t, s, h, t.type !== "foreignObject" && m, d, v, e$1, _)), _ || ("value" in de && (T = de.value) !== void 0 && T !== l.value && N$1(l, "value", T, ne.value, !1), "checked" in de && (T = de.checked) !== void 0 && T !== l.checked && N$1(l, "checked", T, ne.checked, !1));
  }
  return l;
}
function j$1(l, t, s) {
  try {
    typeof l == "function" ? l(t) : l.current = t;
  } catch (h) {
    n.__e(h, s);
  }
}
function D$1(l, t, s) {
  var h, m, d;
  if (n.unmount && n.unmount(l), (h = l.ref) && (h.current && h.current !== l.__e || j$1(h, null, t)), s || typeof l.type == "function" || (s = (m = l.__e) != null), l.__e = l.__d = void 0, (h = l.__c) != null) {
    if (h.componentWillUnmount)
      try {
        h.componentWillUnmount();
      } catch (v) {
        n.__e(v, t);
      }
    h.base = h.__P = null;
  }
  if (h = l.__k)
    for (d = 0; d < h.length; d++)
      h[d] && D$1(h[d], t, s);
  m != null && v$1(m);
}
function E$2(l, t, s) {
  return this.constructor(l, s);
}
n = { __e: function(l, t) {
  for (var s, h; t = t.__; )
    if ((s = t.__c) && !s.__)
      try {
        if (s.constructor && s.constructor.getDerivedStateFromError != null && (h = !0, s.setState(s.constructor.getDerivedStateFromError(l))), s.componentDidCatch != null && (h = !0, s.componentDidCatch(l)), h)
          return g$1(s.__E = s);
      } catch (m) {
        l = m;
      }
  throw l;
} }, m$1.prototype.setState = function(l, t) {
  var s;
  s = this.__s !== this.state ? this.__s : this.__s = a$1({}, this.state), typeof l == "function" && (l = l(s, this.props)), l && a$1(s, l), l != null && this.__v && (t && this.__h.push(t), g$1(this));
}, m$1.prototype.forceUpdate = function(l) {
  this.__v && (this.__e = !0, l && this.__h.push(l), g$1(this));
}, m$1.prototype.render = d$1, u$1 = [], i$2 = 0, t$1 = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout;
var u, r, o = [], c = n.__r, f$1 = n.diffed, e = n.__c, a = n.unmount;
function _$1() {
  o.some(function(l) {
    if (l.__P)
      try {
        l.__H.__h.forEach(g), l.__H.__h.forEach(q$1), l.__H.__h = [];
      } catch (t) {
        return l.__H.__h = [], n.__e(t, l.__v), !0;
      }
  }), o = [];
}
function g(l) {
  l.t && l.t();
}
function q$1(l) {
  var t = l.__();
  typeof t == "function" && (l.t = t);
}
n.__r = function(l) {
  c && c(l), (u = l.__c).__H && (u.__H.__h.forEach(g), u.__H.__h.forEach(q$1), u.__H.__h = []);
}, n.diffed = function(l) {
  f$1 && f$1(l);
  var t = l.__c;
  if (t) {
    var s = t.__H;
    s && s.__h.length && (o.push(t) !== 1 && r === n.requestAnimationFrame || ((r = n.requestAnimationFrame) || function(h) {
      var m, d = function() {
        clearTimeout(v), cancelAnimationFrame(m), setTimeout(h);
      }, v = setTimeout(d, 100);
      typeof window < "u" && (m = requestAnimationFrame(d));
    })(_$1));
  }
}, n.__c = function(l, t) {
  t.some(function(s) {
    try {
      s.__h.forEach(g), s.__h = s.__h.filter(function(h) {
        return !h.__ || q$1(h);
      });
    } catch (h) {
      t.some(function(m) {
        m.__h && (m.__h = []);
      }), t = [], n.__e(h, s.__v);
    }
  }), e && e(l, t);
}, n.unmount = function(l) {
  a && a(l);
  var t = l.__c;
  if (t) {
    var s = t.__H;
    if (s)
      try {
        s.__.forEach(function(h) {
          return h.t && h.t();
        });
      } catch (h) {
        n.__e(h, t.__v);
      }
  }
};
function E(l, t) {
  for (var s in t)
    l[s] = t[s];
  return l;
}
function w(l, t) {
  for (var s in l)
    if (s !== "__source" && !(s in t))
      return !0;
  for (var h in t)
    if (h !== "__source" && l[h] !== t[h])
      return !0;
  return !1;
}
(function(l) {
  var t, s;
  function h(m) {
    var d;
    return (d = l.call(this, m) || this).isPureReactComponent = !0, d;
  }
  return s = l, (t = h).prototype = Object.create(s.prototype), t.prototype.constructor = t, t.__proto__ = s, h.prototype.shouldComponentUpdate = function(m, d) {
    return w(this.props, m) || w(this.state, d);
  }, h;
})(m$1);
var A = n.__b;
n.__b = function(l) {
  l.type && l.type.t && l.ref && (l.props.ref = l.ref, l.ref = null), A && A(l);
};
var F = n.__e;
function N(l) {
  return l && ((l = E({}, l)).__c = null, l.__k = l.__k && l.__k.map(N)), l;
}
function U() {
  this.__u = 0, this.o = null, this.__b = null;
}
function M(l) {
  var t = l.__.__c;
  return t && t.u && t.u(l);
}
function O() {
  this.i = null, this.l = null;
}
n.__e = function(l, t, s) {
  if (l.then) {
    for (var h, m = t; m = m.__; )
      if ((h = m.__c) && h.__c)
        return h.__c(l, t.__c);
  }
  F(l, t, s);
}, (U.prototype = new m$1()).__c = function(l, t) {
  var s = this;
  s.o == null && (s.o = []), s.o.push(t);
  var h = M(s.__v), m = !1, d = function() {
    m || (m = !0, h ? h(v) : v());
  };
  t.__c = t.componentWillUnmount, t.componentWillUnmount = function() {
    d(), t.__c && t.__c();
  };
  var v = function() {
    var _;
    if (!--s.__u)
      for (s.__v.__k[0] = s.state.u, s.setState({ u: s.__b = null }); _ = s.o.pop(); )
        _.forceUpdate();
  };
  s.__u++ || s.setState({ u: s.__b = s.__v.__k[0] }), l.then(d, d);
}, U.prototype.render = function(l, t) {
  return this.__b && (this.__v.__k[0] = N(this.__b), this.__b = null), [h$1(m$1, null, t.u ? null : l.children), t.u && l.fallback];
};
var P = function(l, t, s) {
  if (++s[1] === s[0] && l.l.delete(t), l.props.revealOrder && (l.props.revealOrder[0] !== "t" || !l.l.size))
    for (s = l.i; s; ) {
      for (; s.length > 3; )
        s.pop()();
      if (s[1] < s[0])
        break;
      l.i = s = s[2];
    }
};
(O.prototype = new m$1()).u = function(l) {
  var t = this, s = M(t.__v), h = t.l.get(l);
  return h[0]++, function(m) {
    var d = function() {
      t.props.revealOrder ? (h.push(m), P(t, l, h)) : m();
    };
    s ? s(d) : d();
  };
}, O.prototype.render = function(l) {
  this.i = null, this.l = /* @__PURE__ */ new Map();
  var t = x$1(l.children);
  l.revealOrder && l.revealOrder[0] === "b" && t.reverse();
  for (var s = t.length; s--; )
    this.l.set(t[s], this.i = [1, 0, this.i]);
  return l.children;
}, O.prototype.componentDidUpdate = O.prototype.componentDidMount = function() {
  var l = this;
  l.l.forEach(function(t, s) {
    P(l, s, t);
  });
};
var D = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
m$1.prototype.isReactComponent = {};
var H = typeof Symbol < "u" && Symbol.for && Symbol.for("react.element") || 60103, Z = n.event;
function I(l, t) {
  l["UNSAFE_" + t] && !l[t] && Object.defineProperty(l, t, { configurable: !1, get: function() {
    return this["UNSAFE_" + t];
  }, set: function(s) {
    this["UNSAFE_" + t] = s;
  } });
}
n.event = function(l) {
  Z && (l = Z(l)), l.persist = function() {
  };
  var t = !1, s = !1, h = l.stopPropagation;
  l.stopPropagation = function() {
    h.call(l), t = !0;
  };
  var m = l.preventDefault;
  return l.preventDefault = function() {
    m.call(l), s = !0;
  }, l.isPropagationStopped = function() {
    return t;
  }, l.isDefaultPrevented = function() {
    return s;
  }, l.nativeEvent = l;
};
var $ = { configurable: !0, get: function() {
  return this.class;
} }, q = n.vnode;
n.vnode = function(l) {
  l.$$typeof = H;
  var t = l.type, s = l.props;
  if (t) {
    if (s.class != s.className && ($.enumerable = "className" in s, s.className != null && (s.class = s.className), Object.defineProperty(s, "className", $)), typeof t != "function") {
      var h, m, d;
      for (d in s.defaultValue && s.value !== void 0 && (s.value || s.value === 0 || (s.value = s.defaultValue), delete s.defaultValue), Array.isArray(s.value) && s.multiple && t === "select" && (x$1(s.children).forEach(function(v) {
        s.value.indexOf(v.props.value) != -1 && (v.props.selected = !0);
      }), delete s.value), s)
        if (h = D.test(d))
          break;
      if (h)
        for (d in m = l.props = {}, s)
          m[D.test(d) ? d.replace(/[A-Z0-9]/, "-$&").toLowerCase() : d] = s[d];
    }
    (function(v) {
      var _ = l.type, T = l.props;
      if (T && typeof _ == "string") {
        var z = {};
        for (var J in T)
          /^on(Ani|Tra|Tou)/.test(J) && (T[J.toLowerCase()] = T[J], delete T[J]), z[J.toLowerCase()] = J;
        if (z.ondoubleclick && (T.ondblclick = T[z.ondoubleclick], delete T[z.ondoubleclick]), z.onbeforeinput && (T.onbeforeinput = T[z.onbeforeinput], delete T[z.onbeforeinput]), z.onchange && (_ === "textarea" || _.toLowerCase() === "input" && !/^fil|che|ra/i.test(T.type))) {
          var Y = z.oninput || "oninput";
          T[Y] || (T[Y] = T[z.onchange], delete T[z.onchange]);
        }
      }
    })(), typeof t == "function" && !t.m && t.prototype && (I(t.prototype, "componentWillMount"), I(t.prototype, "componentWillReceiveProps"), I(t.prototype, "componentWillUpdate"), t.m = !0);
  }
  q && q(l);
};
function _interopDefault(l) {
  return l && typeof l == "object" && "default" in l ? l.default : l;
}
_interopDefault(browser$4);
_interopDefault(copyToClipboard);
typeof Symbol < "u" && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")));
typeof Symbol < "u" && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
var eventemitter3 = { exports: {} };
(function(l) {
  var t = Object.prototype.hasOwnProperty, s = "~";
  function h() {
  }
  Object.create && (h.prototype = /* @__PURE__ */ Object.create(null), new h().__proto__ || (s = !1));
  function m(T, z, J) {
    this.fn = T, this.context = z, this.once = J || !1;
  }
  function d(T, z, J, Y, ie) {
    if (typeof J != "function")
      throw new TypeError("The listener must be a function");
    var ne = new m(J, Y || T, ie), de = s ? s + z : z;
    return T._events[de] ? T._events[de].fn ? T._events[de] = [T._events[de], ne] : T._events[de].push(ne) : (T._events[de] = ne, T._eventsCount++), T;
  }
  function v(T, z) {
    --T._eventsCount === 0 ? T._events = new h() : delete T._events[z];
  }
  function _() {
    this._events = new h(), this._eventsCount = 0;
  }
  _.prototype.eventNames = function() {
    var z = [], J, Y;
    if (this._eventsCount === 0)
      return z;
    for (Y in J = this._events)
      t.call(J, Y) && z.push(s ? Y.slice(1) : Y);
    return Object.getOwnPropertySymbols ? z.concat(Object.getOwnPropertySymbols(J)) : z;
  }, _.prototype.listeners = function(z) {
    var J = s ? s + z : z, Y = this._events[J];
    if (!Y)
      return [];
    if (Y.fn)
      return [Y.fn];
    for (var ie = 0, ne = Y.length, de = new Array(ne); ie < ne; ie++)
      de[ie] = Y[ie].fn;
    return de;
  }, _.prototype.listenerCount = function(z) {
    var J = s ? s + z : z, Y = this._events[J];
    return Y ? Y.fn ? 1 : Y.length : 0;
  }, _.prototype.emit = function(z, J, Y, ie, ne, de) {
    var ce = s ? s + z : z;
    if (!this._events[ce])
      return !1;
    var re = this._events[ce], oe = arguments.length, pe, ae;
    if (re.fn) {
      switch (re.once && this.removeListener(z, re.fn, void 0, !0), oe) {
        case 1:
          return re.fn.call(re.context), !0;
        case 2:
          return re.fn.call(re.context, J), !0;
        case 3:
          return re.fn.call(re.context, J, Y), !0;
        case 4:
          return re.fn.call(re.context, J, Y, ie), !0;
        case 5:
          return re.fn.call(re.context, J, Y, ie, ne), !0;
        case 6:
          return re.fn.call(re.context, J, Y, ie, ne, de), !0;
      }
      for (ae = 1, pe = new Array(oe - 1); ae < oe; ae++)
        pe[ae - 1] = arguments[ae];
      re.fn.apply(re.context, pe);
    } else {
      var me = re.length, ge;
      for (ae = 0; ae < me; ae++)
        switch (re[ae].once && this.removeListener(z, re[ae].fn, void 0, !0), oe) {
          case 1:
            re[ae].fn.call(re[ae].context);
            break;
          case 2:
            re[ae].fn.call(re[ae].context, J);
            break;
          case 3:
            re[ae].fn.call(re[ae].context, J, Y);
            break;
          case 4:
            re[ae].fn.call(re[ae].context, J, Y, ie);
            break;
          default:
            if (!pe)
              for (ge = 1, pe = new Array(oe - 1); ge < oe; ge++)
                pe[ge - 1] = arguments[ge];
            re[ae].fn.apply(re[ae].context, pe);
        }
    }
    return !0;
  }, _.prototype.on = function(z, J, Y) {
    return d(this, z, J, Y, !1);
  }, _.prototype.once = function(z, J, Y) {
    return d(this, z, J, Y, !0);
  }, _.prototype.removeListener = function(z, J, Y, ie) {
    var ne = s ? s + z : z;
    if (!this._events[ne])
      return this;
    if (!J)
      return v(this, ne), this;
    var de = this._events[ne];
    if (de.fn)
      de.fn === J && (!ie || de.once) && (!Y || de.context === Y) && v(this, ne);
    else {
      for (var ce = 0, re = [], oe = de.length; ce < oe; ce++)
        (de[ce].fn !== J || ie && !de[ce].once || Y && de[ce].context !== Y) && re.push(de[ce]);
      re.length ? this._events[ne] = re.length === 1 ? re[0] : re : v(this, ne);
    }
    return this;
  }, _.prototype.removeAllListeners = function(z) {
    var J;
    return z ? (J = s ? s + z : z, this._events[J] && v(this, J)) : (this._events = new h(), this._eventsCount = 0), this;
  }, _.prototype.off = _.prototype.removeListener, _.prototype.addListener = _.prototype.on, _.prefixed = s, _.EventEmitter = _, l.exports = _;
})(eventemitter3);
eventemitter3.exports;
var dist$2 = {}, xmlHttpRequest = {}, url$1 = {}, punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.3.2 by @mathias */
(function(l, t) {
  (function(s) {
    var h = t && !t.nodeType && t, m = l && !l.nodeType && l, d = typeof commonjsGlobal == "object" && commonjsGlobal;
    (d.global === d || d.window === d || d.self === d) && (s = d);
    var v, _ = 2147483647, T = 36, z = 1, J = 26, Y = 38, ie = 700, ne = 72, de = 128, ce = "-", re = /^xn--/, oe = /[^\x20-\x7E]/, pe = /[\x2E\u3002\uFF0E\uFF61]/g, ae = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, me = T - z, ge = Math.floor, we = String.fromCharCode, Ee;
    function Te(G) {
      throw RangeError(ae[G]);
    }
    function Ke(G, R) {
      for (var y = G.length, j = []; y--; )
        j[y] = R(G[y]);
      return j;
    }
    function Se(G, R) {
      var y = G.split("@"), j = "";
      y.length > 1 && (j = y[0] + "@", G = y[1]), G = G.replace(pe, ".");
      var ye = G.split("."), ee = Ke(ye, R).join(".");
      return j + ee;
    }
    function X(G) {
      for (var R = [], y = 0, j = G.length, ye, ee; y < j; )
        ye = G.charCodeAt(y++), ye >= 55296 && ye <= 56319 && y < j ? (ee = G.charCodeAt(y++), (ee & 64512) == 56320 ? R.push(((ye & 1023) << 10) + (ee & 1023) + 65536) : (R.push(ye), y--)) : R.push(ye);
      return R;
    }
    function fe(G) {
      return Ke(G, function(R) {
        var y = "";
        return R > 65535 && (R -= 65536, y += we(R >>> 10 & 1023 | 55296), R = 56320 | R & 1023), y += we(R), y;
      }).join("");
    }
    function k(G) {
      return G - 48 < 10 ? G - 22 : G - 65 < 26 ? G - 65 : G - 97 < 26 ? G - 97 : T;
    }
    function p(G, R) {
      return G + 22 + 75 * (G < 26) - ((R != 0) << 5);
    }
    function x(G, R, y) {
      var j = 0;
      for (G = y ? ge(G / ie) : G >> 1, G += ge(G / R); G > me * J >> 1; j += T)
        G = ge(G / me);
      return ge(j + (me + 1) * G / (G + Y));
    }
    function S(G) {
      var R = [], y = G.length, j, ye = 0, ee = de, xe = ne, $e, ke, Ce, ht, Ue, De, wt, He, Ze;
      for ($e = G.lastIndexOf(ce), $e < 0 && ($e = 0), ke = 0; ke < $e; ++ke)
        G.charCodeAt(ke) >= 128 && Te("not-basic"), R.push(G.charCodeAt(ke));
      for (Ce = $e > 0 ? $e + 1 : 0; Ce < y; ) {
        for (ht = ye, Ue = 1, De = T; Ce >= y && Te("invalid-input"), wt = k(G.charCodeAt(Ce++)), (wt >= T || wt > ge((_ - ye) / Ue)) && Te("overflow"), ye += wt * Ue, He = De <= xe ? z : De >= xe + J ? J : De - xe, !(wt < He); De += T)
          Ze = T - He, Ue > ge(_ / Ze) && Te("overflow"), Ue *= Ze;
        j = R.length + 1, xe = x(ye - ht, j, ht == 0), ge(ye / j) > _ - ee && Te("overflow"), ee += ge(ye / j), ye %= j, R.splice(ye++, 0, ee);
      }
      return fe(R);
    }
    function B(G) {
      var R, y, j, ye, ee, xe, $e, ke, Ce, ht, Ue, De = [], wt, He, Ze, Ie;
      for (G = X(G), wt = G.length, R = de, y = 0, ee = ne, xe = 0; xe < wt; ++xe)
        Ue = G[xe], Ue < 128 && De.push(we(Ue));
      for (j = ye = De.length, ye && De.push(ce); j < wt; ) {
        for ($e = _, xe = 0; xe < wt; ++xe)
          Ue = G[xe], Ue >= R && Ue < $e && ($e = Ue);
        for (He = j + 1, $e - R > ge((_ - y) / He) && Te("overflow"), y += ($e - R) * He, R = $e, xe = 0; xe < wt; ++xe)
          if (Ue = G[xe], Ue < R && ++y > _ && Te("overflow"), Ue == R) {
            for (ke = y, Ce = T; ht = Ce <= ee ? z : Ce >= ee + J ? J : Ce - ee, !(ke < ht); Ce += T)
              Ie = ke - ht, Ze = T - ht, De.push(
                we(p(ht + Ie % Ze, 0))
              ), ke = ge(Ie / Ze);
            De.push(we(p(ke, 0))), ee = x(y, He, j == ye), y = 0, ++j;
          }
        ++y, ++R;
      }
      return De.join("");
    }
    function L(G) {
      return Se(G, function(R) {
        return re.test(R) ? S(R.slice(4).toLowerCase()) : R;
      });
    }
    function C(G) {
      return Se(G, function(R) {
        return oe.test(R) ? "xn--" + B(R) : R;
      });
    }
    if (v = {
      version: "1.3.2",
      ucs2: {
        decode: X,
        encode: fe
      },
      decode: S,
      encode: B,
      toASCII: C,
      toUnicode: L
    }, h && m)
      if (l.exports == h)
        m.exports = v;
      else
        for (Ee in v)
          v.hasOwnProperty(Ee) && (h[Ee] = v[Ee]);
    else
      s.punycode = v;
  })(commonjsGlobal);
})(punycode$1, punycode$1.exports);
var util$1 = {
  isString: function(l) {
    return typeof l == "string";
  },
  isObject: function(l) {
    return typeof l == "object" && l !== null;
  },
  isNull: function(l) {
    return l === null;
  },
  isNullOrUndefined: function(l) {
    return l == null;
  }
}, querystring$1 = {};
function hasOwnProperty(l, t) {
  return Object.prototype.hasOwnProperty.call(l, t);
}
var decode = function(l, t, s, h) {
  t = t || "&", s = s || "=";
  var m = {};
  if (typeof l != "string" || l.length === 0)
    return m;
  var d = /\+/g;
  l = l.split(t);
  var v = 1e3;
  h && typeof h.maxKeys == "number" && (v = h.maxKeys);
  var _ = l.length;
  v > 0 && _ > v && (_ = v);
  for (var T = 0; T < _; ++T) {
    var z = l[T].replace(d, "%20"), J = z.indexOf(s), Y, ie, ne, de;
    J >= 0 ? (Y = z.substr(0, J), ie = z.substr(J + 1)) : (Y = z, ie = ""), ne = decodeURIComponent(Y), de = decodeURIComponent(ie), hasOwnProperty(m, ne) ? Array.isArray(m[ne]) ? m[ne].push(de) : m[ne] = [m[ne], de] : m[ne] = de;
  }
  return m;
}, stringifyPrimitive = function(l) {
  switch (typeof l) {
    case "string":
      return l;
    case "boolean":
      return l ? "true" : "false";
    case "number":
      return isFinite(l) ? l : "";
    default:
      return "";
  }
}, encode = function(l, t, s, h) {
  return t = t || "&", s = s || "=", l === null && (l = void 0), typeof l == "object" ? Object.keys(l).map(function(m) {
    var d = encodeURIComponent(stringifyPrimitive(m)) + s;
    return Array.isArray(l[m]) ? l[m].map(function(v) {
      return d + encodeURIComponent(stringifyPrimitive(v));
    }).join(t) : d + encodeURIComponent(stringifyPrimitive(l[m]));
  }).join(t) : h ? encodeURIComponent(stringifyPrimitive(h)) + s + encodeURIComponent(stringifyPrimitive(l)) : "";
};
querystring$1.decode = querystring$1.parse = decode;
querystring$1.encode = querystring$1.stringify = encode;
var punycode = punycode$1.exports, util = util$1;
url$1.parse = urlParse;
url$1.resolve = urlResolve;
url$1.resolveObject = urlResolveObject;
url$1.format = urlFormat;
url$1.Url = Url;
function Url() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", `
`, "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  javascript: !0,
  "javascript:": !0
}, hostlessProtocol = {
  javascript: !0,
  "javascript:": !0
}, slashedProtocol = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, querystring = querystring$1;
function urlParse(l, t, s) {
  if (l && util.isObject(l) && l instanceof Url)
    return l;
  var h = new Url();
  return h.parse(l, t, s), h;
}
Url.prototype.parse = function(l, t, s) {
  if (!util.isString(l))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof l);
  var h = l.indexOf("?"), m = h !== -1 && h < l.indexOf("#") ? "?" : "#", d = l.split(m), v = /\\/g;
  d[0] = d[0].replace(v, "/"), l = d.join(m);
  var _ = l;
  if (_ = _.trim(), !s && l.split("#").length === 1) {
    var T = simplePathPattern.exec(_);
    if (T)
      return this.path = _, this.href = _, this.pathname = T[1], T[2] ? (this.search = T[2], t ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
  }
  var z = protocolPattern.exec(_);
  if (z) {
    z = z[0];
    var J = z.toLowerCase();
    this.protocol = J, _ = _.substr(z.length);
  }
  if (s || z || _.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var Y = _.substr(0, 2) === "//";
    Y && !(z && hostlessProtocol[z]) && (_ = _.substr(2), this.slashes = !0);
  }
  if (!hostlessProtocol[z] && (Y || z && !slashedProtocol[z])) {
    for (var ie = -1, ne = 0; ne < hostEndingChars.length; ne++) {
      var de = _.indexOf(hostEndingChars[ne]);
      de !== -1 && (ie === -1 || de < ie) && (ie = de);
    }
    var ce, re;
    ie === -1 ? re = _.lastIndexOf("@") : re = _.lastIndexOf("@", ie), re !== -1 && (ce = _.slice(0, re), _ = _.slice(re + 1), this.auth = decodeURIComponent(ce)), ie = -1;
    for (var ne = 0; ne < nonHostChars.length; ne++) {
      var de = _.indexOf(nonHostChars[ne]);
      de !== -1 && (ie === -1 || de < ie) && (ie = de);
    }
    ie === -1 && (ie = _.length), this.host = _.slice(0, ie), _ = _.slice(ie), this.parseHost(), this.hostname = this.hostname || "";
    var oe = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!oe)
      for (var pe = this.hostname.split(/\./), ne = 0, ae = pe.length; ne < ae; ne++) {
        var me = pe[ne];
        if (!!me && !me.match(hostnamePartPattern)) {
          for (var ge = "", we = 0, Ee = me.length; we < Ee; we++)
            me.charCodeAt(we) > 127 ? ge += "x" : ge += me[we];
          if (!ge.match(hostnamePartPattern)) {
            var Te = pe.slice(0, ne), Ke = pe.slice(ne + 1), Se = me.match(hostnamePartStart);
            Se && (Te.push(Se[1]), Ke.unshift(Se[2])), Ke.length && (_ = "/" + Ke.join(".") + _), this.hostname = Te.join(".");
            break;
          }
        }
      }
    this.hostname.length > hostnameMaxLen ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), oe || (this.hostname = punycode.toASCII(this.hostname));
    var X = this.port ? ":" + this.port : "", fe = this.hostname || "";
    this.host = fe + X, this.href += this.host, oe && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), _[0] !== "/" && (_ = "/" + _));
  }
  if (!unsafeProtocol[J])
    for (var ne = 0, ae = autoEscape.length; ne < ae; ne++) {
      var k = autoEscape[ne];
      if (_.indexOf(k) !== -1) {
        var p = encodeURIComponent(k);
        p === k && (p = escape(k)), _ = _.split(k).join(p);
      }
    }
  var x = _.indexOf("#");
  x !== -1 && (this.hash = _.substr(x), _ = _.slice(0, x));
  var S = _.indexOf("?");
  if (S !== -1 ? (this.search = _.substr(S), this.query = _.substr(S + 1), t && (this.query = querystring.parse(this.query)), _ = _.slice(0, S)) : t && (this.search = "", this.query = {}), _ && (this.pathname = _), slashedProtocol[J] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var X = this.pathname || "", B = this.search || "";
    this.path = X + B;
  }
  return this.href = this.format(), this;
};
function urlFormat(l) {
  return util.isString(l) && (l = urlParse(l)), l instanceof Url ? l.format() : Url.prototype.format.call(l);
}
Url.prototype.format = function() {
  var l = this.auth || "";
  l && (l = encodeURIComponent(l), l = l.replace(/%3A/i, ":"), l += "@");
  var t = this.protocol || "", s = this.pathname || "", h = this.hash || "", m = !1, d = "";
  this.host ? m = l + this.host : this.hostname && (m = l + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (m += ":" + this.port)), this.query && util.isObject(this.query) && Object.keys(this.query).length && (d = querystring.stringify(this.query));
  var v = this.search || d && "?" + d || "";
  return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || slashedProtocol[t]) && m !== !1 ? (m = "//" + (m || ""), s && s.charAt(0) !== "/" && (s = "/" + s)) : m || (m = ""), h && h.charAt(0) !== "#" && (h = "#" + h), v && v.charAt(0) !== "?" && (v = "?" + v), s = s.replace(/[?#]/g, function(_) {
    return encodeURIComponent(_);
  }), v = v.replace("#", "%23"), t + m + s + v + h;
};
function urlResolve(l, t) {
  return urlParse(l, !1, !0).resolve(t);
}
Url.prototype.resolve = function(l) {
  return this.resolveObject(urlParse(l, !1, !0)).format();
};
function urlResolveObject(l, t) {
  return l ? urlParse(l, !1, !0).resolveObject(t) : t;
}
Url.prototype.resolveObject = function(l) {
  if (util.isString(l)) {
    var t = new Url();
    t.parse(l, !1, !0), l = t;
  }
  for (var s = new Url(), h = Object.keys(this), m = 0; m < h.length; m++) {
    var d = h[m];
    s[d] = this[d];
  }
  if (s.hash = l.hash, l.href === "")
    return s.href = s.format(), s;
  if (l.slashes && !l.protocol) {
    for (var v = Object.keys(l), _ = 0; _ < v.length; _++) {
      var T = v[_];
      T !== "protocol" && (s[T] = l[T]);
    }
    return slashedProtocol[s.protocol] && s.hostname && !s.pathname && (s.path = s.pathname = "/"), s.href = s.format(), s;
  }
  if (l.protocol && l.protocol !== s.protocol) {
    if (!slashedProtocol[l.protocol]) {
      for (var z = Object.keys(l), J = 0; J < z.length; J++) {
        var Y = z[J];
        s[Y] = l[Y];
      }
      return s.href = s.format(), s;
    }
    if (s.protocol = l.protocol, !l.host && !hostlessProtocol[l.protocol]) {
      for (var ae = (l.pathname || "").split("/"); ae.length && !(l.host = ae.shift()); )
        ;
      l.host || (l.host = ""), l.hostname || (l.hostname = ""), ae[0] !== "" && ae.unshift(""), ae.length < 2 && ae.unshift(""), s.pathname = ae.join("/");
    } else
      s.pathname = l.pathname;
    if (s.search = l.search, s.query = l.query, s.host = l.host || "", s.auth = l.auth, s.hostname = l.hostname || l.host, s.port = l.port, s.pathname || s.search) {
      var ie = s.pathname || "", ne = s.search || "";
      s.path = ie + ne;
    }
    return s.slashes = s.slashes || l.slashes, s.href = s.format(), s;
  }
  var de = s.pathname && s.pathname.charAt(0) === "/", ce = l.host || l.pathname && l.pathname.charAt(0) === "/", re = ce || de || s.host && l.pathname, oe = re, pe = s.pathname && s.pathname.split("/") || [], ae = l.pathname && l.pathname.split("/") || [], me = s.protocol && !slashedProtocol[s.protocol];
  if (me && (s.hostname = "", s.port = null, s.host && (pe[0] === "" ? pe[0] = s.host : pe.unshift(s.host)), s.host = "", l.protocol && (l.hostname = null, l.port = null, l.host && (ae[0] === "" ? ae[0] = l.host : ae.unshift(l.host)), l.host = null), re = re && (ae[0] === "" || pe[0] === "")), ce)
    s.host = l.host || l.host === "" ? l.host : s.host, s.hostname = l.hostname || l.hostname === "" ? l.hostname : s.hostname, s.search = l.search, s.query = l.query, pe = ae;
  else if (ae.length)
    pe || (pe = []), pe.pop(), pe = pe.concat(ae), s.search = l.search, s.query = l.query;
  else if (!util.isNullOrUndefined(l.search)) {
    if (me) {
      s.hostname = s.host = pe.shift();
      var ge = s.host && s.host.indexOf("@") > 0 ? s.host.split("@") : !1;
      ge && (s.auth = ge.shift(), s.host = s.hostname = ge.shift());
    }
    return s.search = l.search, s.query = l.query, (!util.isNull(s.pathname) || !util.isNull(s.search)) && (s.path = (s.pathname ? s.pathname : "") + (s.search ? s.search : "")), s.href = s.format(), s;
  }
  if (!pe.length)
    return s.pathname = null, s.search ? s.path = "/" + s.search : s.path = null, s.href = s.format(), s;
  for (var we = pe.slice(-1)[0], Ee = (s.host || l.host || pe.length > 1) && (we === "." || we === "..") || we === "", Te = 0, Ke = pe.length; Ke >= 0; Ke--)
    we = pe[Ke], we === "." ? pe.splice(Ke, 1) : we === ".." ? (pe.splice(Ke, 1), Te++) : Te && (pe.splice(Ke, 1), Te--);
  if (!re && !oe)
    for (; Te--; Te)
      pe.unshift("..");
  re && pe[0] !== "" && (!pe[0] || pe[0].charAt(0) !== "/") && pe.unshift(""), Ee && pe.join("/").substr(-1) !== "/" && pe.push("");
  var Se = pe[0] === "" || pe[0] && pe[0].charAt(0) === "/";
  if (me) {
    s.hostname = s.host = Se ? "" : pe.length ? pe.shift() : "";
    var ge = s.host && s.host.indexOf("@") > 0 ? s.host.split("@") : !1;
    ge && (s.auth = ge.shift(), s.host = s.hostname = ge.shift());
  }
  return re = re || s.host && pe.length, re && !Se && pe.unshift(""), pe.length ? s.pathname = pe.join("/") : (s.pathname = null, s.path = null), (!util.isNull(s.pathname) || !util.isNull(s.search)) && (s.path = (s.pathname ? s.pathname : "") + (s.search ? s.search : "")), s.auth = l.auth || s.auth, s.slashes = s.slashes || l.slashes, s.href = s.format(), s;
};
Url.prototype.parseHost = function() {
  var l = this.host, t = portPattern.exec(l);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), l = l.substr(0, l.length - t.length)), l && (this.hostname = l);
};
var progressEvent = {};
Object.defineProperty(progressEvent, "__esModule", { value: !0 });
var ProgressEvent = function() {
  function l(t) {
    this.type = t, this.bubbles = !1, this.cancelable = !1, this.loaded = 0, this.lengthComputable = !1, this.total = 0;
  }
  return l;
}();
progressEvent.ProgressEvent = ProgressEvent;
var errors$1 = {}, __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
    t.__proto__ = s;
  } || function(t, s) {
    for (var h in s)
      s.hasOwnProperty(h) && (t[h] = s[h]);
  };
  return function(t, s) {
    l(t, s);
    function h() {
      this.constructor = t;
    }
    t.prototype = s === null ? Object.create(s) : (h.prototype = s.prototype, new h());
  };
}();
Object.defineProperty(errors$1, "__esModule", { value: !0 });
var SecurityError = function(l) {
  __extends$2(t, l);
  function t() {
    return l !== null && l.apply(this, arguments) || this;
  }
  return t;
}(Error);
errors$1.SecurityError = SecurityError;
var InvalidStateError = function(l) {
  __extends$2(t, l);
  function t() {
    return l !== null && l.apply(this, arguments) || this;
  }
  return t;
}(Error);
errors$1.InvalidStateError = InvalidStateError;
var NetworkError = function(l) {
  __extends$2(t, l);
  function t() {
    return l !== null && l.apply(this, arguments) || this;
  }
  return t;
}(Error);
errors$1.NetworkError = NetworkError;
var SyntaxError = function(l) {
  __extends$2(t, l);
  function t() {
    return l !== null && l.apply(this, arguments) || this;
  }
  return t;
}(Error);
errors$1.SyntaxError = SyntaxError;
var xmlHttpRequestEventTarget = {};
Object.defineProperty(xmlHttpRequestEventTarget, "__esModule", { value: !0 });
var XMLHttpRequestEventTarget = function() {
  function l() {
    this.listeners = {};
  }
  return l.prototype.addEventListener = function(t, s) {
    t = t.toLowerCase(), this.listeners[t] = this.listeners[t] || [], this.listeners[t].push(s.handleEvent || s);
  }, l.prototype.removeEventListener = function(t, s) {
    if (t = t.toLowerCase(), !!this.listeners[t]) {
      var h = this.listeners[t].indexOf(s.handleEvent || s);
      h < 0 || this.listeners[t].splice(h, 1);
    }
  }, l.prototype.dispatchEvent = function(t) {
    var s = t.type.toLowerCase();
    if (t.target = this, this.listeners[s])
      for (var h = 0, m = this.listeners[s]; h < m.length; h++) {
        var d = m[h];
        d.call(this, t);
      }
    var v = this["on" + s];
    return v && v.call(this, t), !0;
  }, l;
}();
xmlHttpRequestEventTarget.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;
var xmlHttpRequestUpload = {}, __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
    t.__proto__ = s;
  } || function(t, s) {
    for (var h in s)
      s.hasOwnProperty(h) && (t[h] = s[h]);
  };
  return function(t, s) {
    l(t, s);
    function h() {
      this.constructor = t;
    }
    t.prototype = s === null ? Object.create(s) : (h.prototype = s.prototype, new h());
  };
}();
Object.defineProperty(xmlHttpRequestUpload, "__esModule", { value: !0 });
var xml_http_request_event_target_1$1 = xmlHttpRequestEventTarget, XMLHttpRequestUpload = function(l) {
  __extends$1(t, l);
  function t() {
    var s = l.call(this) || this;
    return s._contentType = null, s._body = null, s._reset(), s;
  }
  return t.prototype._reset = function() {
    this._contentType = null, this._body = null;
  }, t.prototype._setData = function(s) {
    if (s != null)
      if (typeof s == "string")
        s.length !== 0 && (this._contentType = "text/plain;charset=UTF-8"), this._body = new Buffer(s, "utf-8");
      else if (Buffer.isBuffer(s))
        this._body = s;
      else if (s instanceof ArrayBuffer) {
        for (var h = new Buffer(s.byteLength), m = new Uint8Array(s), d = 0; d < s.byteLength; d++)
          h[d] = m[d];
        this._body = h;
      } else if (s.buffer && s.buffer instanceof ArrayBuffer) {
        for (var h = new Buffer(s.byteLength), v = s.byteOffset, m = new Uint8Array(s.buffer), d = 0; d < s.byteLength; d++)
          h[d] = m[d + v];
        this._body = h;
      } else
        throw new Error("Unsupported send() data " + s);
  }, t.prototype._finalizeHeaders = function(s, h) {
    this._contentType && !h["content-type"] && (s["Content-Type"] = this._contentType), this._body && (s["Content-Length"] = this._body.length.toString());
  }, t.prototype._startUpload = function(s) {
    this._body && s.write(this._body), s.end();
  }, t;
}(xml_http_request_event_target_1$1.XMLHttpRequestEventTarget);
xmlHttpRequestUpload.XMLHttpRequestUpload = XMLHttpRequestUpload;
var cookiejar = {};
(function() {
  function l(m, d, v, _) {
    return this instanceof l ? (this.domain = m || void 0, this.path = d || "/", this.secure = !!v, this.script = !!_, this) : new l(m, d, v, _);
  }
  l.All = Object.freeze(/* @__PURE__ */ Object.create(null)), cookiejar.CookieAccessInfo = l;
  function t(m, d, v) {
    return m instanceof t ? m : this instanceof t ? (this.name = null, this.value = null, this.expiration_date = 1 / 0, this.path = String(v || "/"), this.explicit_path = !1, this.domain = d || null, this.explicit_domain = !1, this.secure = !1, this.noscript = !1, m && this.parse(m, d, v), this) : new t(m, d, v);
  }
  cookiejar.Cookie = t, t.prototype.toString = function() {
    var d = [this.name + "=" + this.value];
    return this.expiration_date !== 1 / 0 && d.push("expires=" + new Date(this.expiration_date).toGMTString()), this.domain && d.push("domain=" + this.domain), this.path && d.push("path=" + this.path), this.secure && d.push("secure"), this.noscript && d.push("httponly"), d.join("; ");
  }, t.prototype.toValueString = function() {
    return this.name + "=" + this.value;
  };
  var s = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
  t.prototype.parse = function(d, v, _) {
    if (this instanceof t) {
      var T = d.split(";").filter(function(ne) {
        return !!ne;
      }), z, J = T[0].match(/([^=]+)=([\s\S]*)/);
      if (!J) {
        console.warn("Invalid cookie header encountered. Header: '" + d + "'");
        return;
      }
      var Y = J[1], ie = J[2];
      if (typeof Y != "string" || Y.length === 0 || typeof ie != "string") {
        console.warn("Unable to extract values from cookie header. Cookie: '" + d + "'");
        return;
      }
      for (this.name = Y, this.value = ie, z = 1; z < T.length; z += 1)
        switch (J = T[z].match(/([^=]+)(?:=([\s\S]*))?/), Y = J[1].trim().toLowerCase(), ie = J[2], Y) {
          case "httponly":
            this.noscript = !0;
            break;
          case "expires":
            this.expiration_date = ie ? Number(Date.parse(ie)) : 1 / 0;
            break;
          case "path":
            this.path = ie ? ie.trim() : "", this.explicit_path = !0;
            break;
          case "domain":
            this.domain = ie ? ie.trim() : "", this.explicit_domain = !!this.domain;
            break;
          case "secure":
            this.secure = !0;
            break;
        }
      return this.explicit_path || (this.path = _ || "/"), this.explicit_domain || (this.domain = v), this;
    }
    return new t().parse(d, v, _);
  }, t.prototype.matches = function(d) {
    return d === l.All ? !0 : !(this.noscript && d.script || this.secure && !d.secure || !this.collidesWith(d));
  }, t.prototype.collidesWith = function(d) {
    if (this.path && !d.path || this.domain && !d.domain || this.path && d.path.indexOf(this.path) !== 0 || this.explicit_path && d.path.indexOf(this.path) !== 0)
      return !1;
    var v = d.domain && d.domain.replace(/^[\.]/, ""), _ = this.domain && this.domain.replace(/^[\.]/, "");
    if (_ === v)
      return !0;
    if (_) {
      if (!this.explicit_domain)
        return !1;
      var T = v.indexOf(_);
      return !(T === -1 || T !== v.length - _.length);
    }
    return !0;
  };
  function h() {
    var m, d, v;
    return this instanceof h ? (m = /* @__PURE__ */ Object.create(null), this.setCookie = function(T, z, J) {
      var Y, ie;
      if (T = new t(T, z, J), Y = T.expiration_date <= Date.now(), m[T.name] !== void 0) {
        for (d = m[T.name], ie = 0; ie < d.length; ie += 1)
          if (v = d[ie], v.collidesWith(T))
            return Y ? (d.splice(ie, 1), d.length === 0 && delete m[T.name], !1) : (d[ie] = T, T);
        return Y ? !1 : (d.push(T), T);
      }
      return Y ? !1 : (m[T.name] = [T], m[T.name]);
    }, this.getCookie = function(T, z) {
      var J, Y;
      if (d = m[T], !!d)
        for (Y = 0; Y < d.length; Y += 1) {
          if (J = d[Y], J.expiration_date <= Date.now()) {
            d.length === 0 && delete m[J.name];
            continue;
          }
          if (J.matches(z))
            return J;
        }
    }, this.getCookies = function(T) {
      var z = [], J, Y;
      for (J in m)
        Y = this.getCookie(J, T), Y && z.push(Y);
      return z.toString = function() {
        return z.join(":");
      }, z.toValueString = function() {
        return z.map(function(ne) {
          return ne.toValueString();
        }).join("; ");
      }, z;
    }, this) : new h();
  }
  cookiejar.CookieJar = h, h.prototype.setCookies = function(d, v, _) {
    d = Array.isArray(d) ? d : d.split(s);
    var T = [], z, J;
    for (d = d.map(function(Y) {
      return new t(Y, v, _);
    }), z = 0; z < d.length; z += 1)
      J = d[z], this.setCookie(J, v, _) && T.push(J);
    return T;
  };
})();
var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
  var l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
    t.__proto__ = s;
  } || function(t, s) {
    for (var h in s)
      s.hasOwnProperty(h) && (t[h] = s[h]);
  };
  return function(t, s) {
    l(t, s);
    function h() {
      this.constructor = t;
    }
    t.prototype = s === null ? Object.create(s) : (h.prototype = s.prototype, new h());
  };
}(), __assign = commonjsGlobal && commonjsGlobal.__assign || Object.assign || function(l) {
  for (var t, s = 1, h = arguments.length; s < h; s++) {
    t = arguments[s];
    for (var m in t)
      Object.prototype.hasOwnProperty.call(t, m) && (l[m] = t[m]);
  }
  return l;
};
Object.defineProperty(xmlHttpRequest, "__esModule", { value: !0 });
var http = require$$2$3, https = require$$2$3, os = require$$2$3, url = url$1, progress_event_1 = progressEvent, errors_1 = errors$1, xml_http_request_event_target_1 = xmlHttpRequestEventTarget, xml_http_request_upload_1 = xmlHttpRequestUpload, Cookie = cookiejar, XMLHttpRequest = function(l) {
  __extends(t, l);
  function t(s) {
    s === void 0 && (s = {});
    var h = l.call(this) || this;
    return h.UNSENT = t.UNSENT, h.OPENED = t.OPENED, h.HEADERS_RECEIVED = t.HEADERS_RECEIVED, h.LOADING = t.LOADING, h.DONE = t.DONE, h.onreadystatechange = null, h.readyState = t.UNSENT, h.response = null, h.responseText = "", h.responseType = "", h.status = 0, h.statusText = "", h.timeout = 0, h.upload = new xml_http_request_upload_1.XMLHttpRequestUpload(), h.responseUrl = "", h.withCredentials = !1, h._method = null, h._url = null, h._sync = !1, h._headers = {}, h._loweredHeaders = {}, h._mimeOverride = null, h._request = null, h._response = null, h._responseParts = null, h._responseHeaders = null, h._aborting = null, h._error = null, h._loadedBytes = 0, h._totalBytes = 0, h._lengthComputable = !1, h._restrictedMethods = { CONNECT: !0, TRACE: !0, TRACK: !0 }, h._restrictedHeaders = {
      "accept-charset": !0,
      "accept-encoding": !0,
      "access-control-request-headers": !0,
      "access-control-request-method": !0,
      connection: !0,
      "content-length": !0,
      cookie: !0,
      cookie2: !0,
      date: !0,
      dnt: !0,
      expect: !0,
      host: !0,
      "keep-alive": !0,
      origin: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      via: !0
    }, h._privateHeaders = { "set-cookie": !0, "set-cookie2": !0 }, h._userAgent = "Mozilla/5.0 (" + os.type() + " " + os.arch() + ") node.js/" + process.versions.node + " v8/" + process.versions.v8, h._anonymous = s.anon || !1, h;
  }
  return t.prototype.open = function(s, h, m, d, v) {
    if (m === void 0 && (m = !0), s = s.toUpperCase(), this._restrictedMethods[s])
      throw new t.SecurityError("HTTP method " + s + " is not allowed in XHR");
    var _ = this._parseUrl(h, d, v);
    this.readyState === t.HEADERS_RECEIVED || (this.readyState, t.LOADING), this._method = s, this._url = _, this._sync = !m, this._headers = {}, this._loweredHeaders = {}, this._mimeOverride = null, this._setReadyState(t.OPENED), this._request = null, this._response = null, this.status = 0, this.statusText = "", this._responseParts = [], this._responseHeaders = null, this._loadedBytes = 0, this._totalBytes = 0, this._lengthComputable = !1;
  }, t.prototype.setRequestHeader = function(s, h) {
    if (this.readyState !== t.OPENED)
      throw new t.InvalidStateError("XHR readyState must be OPENED");
    var m = s.toLowerCase();
    if (this._restrictedHeaders[m] || /^sec-/.test(m) || /^proxy-/.test(m)) {
      console.warn('Refused to set unsafe header "' + s + '"');
      return;
    }
    h = h.toString(), this._loweredHeaders[m] != null ? (s = this._loweredHeaders[m], this._headers[s] = this._headers[s] + ", " + h) : (this._loweredHeaders[m] = s, this._headers[s] = h);
  }, t.prototype.send = function(s) {
    if (this.readyState !== t.OPENED)
      throw new t.InvalidStateError("XHR readyState must be OPENED");
    if (this._request)
      throw new t.InvalidStateError("send() already called");
    switch (this._url.protocol) {
      case "file:":
        return this._sendFile(s);
      case "http:":
      case "https:":
        return this._sendHttp(s);
      default:
        throw new t.NetworkError("Unsupported protocol " + this._url.protocol);
    }
  }, t.prototype.abort = function() {
    this._request != null && (this._request.abort(), this._setError(), this._dispatchProgress("abort"), this._dispatchProgress("loadend"));
  }, t.prototype.getResponseHeader = function(s) {
    if (this._responseHeaders == null || s == null)
      return null;
    var h = s.toLowerCase();
    return this._responseHeaders.hasOwnProperty(h) ? this._responseHeaders[s.toLowerCase()] : null;
  }, t.prototype.getAllResponseHeaders = function() {
    var s = this;
    return this._responseHeaders == null ? "" : Object.keys(this._responseHeaders).map(function(h) {
      return h + ": " + s._responseHeaders[h];
    }).join(`\r
`);
  }, t.prototype.overrideMimeType = function(s) {
    if (this.readyState === t.LOADING || this.readyState === t.DONE)
      throw new t.InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
    this._mimeOverride = s.toLowerCase();
  }, t.prototype.nodejsSet = function(s) {
    if (this.nodejsHttpAgent = s.httpAgent || this.nodejsHttpAgent, this.nodejsHttpsAgent = s.httpsAgent || this.nodejsHttpsAgent, s.hasOwnProperty("baseUrl")) {
      if (s.baseUrl != null) {
        var h = url.parse(s.baseUrl, !1, !0);
        if (!h.protocol)
          throw new t.SyntaxError("baseUrl must be an absolute URL");
      }
      this.nodejsBaseUrl = s.baseUrl;
    }
  }, t.nodejsSet = function(s) {
    t.prototype.nodejsSet(s);
  }, t.prototype._setReadyState = function(s) {
    this.readyState = s, this.dispatchEvent(new progress_event_1.ProgressEvent("readystatechange"));
  }, t.prototype._sendFile = function(s) {
    throw new Error("Protocol file: not implemented");
  }, t.prototype._sendHttp = function(s) {
    if (this._sync)
      throw new Error("Synchronous XHR processing not implemented");
    s && (this._method === "GET" || this._method === "HEAD") ? (console.warn("Discarding entity body for " + this._method + " requests"), s = null) : s = s || "", this.upload._setData(s), this._finalizeHeaders(), this._sendHxxpRequest();
  }, t.prototype._sendHxxpRequest = function() {
    var s = this;
    if (this.withCredentials) {
      var h = t.cookieJar.getCookies(Cookie.CookieAccessInfo(this._url.hostname, this._url.pathname, this._url.protocol === "https:")).toValueString();
      this._headers.cookie = this._headers.cookie2 = h;
    }
    var m = this._url.protocol === "http:" ? [http, this.nodejsHttpAgent] : [https, this.nodejsHttpsAgent], d = m[0], v = m[1], _ = d.request.bind(d), T = _({
      hostname: this._url.hostname,
      port: +this._url.port,
      path: this._url.path,
      auth: this._url.auth,
      method: this._method,
      headers: this._headers,
      agent: v
    });
    this._request = T, this.timeout && T.setTimeout(this.timeout, function() {
      return s._onHttpTimeout(T);
    }), T.on("response", function(z) {
      return s._onHttpResponse(T, z);
    }), T.on("error", function(z) {
      return s._onHttpRequestError(T, z);
    }), this.upload._startUpload(T), this._request === T && this._dispatchProgress("loadstart");
  }, t.prototype._finalizeHeaders = function() {
    this._headers = __assign({}, this._headers, { Connection: "keep-alive", Host: this._url.host, "User-Agent": this._userAgent }, this._anonymous ? { Referer: "about:blank" } : {}), this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
  }, t.prototype._onHttpResponse = function(s, h) {
    var m = this;
    if (this._request === s) {
      if (this.withCredentials && (h.headers["set-cookie"] || h.headers["set-cookie2"]) && t.cookieJar.setCookies(h.headers["set-cookie"] || h.headers["set-cookie2"]), [301, 302, 303, 307, 308].indexOf(h.statusCode) >= 0) {
        this._url = this._parseUrl(h.headers.location), this._method = "GET", this._loweredHeaders["content-type"] && (delete this._headers[this._loweredHeaders["content-type"]], delete this._loweredHeaders["content-type"]), this._headers["Content-Type"] != null && delete this._headers["Content-Type"], delete this._headers["Content-Length"], this.upload._reset(), this._finalizeHeaders(), this._sendHxxpRequest();
        return;
      }
      this._response = h, this._response.on("data", function(v) {
        return m._onHttpResponseData(h, v);
      }), this._response.on("end", function() {
        return m._onHttpResponseEnd(h);
      }), this._response.on("close", function() {
        return m._onHttpResponseClose(h);
      }), this.responseUrl = this._url.href.split("#")[0], this.status = h.statusCode, this.statusText = http.STATUS_CODES[this.status], this._parseResponseHeaders(h);
      var d = this._responseHeaders["content-length"] || "";
      this._totalBytes = +d, this._lengthComputable = !!d, this._setReadyState(t.HEADERS_RECEIVED);
    }
  }, t.prototype._onHttpResponseData = function(s, h) {
    this._response === s && (this._responseParts.push(new Buffer(h)), this._loadedBytes += h.length, this.readyState !== t.LOADING && this._setReadyState(t.LOADING), this._dispatchProgress("progress"));
  }, t.prototype._onHttpResponseEnd = function(s) {
    this._response === s && (this._parseResponse(), this._request = null, this._response = null, this._setReadyState(t.DONE), this._dispatchProgress("load"), this._dispatchProgress("loadend"));
  }, t.prototype._onHttpResponseClose = function(s) {
    if (this._response === s) {
      var h = this._request;
      this._setError(), h.abort(), this._setReadyState(t.DONE), this._dispatchProgress("error"), this._dispatchProgress("loadend");
    }
  }, t.prototype._onHttpTimeout = function(s) {
    this._request === s && (this._setError(), s.abort(), this._setReadyState(t.DONE), this._dispatchProgress("timeout"), this._dispatchProgress("loadend"));
  }, t.prototype._onHttpRequestError = function(s, h) {
    this._request === s && (this._setError(), s.abort(), this._setReadyState(t.DONE), this._dispatchProgress("error"), this._dispatchProgress("loadend"));
  }, t.prototype._dispatchProgress = function(s) {
    var h = new t.ProgressEvent(s);
    h.lengthComputable = this._lengthComputable, h.loaded = this._loadedBytes, h.total = this._totalBytes, this.dispatchEvent(h);
  }, t.prototype._setError = function() {
    this._request = null, this._response = null, this._responseHeaders = null, this._responseParts = null;
  }, t.prototype._parseUrl = function(s, h, m) {
    var d = this.nodejsBaseUrl == null ? s : url.resolve(this.nodejsBaseUrl, s), v = url.parse(d, !1, !0);
    v.hash = null;
    var _ = (v.auth || "").split(":"), T = _[0], z = _[1];
    return (T || z || h || m) && (v.auth = (h || T || "") + ":" + (m || z || "")), v;
  }, t.prototype._parseResponseHeaders = function(s) {
    this._responseHeaders = {};
    for (var h in s.headers) {
      var m = h.toLowerCase();
      this._privateHeaders[m] || (this._responseHeaders[m] = s.headers[h]);
    }
    this._mimeOverride != null && (this._responseHeaders["content-type"] = this._mimeOverride);
  }, t.prototype._parseResponse = function() {
    var s = Buffer.concat(this._responseParts);
    switch (this._responseParts = null, this.responseType) {
      case "json":
        this.responseText = null;
        try {
          this.response = JSON.parse(s.toString("utf-8"));
        } catch {
          this.response = null;
        }
        return;
      case "buffer":
        this.responseText = null, this.response = s;
        return;
      case "arraybuffer":
        this.responseText = null;
        for (var h = new ArrayBuffer(s.length), m = new Uint8Array(h), d = 0; d < s.length; d++)
          m[d] = s[d];
        this.response = h;
        return;
      case "text":
      default:
        try {
          this.responseText = s.toString(this._parseResponseEncoding());
        } catch {
          this.responseText = s.toString("binary");
        }
        this.response = this.responseText;
    }
  }, t.prototype._parseResponseEncoding = function() {
    return /;\s*charset=(.*)$/.exec(this._responseHeaders["content-type"] || "")[1] || "utf-8";
  }, t.ProgressEvent = progress_event_1.ProgressEvent, t.InvalidStateError = errors_1.InvalidStateError, t.NetworkError = errors_1.NetworkError, t.SecurityError = errors_1.SecurityError, t.SyntaxError = errors_1.SyntaxError, t.XMLHttpRequestUpload = xml_http_request_upload_1.XMLHttpRequestUpload, t.UNSENT = 0, t.OPENED = 1, t.HEADERS_RECEIVED = 2, t.LOADING = 3, t.DONE = 4, t.cookieJar = Cookie.CookieJar(), t;
}(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
xmlHttpRequest.XMLHttpRequest = XMLHttpRequest;
XMLHttpRequest.prototype.nodejsHttpAgent = http.globalAgent;
XMLHttpRequest.prototype.nodejsHttpsAgent = https.globalAgent;
XMLHttpRequest.prototype.nodejsBaseUrl = null;
(function(l) {
  function t(h) {
    for (var m in h)
      l.hasOwnProperty(m) || (l[m] = h[m]);
  }
  Object.defineProperty(l, "__esModule", { value: !0 }), t(xmlHttpRequest);
  var s = xmlHttpRequestEventTarget;
  l.XMLHttpRequestEventTarget = s.XMLHttpRequestEventTarget;
})(dist$2);
getFromWindow("XMLHttpRequest") || dist$2.XMLHttpRequest;
require("web3-provider-engine");
require("web3-provider-engine/subproviders/cache");
require("web3-provider-engine/subproviders/fixture");
require("web3-provider-engine/subproviders/filters");
require("web3-provider-engine/subproviders/hooked-wallet");
require("web3-provider-engine/subproviders/nonce-tracker");
require("web3-provider-engine/subproviders/subscriptions");
var dist$1 = {}, face = {}, dist = {}, auth$1 = {};
Object.defineProperty(auth$1, "__esModule", { value: !0 });
var blockchain = {};
(function(l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.getPlatFormCoinDecimalByBlockchain = l.isEthlikeBlockchain = l.networkToBlockchain = l.Blockchain = l.NetworkChainIdMap = l.isSupportedNetwork = l.Network = void 0;
  var t;
  (function(T) {
    T.ETHEREUM = "ethereum", T.ROPSTEN = "ropsten", T.GOERLI = "goerli", T.POLYGON = "polygon", T.MUMBAI = "mumbai", T.BNB_SMART_CHAIN = "bnb_smart_chain", T.BNB_SMART_CHAIN_TESTNET = "bnb_smart_chain_testnet", T.KLAYTN = "klaytn", T.BAOBAB = "baobab", T.SOLANA = "solana", T.SOLANA_DEVNET = "solana_devnet", T.NEAR = "near", T.NEAR_TESTNET = "near_testnet", T.BORA = "bora", T.BORA_TESTNET = "bora_testnet", T.ETH_MAINNET = "ethereum", T.ETH_TESTNET = "ropsten", T.MATIC_MAINNET = "polygon", T.MATIC_TESTNET = "mumbai", T.BINANCE_COIN_MAINNET = "bnb_smart_chain", T.BINANCE_COIN_TESTNET = "bnb_smart_chain_testnet", T.KLAYTN_MAINNET = "klaytn", T.KLAYTN_TESTNET = "baobab";
  })(t = l.Network || (l.Network = {}));
  const s = (T) => {
    switch (T) {
      case t.ETHEREUM:
      case t.GOERLI:
      case t.POLYGON:
      case t.MUMBAI:
      case t.BNB_SMART_CHAIN:
      case t.BNB_SMART_CHAIN_TESTNET:
      case t.KLAYTN:
      case t.BAOBAB:
      case t.SOLANA:
      case t.SOLANA_DEVNET:
      case t.NEAR:
      case t.NEAR_TESTNET:
      case t.BORA:
      case t.BORA_TESTNET:
        return !0;
      default:
        return !1;
    }
  };
  l.isSupportedNetwork = s, l.NetworkChainIdMap = {
    [t.ETHEREUM]: 1,
    [t.ROPSTEN]: 3,
    [t.GOERLI]: 5,
    [t.POLYGON]: 137,
    [t.MUMBAI]: 80001,
    [t.BNB_SMART_CHAIN]: 56,
    [t.BNB_SMART_CHAIN_TESTNET]: 97,
    [t.KLAYTN]: 8217,
    [t.BAOBAB]: 1001,
    [t.SOLANA]: 0,
    [t.SOLANA_DEVNET]: 0,
    [t.NEAR]: 0,
    [t.NEAR_TESTNET]: 0,
    [t.BORA]: 77001,
    [t.BORA_TESTNET]: 99001,
    1: t.ETHEREUM,
    3: t.ROPSTEN,
    5: t.GOERLI,
    137: t.POLYGON,
    80001: t.MUMBAI,
    56: t.BNB_SMART_CHAIN,
    97: t.BNB_SMART_CHAIN_TESTNET,
    8217: t.KLAYTN,
    1001: t.BAOBAB,
    77001: t.BORA,
    99001: t.BORA_TESTNET
  };
  var h;
  (function(T) {
    T.ETHEREUM = "ETHEREUM", T.POLYGON = "POLYGON", T.BNB_SMART_CHAIN = "BNB_SMART_CHAIN", T.KLAYTN = "KLAYTN", T.SOLANA = "SOLANA", T.NEAR = "NEAR", T.BORA = "BORA";
  })(h = l.Blockchain || (l.Blockchain = {}));
  const m = [
    h.ETHEREUM,
    h.POLYGON,
    h.BNB_SMART_CHAIN,
    h.KLAYTN,
    h.BORA
  ];
  function d(T) {
    switch (T) {
      case t.ETHEREUM:
      case t.ROPSTEN:
      case t.GOERLI:
        return h.ETHEREUM;
      case t.POLYGON:
      case t.MUMBAI:
        return h.POLYGON;
      case t.BNB_SMART_CHAIN:
      case t.BNB_SMART_CHAIN_TESTNET:
        return h.BNB_SMART_CHAIN;
      case t.KLAYTN:
      case t.BAOBAB:
        return h.KLAYTN;
      case t.SOLANA:
      case t.SOLANA_DEVNET:
        return h.SOLANA;
      case t.BORA:
      case t.BORA_TESTNET:
        return h.BORA;
      case t.NEAR:
      case t.NEAR_TESTNET:
        return h.NEAR;
    }
    throw new Error(`Unsupported network: ${T}`);
  }
  l.networkToBlockchain = d;
  function v(T) {
    return m.indexOf(T) !== -1;
  }
  l.isEthlikeBlockchain = v;
  const _ = (T) => {
    switch (T) {
      case h.ETHEREUM:
      case h.POLYGON:
      case h.KLAYTN:
      case h.BNB_SMART_CHAIN:
      case h.BORA:
        return 18;
      case h.SOLANA:
        return 9;
      case h.NEAR:
        return 24;
      default:
        throw new Error("unsupported blockchain");
    }
  };
  l.getPlatFormCoinDecimalByBlockchain = _;
})(blockchain);
var crypto$3 = {}, require$$1$3 = /* @__PURE__ */ getAugmentedNamespace(lib_esm);
Object.defineProperty(crypto$3, "__esModule", { value: !0 });
crypto$3.CryptoBuffer = void 0;
const ethers_1$1 = require$$1$3;
class CryptoBuffer {
  constructor(t, s) {
    CryptoBuffer.ensureHexString(t), CryptoBuffer.checkLength(t, s), this.hex = t, this.length = s;
  }
  static empty() {
    return new CryptoBuffer("", 0);
  }
  static fromUint8Array(t) {
    return new CryptoBuffer(uint8ArrayToHex(t), t.length);
  }
  static fromHex(t, s) {
    return new CryptoBuffer(t, s);
  }
  static ensureHexString(t) {
    try {
      if (t === "")
        return;
      if (t == null)
        throw new Error(`hex is null ${t}`);
      if (!t.startsWith("0x"))
        throw new Error(`hex does not start with 0x ${t}`);
      if (t.match("0x[0-9a-fA-F]+") == null)
        throw new Error(`invalid hex data ${t}`);
    } catch (s) {
      throw s;
    }
  }
  static checkLength(t, s) {
    if (t.length === 0)
      return;
    if ((t.length - 2) * 4 / 8 > s)
      throw new Error(`length is less than hex data ${t}, ${s}`);
  }
  toString() {
    return this.hex;
  }
  toHex() {
    return this.hex;
  }
  toBigNumber() {
    return ethers_1$1.BigNumber.from(this.hex);
  }
  toJSON() {
    return JSON.stringify({
      hex: this.hex,
      length: this.length
    });
  }
  static fromJSON(t) {
    const { hex: s, length: h } = JSON.parse(t);
    return new CryptoBuffer(s, h);
  }
  static fromBigNumber(t, s) {
    return CryptoBuffer.fromHex(t.toHexString(), s);
  }
  toUInt8Array() {
    const t = this.hex.substring(2), s = [];
    for (let h = 0; h < t.length; h += 2)
      s.push(parseInt(t.substring(h, h + 2), 16));
    return new Uint8Array(s);
  }
  static concat(t, s) {
    try {
      const h = t.toUInt8Array(), m = s.toUInt8Array(), d = new Uint8Array(h.length + m.length);
      d.set(h), d.set(m, h.length);
      const v = uint8ArrayToHex(d);
      return new CryptoBuffer(v, h.length + m.length);
    } catch {
      return CryptoBuffer.empty();
    }
    return CryptoBuffer.empty();
  }
  split(t) {
    const s = this.toUInt8Array();
    return [
      CryptoBuffer.fromUint8Array(s.slice(0, t)),
      CryptoBuffer.fromUint8Array(s.slice(t))
    ];
  }
  clone() {
    return new CryptoBuffer(this.hex, this.length);
  }
  unsafeSetLength(t) {
    this.length = t;
  }
}
crypto$3.CryptoBuffer = CryptoBuffer;
function uint8ArrayToHex(l) {
  return "0x" + [...l].map((t) => t.toString(16).padStart(2, "0")).join("");
}
var currency = {};
Object.defineProperty(currency, "__esModule", { value: !0 });
var env = {};
(function(l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.Env = void 0, function(t) {
    t.Local = "Local", t.Dev = "Dev", t.StageTest = "StageTest", t.StageMainnet = "StageMainnet", t.ProdTest = "ProdTest", t.ProdMainnet = "ProdMainnet";
  }(l.Env || (l.Env = {}));
})(env);
var error = {}, typeGuards = {}, jsonRpc = {};
(function(l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.RpcErrorCode = l.JsonRpcSource = l.JsonRpcMethod = void 0, function(t) {
    t.face_logInSignUp = "face_logInSignUp", t.face_loggedIn = "face_loggedIn", t.face_logOut = "face_logOut", t.face_currentUser = "face_currentUser", t.face_accounts = "face_accounts", t.face_openIframe = "face_openIframe", t.face_closeIframe = "face_closeIframe", t.face_ready = "face_ready", t.face_openHome = "face_openHome", t.face_openWalletConnect = "face_openWalletConnect", t.face_switchNetwork = "face_switchNetwork", t.face_directSocialLogin = "face_directSocialLogin", t.face_loginWithIdToken = "face_loginWithIdToken", t.eth_sendTransaction = "eth_sendTransaction", t.eth_getBalance = "eth_getBalance", t.eth_call = "eth_call", t.eth_estimateGas = "eth_estimateGas", t.eth_sign = "eth_sign", t.eth_accounts = "eth_accounts", t.personal_sign = "personal_sign", t.personal_listAccounts = "personal_listAccounts", t.wallet_switchEthereumChain = "wallet_switchEthereumChain", t.solana_sendTransaction = "solana_sendTransaction", t.near_broadcast_tx_async = "near_broadcast_tx_async", t.near_get_balance = "near_get_balance";
  }(l.JsonRpcMethod || (l.JsonRpcMethod = {})), function(t) {
    t.FACE_SDK = "FACE_SDK", t.FACE_IFRAME = "FACE_IFRAME", t.FACE_WALLET_CONNECT = "FACE_WALLET_CONNECT", t.FACE_NATIVE_SDK = "FACE_NATIVE_SDK";
  }(l.JsonRpcSource || (l.JsonRpcSource = {})), function(t) {
    t[t.PARSE_ERROR = -32700] = "PARSE_ERROR", t[t.INVALID_REQUEST = -32600] = "INVALID_REQUEST", t[t.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", t[t.INVALID_PARAMS = -32602] = "INVALID_PARAMS", t[t.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR";
  }(l.RpcErrorCode || (l.RpcErrorCode = {}));
})(jsonRpc);
var hasRequiredTypeGuards;
function requireTypeGuards() {
  if (hasRequiredTypeGuards)
    return typeGuards;
  hasRequiredTypeGuards = 1, Object.defineProperty(typeGuards, "__esModule", { value: !0 }), typeGuards.isFaceErrorCode = typeGuards.isJsonRpcErrorCode = typeGuards.isEmpty = typeGuards.isJsonRpcResponsePayload = typeGuards.isJsonRpcRequestPayload = void 0;
  const l = requireError(), t = jsonRpc;
  function s(J) {
    return typeof J > "u";
  }
  function h(J) {
    return J === null;
  }
  function m(J) {
    return h(J) || s(J);
  }
  function d(J) {
    return m(J) ? !1 : !s(J.jsonrpc) && !s(J.id) && !s(J.method) && !s(J.params);
  }
  typeGuards.isJsonRpcRequestPayload = d;
  function v(J) {
    return m(J) ? !1 : !s(J.jsonrpc) && !s(J.id) && (!s(J.result) || !s(J.error));
  }
  typeGuards.isJsonRpcResponsePayload = v;
  function _(J) {
    if (!J)
      return !0;
    for (const Y in J)
      if (Object.hasOwnProperty.call(J, Y))
        return !1;
    return !0;
  }
  typeGuards.isEmpty = _;
  function T(J) {
    return m(J) ? !1 : typeof J == "number" && Object.values(t.RpcErrorCode).includes(J);
  }
  typeGuards.isJsonRpcErrorCode = T;
  function z(J) {
    return m(J) ? !1 : typeof J == "number" && Object.values(l.FaceErrorCode).includes(J);
  }
  return typeGuards.isFaceErrorCode = z, typeGuards;
}
var hasRequiredError;
function requireError() {
  return hasRequiredError || (hasRequiredError = 1, function(l) {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.noUserDataError = l.pinCodeTrialLimitExceededError = l.wrongPinCodeError = l.invalidAddressWithWalletError = l.unsupportedChainError = l.invalidHostNameError = l.invalidApiKeyError = l.unknownError = l.notImplementedError = l.localStorageError = l.invalidParameterError = l.invalidFormatError = l.cryptoError = l.invalidEnvironmentError = l.firebaseError = l.nitroEnclaveError = l.faceServerError = l.jsonRpcError = l.sendTransactionError = l.FaceError = l.FaceErrorCode = l.HttpStatus = void 0;
    const t = requireTypeGuards();
    (function(Ee) {
      Ee[Ee.SUCCESS = 200] = "SUCCESS", Ee[Ee.CREATED = 201] = "CREATED", Ee[Ee.BAD_REQUEST = 400] = "BAD_REQUEST", Ee[Ee.UNAUTHORIZED = 401] = "UNAUTHORIZED", Ee[Ee.FORBIDDEN = 403] = "FORBIDDEN", Ee[Ee.NOT_FOUND = 404] = "NOT_FOUND", Ee[Ee.INTERNAL_SERVER_ERROR = 500] = "INTERNAL_SERVER_ERROR";
    })(l.HttpStatus || (l.HttpStatus = {}));
    var s;
    (function(Ee) {
      Ee[Ee.BAD_REQUEST = 4e3] = "BAD_REQUEST", Ee[Ee.USER_REJECTED_REQUEST = 4001] = "USER_REJECTED_REQUEST", Ee[Ee.NOT_IMPLEMENTED = 4002] = "NOT_IMPLEMENTED", Ee[Ee.UNAUTHORIZED = 4100] = "UNAUTHORIZED", Ee[Ee.UNSUPPORTED_METHOD = 4200] = "UNSUPPORTED_METHOD", Ee[Ee.UNSUPPORTED_CHAIN = 4201] = "UNSUPPORTED_CHAIN", Ee[Ee.DISCONNECTED = 4900] = "DISCONNECTED", Ee[Ee.CHAIN_DISCONNECTED = 4901] = "CHAIN_DISCONNECTED", Ee[Ee.SEND_TRANCTION_FAILED = 4902] = "SEND_TRANCTION_FAILED", Ee[Ee.WRONG_PINCODE = 4903] = "WRONG_PINCODE", Ee[Ee.PINCODE_TRIAL_LIMIT_EXCEEDED = 4904] = "PINCODE_TRIAL_LIMIT_EXCEEDED", Ee[Ee.NO_USER_DATA = 4905] = "NO_USER_DATA", Ee[Ee.INTERNAL = 5e3] = "INTERNAL";
    })(s = l.FaceErrorCode || (l.FaceErrorCode = {}));
    class h extends Error {
      constructor(Te) {
        super(), this.isFaceError = !0, this.code = this.isValidErrorCode(Te.code) ? Te.code : s.INTERNAL, this.message = `Face Error: [${this.code}] ${Te.message}`, this.origin = Te.origin, this.data = Te.data, Object.setPrototypeOf(this, h.prototype), Error.captureStackTrace(this, this.constructor);
      }
      isValidErrorCode(Te) {
        return (0, t.isJsonRpcErrorCode)(Te) || (0, t.isFaceErrorCode)(Te);
      }
    }
    l.FaceError = h;
    function m(Ee) {
      return new h({
        message: Ee.message,
        code: s.SEND_TRANCTION_FAILED,
        data: Ee.data
      });
    }
    l.sendTransactionError = m;
    function d(Ee) {
      return new h({
        message: Ee.message,
        code: Ee.code,
        data: Ee.data
      });
    }
    l.jsonRpcError = d;
    function v(Ee, Te, Ke) {
      return new h({
        message: `face server error: ${Ee}`,
        code: s.INTERNAL,
        origin: Te,
        data: Ke
      });
    }
    l.faceServerError = v;
    function _(Ee, Te, Ke) {
      return new h({
        message: `nitro enclave error: ${Ee}`,
        code: s.INTERNAL,
        origin: Te,
        data: Ke
      });
    }
    l.nitroEnclaveError = _;
    function T(Ee, Te, Ke) {
      return new h({
        message: `firebase error: ${Ee}`,
        code: s.INTERNAL,
        origin: Te,
        data: Ke
      });
    }
    l.firebaseError = T;
    function z(Ee) {
      return new h({
        message: "invalid environment",
        code: s.INTERNAL,
        data: Ee
      });
    }
    l.invalidEnvironmentError = z;
    function J(Ee, Te, Ke) {
      return new h({
        message: `crypto error: ${Ee}`,
        code: s.INTERNAL,
        origin: Te,
        data: Ke
      });
    }
    l.cryptoError = J;
    function Y(Ee, Te, Ke) {
      return new h({
        message: `invalid format error: ${Ee}`,
        code: s.INTERNAL,
        origin: Te,
        data: Ke
      });
    }
    l.invalidFormatError = Y;
    function ie(Ee, Te, Ke) {
      return new h({
        message: `invalid params error: ${Ee}`,
        code: s.INTERNAL,
        origin: Te,
        data: Ke
      });
    }
    l.invalidParameterError = ie;
    function ne(Ee, Te, Ke) {
      return new h({
        message: `local storage error: ${Ee}`,
        code: s.INTERNAL,
        origin: Te,
        data: Ke
      });
    }
    l.localStorageError = ne;
    function de(Ee) {
      return new h({
        message: Ee,
        code: s.NOT_IMPLEMENTED
      });
    }
    l.notImplementedError = de;
    function ce(Ee) {
      return new h({
        message: "unknown error",
        code: s.INTERNAL,
        origin: Ee
      });
    }
    l.unknownError = ce;
    function re(Ee) {
      return new h({
        message: "invalid api key error",
        code: s.UNAUTHORIZED,
        origin: Ee
      });
    }
    l.invalidApiKeyError = re;
    function oe(Ee) {
      return new h({
        message: "invalid host name error",
        code: s.UNAUTHORIZED,
        origin: Ee
      });
    }
    l.invalidHostNameError = oe;
    function pe(Ee) {
      return new h({
        message: "unsupported chain error",
        code: s.UNSUPPORTED_CHAIN,
        origin: Ee
      });
    }
    l.unsupportedChainError = pe;
    function ae(Ee) {
      return new h({
        message: "invalid address compared with wallet address",
        code: s.INTERNAL,
        origin: Ee
      });
    }
    l.invalidAddressWithWalletError = ae;
    function me(Ee) {
      return new h({
        message: "invalid pin code",
        code: s.WRONG_PINCODE,
        origin: Ee
      });
    }
    l.wrongPinCodeError = me;
    function ge(Ee) {
      return new h({
        message: "pin code trial limit exceeded",
        code: s.PINCODE_TRIAL_LIMIT_EXCEEDED,
        origin: Ee
      });
    }
    l.pinCodeTrialLimitExceededError = ge;
    function we(Ee) {
      return new h({
        message: "no user data",
        code: s.NO_USER_DATA,
        origin: Ee
      });
    }
    l.noUserDataError = we;
  }(error)), error;
}
var faceEvent = {};
Object.defineProperty(faceEvent, "__esModule", { value: !0 });
faceEvent.parseFaceSolanaNearTransactionPayload = void 0;
function parseFaceSolanaNearTransactionPayload(l) {
  return l == null || typeof l != "object" || l.serializedHex == null || typeof l.serializedHex != "string" ? null : l;
}
faceEvent.parseFaceSolanaNearTransactionPayload = parseFaceSolanaNearTransactionPayload;
var transaction$1 = {};
(function(l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.TxType = void 0, function(t) {
    t.COIN = "COIN", t.ERC20 = "ERC20", t.ERC721 = "ERC721", t.ERC1155 = "ERC1155", t.FT = "FT";
  }(l.TxType || (l.TxType = {}));
})(transaction$1);
var user = {};
(function(l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.UserStatus = l.WalletPath = l.FaceVersionLocalKey = l.FaceShare1LocalKey = l.FaceUserLocalKey = l.FaceSessionLocalKey = void 0, l.FaceSessionLocalKey = "Face-Session", l.FaceUserLocalKey = "Face-User", l.FaceShare1LocalKey = "Face-Share1", l.FaceVersionLocalKey = "Face-Version", l.WalletPath = "m/44'/60'/1'/0/0", function(t) {
    t.isWalletCreated = "isWalletCreated", t.isNewUser = "isNewUser", t.isRegisteredPinCode = "isRegisteredPinCode", t.isAdmin = "isAdmin";
  }(l.UserStatus || (l.UserStatus = {}));
})(user);
(function(l) {
  var t = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(h, m, d, v) {
    v === void 0 && (v = d);
    var _ = Object.getOwnPropertyDescriptor(m, d);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[d];
    } }), Object.defineProperty(h, v, _);
  } : function(h, m, d, v) {
    v === void 0 && (v = d), h[v] = m[d];
  }), s = commonjsGlobal && commonjsGlobal.__exportStar || function(h, m) {
    for (var d in h)
      d !== "default" && !Object.prototype.hasOwnProperty.call(m, d) && t(m, h, d);
  };
  Object.defineProperty(l, "__esModule", { value: !0 }), s(auth$1, l), s(blockchain, l), s(crypto$3, l), s(currency, l), s(env, l), s(requireError(), l), s(faceEvent, l), s(jsonRpc, l), s(transaction$1, l), s(user, l);
})(dist);
var auth = {};
Object.defineProperty(auth, "__esModule", { value: !0 });
auth.Auth = void 0;
class Auth {
  constructor(t) {
    this.internal = t;
  }
  async login() {
    return this.internal.loginWithCredential();
  }
  async directSocialLogin(t) {
    return this.internal.directSocialLogin(t);
  }
  async loginWithIdToken(t) {
    return this.internal.loginWithIdToken(t);
  }
  async logout() {
    await this.internal.logout();
  }
  async getCurrentUser() {
    return await this.internal.getCurrentUser();
  }
  async isLoggedIn() {
    return await this.internal.isLoggedIn();
  }
}
auth.Auth = Auth;
var Near$1 = {}, NearProvider$1 = {}, browserIndex$1 = {}, browserIndex = {}, keystore = {};
Object.defineProperty(keystore, "__esModule", { value: !0 });
keystore.KeyStore = void 0;
class KeyStore {
}
keystore.KeyStore = KeyStore;
var in_memory_key_store = {}, key_pair = {};
function commonjsRequire(l) {
  throw new Error('Could not dynamically require "' + l + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
(function(l) {
  (function(t) {
    var s = function(le) {
      var be, Me = new Float64Array(16);
      if (le)
        for (be = 0; be < le.length; be++)
          Me[be] = le[be];
      return Me;
    }, h = function() {
      throw new Error("no PRNG");
    }, m = new Uint8Array(16), d = new Uint8Array(32);
    d[0] = 9;
    var v = s(), _ = s([1]), T = s([56129, 1]), z = s([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), J = s([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), Y = s([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), ie = s([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), ne = s([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function de(le, be, Me, te) {
      le[be] = Me >> 24 & 255, le[be + 1] = Me >> 16 & 255, le[be + 2] = Me >> 8 & 255, le[be + 3] = Me & 255, le[be + 4] = te >> 24 & 255, le[be + 5] = te >> 16 & 255, le[be + 6] = te >> 8 & 255, le[be + 7] = te & 255;
    }
    function ce(le, be, Me, te, ve) {
      var qe, Pe = 0;
      for (qe = 0; qe < ve; qe++)
        Pe |= le[be + qe] ^ Me[te + qe];
      return (1 & Pe - 1 >>> 8) - 1;
    }
    function re(le, be, Me, te) {
      return ce(le, be, Me, te, 16);
    }
    function oe(le, be, Me, te) {
      return ce(le, be, Me, te, 32);
    }
    function pe(le, be, Me, te) {
      for (var ve = te[0] & 255 | (te[1] & 255) << 8 | (te[2] & 255) << 16 | (te[3] & 255) << 24, qe = Me[0] & 255 | (Me[1] & 255) << 8 | (Me[2] & 255) << 16 | (Me[3] & 255) << 24, Pe = Me[4] & 255 | (Me[5] & 255) << 8 | (Me[6] & 255) << 16 | (Me[7] & 255) << 24, Le = Me[8] & 255 | (Me[9] & 255) << 8 | (Me[10] & 255) << 16 | (Me[11] & 255) << 24, pt = Me[12] & 255 | (Me[13] & 255) << 8 | (Me[14] & 255) << 16 | (Me[15] & 255) << 24, Je = te[4] & 255 | (te[5] & 255) << 8 | (te[6] & 255) << 16 | (te[7] & 255) << 24, Ge = be[0] & 255 | (be[1] & 255) << 8 | (be[2] & 255) << 16 | (be[3] & 255) << 24, $t = be[4] & 255 | (be[5] & 255) << 8 | (be[6] & 255) << 16 | (be[7] & 255) << 24, bt = be[8] & 255 | (be[9] & 255) << 8 | (be[10] & 255) << 16 | (be[11] & 255) << 24, Mt = be[12] & 255 | (be[13] & 255) << 8 | (be[14] & 255) << 16 | (be[15] & 255) << 24, Rt = te[8] & 255 | (te[9] & 255) << 8 | (te[10] & 255) << 16 | (te[11] & 255) << 24, Tt = Me[16] & 255 | (Me[17] & 255) << 8 | (Me[18] & 255) << 16 | (Me[19] & 255) << 24, Nt = Me[20] & 255 | (Me[21] & 255) << 8 | (Me[22] & 255) << 16 | (Me[23] & 255) << 24, It = Me[24] & 255 | (Me[25] & 255) << 8 | (Me[26] & 255) << 16 | (Me[27] & 255) << 24, Ct = Me[28] & 255 | (Me[29] & 255) << 8 | (Me[30] & 255) << 16 | (Me[31] & 255) << 24, Bt = te[12] & 255 | (te[13] & 255) << 8 | (te[14] & 255) << 16 | (te[15] & 255) << 24, _t = ve, St = qe, vt = Pe, At = Le, Et = pt, yt = Je, Xe = Ge, Qe = $t, dt = bt, ft = Mt, gt = Rt, xt = Tt, Lt = Nt, Ot = It, Ut = Ct, Ft = Bt, Fe, Kt = 0; Kt < 20; Kt += 2)
        Fe = _t + Lt | 0, Et ^= Fe << 7 | Fe >>> 32 - 7, Fe = Et + _t | 0, dt ^= Fe << 9 | Fe >>> 32 - 9, Fe = dt + Et | 0, Lt ^= Fe << 13 | Fe >>> 32 - 13, Fe = Lt + dt | 0, _t ^= Fe << 18 | Fe >>> 32 - 18, Fe = yt + St | 0, ft ^= Fe << 7 | Fe >>> 32 - 7, Fe = ft + yt | 0, Ot ^= Fe << 9 | Fe >>> 32 - 9, Fe = Ot + ft | 0, St ^= Fe << 13 | Fe >>> 32 - 13, Fe = St + Ot | 0, yt ^= Fe << 18 | Fe >>> 32 - 18, Fe = gt + Xe | 0, Ut ^= Fe << 7 | Fe >>> 32 - 7, Fe = Ut + gt | 0, vt ^= Fe << 9 | Fe >>> 32 - 9, Fe = vt + Ut | 0, Xe ^= Fe << 13 | Fe >>> 32 - 13, Fe = Xe + vt | 0, gt ^= Fe << 18 | Fe >>> 32 - 18, Fe = Ft + xt | 0, At ^= Fe << 7 | Fe >>> 32 - 7, Fe = At + Ft | 0, Qe ^= Fe << 9 | Fe >>> 32 - 9, Fe = Qe + At | 0, xt ^= Fe << 13 | Fe >>> 32 - 13, Fe = xt + Qe | 0, Ft ^= Fe << 18 | Fe >>> 32 - 18, Fe = _t + At | 0, St ^= Fe << 7 | Fe >>> 32 - 7, Fe = St + _t | 0, vt ^= Fe << 9 | Fe >>> 32 - 9, Fe = vt + St | 0, At ^= Fe << 13 | Fe >>> 32 - 13, Fe = At + vt | 0, _t ^= Fe << 18 | Fe >>> 32 - 18, Fe = yt + Et | 0, Xe ^= Fe << 7 | Fe >>> 32 - 7, Fe = Xe + yt | 0, Qe ^= Fe << 9 | Fe >>> 32 - 9, Fe = Qe + Xe | 0, Et ^= Fe << 13 | Fe >>> 32 - 13, Fe = Et + Qe | 0, yt ^= Fe << 18 | Fe >>> 32 - 18, Fe = gt + ft | 0, xt ^= Fe << 7 | Fe >>> 32 - 7, Fe = xt + gt | 0, dt ^= Fe << 9 | Fe >>> 32 - 9, Fe = dt + xt | 0, ft ^= Fe << 13 | Fe >>> 32 - 13, Fe = ft + dt | 0, gt ^= Fe << 18 | Fe >>> 32 - 18, Fe = Ft + Ut | 0, Lt ^= Fe << 7 | Fe >>> 32 - 7, Fe = Lt + Ft | 0, Ot ^= Fe << 9 | Fe >>> 32 - 9, Fe = Ot + Lt | 0, Ut ^= Fe << 13 | Fe >>> 32 - 13, Fe = Ut + Ot | 0, Ft ^= Fe << 18 | Fe >>> 32 - 18;
      _t = _t + ve | 0, St = St + qe | 0, vt = vt + Pe | 0, At = At + Le | 0, Et = Et + pt | 0, yt = yt + Je | 0, Xe = Xe + Ge | 0, Qe = Qe + $t | 0, dt = dt + bt | 0, ft = ft + Mt | 0, gt = gt + Rt | 0, xt = xt + Tt | 0, Lt = Lt + Nt | 0, Ot = Ot + It | 0, Ut = Ut + Ct | 0, Ft = Ft + Bt | 0, le[0] = _t >>> 0 & 255, le[1] = _t >>> 8 & 255, le[2] = _t >>> 16 & 255, le[3] = _t >>> 24 & 255, le[4] = St >>> 0 & 255, le[5] = St >>> 8 & 255, le[6] = St >>> 16 & 255, le[7] = St >>> 24 & 255, le[8] = vt >>> 0 & 255, le[9] = vt >>> 8 & 255, le[10] = vt >>> 16 & 255, le[11] = vt >>> 24 & 255, le[12] = At >>> 0 & 255, le[13] = At >>> 8 & 255, le[14] = At >>> 16 & 255, le[15] = At >>> 24 & 255, le[16] = Et >>> 0 & 255, le[17] = Et >>> 8 & 255, le[18] = Et >>> 16 & 255, le[19] = Et >>> 24 & 255, le[20] = yt >>> 0 & 255, le[21] = yt >>> 8 & 255, le[22] = yt >>> 16 & 255, le[23] = yt >>> 24 & 255, le[24] = Xe >>> 0 & 255, le[25] = Xe >>> 8 & 255, le[26] = Xe >>> 16 & 255, le[27] = Xe >>> 24 & 255, le[28] = Qe >>> 0 & 255, le[29] = Qe >>> 8 & 255, le[30] = Qe >>> 16 & 255, le[31] = Qe >>> 24 & 255, le[32] = dt >>> 0 & 255, le[33] = dt >>> 8 & 255, le[34] = dt >>> 16 & 255, le[35] = dt >>> 24 & 255, le[36] = ft >>> 0 & 255, le[37] = ft >>> 8 & 255, le[38] = ft >>> 16 & 255, le[39] = ft >>> 24 & 255, le[40] = gt >>> 0 & 255, le[41] = gt >>> 8 & 255, le[42] = gt >>> 16 & 255, le[43] = gt >>> 24 & 255, le[44] = xt >>> 0 & 255, le[45] = xt >>> 8 & 255, le[46] = xt >>> 16 & 255, le[47] = xt >>> 24 & 255, le[48] = Lt >>> 0 & 255, le[49] = Lt >>> 8 & 255, le[50] = Lt >>> 16 & 255, le[51] = Lt >>> 24 & 255, le[52] = Ot >>> 0 & 255, le[53] = Ot >>> 8 & 255, le[54] = Ot >>> 16 & 255, le[55] = Ot >>> 24 & 255, le[56] = Ut >>> 0 & 255, le[57] = Ut >>> 8 & 255, le[58] = Ut >>> 16 & 255, le[59] = Ut >>> 24 & 255, le[60] = Ft >>> 0 & 255, le[61] = Ft >>> 8 & 255, le[62] = Ft >>> 16 & 255, le[63] = Ft >>> 24 & 255;
    }
    function ae(le, be, Me, te) {
      for (var ve = te[0] & 255 | (te[1] & 255) << 8 | (te[2] & 255) << 16 | (te[3] & 255) << 24, qe = Me[0] & 255 | (Me[1] & 255) << 8 | (Me[2] & 255) << 16 | (Me[3] & 255) << 24, Pe = Me[4] & 255 | (Me[5] & 255) << 8 | (Me[6] & 255) << 16 | (Me[7] & 255) << 24, Le = Me[8] & 255 | (Me[9] & 255) << 8 | (Me[10] & 255) << 16 | (Me[11] & 255) << 24, pt = Me[12] & 255 | (Me[13] & 255) << 8 | (Me[14] & 255) << 16 | (Me[15] & 255) << 24, Je = te[4] & 255 | (te[5] & 255) << 8 | (te[6] & 255) << 16 | (te[7] & 255) << 24, Ge = be[0] & 255 | (be[1] & 255) << 8 | (be[2] & 255) << 16 | (be[3] & 255) << 24, $t = be[4] & 255 | (be[5] & 255) << 8 | (be[6] & 255) << 16 | (be[7] & 255) << 24, bt = be[8] & 255 | (be[9] & 255) << 8 | (be[10] & 255) << 16 | (be[11] & 255) << 24, Mt = be[12] & 255 | (be[13] & 255) << 8 | (be[14] & 255) << 16 | (be[15] & 255) << 24, Rt = te[8] & 255 | (te[9] & 255) << 8 | (te[10] & 255) << 16 | (te[11] & 255) << 24, Tt = Me[16] & 255 | (Me[17] & 255) << 8 | (Me[18] & 255) << 16 | (Me[19] & 255) << 24, Nt = Me[20] & 255 | (Me[21] & 255) << 8 | (Me[22] & 255) << 16 | (Me[23] & 255) << 24, It = Me[24] & 255 | (Me[25] & 255) << 8 | (Me[26] & 255) << 16 | (Me[27] & 255) << 24, Ct = Me[28] & 255 | (Me[29] & 255) << 8 | (Me[30] & 255) << 16 | (Me[31] & 255) << 24, Bt = te[12] & 255 | (te[13] & 255) << 8 | (te[14] & 255) << 16 | (te[15] & 255) << 24, _t = ve, St = qe, vt = Pe, At = Le, Et = pt, yt = Je, Xe = Ge, Qe = $t, dt = bt, ft = Mt, gt = Rt, xt = Tt, Lt = Nt, Ot = It, Ut = Ct, Ft = Bt, Fe, Kt = 0; Kt < 20; Kt += 2)
        Fe = _t + Lt | 0, Et ^= Fe << 7 | Fe >>> 32 - 7, Fe = Et + _t | 0, dt ^= Fe << 9 | Fe >>> 32 - 9, Fe = dt + Et | 0, Lt ^= Fe << 13 | Fe >>> 32 - 13, Fe = Lt + dt | 0, _t ^= Fe << 18 | Fe >>> 32 - 18, Fe = yt + St | 0, ft ^= Fe << 7 | Fe >>> 32 - 7, Fe = ft + yt | 0, Ot ^= Fe << 9 | Fe >>> 32 - 9, Fe = Ot + ft | 0, St ^= Fe << 13 | Fe >>> 32 - 13, Fe = St + Ot | 0, yt ^= Fe << 18 | Fe >>> 32 - 18, Fe = gt + Xe | 0, Ut ^= Fe << 7 | Fe >>> 32 - 7, Fe = Ut + gt | 0, vt ^= Fe << 9 | Fe >>> 32 - 9, Fe = vt + Ut | 0, Xe ^= Fe << 13 | Fe >>> 32 - 13, Fe = Xe + vt | 0, gt ^= Fe << 18 | Fe >>> 32 - 18, Fe = Ft + xt | 0, At ^= Fe << 7 | Fe >>> 32 - 7, Fe = At + Ft | 0, Qe ^= Fe << 9 | Fe >>> 32 - 9, Fe = Qe + At | 0, xt ^= Fe << 13 | Fe >>> 32 - 13, Fe = xt + Qe | 0, Ft ^= Fe << 18 | Fe >>> 32 - 18, Fe = _t + At | 0, St ^= Fe << 7 | Fe >>> 32 - 7, Fe = St + _t | 0, vt ^= Fe << 9 | Fe >>> 32 - 9, Fe = vt + St | 0, At ^= Fe << 13 | Fe >>> 32 - 13, Fe = At + vt | 0, _t ^= Fe << 18 | Fe >>> 32 - 18, Fe = yt + Et | 0, Xe ^= Fe << 7 | Fe >>> 32 - 7, Fe = Xe + yt | 0, Qe ^= Fe << 9 | Fe >>> 32 - 9, Fe = Qe + Xe | 0, Et ^= Fe << 13 | Fe >>> 32 - 13, Fe = Et + Qe | 0, yt ^= Fe << 18 | Fe >>> 32 - 18, Fe = gt + ft | 0, xt ^= Fe << 7 | Fe >>> 32 - 7, Fe = xt + gt | 0, dt ^= Fe << 9 | Fe >>> 32 - 9, Fe = dt + xt | 0, ft ^= Fe << 13 | Fe >>> 32 - 13, Fe = ft + dt | 0, gt ^= Fe << 18 | Fe >>> 32 - 18, Fe = Ft + Ut | 0, Lt ^= Fe << 7 | Fe >>> 32 - 7, Fe = Lt + Ft | 0, Ot ^= Fe << 9 | Fe >>> 32 - 9, Fe = Ot + Lt | 0, Ut ^= Fe << 13 | Fe >>> 32 - 13, Fe = Ut + Ot | 0, Ft ^= Fe << 18 | Fe >>> 32 - 18;
      le[0] = _t >>> 0 & 255, le[1] = _t >>> 8 & 255, le[2] = _t >>> 16 & 255, le[3] = _t >>> 24 & 255, le[4] = yt >>> 0 & 255, le[5] = yt >>> 8 & 255, le[6] = yt >>> 16 & 255, le[7] = yt >>> 24 & 255, le[8] = gt >>> 0 & 255, le[9] = gt >>> 8 & 255, le[10] = gt >>> 16 & 255, le[11] = gt >>> 24 & 255, le[12] = Ft >>> 0 & 255, le[13] = Ft >>> 8 & 255, le[14] = Ft >>> 16 & 255, le[15] = Ft >>> 24 & 255, le[16] = Xe >>> 0 & 255, le[17] = Xe >>> 8 & 255, le[18] = Xe >>> 16 & 255, le[19] = Xe >>> 24 & 255, le[20] = Qe >>> 0 & 255, le[21] = Qe >>> 8 & 255, le[22] = Qe >>> 16 & 255, le[23] = Qe >>> 24 & 255, le[24] = dt >>> 0 & 255, le[25] = dt >>> 8 & 255, le[26] = dt >>> 16 & 255, le[27] = dt >>> 24 & 255, le[28] = ft >>> 0 & 255, le[29] = ft >>> 8 & 255, le[30] = ft >>> 16 & 255, le[31] = ft >>> 24 & 255;
    }
    function me(le, be, Me, te) {
      pe(le, be, Me, te);
    }
    function ge(le, be, Me, te) {
      ae(le, be, Me, te);
    }
    var we = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function Ee(le, be, Me, te, ve, qe, Pe) {
      var Le = new Uint8Array(16), pt = new Uint8Array(64), Je, Ge;
      for (Ge = 0; Ge < 16; Ge++)
        Le[Ge] = 0;
      for (Ge = 0; Ge < 8; Ge++)
        Le[Ge] = qe[Ge];
      for (; ve >= 64; ) {
        for (me(pt, Le, Pe, we), Ge = 0; Ge < 64; Ge++)
          le[be + Ge] = Me[te + Ge] ^ pt[Ge];
        for (Je = 1, Ge = 8; Ge < 16; Ge++)
          Je = Je + (Le[Ge] & 255) | 0, Le[Ge] = Je & 255, Je >>>= 8;
        ve -= 64, be += 64, te += 64;
      }
      if (ve > 0)
        for (me(pt, Le, Pe, we), Ge = 0; Ge < ve; Ge++)
          le[be + Ge] = Me[te + Ge] ^ pt[Ge];
      return 0;
    }
    function Te(le, be, Me, te, ve) {
      var qe = new Uint8Array(16), Pe = new Uint8Array(64), Le, pt;
      for (pt = 0; pt < 16; pt++)
        qe[pt] = 0;
      for (pt = 0; pt < 8; pt++)
        qe[pt] = te[pt];
      for (; Me >= 64; ) {
        for (me(Pe, qe, ve, we), pt = 0; pt < 64; pt++)
          le[be + pt] = Pe[pt];
        for (Le = 1, pt = 8; pt < 16; pt++)
          Le = Le + (qe[pt] & 255) | 0, qe[pt] = Le & 255, Le >>>= 8;
        Me -= 64, be += 64;
      }
      if (Me > 0)
        for (me(Pe, qe, ve, we), pt = 0; pt < Me; pt++)
          le[be + pt] = Pe[pt];
      return 0;
    }
    function Ke(le, be, Me, te, ve) {
      var qe = new Uint8Array(32);
      ge(qe, te, ve, we);
      for (var Pe = new Uint8Array(8), Le = 0; Le < 8; Le++)
        Pe[Le] = te[Le + 16];
      return Te(le, be, Me, Pe, qe);
    }
    function Se(le, be, Me, te, ve, qe, Pe) {
      var Le = new Uint8Array(32);
      ge(Le, qe, Pe, we);
      for (var pt = new Uint8Array(8), Je = 0; Je < 8; Je++)
        pt[Je] = qe[Je + 16];
      return Ee(le, be, Me, te, ve, pt, Le);
    }
    var X = function(le) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var be, Me, te, ve, qe, Pe, Le, pt;
      be = le[0] & 255 | (le[1] & 255) << 8, this.r[0] = be & 8191, Me = le[2] & 255 | (le[3] & 255) << 8, this.r[1] = (be >>> 13 | Me << 3) & 8191, te = le[4] & 255 | (le[5] & 255) << 8, this.r[2] = (Me >>> 10 | te << 6) & 7939, ve = le[6] & 255 | (le[7] & 255) << 8, this.r[3] = (te >>> 7 | ve << 9) & 8191, qe = le[8] & 255 | (le[9] & 255) << 8, this.r[4] = (ve >>> 4 | qe << 12) & 255, this.r[5] = qe >>> 1 & 8190, Pe = le[10] & 255 | (le[11] & 255) << 8, this.r[6] = (qe >>> 14 | Pe << 2) & 8191, Le = le[12] & 255 | (le[13] & 255) << 8, this.r[7] = (Pe >>> 11 | Le << 5) & 8065, pt = le[14] & 255 | (le[15] & 255) << 8, this.r[8] = (Le >>> 8 | pt << 8) & 8191, this.r[9] = pt >>> 5 & 127, this.pad[0] = le[16] & 255 | (le[17] & 255) << 8, this.pad[1] = le[18] & 255 | (le[19] & 255) << 8, this.pad[2] = le[20] & 255 | (le[21] & 255) << 8, this.pad[3] = le[22] & 255 | (le[23] & 255) << 8, this.pad[4] = le[24] & 255 | (le[25] & 255) << 8, this.pad[5] = le[26] & 255 | (le[27] & 255) << 8, this.pad[6] = le[28] & 255 | (le[29] & 255) << 8, this.pad[7] = le[30] & 255 | (le[31] & 255) << 8;
    };
    X.prototype.blocks = function(le, be, Me) {
      for (var te = this.fin ? 0 : 2048, ve, qe, Pe, Le, pt, Je, Ge, $t, bt, Mt, Rt, Tt, Nt, It, Ct, Bt, _t, St, vt, At = this.h[0], Et = this.h[1], yt = this.h[2], Xe = this.h[3], Qe = this.h[4], dt = this.h[5], ft = this.h[6], gt = this.h[7], xt = this.h[8], Lt = this.h[9], Ot = this.r[0], Ut = this.r[1], Ft = this.r[2], Fe = this.r[3], Kt = this.r[4], jt = this.r[5], zt = this.r[6], Dt = this.r[7], Ht = this.r[8], qt = this.r[9]; Me >= 16; )
        ve = le[be + 0] & 255 | (le[be + 1] & 255) << 8, At += ve & 8191, qe = le[be + 2] & 255 | (le[be + 3] & 255) << 8, Et += (ve >>> 13 | qe << 3) & 8191, Pe = le[be + 4] & 255 | (le[be + 5] & 255) << 8, yt += (qe >>> 10 | Pe << 6) & 8191, Le = le[be + 6] & 255 | (le[be + 7] & 255) << 8, Xe += (Pe >>> 7 | Le << 9) & 8191, pt = le[be + 8] & 255 | (le[be + 9] & 255) << 8, Qe += (Le >>> 4 | pt << 12) & 8191, dt += pt >>> 1 & 8191, Je = le[be + 10] & 255 | (le[be + 11] & 255) << 8, ft += (pt >>> 14 | Je << 2) & 8191, Ge = le[be + 12] & 255 | (le[be + 13] & 255) << 8, gt += (Je >>> 11 | Ge << 5) & 8191, $t = le[be + 14] & 255 | (le[be + 15] & 255) << 8, xt += (Ge >>> 8 | $t << 8) & 8191, Lt += $t >>> 5 | te, bt = 0, Mt = bt, Mt += At * Ot, Mt += Et * (5 * qt), Mt += yt * (5 * Ht), Mt += Xe * (5 * Dt), Mt += Qe * (5 * zt), bt = Mt >>> 13, Mt &= 8191, Mt += dt * (5 * jt), Mt += ft * (5 * Kt), Mt += gt * (5 * Fe), Mt += xt * (5 * Ft), Mt += Lt * (5 * Ut), bt += Mt >>> 13, Mt &= 8191, Rt = bt, Rt += At * Ut, Rt += Et * Ot, Rt += yt * (5 * qt), Rt += Xe * (5 * Ht), Rt += Qe * (5 * Dt), bt = Rt >>> 13, Rt &= 8191, Rt += dt * (5 * zt), Rt += ft * (5 * jt), Rt += gt * (5 * Kt), Rt += xt * (5 * Fe), Rt += Lt * (5 * Ft), bt += Rt >>> 13, Rt &= 8191, Tt = bt, Tt += At * Ft, Tt += Et * Ut, Tt += yt * Ot, Tt += Xe * (5 * qt), Tt += Qe * (5 * Ht), bt = Tt >>> 13, Tt &= 8191, Tt += dt * (5 * Dt), Tt += ft * (5 * zt), Tt += gt * (5 * jt), Tt += xt * (5 * Kt), Tt += Lt * (5 * Fe), bt += Tt >>> 13, Tt &= 8191, Nt = bt, Nt += At * Fe, Nt += Et * Ft, Nt += yt * Ut, Nt += Xe * Ot, Nt += Qe * (5 * qt), bt = Nt >>> 13, Nt &= 8191, Nt += dt * (5 * Ht), Nt += ft * (5 * Dt), Nt += gt * (5 * zt), Nt += xt * (5 * jt), Nt += Lt * (5 * Kt), bt += Nt >>> 13, Nt &= 8191, It = bt, It += At * Kt, It += Et * Fe, It += yt * Ft, It += Xe * Ut, It += Qe * Ot, bt = It >>> 13, It &= 8191, It += dt * (5 * qt), It += ft * (5 * Ht), It += gt * (5 * Dt), It += xt * (5 * zt), It += Lt * (5 * jt), bt += It >>> 13, It &= 8191, Ct = bt, Ct += At * jt, Ct += Et * Kt, Ct += yt * Fe, Ct += Xe * Ft, Ct += Qe * Ut, bt = Ct >>> 13, Ct &= 8191, Ct += dt * Ot, Ct += ft * (5 * qt), Ct += gt * (5 * Ht), Ct += xt * (5 * Dt), Ct += Lt * (5 * zt), bt += Ct >>> 13, Ct &= 8191, Bt = bt, Bt += At * zt, Bt += Et * jt, Bt += yt * Kt, Bt += Xe * Fe, Bt += Qe * Ft, bt = Bt >>> 13, Bt &= 8191, Bt += dt * Ut, Bt += ft * Ot, Bt += gt * (5 * qt), Bt += xt * (5 * Ht), Bt += Lt * (5 * Dt), bt += Bt >>> 13, Bt &= 8191, _t = bt, _t += At * Dt, _t += Et * zt, _t += yt * jt, _t += Xe * Kt, _t += Qe * Fe, bt = _t >>> 13, _t &= 8191, _t += dt * Ft, _t += ft * Ut, _t += gt * Ot, _t += xt * (5 * qt), _t += Lt * (5 * Ht), bt += _t >>> 13, _t &= 8191, St = bt, St += At * Ht, St += Et * Dt, St += yt * zt, St += Xe * jt, St += Qe * Kt, bt = St >>> 13, St &= 8191, St += dt * Fe, St += ft * Ft, St += gt * Ut, St += xt * Ot, St += Lt * (5 * qt), bt += St >>> 13, St &= 8191, vt = bt, vt += At * qt, vt += Et * Ht, vt += yt * Dt, vt += Xe * zt, vt += Qe * jt, bt = vt >>> 13, vt &= 8191, vt += dt * Kt, vt += ft * Fe, vt += gt * Ft, vt += xt * Ut, vt += Lt * Ot, bt += vt >>> 13, vt &= 8191, bt = (bt << 2) + bt | 0, bt = bt + Mt | 0, Mt = bt & 8191, bt = bt >>> 13, Rt += bt, At = Mt, Et = Rt, yt = Tt, Xe = Nt, Qe = It, dt = Ct, ft = Bt, gt = _t, xt = St, Lt = vt, be += 16, Me -= 16;
      this.h[0] = At, this.h[1] = Et, this.h[2] = yt, this.h[3] = Xe, this.h[4] = Qe, this.h[5] = dt, this.h[6] = ft, this.h[7] = gt, this.h[8] = xt, this.h[9] = Lt;
    }, X.prototype.finish = function(le, be) {
      var Me = new Uint16Array(10), te, ve, qe, Pe;
      if (this.leftover) {
        for (Pe = this.leftover, this.buffer[Pe++] = 1; Pe < 16; Pe++)
          this.buffer[Pe] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (te = this.h[1] >>> 13, this.h[1] &= 8191, Pe = 2; Pe < 10; Pe++)
        this.h[Pe] += te, te = this.h[Pe] >>> 13, this.h[Pe] &= 8191;
      for (this.h[0] += te * 5, te = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += te, te = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += te, Me[0] = this.h[0] + 5, te = Me[0] >>> 13, Me[0] &= 8191, Pe = 1; Pe < 10; Pe++)
        Me[Pe] = this.h[Pe] + te, te = Me[Pe] >>> 13, Me[Pe] &= 8191;
      for (Me[9] -= 1 << 13, ve = (te ^ 1) - 1, Pe = 0; Pe < 10; Pe++)
        Me[Pe] &= ve;
      for (ve = ~ve, Pe = 0; Pe < 10; Pe++)
        this.h[Pe] = this.h[Pe] & ve | Me[Pe];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, qe = this.h[0] + this.pad[0], this.h[0] = qe & 65535, Pe = 1; Pe < 8; Pe++)
        qe = (this.h[Pe] + this.pad[Pe] | 0) + (qe >>> 16) | 0, this.h[Pe] = qe & 65535;
      le[be + 0] = this.h[0] >>> 0 & 255, le[be + 1] = this.h[0] >>> 8 & 255, le[be + 2] = this.h[1] >>> 0 & 255, le[be + 3] = this.h[1] >>> 8 & 255, le[be + 4] = this.h[2] >>> 0 & 255, le[be + 5] = this.h[2] >>> 8 & 255, le[be + 6] = this.h[3] >>> 0 & 255, le[be + 7] = this.h[3] >>> 8 & 255, le[be + 8] = this.h[4] >>> 0 & 255, le[be + 9] = this.h[4] >>> 8 & 255, le[be + 10] = this.h[5] >>> 0 & 255, le[be + 11] = this.h[5] >>> 8 & 255, le[be + 12] = this.h[6] >>> 0 & 255, le[be + 13] = this.h[6] >>> 8 & 255, le[be + 14] = this.h[7] >>> 0 & 255, le[be + 15] = this.h[7] >>> 8 & 255;
    }, X.prototype.update = function(le, be, Me) {
      var te, ve;
      if (this.leftover) {
        for (ve = 16 - this.leftover, ve > Me && (ve = Me), te = 0; te < ve; te++)
          this.buffer[this.leftover + te] = le[be + te];
        if (Me -= ve, be += ve, this.leftover += ve, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (Me >= 16 && (ve = Me - Me % 16, this.blocks(le, be, ve), be += ve, Me -= ve), Me) {
        for (te = 0; te < Me; te++)
          this.buffer[this.leftover + te] = le[be + te];
        this.leftover += Me;
      }
    };
    function fe(le, be, Me, te, ve, qe) {
      var Pe = new X(qe);
      return Pe.update(Me, te, ve), Pe.finish(le, be), 0;
    }
    function k(le, be, Me, te, ve, qe) {
      var Pe = new Uint8Array(16);
      return fe(Pe, 0, Me, te, ve, qe), re(le, be, Pe, 0);
    }
    function p(le, be, Me, te, ve) {
      var qe;
      if (Me < 32)
        return -1;
      for (Se(le, 0, be, 0, Me, te, ve), fe(le, 16, le, 32, Me - 32, le), qe = 0; qe < 16; qe++)
        le[qe] = 0;
      return 0;
    }
    function x(le, be, Me, te, ve) {
      var qe, Pe = new Uint8Array(32);
      if (Me < 32 || (Ke(Pe, 0, 32, te, ve), k(be, 16, be, 32, Me - 32, Pe) !== 0))
        return -1;
      for (Se(le, 0, be, 0, Me, te, ve), qe = 0; qe < 32; qe++)
        le[qe] = 0;
      return 0;
    }
    function S(le, be) {
      var Me;
      for (Me = 0; Me < 16; Me++)
        le[Me] = be[Me] | 0;
    }
    function B(le) {
      var be, Me, te = 1;
      for (be = 0; be < 16; be++)
        Me = le[be] + te + 65535, te = Math.floor(Me / 65536), le[be] = Me - te * 65536;
      le[0] += te - 1 + 37 * (te - 1);
    }
    function L(le, be, Me) {
      for (var te, ve = ~(Me - 1), qe = 0; qe < 16; qe++)
        te = ve & (le[qe] ^ be[qe]), le[qe] ^= te, be[qe] ^= te;
    }
    function C(le, be) {
      var Me, te, ve, qe = s(), Pe = s();
      for (Me = 0; Me < 16; Me++)
        Pe[Me] = be[Me];
      for (B(Pe), B(Pe), B(Pe), te = 0; te < 2; te++) {
        for (qe[0] = Pe[0] - 65517, Me = 1; Me < 15; Me++)
          qe[Me] = Pe[Me] - 65535 - (qe[Me - 1] >> 16 & 1), qe[Me - 1] &= 65535;
        qe[15] = Pe[15] - 32767 - (qe[14] >> 16 & 1), ve = qe[15] >> 16 & 1, qe[14] &= 65535, L(Pe, qe, 1 - ve);
      }
      for (Me = 0; Me < 16; Me++)
        le[2 * Me] = Pe[Me] & 255, le[2 * Me + 1] = Pe[Me] >> 8;
    }
    function G(le, be) {
      var Me = new Uint8Array(32), te = new Uint8Array(32);
      return C(Me, le), C(te, be), oe(Me, 0, te, 0);
    }
    function R(le) {
      var be = new Uint8Array(32);
      return C(be, le), be[0] & 1;
    }
    function y(le, be) {
      var Me;
      for (Me = 0; Me < 16; Me++)
        le[Me] = be[2 * Me] + (be[2 * Me + 1] << 8);
      le[15] &= 32767;
    }
    function j(le, be, Me) {
      for (var te = 0; te < 16; te++)
        le[te] = be[te] + Me[te];
    }
    function ye(le, be, Me) {
      for (var te = 0; te < 16; te++)
        le[te] = be[te] - Me[te];
    }
    function ee(le, be, Me) {
      var te, ve, qe = 0, Pe = 0, Le = 0, pt = 0, Je = 0, Ge = 0, $t = 0, bt = 0, Mt = 0, Rt = 0, Tt = 0, Nt = 0, It = 0, Ct = 0, Bt = 0, _t = 0, St = 0, vt = 0, At = 0, Et = 0, yt = 0, Xe = 0, Qe = 0, dt = 0, ft = 0, gt = 0, xt = 0, Lt = 0, Ot = 0, Ut = 0, Ft = 0, Fe = Me[0], Kt = Me[1], jt = Me[2], zt = Me[3], Dt = Me[4], Ht = Me[5], qt = Me[6], tr = Me[7], Wt = Me[8], Xt = Me[9], Qt = Me[10], er = Me[11], rr = Me[12], nr = Me[13], ir = Me[14], or = Me[15];
      te = be[0], qe += te * Fe, Pe += te * Kt, Le += te * jt, pt += te * zt, Je += te * Dt, Ge += te * Ht, $t += te * qt, bt += te * tr, Mt += te * Wt, Rt += te * Xt, Tt += te * Qt, Nt += te * er, It += te * rr, Ct += te * nr, Bt += te * ir, _t += te * or, te = be[1], Pe += te * Fe, Le += te * Kt, pt += te * jt, Je += te * zt, Ge += te * Dt, $t += te * Ht, bt += te * qt, Mt += te * tr, Rt += te * Wt, Tt += te * Xt, Nt += te * Qt, It += te * er, Ct += te * rr, Bt += te * nr, _t += te * ir, St += te * or, te = be[2], Le += te * Fe, pt += te * Kt, Je += te * jt, Ge += te * zt, $t += te * Dt, bt += te * Ht, Mt += te * qt, Rt += te * tr, Tt += te * Wt, Nt += te * Xt, It += te * Qt, Ct += te * er, Bt += te * rr, _t += te * nr, St += te * ir, vt += te * or, te = be[3], pt += te * Fe, Je += te * Kt, Ge += te * jt, $t += te * zt, bt += te * Dt, Mt += te * Ht, Rt += te * qt, Tt += te * tr, Nt += te * Wt, It += te * Xt, Ct += te * Qt, Bt += te * er, _t += te * rr, St += te * nr, vt += te * ir, At += te * or, te = be[4], Je += te * Fe, Ge += te * Kt, $t += te * jt, bt += te * zt, Mt += te * Dt, Rt += te * Ht, Tt += te * qt, Nt += te * tr, It += te * Wt, Ct += te * Xt, Bt += te * Qt, _t += te * er, St += te * rr, vt += te * nr, At += te * ir, Et += te * or, te = be[5], Ge += te * Fe, $t += te * Kt, bt += te * jt, Mt += te * zt, Rt += te * Dt, Tt += te * Ht, Nt += te * qt, It += te * tr, Ct += te * Wt, Bt += te * Xt, _t += te * Qt, St += te * er, vt += te * rr, At += te * nr, Et += te * ir, yt += te * or, te = be[6], $t += te * Fe, bt += te * Kt, Mt += te * jt, Rt += te * zt, Tt += te * Dt, Nt += te * Ht, It += te * qt, Ct += te * tr, Bt += te * Wt, _t += te * Xt, St += te * Qt, vt += te * er, At += te * rr, Et += te * nr, yt += te * ir, Xe += te * or, te = be[7], bt += te * Fe, Mt += te * Kt, Rt += te * jt, Tt += te * zt, Nt += te * Dt, It += te * Ht, Ct += te * qt, Bt += te * tr, _t += te * Wt, St += te * Xt, vt += te * Qt, At += te * er, Et += te * rr, yt += te * nr, Xe += te * ir, Qe += te * or, te = be[8], Mt += te * Fe, Rt += te * Kt, Tt += te * jt, Nt += te * zt, It += te * Dt, Ct += te * Ht, Bt += te * qt, _t += te * tr, St += te * Wt, vt += te * Xt, At += te * Qt, Et += te * er, yt += te * rr, Xe += te * nr, Qe += te * ir, dt += te * or, te = be[9], Rt += te * Fe, Tt += te * Kt, Nt += te * jt, It += te * zt, Ct += te * Dt, Bt += te * Ht, _t += te * qt, St += te * tr, vt += te * Wt, At += te * Xt, Et += te * Qt, yt += te * er, Xe += te * rr, Qe += te * nr, dt += te * ir, ft += te * or, te = be[10], Tt += te * Fe, Nt += te * Kt, It += te * jt, Ct += te * zt, Bt += te * Dt, _t += te * Ht, St += te * qt, vt += te * tr, At += te * Wt, Et += te * Xt, yt += te * Qt, Xe += te * er, Qe += te * rr, dt += te * nr, ft += te * ir, gt += te * or, te = be[11], Nt += te * Fe, It += te * Kt, Ct += te * jt, Bt += te * zt, _t += te * Dt, St += te * Ht, vt += te * qt, At += te * tr, Et += te * Wt, yt += te * Xt, Xe += te * Qt, Qe += te * er, dt += te * rr, ft += te * nr, gt += te * ir, xt += te * or, te = be[12], It += te * Fe, Ct += te * Kt, Bt += te * jt, _t += te * zt, St += te * Dt, vt += te * Ht, At += te * qt, Et += te * tr, yt += te * Wt, Xe += te * Xt, Qe += te * Qt, dt += te * er, ft += te * rr, gt += te * nr, xt += te * ir, Lt += te * or, te = be[13], Ct += te * Fe, Bt += te * Kt, _t += te * jt, St += te * zt, vt += te * Dt, At += te * Ht, Et += te * qt, yt += te * tr, Xe += te * Wt, Qe += te * Xt, dt += te * Qt, ft += te * er, gt += te * rr, xt += te * nr, Lt += te * ir, Ot += te * or, te = be[14], Bt += te * Fe, _t += te * Kt, St += te * jt, vt += te * zt, At += te * Dt, Et += te * Ht, yt += te * qt, Xe += te * tr, Qe += te * Wt, dt += te * Xt, ft += te * Qt, gt += te * er, xt += te * rr, Lt += te * nr, Ot += te * ir, Ut += te * or, te = be[15], _t += te * Fe, St += te * Kt, vt += te * jt, At += te * zt, Et += te * Dt, yt += te * Ht, Xe += te * qt, Qe += te * tr, dt += te * Wt, ft += te * Xt, gt += te * Qt, xt += te * er, Lt += te * rr, Ot += te * nr, Ut += te * ir, Ft += te * or, qe += 38 * St, Pe += 38 * vt, Le += 38 * At, pt += 38 * Et, Je += 38 * yt, Ge += 38 * Xe, $t += 38 * Qe, bt += 38 * dt, Mt += 38 * ft, Rt += 38 * gt, Tt += 38 * xt, Nt += 38 * Lt, It += 38 * Ot, Ct += 38 * Ut, Bt += 38 * Ft, ve = 1, te = qe + ve + 65535, ve = Math.floor(te / 65536), qe = te - ve * 65536, te = Pe + ve + 65535, ve = Math.floor(te / 65536), Pe = te - ve * 65536, te = Le + ve + 65535, ve = Math.floor(te / 65536), Le = te - ve * 65536, te = pt + ve + 65535, ve = Math.floor(te / 65536), pt = te - ve * 65536, te = Je + ve + 65535, ve = Math.floor(te / 65536), Je = te - ve * 65536, te = Ge + ve + 65535, ve = Math.floor(te / 65536), Ge = te - ve * 65536, te = $t + ve + 65535, ve = Math.floor(te / 65536), $t = te - ve * 65536, te = bt + ve + 65535, ve = Math.floor(te / 65536), bt = te - ve * 65536, te = Mt + ve + 65535, ve = Math.floor(te / 65536), Mt = te - ve * 65536, te = Rt + ve + 65535, ve = Math.floor(te / 65536), Rt = te - ve * 65536, te = Tt + ve + 65535, ve = Math.floor(te / 65536), Tt = te - ve * 65536, te = Nt + ve + 65535, ve = Math.floor(te / 65536), Nt = te - ve * 65536, te = It + ve + 65535, ve = Math.floor(te / 65536), It = te - ve * 65536, te = Ct + ve + 65535, ve = Math.floor(te / 65536), Ct = te - ve * 65536, te = Bt + ve + 65535, ve = Math.floor(te / 65536), Bt = te - ve * 65536, te = _t + ve + 65535, ve = Math.floor(te / 65536), _t = te - ve * 65536, qe += ve - 1 + 37 * (ve - 1), ve = 1, te = qe + ve + 65535, ve = Math.floor(te / 65536), qe = te - ve * 65536, te = Pe + ve + 65535, ve = Math.floor(te / 65536), Pe = te - ve * 65536, te = Le + ve + 65535, ve = Math.floor(te / 65536), Le = te - ve * 65536, te = pt + ve + 65535, ve = Math.floor(te / 65536), pt = te - ve * 65536, te = Je + ve + 65535, ve = Math.floor(te / 65536), Je = te - ve * 65536, te = Ge + ve + 65535, ve = Math.floor(te / 65536), Ge = te - ve * 65536, te = $t + ve + 65535, ve = Math.floor(te / 65536), $t = te - ve * 65536, te = bt + ve + 65535, ve = Math.floor(te / 65536), bt = te - ve * 65536, te = Mt + ve + 65535, ve = Math.floor(te / 65536), Mt = te - ve * 65536, te = Rt + ve + 65535, ve = Math.floor(te / 65536), Rt = te - ve * 65536, te = Tt + ve + 65535, ve = Math.floor(te / 65536), Tt = te - ve * 65536, te = Nt + ve + 65535, ve = Math.floor(te / 65536), Nt = te - ve * 65536, te = It + ve + 65535, ve = Math.floor(te / 65536), It = te - ve * 65536, te = Ct + ve + 65535, ve = Math.floor(te / 65536), Ct = te - ve * 65536, te = Bt + ve + 65535, ve = Math.floor(te / 65536), Bt = te - ve * 65536, te = _t + ve + 65535, ve = Math.floor(te / 65536), _t = te - ve * 65536, qe += ve - 1 + 37 * (ve - 1), le[0] = qe, le[1] = Pe, le[2] = Le, le[3] = pt, le[4] = Je, le[5] = Ge, le[6] = $t, le[7] = bt, le[8] = Mt, le[9] = Rt, le[10] = Tt, le[11] = Nt, le[12] = It, le[13] = Ct, le[14] = Bt, le[15] = _t;
    }
    function xe(le, be) {
      ee(le, be, be);
    }
    function $e(le, be) {
      var Me = s(), te;
      for (te = 0; te < 16; te++)
        Me[te] = be[te];
      for (te = 253; te >= 0; te--)
        xe(Me, Me), te !== 2 && te !== 4 && ee(Me, Me, be);
      for (te = 0; te < 16; te++)
        le[te] = Me[te];
    }
    function ke(le, be) {
      var Me = s(), te;
      for (te = 0; te < 16; te++)
        Me[te] = be[te];
      for (te = 250; te >= 0; te--)
        xe(Me, Me), te !== 1 && ee(Me, Me, be);
      for (te = 0; te < 16; te++)
        le[te] = Me[te];
    }
    function Ce(le, be, Me) {
      var te = new Uint8Array(32), ve = new Float64Array(80), qe, Pe, Le = s(), pt = s(), Je = s(), Ge = s(), $t = s(), bt = s();
      for (Pe = 0; Pe < 31; Pe++)
        te[Pe] = be[Pe];
      for (te[31] = be[31] & 127 | 64, te[0] &= 248, y(ve, Me), Pe = 0; Pe < 16; Pe++)
        pt[Pe] = ve[Pe], Ge[Pe] = Le[Pe] = Je[Pe] = 0;
      for (Le[0] = Ge[0] = 1, Pe = 254; Pe >= 0; --Pe)
        qe = te[Pe >>> 3] >>> (Pe & 7) & 1, L(Le, pt, qe), L(Je, Ge, qe), j($t, Le, Je), ye(Le, Le, Je), j(Je, pt, Ge), ye(pt, pt, Ge), xe(Ge, $t), xe(bt, Le), ee(Le, Je, Le), ee(Je, pt, $t), j($t, Le, Je), ye(Le, Le, Je), xe(pt, Le), ye(Je, Ge, bt), ee(Le, Je, T), j(Le, Le, Ge), ee(Je, Je, Le), ee(Le, Ge, bt), ee(Ge, pt, ve), xe(pt, $t), L(Le, pt, qe), L(Je, Ge, qe);
      for (Pe = 0; Pe < 16; Pe++)
        ve[Pe + 16] = Le[Pe], ve[Pe + 32] = Je[Pe], ve[Pe + 48] = pt[Pe], ve[Pe + 64] = Ge[Pe];
      var Mt = ve.subarray(32), Rt = ve.subarray(16);
      return $e(Mt, Mt), ee(Rt, Rt, Mt), C(le, Rt), 0;
    }
    function ht(le, be) {
      return Ce(le, be, d);
    }
    function Ue(le, be) {
      return h(be, 32), ht(le, be);
    }
    function De(le, be, Me) {
      var te = new Uint8Array(32);
      return Ce(te, Me, be), ge(le, m, te, we);
    }
    var wt = p, He = x;
    function Ze(le, be, Me, te, ve, qe) {
      var Pe = new Uint8Array(32);
      return De(Pe, ve, qe), wt(le, be, Me, te, Pe);
    }
    function Ie(le, be, Me, te, ve, qe) {
      var Pe = new Uint8Array(32);
      return De(Pe, ve, qe), He(le, be, Me, te, Pe);
    }
    var ue = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function he(le, be, Me, te) {
      for (var ve = new Int32Array(16), qe = new Int32Array(16), Pe, Le, pt, Je, Ge, $t, bt, Mt, Rt, Tt, Nt, It, Ct, Bt, _t, St, vt, At, Et, yt, Xe, Qe, dt, ft, gt, xt, Lt = le[0], Ot = le[1], Ut = le[2], Ft = le[3], Fe = le[4], Kt = le[5], jt = le[6], zt = le[7], Dt = be[0], Ht = be[1], qt = be[2], tr = be[3], Wt = be[4], Xt = be[5], Qt = be[6], er = be[7], rr = 0; te >= 128; ) {
        for (Et = 0; Et < 16; Et++)
          yt = 8 * Et + rr, ve[Et] = Me[yt + 0] << 24 | Me[yt + 1] << 16 | Me[yt + 2] << 8 | Me[yt + 3], qe[Et] = Me[yt + 4] << 24 | Me[yt + 5] << 16 | Me[yt + 6] << 8 | Me[yt + 7];
        for (Et = 0; Et < 80; Et++)
          if (Pe = Lt, Le = Ot, pt = Ut, Je = Ft, Ge = Fe, $t = Kt, bt = jt, Mt = zt, Rt = Dt, Tt = Ht, Nt = qt, It = tr, Ct = Wt, Bt = Xt, _t = Qt, St = er, Xe = zt, Qe = er, dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = (Fe >>> 14 | Wt << 32 - 14) ^ (Fe >>> 18 | Wt << 32 - 18) ^ (Wt >>> 41 - 32 | Fe << 32 - (41 - 32)), Qe = (Wt >>> 14 | Fe << 32 - 14) ^ (Wt >>> 18 | Fe << 32 - 18) ^ (Fe >>> 41 - 32 | Wt << 32 - (41 - 32)), dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, Xe = Fe & Kt ^ ~Fe & jt, Qe = Wt & Xt ^ ~Wt & Qt, dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, Xe = ue[Et * 2], Qe = ue[Et * 2 + 1], dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, Xe = ve[Et % 16], Qe = qe[Et % 16], dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, vt = gt & 65535 | xt << 16, At = dt & 65535 | ft << 16, Xe = vt, Qe = At, dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = (Lt >>> 28 | Dt << 32 - 28) ^ (Dt >>> 34 - 32 | Lt << 32 - (34 - 32)) ^ (Dt >>> 39 - 32 | Lt << 32 - (39 - 32)), Qe = (Dt >>> 28 | Lt << 32 - 28) ^ (Lt >>> 34 - 32 | Dt << 32 - (34 - 32)) ^ (Lt >>> 39 - 32 | Dt << 32 - (39 - 32)), dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, Xe = Lt & Ot ^ Lt & Ut ^ Ot & Ut, Qe = Dt & Ht ^ Dt & qt ^ Ht & qt, dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, Mt = gt & 65535 | xt << 16, St = dt & 65535 | ft << 16, Xe = Je, Qe = It, dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = vt, Qe = At, dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, Je = gt & 65535 | xt << 16, It = dt & 65535 | ft << 16, Ot = Pe, Ut = Le, Ft = pt, Fe = Je, Kt = Ge, jt = $t, zt = bt, Lt = Mt, Ht = Rt, qt = Tt, tr = Nt, Wt = It, Xt = Ct, Qt = Bt, er = _t, Dt = St, Et % 16 === 15)
            for (yt = 0; yt < 16; yt++)
              Xe = ve[yt], Qe = qe[yt], dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = ve[(yt + 9) % 16], Qe = qe[(yt + 9) % 16], dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, vt = ve[(yt + 1) % 16], At = qe[(yt + 1) % 16], Xe = (vt >>> 1 | At << 32 - 1) ^ (vt >>> 8 | At << 32 - 8) ^ vt >>> 7, Qe = (At >>> 1 | vt << 32 - 1) ^ (At >>> 8 | vt << 32 - 8) ^ (At >>> 7 | vt << 32 - 7), dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, vt = ve[(yt + 14) % 16], At = qe[(yt + 14) % 16], Xe = (vt >>> 19 | At << 32 - 19) ^ (At >>> 61 - 32 | vt << 32 - (61 - 32)) ^ vt >>> 6, Qe = (At >>> 19 | vt << 32 - 19) ^ (vt >>> 61 - 32 | At << 32 - (61 - 32)) ^ (At >>> 6 | vt << 32 - 6), dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, ve[yt] = gt & 65535 | xt << 16, qe[yt] = dt & 65535 | ft << 16;
        Xe = Lt, Qe = Dt, dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = le[0], Qe = be[0], dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, le[0] = Lt = gt & 65535 | xt << 16, be[0] = Dt = dt & 65535 | ft << 16, Xe = Ot, Qe = Ht, dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = le[1], Qe = be[1], dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, le[1] = Ot = gt & 65535 | xt << 16, be[1] = Ht = dt & 65535 | ft << 16, Xe = Ut, Qe = qt, dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = le[2], Qe = be[2], dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, le[2] = Ut = gt & 65535 | xt << 16, be[2] = qt = dt & 65535 | ft << 16, Xe = Ft, Qe = tr, dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = le[3], Qe = be[3], dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, le[3] = Ft = gt & 65535 | xt << 16, be[3] = tr = dt & 65535 | ft << 16, Xe = Fe, Qe = Wt, dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = le[4], Qe = be[4], dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, le[4] = Fe = gt & 65535 | xt << 16, be[4] = Wt = dt & 65535 | ft << 16, Xe = Kt, Qe = Xt, dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = le[5], Qe = be[5], dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, le[5] = Kt = gt & 65535 | xt << 16, be[5] = Xt = dt & 65535 | ft << 16, Xe = jt, Qe = Qt, dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = le[6], Qe = be[6], dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, le[6] = jt = gt & 65535 | xt << 16, be[6] = Qt = dt & 65535 | ft << 16, Xe = zt, Qe = er, dt = Qe & 65535, ft = Qe >>> 16, gt = Xe & 65535, xt = Xe >>> 16, Xe = le[7], Qe = be[7], dt += Qe & 65535, ft += Qe >>> 16, gt += Xe & 65535, xt += Xe >>> 16, ft += dt >>> 16, gt += ft >>> 16, xt += gt >>> 16, le[7] = zt = gt & 65535 | xt << 16, be[7] = er = dt & 65535 | ft << 16, rr += 128, te -= 128;
      }
      return te;
    }
    function Ne(le, be, Me) {
      var te = new Int32Array(8), ve = new Int32Array(8), qe = new Uint8Array(256), Pe, Le = Me;
      for (te[0] = 1779033703, te[1] = 3144134277, te[2] = 1013904242, te[3] = 2773480762, te[4] = 1359893119, te[5] = 2600822924, te[6] = 528734635, te[7] = 1541459225, ve[0] = 4089235720, ve[1] = 2227873595, ve[2] = 4271175723, ve[3] = 1595750129, ve[4] = 2917565137, ve[5] = 725511199, ve[6] = 4215389547, ve[7] = 327033209, he(te, ve, be, Me), Me %= 128, Pe = 0; Pe < Me; Pe++)
        qe[Pe] = be[Le - Me + Pe];
      for (qe[Me] = 128, Me = 256 - 128 * (Me < 112 ? 1 : 0), qe[Me - 9] = 0, de(qe, Me - 8, Le / 536870912 | 0, Le << 3), he(te, ve, qe, Me), Pe = 0; Pe < 8; Pe++)
        de(le, 8 * Pe, te[Pe], ve[Pe]);
      return 0;
    }
    function Be(le, be) {
      var Me = s(), te = s(), ve = s(), qe = s(), Pe = s(), Le = s(), pt = s(), Je = s(), Ge = s();
      ye(Me, le[1], le[0]), ye(Ge, be[1], be[0]), ee(Me, Me, Ge), j(te, le[0], le[1]), j(Ge, be[0], be[1]), ee(te, te, Ge), ee(ve, le[3], be[3]), ee(ve, ve, J), ee(qe, le[2], be[2]), j(qe, qe, qe), ye(Pe, te, Me), ye(Le, qe, ve), j(pt, qe, ve), j(Je, te, Me), ee(le[0], Pe, Le), ee(le[1], Je, pt), ee(le[2], pt, Le), ee(le[3], Pe, Je);
    }
    function Oe(le, be, Me) {
      var te;
      for (te = 0; te < 4; te++)
        L(le[te], be[te], Me);
    }
    function it(le, be) {
      var Me = s(), te = s(), ve = s();
      $e(ve, be[2]), ee(Me, be[0], ve), ee(te, be[1], ve), C(le, te), le[31] ^= R(Me) << 7;
    }
    function Ve(le, be, Me) {
      var te, ve;
      for (S(le[0], v), S(le[1], _), S(le[2], _), S(le[3], v), ve = 255; ve >= 0; --ve)
        te = Me[ve / 8 | 0] >> (ve & 7) & 1, Oe(le, be, te), Be(be, le), Be(le, le), Oe(le, be, te);
    }
    function Ye(le, be) {
      var Me = [s(), s(), s(), s()];
      S(Me[0], Y), S(Me[1], ie), S(Me[2], _), ee(Me[3], Y, ie), Ve(le, Me, be);
    }
    function Pt(le, be, Me) {
      var te = new Uint8Array(64), ve = [s(), s(), s(), s()], qe;
      for (Me || h(be, 32), Ne(te, be, 32), te[0] &= 248, te[31] &= 127, te[31] |= 64, Ye(ve, te), it(le, ve), qe = 0; qe < 32; qe++)
        be[qe + 32] = le[qe];
      return 0;
    }
    var et = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function Q(le, be) {
      var Me, te, ve, qe;
      for (te = 63; te >= 32; --te) {
        for (Me = 0, ve = te - 32, qe = te - 12; ve < qe; ++ve)
          be[ve] += Me - 16 * be[te] * et[ve - (te - 32)], Me = Math.floor((be[ve] + 128) / 256), be[ve] -= Me * 256;
        be[ve] += Me, be[te] = 0;
      }
      for (Me = 0, ve = 0; ve < 32; ve++)
        be[ve] += Me - (be[31] >> 4) * et[ve], Me = be[ve] >> 8, be[ve] &= 255;
      for (ve = 0; ve < 32; ve++)
        be[ve] -= Me * et[ve];
      for (te = 0; te < 32; te++)
        be[te + 1] += be[te] >> 8, le[te] = be[te] & 255;
    }
    function W(le) {
      var be = new Float64Array(64), Me;
      for (Me = 0; Me < 64; Me++)
        be[Me] = le[Me];
      for (Me = 0; Me < 64; Me++)
        le[Me] = 0;
      Q(le, be);
    }
    function V(le, be, Me, te) {
      var ve = new Uint8Array(64), qe = new Uint8Array(64), Pe = new Uint8Array(64), Le, pt, Je = new Float64Array(64), Ge = [s(), s(), s(), s()];
      Ne(ve, te, 32), ve[0] &= 248, ve[31] &= 127, ve[31] |= 64;
      var $t = Me + 64;
      for (Le = 0; Le < Me; Le++)
        le[64 + Le] = be[Le];
      for (Le = 0; Le < 32; Le++)
        le[32 + Le] = ve[32 + Le];
      for (Ne(Pe, le.subarray(32), Me + 32), W(Pe), Ye(Ge, Pe), it(le, Ge), Le = 32; Le < 64; Le++)
        le[Le] = te[Le];
      for (Ne(qe, le, Me + 64), W(qe), Le = 0; Le < 64; Le++)
        Je[Le] = 0;
      for (Le = 0; Le < 32; Le++)
        Je[Le] = Pe[Le];
      for (Le = 0; Le < 32; Le++)
        for (pt = 0; pt < 32; pt++)
          Je[Le + pt] += qe[Le] * ve[pt];
      return Q(le.subarray(32), Je), $t;
    }
    function se(le, be) {
      var Me = s(), te = s(), ve = s(), qe = s(), Pe = s(), Le = s(), pt = s();
      return S(le[2], _), y(le[1], be), xe(ve, le[1]), ee(qe, ve, z), ye(ve, ve, le[2]), j(qe, le[2], qe), xe(Pe, qe), xe(Le, Pe), ee(pt, Le, Pe), ee(Me, pt, ve), ee(Me, Me, qe), ke(Me, Me), ee(Me, Me, ve), ee(Me, Me, qe), ee(Me, Me, qe), ee(le[0], Me, qe), xe(te, le[0]), ee(te, te, qe), G(te, ve) && ee(le[0], le[0], ne), xe(te, le[0]), ee(te, te, qe), G(te, ve) ? -1 : (R(le[0]) === be[31] >> 7 && ye(le[0], v, le[0]), ee(le[3], le[0], le[1]), 0);
    }
    function Ae(le, be, Me, te) {
      var ve, qe = new Uint8Array(32), Pe = new Uint8Array(64), Le = [s(), s(), s(), s()], pt = [s(), s(), s(), s()];
      if (Me < 64 || se(pt, te))
        return -1;
      for (ve = 0; ve < Me; ve++)
        le[ve] = be[ve];
      for (ve = 0; ve < 32; ve++)
        le[ve + 32] = te[ve];
      if (Ne(Pe, le, Me), W(Pe), Ve(Le, pt, Pe), Ye(pt, be.subarray(32)), Be(Le, pt), it(qe, Le), Me -= 64, oe(be, 0, qe, 0)) {
        for (ve = 0; ve < Me; ve++)
          le[ve] = 0;
        return -1;
      }
      for (ve = 0; ve < Me; ve++)
        le[ve] = be[ve + 64];
      return Me;
    }
    var _e = 32, Re = 24, mt = 32, We = 16, ze = 32, kt = 32, je = 32, ot = 32, Vt = 32, ct = Re, ut = mt, Zt = We, rt = 64, nt = 32, Gt = 64, st = 32, at = 64;
    t.lowlevel = {
      crypto_core_hsalsa20: ge,
      crypto_stream_xor: Se,
      crypto_stream: Ke,
      crypto_stream_salsa20_xor: Ee,
      crypto_stream_salsa20: Te,
      crypto_onetimeauth: fe,
      crypto_onetimeauth_verify: k,
      crypto_verify_16: re,
      crypto_verify_32: oe,
      crypto_secretbox: p,
      crypto_secretbox_open: x,
      crypto_scalarmult: Ce,
      crypto_scalarmult_base: ht,
      crypto_box_beforenm: De,
      crypto_box_afternm: wt,
      crypto_box: Ze,
      crypto_box_open: Ie,
      crypto_box_keypair: Ue,
      crypto_hash: Ne,
      crypto_sign: V,
      crypto_sign_keypair: Pt,
      crypto_sign_open: Ae,
      crypto_secretbox_KEYBYTES: _e,
      crypto_secretbox_NONCEBYTES: Re,
      crypto_secretbox_ZEROBYTES: mt,
      crypto_secretbox_BOXZEROBYTES: We,
      crypto_scalarmult_BYTES: ze,
      crypto_scalarmult_SCALARBYTES: kt,
      crypto_box_PUBLICKEYBYTES: je,
      crypto_box_SECRETKEYBYTES: ot,
      crypto_box_BEFORENMBYTES: Vt,
      crypto_box_NONCEBYTES: ct,
      crypto_box_ZEROBYTES: ut,
      crypto_box_BOXZEROBYTES: Zt,
      crypto_sign_BYTES: rt,
      crypto_sign_PUBLICKEYBYTES: nt,
      crypto_sign_SECRETKEYBYTES: Gt,
      crypto_sign_SEEDBYTES: st,
      crypto_hash_BYTES: at,
      gf: s,
      D: z,
      L: et,
      pack25519: C,
      unpack25519: y,
      M: ee,
      A: j,
      S: xe,
      Z: ye,
      pow2523: ke,
      add: Be,
      set25519: S,
      modL: Q,
      scalarmult: Ve,
      scalarbase: Ye
    };
    function Jt(le, be) {
      if (le.length !== _e)
        throw new Error("bad key size");
      if (be.length !== Re)
        throw new Error("bad nonce size");
    }
    function lt(le, be) {
      if (le.length !== je)
        throw new Error("bad public key size");
      if (be.length !== ot)
        throw new Error("bad secret key size");
    }
    function tt() {
      for (var le = 0; le < arguments.length; le++)
        if (!(arguments[le] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Yt(le) {
      for (var be = 0; be < le.length; be++)
        le[be] = 0;
    }
    t.randomBytes = function(le) {
      var be = new Uint8Array(le);
      return h(be, le), be;
    }, t.secretbox = function(le, be, Me) {
      tt(le, be, Me), Jt(Me, be);
      for (var te = new Uint8Array(mt + le.length), ve = new Uint8Array(te.length), qe = 0; qe < le.length; qe++)
        te[qe + mt] = le[qe];
      return p(ve, te, te.length, be, Me), ve.subarray(We);
    }, t.secretbox.open = function(le, be, Me) {
      tt(le, be, Me), Jt(Me, be);
      for (var te = new Uint8Array(We + le.length), ve = new Uint8Array(te.length), qe = 0; qe < le.length; qe++)
        te[qe + We] = le[qe];
      return te.length < 32 || x(ve, te, te.length, be, Me) !== 0 ? null : ve.subarray(mt);
    }, t.secretbox.keyLength = _e, t.secretbox.nonceLength = Re, t.secretbox.overheadLength = We, t.scalarMult = function(le, be) {
      if (tt(le, be), le.length !== kt)
        throw new Error("bad n size");
      if (be.length !== ze)
        throw new Error("bad p size");
      var Me = new Uint8Array(ze);
      return Ce(Me, le, be), Me;
    }, t.scalarMult.base = function(le) {
      if (tt(le), le.length !== kt)
        throw new Error("bad n size");
      var be = new Uint8Array(ze);
      return ht(be, le), be;
    }, t.scalarMult.scalarLength = kt, t.scalarMult.groupElementLength = ze, t.box = function(le, be, Me, te) {
      var ve = t.box.before(Me, te);
      return t.secretbox(le, be, ve);
    }, t.box.before = function(le, be) {
      tt(le, be), lt(le, be);
      var Me = new Uint8Array(Vt);
      return De(Me, le, be), Me;
    }, t.box.after = t.secretbox, t.box.open = function(le, be, Me, te) {
      var ve = t.box.before(Me, te);
      return t.secretbox.open(le, be, ve);
    }, t.box.open.after = t.secretbox.open, t.box.keyPair = function() {
      var le = new Uint8Array(je), be = new Uint8Array(ot);
      return Ue(le, be), { publicKey: le, secretKey: be };
    }, t.box.keyPair.fromSecretKey = function(le) {
      if (tt(le), le.length !== ot)
        throw new Error("bad secret key size");
      var be = new Uint8Array(je);
      return ht(be, le), { publicKey: be, secretKey: new Uint8Array(le) };
    }, t.box.publicKeyLength = je, t.box.secretKeyLength = ot, t.box.sharedKeyLength = Vt, t.box.nonceLength = ct, t.box.overheadLength = t.secretbox.overheadLength, t.sign = function(le, be) {
      if (tt(le, be), be.length !== Gt)
        throw new Error("bad secret key size");
      var Me = new Uint8Array(rt + le.length);
      return V(Me, le, le.length, be), Me;
    }, t.sign.open = function(le, be) {
      if (tt(le, be), be.length !== nt)
        throw new Error("bad public key size");
      var Me = new Uint8Array(le.length), te = Ae(Me, le, le.length, be);
      if (te < 0)
        return null;
      for (var ve = new Uint8Array(te), qe = 0; qe < ve.length; qe++)
        ve[qe] = Me[qe];
      return ve;
    }, t.sign.detached = function(le, be) {
      for (var Me = t.sign(le, be), te = new Uint8Array(rt), ve = 0; ve < te.length; ve++)
        te[ve] = Me[ve];
      return te;
    }, t.sign.detached.verify = function(le, be, Me) {
      if (tt(le, be, Me), be.length !== rt)
        throw new Error("bad signature size");
      if (Me.length !== nt)
        throw new Error("bad public key size");
      var te = new Uint8Array(rt + le.length), ve = new Uint8Array(rt + le.length), qe;
      for (qe = 0; qe < rt; qe++)
        te[qe] = be[qe];
      for (qe = 0; qe < le.length; qe++)
        te[qe + rt] = le[qe];
      return Ae(ve, te, te.length, Me) >= 0;
    }, t.sign.keyPair = function() {
      var le = new Uint8Array(nt), be = new Uint8Array(Gt);
      return Pt(le, be), { publicKey: le, secretKey: be };
    }, t.sign.keyPair.fromSecretKey = function(le) {
      if (tt(le), le.length !== Gt)
        throw new Error("bad secret key size");
      for (var be = new Uint8Array(nt), Me = 0; Me < be.length; Me++)
        be[Me] = le[32 + Me];
      return { publicKey: be, secretKey: new Uint8Array(le) };
    }, t.sign.keyPair.fromSeed = function(le) {
      if (tt(le), le.length !== st)
        throw new Error("bad seed size");
      for (var be = new Uint8Array(nt), Me = new Uint8Array(Gt), te = 0; te < 32; te++)
        Me[te] = le[te];
      return Pt(be, Me, !0), { publicKey: be, secretKey: Me };
    }, t.sign.publicKeyLength = nt, t.sign.secretKeyLength = Gt, t.sign.seedLength = st, t.sign.signatureLength = rt, t.hash = function(le) {
      tt(le);
      var be = new Uint8Array(at);
      return Ne(be, le, le.length), be;
    }, t.hash.hashLength = at, t.verify = function(le, be) {
      return tt(le, be), le.length === 0 || be.length === 0 || le.length !== be.length ? !1 : ce(le, 0, be, 0, le.length) === 0;
    }, t.setPRNG = function(le) {
      h = le;
    }, function() {
      var le = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (le && le.getRandomValues) {
        var be = 65536;
        t.setPRNG(function(Me, te) {
          var ve, qe = new Uint8Array(te);
          for (ve = 0; ve < te; ve += be)
            le.getRandomValues(qe.subarray(ve, ve + Math.min(te - ve, be)));
          for (ve = 0; ve < te; ve++)
            Me[ve] = qe[ve];
          Yt(qe);
        });
      } else
        typeof commonjsRequire < "u" && (le = require$$0$5, le && le.randomBytes && t.setPRNG(function(Me, te) {
          var ve, qe = le.randomBytes(te);
          for (ve = 0; ve < te; ve++)
            Me[ve] = qe[ve];
          Yt(qe);
        }));
    }();
  })(l.exports ? l.exports : self.nacl = self.nacl || {});
})(naclFast);
var serialize$1 = {}, lib$4 = {}, bn$2 = { exports: {} };
(function(l) {
  (function(t, s) {
    function h(k, p) {
      if (!k)
        throw new Error(p || "Assertion failed");
    }
    function m(k, p) {
      k.super_ = p;
      var x = function() {
      };
      x.prototype = p.prototype, k.prototype = new x(), k.prototype.constructor = k;
    }
    function d(k, p, x) {
      if (d.isBN(k))
        return k;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, k !== null && ((p === "le" || p === "be") && (x = p, p = 10), this._init(k || 0, p || 10, x || "be"));
    }
    typeof t == "object" ? t.exports = d : s.BN = d, d.BN = d, d.wordSize = 26;
    var v;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? v = window.Buffer : v = require$$0$5.Buffer;
    } catch {
    }
    d.isBN = function(p) {
      return p instanceof d ? !0 : p !== null && typeof p == "object" && p.constructor.wordSize === d.wordSize && Array.isArray(p.words);
    }, d.max = function(p, x) {
      return p.cmp(x) > 0 ? p : x;
    }, d.min = function(p, x) {
      return p.cmp(x) < 0 ? p : x;
    }, d.prototype._init = function(p, x, S) {
      if (typeof p == "number")
        return this._initNumber(p, x, S);
      if (typeof p == "object")
        return this._initArray(p, x, S);
      x === "hex" && (x = 16), h(x === (x | 0) && x >= 2 && x <= 36), p = p.toString().replace(/\s+/g, "");
      var B = 0;
      p[0] === "-" && (B++, this.negative = 1), B < p.length && (x === 16 ? this._parseHex(p, B, S) : (this._parseBase(p, x, B), S === "le" && this._initArray(this.toArray(), x, S)));
    }, d.prototype._initNumber = function(p, x, S) {
      p < 0 && (this.negative = 1, p = -p), p < 67108864 ? (this.words = [p & 67108863], this.length = 1) : p < 4503599627370496 ? (this.words = [
        p & 67108863,
        p / 67108864 & 67108863
      ], this.length = 2) : (h(p < 9007199254740992), this.words = [
        p & 67108863,
        p / 67108864 & 67108863,
        1
      ], this.length = 3), S === "le" && this._initArray(this.toArray(), x, S);
    }, d.prototype._initArray = function(p, x, S) {
      if (h(typeof p.length == "number"), p.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(p.length / 3), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var L, C, G = 0;
      if (S === "be")
        for (B = p.length - 1, L = 0; B >= 0; B -= 3)
          C = p[B] | p[B - 1] << 8 | p[B - 2] << 16, this.words[L] |= C << G & 67108863, this.words[L + 1] = C >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, L++);
      else if (S === "le")
        for (B = 0, L = 0; B < p.length; B += 3)
          C = p[B] | p[B + 1] << 8 | p[B + 2] << 16, this.words[L] |= C << G & 67108863, this.words[L + 1] = C >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, L++);
      return this._strip();
    };
    function _(k, p) {
      var x = k.charCodeAt(p);
      if (x >= 48 && x <= 57)
        return x - 48;
      if (x >= 65 && x <= 70)
        return x - 55;
      if (x >= 97 && x <= 102)
        return x - 87;
      h(!1, "Invalid character in " + k);
    }
    function T(k, p, x) {
      var S = _(k, x);
      return x - 1 >= p && (S |= _(k, x - 1) << 4), S;
    }
    d.prototype._parseHex = function(p, x, S) {
      this.length = Math.ceil((p.length - x) / 6), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var L = 0, C = 0, G;
      if (S === "be")
        for (B = p.length - 1; B >= x; B -= 2)
          G = T(p, x, B) << L, this.words[C] |= G & 67108863, L >= 18 ? (L -= 18, C += 1, this.words[C] |= G >>> 26) : L += 8;
      else {
        var R = p.length - x;
        for (B = R % 2 === 0 ? x + 1 : x; B < p.length; B += 2)
          G = T(p, x, B) << L, this.words[C] |= G & 67108863, L >= 18 ? (L -= 18, C += 1, this.words[C] |= G >>> 26) : L += 8;
      }
      this._strip();
    };
    function z(k, p, x, S) {
      for (var B = 0, L = 0, C = Math.min(k.length, x), G = p; G < C; G++) {
        var R = k.charCodeAt(G) - 48;
        B *= S, R >= 49 ? L = R - 49 + 10 : R >= 17 ? L = R - 17 + 10 : L = R, h(R >= 0 && L < S, "Invalid character"), B += L;
      }
      return B;
    }
    d.prototype._parseBase = function(p, x, S) {
      this.words = [0], this.length = 1;
      for (var B = 0, L = 1; L <= 67108863; L *= x)
        B++;
      B--, L = L / x | 0;
      for (var C = p.length - S, G = C % B, R = Math.min(C, C - G) + S, y = 0, j = S; j < R; j += B)
        y = z(p, j, j + B, x), this.imuln(L), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      if (G !== 0) {
        var ye = 1;
        for (y = z(p, j, p.length, x), j = 0; j < G; j++)
          ye *= x;
        this.imuln(ye), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      }
      this._strip();
    }, d.prototype.copy = function(p) {
      p.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        p.words[x] = this.words[x];
      p.length = this.length, p.negative = this.negative, p.red = this.red;
    };
    function J(k, p) {
      k.words = p.words, k.length = p.length, k.negative = p.negative, k.red = p.red;
    }
    if (d.prototype._move = function(p) {
      J(p, this);
    }, d.prototype.clone = function() {
      var p = new d(null);
      return this.copy(p), p;
    }, d.prototype._expand = function(p) {
      for (; this.length < p; )
        this.words[this.length++] = 0;
      return this;
    }, d.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, d.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        d.prototype[Symbol.for("nodejs.util.inspect.custom")] = Y;
      } catch {
        d.prototype.inspect = Y;
      }
    else
      d.prototype.inspect = Y;
    function Y() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var ie = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ne = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], de = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    d.prototype.toString = function(p, x) {
      p = p || 10, x = x | 0 || 1;
      var S;
      if (p === 16 || p === "hex") {
        S = "";
        for (var B = 0, L = 0, C = 0; C < this.length; C++) {
          var G = this.words[C], R = ((G << B | L) & 16777215).toString(16);
          L = G >>> 24 - B & 16777215, B += 2, B >= 26 && (B -= 26, C--), L !== 0 || C !== this.length - 1 ? S = ie[6 - R.length] + R + S : S = R + S;
        }
        for (L !== 0 && (S = L.toString(16) + S); S.length % x !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      if (p === (p | 0) && p >= 2 && p <= 36) {
        var y = ne[p], j = de[p];
        S = "";
        var ye = this.clone();
        for (ye.negative = 0; !ye.isZero(); ) {
          var ee = ye.modrn(j).toString(p);
          ye = ye.idivn(j), ye.isZero() ? S = ee + S : S = ie[y - ee.length] + ee + S;
        }
        for (this.isZero() && (S = "0" + S); S.length % x !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      h(!1, "Base should be between 2 and 36");
    }, d.prototype.toNumber = function() {
      var p = this.words[0];
      return this.length === 2 ? p += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? p += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && h(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -p : p;
    }, d.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, v && (d.prototype.toBuffer = function(p, x) {
      return this.toArrayLike(v, p, x);
    }), d.prototype.toArray = function(p, x) {
      return this.toArrayLike(Array, p, x);
    };
    var ce = function(p, x) {
      return p.allocUnsafe ? p.allocUnsafe(x) : new p(x);
    };
    d.prototype.toArrayLike = function(p, x, S) {
      this._strip();
      var B = this.byteLength(), L = S || Math.max(1, B);
      h(B <= L, "byte array longer than desired length"), h(L > 0, "Requested array length <= 0");
      var C = ce(p, L), G = x === "le" ? "LE" : "BE";
      return this["_toArrayLike" + G](C, B), C;
    }, d.prototype._toArrayLikeLE = function(p, x) {
      for (var S = 0, B = 0, L = 0, C = 0; L < this.length; L++) {
        var G = this.words[L] << C | B;
        p[S++] = G & 255, S < p.length && (p[S++] = G >> 8 & 255), S < p.length && (p[S++] = G >> 16 & 255), C === 6 ? (S < p.length && (p[S++] = G >> 24 & 255), B = 0, C = 0) : (B = G >>> 24, C += 2);
      }
      if (S < p.length)
        for (p[S++] = B; S < p.length; )
          p[S++] = 0;
    }, d.prototype._toArrayLikeBE = function(p, x) {
      for (var S = p.length - 1, B = 0, L = 0, C = 0; L < this.length; L++) {
        var G = this.words[L] << C | B;
        p[S--] = G & 255, S >= 0 && (p[S--] = G >> 8 & 255), S >= 0 && (p[S--] = G >> 16 & 255), C === 6 ? (S >= 0 && (p[S--] = G >> 24 & 255), B = 0, C = 0) : (B = G >>> 24, C += 2);
      }
      if (S >= 0)
        for (p[S--] = B; S >= 0; )
          p[S--] = 0;
    }, Math.clz32 ? d.prototype._countBits = function(p) {
      return 32 - Math.clz32(p);
    } : d.prototype._countBits = function(p) {
      var x = p, S = 0;
      return x >= 4096 && (S += 13, x >>>= 13), x >= 64 && (S += 7, x >>>= 7), x >= 8 && (S += 4, x >>>= 4), x >= 2 && (S += 2, x >>>= 2), S + x;
    }, d.prototype._zeroBits = function(p) {
      if (p === 0)
        return 26;
      var x = p, S = 0;
      return (x & 8191) === 0 && (S += 13, x >>>= 13), (x & 127) === 0 && (S += 7, x >>>= 7), (x & 15) === 0 && (S += 4, x >>>= 4), (x & 3) === 0 && (S += 2, x >>>= 2), (x & 1) === 0 && S++, S;
    }, d.prototype.bitLength = function() {
      var p = this.words[this.length - 1], x = this._countBits(p);
      return (this.length - 1) * 26 + x;
    };
    function re(k) {
      for (var p = new Array(k.bitLength()), x = 0; x < p.length; x++) {
        var S = x / 26 | 0, B = x % 26;
        p[x] = k.words[S] >>> B & 1;
      }
      return p;
    }
    d.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var p = 0, x = 0; x < this.length; x++) {
        var S = this._zeroBits(this.words[x]);
        if (p += S, S !== 26)
          break;
      }
      return p;
    }, d.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, d.prototype.toTwos = function(p) {
      return this.negative !== 0 ? this.abs().inotn(p).iaddn(1) : this.clone();
    }, d.prototype.fromTwos = function(p) {
      return this.testn(p - 1) ? this.notn(p).iaddn(1).ineg() : this.clone();
    }, d.prototype.isNeg = function() {
      return this.negative !== 0;
    }, d.prototype.neg = function() {
      return this.clone().ineg();
    }, d.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, d.prototype.iuor = function(p) {
      for (; this.length < p.length; )
        this.words[this.length++] = 0;
      for (var x = 0; x < p.length; x++)
        this.words[x] = this.words[x] | p.words[x];
      return this._strip();
    }, d.prototype.ior = function(p) {
      return h((this.negative | p.negative) === 0), this.iuor(p);
    }, d.prototype.or = function(p) {
      return this.length > p.length ? this.clone().ior(p) : p.clone().ior(this);
    }, d.prototype.uor = function(p) {
      return this.length > p.length ? this.clone().iuor(p) : p.clone().iuor(this);
    }, d.prototype.iuand = function(p) {
      var x;
      this.length > p.length ? x = p : x = this;
      for (var S = 0; S < x.length; S++)
        this.words[S] = this.words[S] & p.words[S];
      return this.length = x.length, this._strip();
    }, d.prototype.iand = function(p) {
      return h((this.negative | p.negative) === 0), this.iuand(p);
    }, d.prototype.and = function(p) {
      return this.length > p.length ? this.clone().iand(p) : p.clone().iand(this);
    }, d.prototype.uand = function(p) {
      return this.length > p.length ? this.clone().iuand(p) : p.clone().iuand(this);
    }, d.prototype.iuxor = function(p) {
      var x, S;
      this.length > p.length ? (x = this, S = p) : (x = p, S = this);
      for (var B = 0; B < S.length; B++)
        this.words[B] = x.words[B] ^ S.words[B];
      if (this !== x)
        for (; B < x.length; B++)
          this.words[B] = x.words[B];
      return this.length = x.length, this._strip();
    }, d.prototype.ixor = function(p) {
      return h((this.negative | p.negative) === 0), this.iuxor(p);
    }, d.prototype.xor = function(p) {
      return this.length > p.length ? this.clone().ixor(p) : p.clone().ixor(this);
    }, d.prototype.uxor = function(p) {
      return this.length > p.length ? this.clone().iuxor(p) : p.clone().iuxor(this);
    }, d.prototype.inotn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = Math.ceil(p / 26) | 0, S = p % 26;
      this._expand(x), S > 0 && x--;
      for (var B = 0; B < x; B++)
        this.words[B] = ~this.words[B] & 67108863;
      return S > 0 && (this.words[B] = ~this.words[B] & 67108863 >> 26 - S), this._strip();
    }, d.prototype.notn = function(p) {
      return this.clone().inotn(p);
    }, d.prototype.setn = function(p, x) {
      h(typeof p == "number" && p >= 0);
      var S = p / 26 | 0, B = p % 26;
      return this._expand(S + 1), x ? this.words[S] = this.words[S] | 1 << B : this.words[S] = this.words[S] & ~(1 << B), this._strip();
    }, d.prototype.iadd = function(p) {
      var x;
      if (this.negative !== 0 && p.negative === 0)
        return this.negative = 0, x = this.isub(p), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && p.negative !== 0)
        return p.negative = 0, x = this.isub(p), p.negative = 1, x._normSign();
      var S, B;
      this.length > p.length ? (S = this, B = p) : (S = p, B = this);
      for (var L = 0, C = 0; C < B.length; C++)
        x = (S.words[C] | 0) + (B.words[C] | 0) + L, this.words[C] = x & 67108863, L = x >>> 26;
      for (; L !== 0 && C < S.length; C++)
        x = (S.words[C] | 0) + L, this.words[C] = x & 67108863, L = x >>> 26;
      if (this.length = S.length, L !== 0)
        this.words[this.length] = L, this.length++;
      else if (S !== this)
        for (; C < S.length; C++)
          this.words[C] = S.words[C];
      return this;
    }, d.prototype.add = function(p) {
      var x;
      return p.negative !== 0 && this.negative === 0 ? (p.negative = 0, x = this.sub(p), p.negative ^= 1, x) : p.negative === 0 && this.negative !== 0 ? (this.negative = 0, x = p.sub(this), this.negative = 1, x) : this.length > p.length ? this.clone().iadd(p) : p.clone().iadd(this);
    }, d.prototype.isub = function(p) {
      if (p.negative !== 0) {
        p.negative = 0;
        var x = this.iadd(p);
        return p.negative = 1, x._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(p), this.negative = 1, this._normSign();
      var S = this.cmp(p);
      if (S === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var B, L;
      S > 0 ? (B = this, L = p) : (B = p, L = this);
      for (var C = 0, G = 0; G < L.length; G++)
        x = (B.words[G] | 0) - (L.words[G] | 0) + C, C = x >> 26, this.words[G] = x & 67108863;
      for (; C !== 0 && G < B.length; G++)
        x = (B.words[G] | 0) + C, C = x >> 26, this.words[G] = x & 67108863;
      if (C === 0 && G < B.length && B !== this)
        for (; G < B.length; G++)
          this.words[G] = B.words[G];
      return this.length = Math.max(this.length, G), B !== this && (this.negative = 1), this._strip();
    }, d.prototype.sub = function(p) {
      return this.clone().isub(p);
    };
    function oe(k, p, x) {
      x.negative = p.negative ^ k.negative;
      var S = k.length + p.length | 0;
      x.length = S, S = S - 1 | 0;
      var B = k.words[0] | 0, L = p.words[0] | 0, C = B * L, G = C & 67108863, R = C / 67108864 | 0;
      x.words[0] = G;
      for (var y = 1; y < S; y++) {
        for (var j = R >>> 26, ye = R & 67108863, ee = Math.min(y, p.length - 1), xe = Math.max(0, y - k.length + 1); xe <= ee; xe++) {
          var $e = y - xe | 0;
          B = k.words[$e] | 0, L = p.words[xe] | 0, C = B * L + ye, j += C / 67108864 | 0, ye = C & 67108863;
        }
        x.words[y] = ye | 0, R = j | 0;
      }
      return R !== 0 ? x.words[y] = R | 0 : x.length--, x._strip();
    }
    var pe = function(p, x, S) {
      var B = p.words, L = x.words, C = S.words, G = 0, R, y, j, ye = B[0] | 0, ee = ye & 8191, xe = ye >>> 13, $e = B[1] | 0, ke = $e & 8191, Ce = $e >>> 13, ht = B[2] | 0, Ue = ht & 8191, De = ht >>> 13, wt = B[3] | 0, He = wt & 8191, Ze = wt >>> 13, Ie = B[4] | 0, ue = Ie & 8191, he = Ie >>> 13, Ne = B[5] | 0, Be = Ne & 8191, Oe = Ne >>> 13, it = B[6] | 0, Ve = it & 8191, Ye = it >>> 13, Pt = B[7] | 0, et = Pt & 8191, Q = Pt >>> 13, W = B[8] | 0, V = W & 8191, se = W >>> 13, Ae = B[9] | 0, _e = Ae & 8191, Re = Ae >>> 13, mt = L[0] | 0, We = mt & 8191, ze = mt >>> 13, kt = L[1] | 0, je = kt & 8191, ot = kt >>> 13, Vt = L[2] | 0, ct = Vt & 8191, ut = Vt >>> 13, Zt = L[3] | 0, rt = Zt & 8191, nt = Zt >>> 13, Gt = L[4] | 0, st = Gt & 8191, at = Gt >>> 13, Jt = L[5] | 0, lt = Jt & 8191, tt = Jt >>> 13, Yt = L[6] | 0, le = Yt & 8191, be = Yt >>> 13, Me = L[7] | 0, te = Me & 8191, ve = Me >>> 13, qe = L[8] | 0, Pe = qe & 8191, Le = qe >>> 13, pt = L[9] | 0, Je = pt & 8191, Ge = pt >>> 13;
      S.negative = p.negative ^ x.negative, S.length = 19, R = Math.imul(ee, We), y = Math.imul(ee, ze), y = y + Math.imul(xe, We) | 0, j = Math.imul(xe, ze);
      var $t = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, R = Math.imul(ke, We), y = Math.imul(ke, ze), y = y + Math.imul(Ce, We) | 0, j = Math.imul(Ce, ze), R = R + Math.imul(ee, je) | 0, y = y + Math.imul(ee, ot) | 0, y = y + Math.imul(xe, je) | 0, j = j + Math.imul(xe, ot) | 0;
      var bt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, R = Math.imul(Ue, We), y = Math.imul(Ue, ze), y = y + Math.imul(De, We) | 0, j = Math.imul(De, ze), R = R + Math.imul(ke, je) | 0, y = y + Math.imul(ke, ot) | 0, y = y + Math.imul(Ce, je) | 0, j = j + Math.imul(Ce, ot) | 0, R = R + Math.imul(ee, ct) | 0, y = y + Math.imul(ee, ut) | 0, y = y + Math.imul(xe, ct) | 0, j = j + Math.imul(xe, ut) | 0;
      var Mt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, R = Math.imul(He, We), y = Math.imul(He, ze), y = y + Math.imul(Ze, We) | 0, j = Math.imul(Ze, ze), R = R + Math.imul(Ue, je) | 0, y = y + Math.imul(Ue, ot) | 0, y = y + Math.imul(De, je) | 0, j = j + Math.imul(De, ot) | 0, R = R + Math.imul(ke, ct) | 0, y = y + Math.imul(ke, ut) | 0, y = y + Math.imul(Ce, ct) | 0, j = j + Math.imul(Ce, ut) | 0, R = R + Math.imul(ee, rt) | 0, y = y + Math.imul(ee, nt) | 0, y = y + Math.imul(xe, rt) | 0, j = j + Math.imul(xe, nt) | 0;
      var Rt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, R = Math.imul(ue, We), y = Math.imul(ue, ze), y = y + Math.imul(he, We) | 0, j = Math.imul(he, ze), R = R + Math.imul(He, je) | 0, y = y + Math.imul(He, ot) | 0, y = y + Math.imul(Ze, je) | 0, j = j + Math.imul(Ze, ot) | 0, R = R + Math.imul(Ue, ct) | 0, y = y + Math.imul(Ue, ut) | 0, y = y + Math.imul(De, ct) | 0, j = j + Math.imul(De, ut) | 0, R = R + Math.imul(ke, rt) | 0, y = y + Math.imul(ke, nt) | 0, y = y + Math.imul(Ce, rt) | 0, j = j + Math.imul(Ce, nt) | 0, R = R + Math.imul(ee, st) | 0, y = y + Math.imul(ee, at) | 0, y = y + Math.imul(xe, st) | 0, j = j + Math.imul(xe, at) | 0;
      var Tt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, R = Math.imul(Be, We), y = Math.imul(Be, ze), y = y + Math.imul(Oe, We) | 0, j = Math.imul(Oe, ze), R = R + Math.imul(ue, je) | 0, y = y + Math.imul(ue, ot) | 0, y = y + Math.imul(he, je) | 0, j = j + Math.imul(he, ot) | 0, R = R + Math.imul(He, ct) | 0, y = y + Math.imul(He, ut) | 0, y = y + Math.imul(Ze, ct) | 0, j = j + Math.imul(Ze, ut) | 0, R = R + Math.imul(Ue, rt) | 0, y = y + Math.imul(Ue, nt) | 0, y = y + Math.imul(De, rt) | 0, j = j + Math.imul(De, nt) | 0, R = R + Math.imul(ke, st) | 0, y = y + Math.imul(ke, at) | 0, y = y + Math.imul(Ce, st) | 0, j = j + Math.imul(Ce, at) | 0, R = R + Math.imul(ee, lt) | 0, y = y + Math.imul(ee, tt) | 0, y = y + Math.imul(xe, lt) | 0, j = j + Math.imul(xe, tt) | 0;
      var Nt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, R = Math.imul(Ve, We), y = Math.imul(Ve, ze), y = y + Math.imul(Ye, We) | 0, j = Math.imul(Ye, ze), R = R + Math.imul(Be, je) | 0, y = y + Math.imul(Be, ot) | 0, y = y + Math.imul(Oe, je) | 0, j = j + Math.imul(Oe, ot) | 0, R = R + Math.imul(ue, ct) | 0, y = y + Math.imul(ue, ut) | 0, y = y + Math.imul(he, ct) | 0, j = j + Math.imul(he, ut) | 0, R = R + Math.imul(He, rt) | 0, y = y + Math.imul(He, nt) | 0, y = y + Math.imul(Ze, rt) | 0, j = j + Math.imul(Ze, nt) | 0, R = R + Math.imul(Ue, st) | 0, y = y + Math.imul(Ue, at) | 0, y = y + Math.imul(De, st) | 0, j = j + Math.imul(De, at) | 0, R = R + Math.imul(ke, lt) | 0, y = y + Math.imul(ke, tt) | 0, y = y + Math.imul(Ce, lt) | 0, j = j + Math.imul(Ce, tt) | 0, R = R + Math.imul(ee, le) | 0, y = y + Math.imul(ee, be) | 0, y = y + Math.imul(xe, le) | 0, j = j + Math.imul(xe, be) | 0;
      var It = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, R = Math.imul(et, We), y = Math.imul(et, ze), y = y + Math.imul(Q, We) | 0, j = Math.imul(Q, ze), R = R + Math.imul(Ve, je) | 0, y = y + Math.imul(Ve, ot) | 0, y = y + Math.imul(Ye, je) | 0, j = j + Math.imul(Ye, ot) | 0, R = R + Math.imul(Be, ct) | 0, y = y + Math.imul(Be, ut) | 0, y = y + Math.imul(Oe, ct) | 0, j = j + Math.imul(Oe, ut) | 0, R = R + Math.imul(ue, rt) | 0, y = y + Math.imul(ue, nt) | 0, y = y + Math.imul(he, rt) | 0, j = j + Math.imul(he, nt) | 0, R = R + Math.imul(He, st) | 0, y = y + Math.imul(He, at) | 0, y = y + Math.imul(Ze, st) | 0, j = j + Math.imul(Ze, at) | 0, R = R + Math.imul(Ue, lt) | 0, y = y + Math.imul(Ue, tt) | 0, y = y + Math.imul(De, lt) | 0, j = j + Math.imul(De, tt) | 0, R = R + Math.imul(ke, le) | 0, y = y + Math.imul(ke, be) | 0, y = y + Math.imul(Ce, le) | 0, j = j + Math.imul(Ce, be) | 0, R = R + Math.imul(ee, te) | 0, y = y + Math.imul(ee, ve) | 0, y = y + Math.imul(xe, te) | 0, j = j + Math.imul(xe, ve) | 0;
      var Ct = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, R = Math.imul(V, We), y = Math.imul(V, ze), y = y + Math.imul(se, We) | 0, j = Math.imul(se, ze), R = R + Math.imul(et, je) | 0, y = y + Math.imul(et, ot) | 0, y = y + Math.imul(Q, je) | 0, j = j + Math.imul(Q, ot) | 0, R = R + Math.imul(Ve, ct) | 0, y = y + Math.imul(Ve, ut) | 0, y = y + Math.imul(Ye, ct) | 0, j = j + Math.imul(Ye, ut) | 0, R = R + Math.imul(Be, rt) | 0, y = y + Math.imul(Be, nt) | 0, y = y + Math.imul(Oe, rt) | 0, j = j + Math.imul(Oe, nt) | 0, R = R + Math.imul(ue, st) | 0, y = y + Math.imul(ue, at) | 0, y = y + Math.imul(he, st) | 0, j = j + Math.imul(he, at) | 0, R = R + Math.imul(He, lt) | 0, y = y + Math.imul(He, tt) | 0, y = y + Math.imul(Ze, lt) | 0, j = j + Math.imul(Ze, tt) | 0, R = R + Math.imul(Ue, le) | 0, y = y + Math.imul(Ue, be) | 0, y = y + Math.imul(De, le) | 0, j = j + Math.imul(De, be) | 0, R = R + Math.imul(ke, te) | 0, y = y + Math.imul(ke, ve) | 0, y = y + Math.imul(Ce, te) | 0, j = j + Math.imul(Ce, ve) | 0, R = R + Math.imul(ee, Pe) | 0, y = y + Math.imul(ee, Le) | 0, y = y + Math.imul(xe, Pe) | 0, j = j + Math.imul(xe, Le) | 0;
      var Bt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, R = Math.imul(_e, We), y = Math.imul(_e, ze), y = y + Math.imul(Re, We) | 0, j = Math.imul(Re, ze), R = R + Math.imul(V, je) | 0, y = y + Math.imul(V, ot) | 0, y = y + Math.imul(se, je) | 0, j = j + Math.imul(se, ot) | 0, R = R + Math.imul(et, ct) | 0, y = y + Math.imul(et, ut) | 0, y = y + Math.imul(Q, ct) | 0, j = j + Math.imul(Q, ut) | 0, R = R + Math.imul(Ve, rt) | 0, y = y + Math.imul(Ve, nt) | 0, y = y + Math.imul(Ye, rt) | 0, j = j + Math.imul(Ye, nt) | 0, R = R + Math.imul(Be, st) | 0, y = y + Math.imul(Be, at) | 0, y = y + Math.imul(Oe, st) | 0, j = j + Math.imul(Oe, at) | 0, R = R + Math.imul(ue, lt) | 0, y = y + Math.imul(ue, tt) | 0, y = y + Math.imul(he, lt) | 0, j = j + Math.imul(he, tt) | 0, R = R + Math.imul(He, le) | 0, y = y + Math.imul(He, be) | 0, y = y + Math.imul(Ze, le) | 0, j = j + Math.imul(Ze, be) | 0, R = R + Math.imul(Ue, te) | 0, y = y + Math.imul(Ue, ve) | 0, y = y + Math.imul(De, te) | 0, j = j + Math.imul(De, ve) | 0, R = R + Math.imul(ke, Pe) | 0, y = y + Math.imul(ke, Le) | 0, y = y + Math.imul(Ce, Pe) | 0, j = j + Math.imul(Ce, Le) | 0, R = R + Math.imul(ee, Je) | 0, y = y + Math.imul(ee, Ge) | 0, y = y + Math.imul(xe, Je) | 0, j = j + Math.imul(xe, Ge) | 0;
      var _t = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, R = Math.imul(_e, je), y = Math.imul(_e, ot), y = y + Math.imul(Re, je) | 0, j = Math.imul(Re, ot), R = R + Math.imul(V, ct) | 0, y = y + Math.imul(V, ut) | 0, y = y + Math.imul(se, ct) | 0, j = j + Math.imul(se, ut) | 0, R = R + Math.imul(et, rt) | 0, y = y + Math.imul(et, nt) | 0, y = y + Math.imul(Q, rt) | 0, j = j + Math.imul(Q, nt) | 0, R = R + Math.imul(Ve, st) | 0, y = y + Math.imul(Ve, at) | 0, y = y + Math.imul(Ye, st) | 0, j = j + Math.imul(Ye, at) | 0, R = R + Math.imul(Be, lt) | 0, y = y + Math.imul(Be, tt) | 0, y = y + Math.imul(Oe, lt) | 0, j = j + Math.imul(Oe, tt) | 0, R = R + Math.imul(ue, le) | 0, y = y + Math.imul(ue, be) | 0, y = y + Math.imul(he, le) | 0, j = j + Math.imul(he, be) | 0, R = R + Math.imul(He, te) | 0, y = y + Math.imul(He, ve) | 0, y = y + Math.imul(Ze, te) | 0, j = j + Math.imul(Ze, ve) | 0, R = R + Math.imul(Ue, Pe) | 0, y = y + Math.imul(Ue, Le) | 0, y = y + Math.imul(De, Pe) | 0, j = j + Math.imul(De, Le) | 0, R = R + Math.imul(ke, Je) | 0, y = y + Math.imul(ke, Ge) | 0, y = y + Math.imul(Ce, Je) | 0, j = j + Math.imul(Ce, Ge) | 0;
      var St = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, R = Math.imul(_e, ct), y = Math.imul(_e, ut), y = y + Math.imul(Re, ct) | 0, j = Math.imul(Re, ut), R = R + Math.imul(V, rt) | 0, y = y + Math.imul(V, nt) | 0, y = y + Math.imul(se, rt) | 0, j = j + Math.imul(se, nt) | 0, R = R + Math.imul(et, st) | 0, y = y + Math.imul(et, at) | 0, y = y + Math.imul(Q, st) | 0, j = j + Math.imul(Q, at) | 0, R = R + Math.imul(Ve, lt) | 0, y = y + Math.imul(Ve, tt) | 0, y = y + Math.imul(Ye, lt) | 0, j = j + Math.imul(Ye, tt) | 0, R = R + Math.imul(Be, le) | 0, y = y + Math.imul(Be, be) | 0, y = y + Math.imul(Oe, le) | 0, j = j + Math.imul(Oe, be) | 0, R = R + Math.imul(ue, te) | 0, y = y + Math.imul(ue, ve) | 0, y = y + Math.imul(he, te) | 0, j = j + Math.imul(he, ve) | 0, R = R + Math.imul(He, Pe) | 0, y = y + Math.imul(He, Le) | 0, y = y + Math.imul(Ze, Pe) | 0, j = j + Math.imul(Ze, Le) | 0, R = R + Math.imul(Ue, Je) | 0, y = y + Math.imul(Ue, Ge) | 0, y = y + Math.imul(De, Je) | 0, j = j + Math.imul(De, Ge) | 0;
      var vt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, R = Math.imul(_e, rt), y = Math.imul(_e, nt), y = y + Math.imul(Re, rt) | 0, j = Math.imul(Re, nt), R = R + Math.imul(V, st) | 0, y = y + Math.imul(V, at) | 0, y = y + Math.imul(se, st) | 0, j = j + Math.imul(se, at) | 0, R = R + Math.imul(et, lt) | 0, y = y + Math.imul(et, tt) | 0, y = y + Math.imul(Q, lt) | 0, j = j + Math.imul(Q, tt) | 0, R = R + Math.imul(Ve, le) | 0, y = y + Math.imul(Ve, be) | 0, y = y + Math.imul(Ye, le) | 0, j = j + Math.imul(Ye, be) | 0, R = R + Math.imul(Be, te) | 0, y = y + Math.imul(Be, ve) | 0, y = y + Math.imul(Oe, te) | 0, j = j + Math.imul(Oe, ve) | 0, R = R + Math.imul(ue, Pe) | 0, y = y + Math.imul(ue, Le) | 0, y = y + Math.imul(he, Pe) | 0, j = j + Math.imul(he, Le) | 0, R = R + Math.imul(He, Je) | 0, y = y + Math.imul(He, Ge) | 0, y = y + Math.imul(Ze, Je) | 0, j = j + Math.imul(Ze, Ge) | 0;
      var At = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, R = Math.imul(_e, st), y = Math.imul(_e, at), y = y + Math.imul(Re, st) | 0, j = Math.imul(Re, at), R = R + Math.imul(V, lt) | 0, y = y + Math.imul(V, tt) | 0, y = y + Math.imul(se, lt) | 0, j = j + Math.imul(se, tt) | 0, R = R + Math.imul(et, le) | 0, y = y + Math.imul(et, be) | 0, y = y + Math.imul(Q, le) | 0, j = j + Math.imul(Q, be) | 0, R = R + Math.imul(Ve, te) | 0, y = y + Math.imul(Ve, ve) | 0, y = y + Math.imul(Ye, te) | 0, j = j + Math.imul(Ye, ve) | 0, R = R + Math.imul(Be, Pe) | 0, y = y + Math.imul(Be, Le) | 0, y = y + Math.imul(Oe, Pe) | 0, j = j + Math.imul(Oe, Le) | 0, R = R + Math.imul(ue, Je) | 0, y = y + Math.imul(ue, Ge) | 0, y = y + Math.imul(he, Je) | 0, j = j + Math.imul(he, Ge) | 0;
      var Et = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, R = Math.imul(_e, lt), y = Math.imul(_e, tt), y = y + Math.imul(Re, lt) | 0, j = Math.imul(Re, tt), R = R + Math.imul(V, le) | 0, y = y + Math.imul(V, be) | 0, y = y + Math.imul(se, le) | 0, j = j + Math.imul(se, be) | 0, R = R + Math.imul(et, te) | 0, y = y + Math.imul(et, ve) | 0, y = y + Math.imul(Q, te) | 0, j = j + Math.imul(Q, ve) | 0, R = R + Math.imul(Ve, Pe) | 0, y = y + Math.imul(Ve, Le) | 0, y = y + Math.imul(Ye, Pe) | 0, j = j + Math.imul(Ye, Le) | 0, R = R + Math.imul(Be, Je) | 0, y = y + Math.imul(Be, Ge) | 0, y = y + Math.imul(Oe, Je) | 0, j = j + Math.imul(Oe, Ge) | 0;
      var yt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, R = Math.imul(_e, le), y = Math.imul(_e, be), y = y + Math.imul(Re, le) | 0, j = Math.imul(Re, be), R = R + Math.imul(V, te) | 0, y = y + Math.imul(V, ve) | 0, y = y + Math.imul(se, te) | 0, j = j + Math.imul(se, ve) | 0, R = R + Math.imul(et, Pe) | 0, y = y + Math.imul(et, Le) | 0, y = y + Math.imul(Q, Pe) | 0, j = j + Math.imul(Q, Le) | 0, R = R + Math.imul(Ve, Je) | 0, y = y + Math.imul(Ve, Ge) | 0, y = y + Math.imul(Ye, Je) | 0, j = j + Math.imul(Ye, Ge) | 0;
      var Xe = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, R = Math.imul(_e, te), y = Math.imul(_e, ve), y = y + Math.imul(Re, te) | 0, j = Math.imul(Re, ve), R = R + Math.imul(V, Pe) | 0, y = y + Math.imul(V, Le) | 0, y = y + Math.imul(se, Pe) | 0, j = j + Math.imul(se, Le) | 0, R = R + Math.imul(et, Je) | 0, y = y + Math.imul(et, Ge) | 0, y = y + Math.imul(Q, Je) | 0, j = j + Math.imul(Q, Ge) | 0;
      var Qe = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, R = Math.imul(_e, Pe), y = Math.imul(_e, Le), y = y + Math.imul(Re, Pe) | 0, j = Math.imul(Re, Le), R = R + Math.imul(V, Je) | 0, y = y + Math.imul(V, Ge) | 0, y = y + Math.imul(se, Je) | 0, j = j + Math.imul(se, Ge) | 0;
      var dt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, R = Math.imul(_e, Je), y = Math.imul(_e, Ge), y = y + Math.imul(Re, Je) | 0, j = Math.imul(Re, Ge);
      var ft = (G + R | 0) + ((y & 8191) << 13) | 0;
      return G = (j + (y >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, C[0] = $t, C[1] = bt, C[2] = Mt, C[3] = Rt, C[4] = Tt, C[5] = Nt, C[6] = It, C[7] = Ct, C[8] = Bt, C[9] = _t, C[10] = St, C[11] = vt, C[12] = At, C[13] = Et, C[14] = yt, C[15] = Xe, C[16] = Qe, C[17] = dt, C[18] = ft, G !== 0 && (C[19] = G, S.length++), S;
    };
    Math.imul || (pe = oe);
    function ae(k, p, x) {
      x.negative = p.negative ^ k.negative, x.length = k.length + p.length;
      for (var S = 0, B = 0, L = 0; L < x.length - 1; L++) {
        var C = B;
        B = 0;
        for (var G = S & 67108863, R = Math.min(L, p.length - 1), y = Math.max(0, L - k.length + 1); y <= R; y++) {
          var j = L - y, ye = k.words[j] | 0, ee = p.words[y] | 0, xe = ye * ee, $e = xe & 67108863;
          C = C + (xe / 67108864 | 0) | 0, $e = $e + G | 0, G = $e & 67108863, C = C + ($e >>> 26) | 0, B += C >>> 26, C &= 67108863;
        }
        x.words[L] = G, S = C, C = B;
      }
      return S !== 0 ? x.words[L] = S : x.length--, x._strip();
    }
    function me(k, p, x) {
      return ae(k, p, x);
    }
    d.prototype.mulTo = function(p, x) {
      var S, B = this.length + p.length;
      return this.length === 10 && p.length === 10 ? S = pe(this, p, x) : B < 63 ? S = oe(this, p, x) : B < 1024 ? S = ae(this, p, x) : S = me(this, p, x), S;
    }, d.prototype.mul = function(p) {
      var x = new d(null);
      return x.words = new Array(this.length + p.length), this.mulTo(p, x);
    }, d.prototype.mulf = function(p) {
      var x = new d(null);
      return x.words = new Array(this.length + p.length), me(this, p, x);
    }, d.prototype.imul = function(p) {
      return this.clone().mulTo(p, this);
    }, d.prototype.imuln = function(p) {
      var x = p < 0;
      x && (p = -p), h(typeof p == "number"), h(p < 67108864);
      for (var S = 0, B = 0; B < this.length; B++) {
        var L = (this.words[B] | 0) * p, C = (L & 67108863) + (S & 67108863);
        S >>= 26, S += L / 67108864 | 0, S += C >>> 26, this.words[B] = C & 67108863;
      }
      return S !== 0 && (this.words[B] = S, this.length++), x ? this.ineg() : this;
    }, d.prototype.muln = function(p) {
      return this.clone().imuln(p);
    }, d.prototype.sqr = function() {
      return this.mul(this);
    }, d.prototype.isqr = function() {
      return this.imul(this.clone());
    }, d.prototype.pow = function(p) {
      var x = re(p);
      if (x.length === 0)
        return new d(1);
      for (var S = this, B = 0; B < x.length && x[B] === 0; B++, S = S.sqr())
        ;
      if (++B < x.length)
        for (var L = S.sqr(); B < x.length; B++, L = L.sqr())
          x[B] !== 0 && (S = S.mul(L));
      return S;
    }, d.prototype.iushln = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26, B = 67108863 >>> 26 - x << 26 - x, L;
      if (x !== 0) {
        var C = 0;
        for (L = 0; L < this.length; L++) {
          var G = this.words[L] & B, R = (this.words[L] | 0) - G << x;
          this.words[L] = R | C, C = G >>> 26 - x;
        }
        C && (this.words[L] = C, this.length++);
      }
      if (S !== 0) {
        for (L = this.length - 1; L >= 0; L--)
          this.words[L + S] = this.words[L];
        for (L = 0; L < S; L++)
          this.words[L] = 0;
        this.length += S;
      }
      return this._strip();
    }, d.prototype.ishln = function(p) {
      return h(this.negative === 0), this.iushln(p);
    }, d.prototype.iushrn = function(p, x, S) {
      h(typeof p == "number" && p >= 0);
      var B;
      x ? B = (x - x % 26) / 26 : B = 0;
      var L = p % 26, C = Math.min((p - L) / 26, this.length), G = 67108863 ^ 67108863 >>> L << L, R = S;
      if (B -= C, B = Math.max(0, B), R) {
        for (var y = 0; y < C; y++)
          R.words[y] = this.words[y];
        R.length = C;
      }
      if (C !== 0)
        if (this.length > C)
          for (this.length -= C, y = 0; y < this.length; y++)
            this.words[y] = this.words[y + C];
        else
          this.words[0] = 0, this.length = 1;
      var j = 0;
      for (y = this.length - 1; y >= 0 && (j !== 0 || y >= B); y--) {
        var ye = this.words[y] | 0;
        this.words[y] = j << 26 - L | ye >>> L, j = ye & G;
      }
      return R && j !== 0 && (R.words[R.length++] = j), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, d.prototype.ishrn = function(p, x, S) {
      return h(this.negative === 0), this.iushrn(p, x, S);
    }, d.prototype.shln = function(p) {
      return this.clone().ishln(p);
    }, d.prototype.ushln = function(p) {
      return this.clone().iushln(p);
    }, d.prototype.shrn = function(p) {
      return this.clone().ishrn(p);
    }, d.prototype.ushrn = function(p) {
      return this.clone().iushrn(p);
    }, d.prototype.testn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26, B = 1 << x;
      if (this.length <= S)
        return !1;
      var L = this.words[S];
      return !!(L & B);
    }, d.prototype.imaskn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26;
      if (h(this.negative === 0, "imaskn works only with positive numbers"), this.length <= S)
        return this;
      if (x !== 0 && S++, this.length = Math.min(S, this.length), x !== 0) {
        var B = 67108863 ^ 67108863 >>> x << x;
        this.words[this.length - 1] &= B;
      }
      return this._strip();
    }, d.prototype.maskn = function(p) {
      return this.clone().imaskn(p);
    }, d.prototype.iaddn = function(p) {
      return h(typeof p == "number"), h(p < 67108864), p < 0 ? this.isubn(-p) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= p ? (this.words[0] = p - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(p), this.negative = 1, this) : this._iaddn(p);
    }, d.prototype._iaddn = function(p) {
      this.words[0] += p;
      for (var x = 0; x < this.length && this.words[x] >= 67108864; x++)
        this.words[x] -= 67108864, x === this.length - 1 ? this.words[x + 1] = 1 : this.words[x + 1]++;
      return this.length = Math.max(this.length, x + 1), this;
    }, d.prototype.isubn = function(p) {
      if (h(typeof p == "number"), h(p < 67108864), p < 0)
        return this.iaddn(-p);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(p), this.negative = 1, this;
      if (this.words[0] -= p, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var x = 0; x < this.length && this.words[x] < 0; x++)
          this.words[x] += 67108864, this.words[x + 1] -= 1;
      return this._strip();
    }, d.prototype.addn = function(p) {
      return this.clone().iaddn(p);
    }, d.prototype.subn = function(p) {
      return this.clone().isubn(p);
    }, d.prototype.iabs = function() {
      return this.negative = 0, this;
    }, d.prototype.abs = function() {
      return this.clone().iabs();
    }, d.prototype._ishlnsubmul = function(p, x, S) {
      var B = p.length + S, L;
      this._expand(B);
      var C, G = 0;
      for (L = 0; L < p.length; L++) {
        C = (this.words[L + S] | 0) + G;
        var R = (p.words[L] | 0) * x;
        C -= R & 67108863, G = (C >> 26) - (R / 67108864 | 0), this.words[L + S] = C & 67108863;
      }
      for (; L < this.length - S; L++)
        C = (this.words[L + S] | 0) + G, G = C >> 26, this.words[L + S] = C & 67108863;
      if (G === 0)
        return this._strip();
      for (h(G === -1), G = 0, L = 0; L < this.length; L++)
        C = -(this.words[L] | 0) + G, G = C >> 26, this.words[L] = C & 67108863;
      return this.negative = 1, this._strip();
    }, d.prototype._wordDiv = function(p, x) {
      var S = this.length - p.length, B = this.clone(), L = p, C = L.words[L.length - 1] | 0, G = this._countBits(C);
      S = 26 - G, S !== 0 && (L = L.ushln(S), B.iushln(S), C = L.words[L.length - 1] | 0);
      var R = B.length - L.length, y;
      if (x !== "mod") {
        y = new d(null), y.length = R + 1, y.words = new Array(y.length);
        for (var j = 0; j < y.length; j++)
          y.words[j] = 0;
      }
      var ye = B.clone()._ishlnsubmul(L, 1, R);
      ye.negative === 0 && (B = ye, y && (y.words[R] = 1));
      for (var ee = R - 1; ee >= 0; ee--) {
        var xe = (B.words[L.length + ee] | 0) * 67108864 + (B.words[L.length + ee - 1] | 0);
        for (xe = Math.min(xe / C | 0, 67108863), B._ishlnsubmul(L, xe, ee); B.negative !== 0; )
          xe--, B.negative = 0, B._ishlnsubmul(L, 1, ee), B.isZero() || (B.negative ^= 1);
        y && (y.words[ee] = xe);
      }
      return y && y._strip(), B._strip(), x !== "div" && S !== 0 && B.iushrn(S), {
        div: y || null,
        mod: B
      };
    }, d.prototype.divmod = function(p, x, S) {
      if (h(!p.isZero()), this.isZero())
        return {
          div: new d(0),
          mod: new d(0)
        };
      var B, L, C;
      return this.negative !== 0 && p.negative === 0 ? (C = this.neg().divmod(p, x), x !== "mod" && (B = C.div.neg()), x !== "div" && (L = C.mod.neg(), S && L.negative !== 0 && L.iadd(p)), {
        div: B,
        mod: L
      }) : this.negative === 0 && p.negative !== 0 ? (C = this.divmod(p.neg(), x), x !== "mod" && (B = C.div.neg()), {
        div: B,
        mod: C.mod
      }) : (this.negative & p.negative) !== 0 ? (C = this.neg().divmod(p.neg(), x), x !== "div" && (L = C.mod.neg(), S && L.negative !== 0 && L.isub(p)), {
        div: C.div,
        mod: L
      }) : p.length > this.length || this.cmp(p) < 0 ? {
        div: new d(0),
        mod: this
      } : p.length === 1 ? x === "div" ? {
        div: this.divn(p.words[0]),
        mod: null
      } : x === "mod" ? {
        div: null,
        mod: new d(this.modrn(p.words[0]))
      } : {
        div: this.divn(p.words[0]),
        mod: new d(this.modrn(p.words[0]))
      } : this._wordDiv(p, x);
    }, d.prototype.div = function(p) {
      return this.divmod(p, "div", !1).div;
    }, d.prototype.mod = function(p) {
      return this.divmod(p, "mod", !1).mod;
    }, d.prototype.umod = function(p) {
      return this.divmod(p, "mod", !0).mod;
    }, d.prototype.divRound = function(p) {
      var x = this.divmod(p);
      if (x.mod.isZero())
        return x.div;
      var S = x.div.negative !== 0 ? x.mod.isub(p) : x.mod, B = p.ushrn(1), L = p.andln(1), C = S.cmp(B);
      return C < 0 || L === 1 && C === 0 ? x.div : x.div.negative !== 0 ? x.div.isubn(1) : x.div.iaddn(1);
    }, d.prototype.modrn = function(p) {
      var x = p < 0;
      x && (p = -p), h(p <= 67108863);
      for (var S = (1 << 26) % p, B = 0, L = this.length - 1; L >= 0; L--)
        B = (S * B + (this.words[L] | 0)) % p;
      return x ? -B : B;
    }, d.prototype.modn = function(p) {
      return this.modrn(p);
    }, d.prototype.idivn = function(p) {
      var x = p < 0;
      x && (p = -p), h(p <= 67108863);
      for (var S = 0, B = this.length - 1; B >= 0; B--) {
        var L = (this.words[B] | 0) + S * 67108864;
        this.words[B] = L / p | 0, S = L % p;
      }
      return this._strip(), x ? this.ineg() : this;
    }, d.prototype.divn = function(p) {
      return this.clone().idivn(p);
    }, d.prototype.egcd = function(p) {
      h(p.negative === 0), h(!p.isZero());
      var x = this, S = p.clone();
      x.negative !== 0 ? x = x.umod(p) : x = x.clone();
      for (var B = new d(1), L = new d(0), C = new d(0), G = new d(1), R = 0; x.isEven() && S.isEven(); )
        x.iushrn(1), S.iushrn(1), ++R;
      for (var y = S.clone(), j = x.clone(); !x.isZero(); ) {
        for (var ye = 0, ee = 1; (x.words[0] & ee) === 0 && ye < 26; ++ye, ee <<= 1)
          ;
        if (ye > 0)
          for (x.iushrn(ye); ye-- > 0; )
            (B.isOdd() || L.isOdd()) && (B.iadd(y), L.isub(j)), B.iushrn(1), L.iushrn(1);
        for (var xe = 0, $e = 1; (S.words[0] & $e) === 0 && xe < 26; ++xe, $e <<= 1)
          ;
        if (xe > 0)
          for (S.iushrn(xe); xe-- > 0; )
            (C.isOdd() || G.isOdd()) && (C.iadd(y), G.isub(j)), C.iushrn(1), G.iushrn(1);
        x.cmp(S) >= 0 ? (x.isub(S), B.isub(C), L.isub(G)) : (S.isub(x), C.isub(B), G.isub(L));
      }
      return {
        a: C,
        b: G,
        gcd: S.iushln(R)
      };
    }, d.prototype._invmp = function(p) {
      h(p.negative === 0), h(!p.isZero());
      var x = this, S = p.clone();
      x.negative !== 0 ? x = x.umod(p) : x = x.clone();
      for (var B = new d(1), L = new d(0), C = S.clone(); x.cmpn(1) > 0 && S.cmpn(1) > 0; ) {
        for (var G = 0, R = 1; (x.words[0] & R) === 0 && G < 26; ++G, R <<= 1)
          ;
        if (G > 0)
          for (x.iushrn(G); G-- > 0; )
            B.isOdd() && B.iadd(C), B.iushrn(1);
        for (var y = 0, j = 1; (S.words[0] & j) === 0 && y < 26; ++y, j <<= 1)
          ;
        if (y > 0)
          for (S.iushrn(y); y-- > 0; )
            L.isOdd() && L.iadd(C), L.iushrn(1);
        x.cmp(S) >= 0 ? (x.isub(S), B.isub(L)) : (S.isub(x), L.isub(B));
      }
      var ye;
      return x.cmpn(1) === 0 ? ye = B : ye = L, ye.cmpn(0) < 0 && ye.iadd(p), ye;
    }, d.prototype.gcd = function(p) {
      if (this.isZero())
        return p.abs();
      if (p.isZero())
        return this.abs();
      var x = this.clone(), S = p.clone();
      x.negative = 0, S.negative = 0;
      for (var B = 0; x.isEven() && S.isEven(); B++)
        x.iushrn(1), S.iushrn(1);
      do {
        for (; x.isEven(); )
          x.iushrn(1);
        for (; S.isEven(); )
          S.iushrn(1);
        var L = x.cmp(S);
        if (L < 0) {
          var C = x;
          x = S, S = C;
        } else if (L === 0 || S.cmpn(1) === 0)
          break;
        x.isub(S);
      } while (!0);
      return S.iushln(B);
    }, d.prototype.invm = function(p) {
      return this.egcd(p).a.umod(p);
    }, d.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, d.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, d.prototype.andln = function(p) {
      return this.words[0] & p;
    }, d.prototype.bincn = function(p) {
      h(typeof p == "number");
      var x = p % 26, S = (p - x) / 26, B = 1 << x;
      if (this.length <= S)
        return this._expand(S + 1), this.words[S] |= B, this;
      for (var L = B, C = S; L !== 0 && C < this.length; C++) {
        var G = this.words[C] | 0;
        G += L, L = G >>> 26, G &= 67108863, this.words[C] = G;
      }
      return L !== 0 && (this.words[C] = L, this.length++), this;
    }, d.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, d.prototype.cmpn = function(p) {
      var x = p < 0;
      if (this.negative !== 0 && !x)
        return -1;
      if (this.negative === 0 && x)
        return 1;
      this._strip();
      var S;
      if (this.length > 1)
        S = 1;
      else {
        x && (p = -p), h(p <= 67108863, "Number is too big");
        var B = this.words[0] | 0;
        S = B === p ? 0 : B < p ? -1 : 1;
      }
      return this.negative !== 0 ? -S | 0 : S;
    }, d.prototype.cmp = function(p) {
      if (this.negative !== 0 && p.negative === 0)
        return -1;
      if (this.negative === 0 && p.negative !== 0)
        return 1;
      var x = this.ucmp(p);
      return this.negative !== 0 ? -x | 0 : x;
    }, d.prototype.ucmp = function(p) {
      if (this.length > p.length)
        return 1;
      if (this.length < p.length)
        return -1;
      for (var x = 0, S = this.length - 1; S >= 0; S--) {
        var B = this.words[S] | 0, L = p.words[S] | 0;
        if (B !== L) {
          B < L ? x = -1 : B > L && (x = 1);
          break;
        }
      }
      return x;
    }, d.prototype.gtn = function(p) {
      return this.cmpn(p) === 1;
    }, d.prototype.gt = function(p) {
      return this.cmp(p) === 1;
    }, d.prototype.gten = function(p) {
      return this.cmpn(p) >= 0;
    }, d.prototype.gte = function(p) {
      return this.cmp(p) >= 0;
    }, d.prototype.ltn = function(p) {
      return this.cmpn(p) === -1;
    }, d.prototype.lt = function(p) {
      return this.cmp(p) === -1;
    }, d.prototype.lten = function(p) {
      return this.cmpn(p) <= 0;
    }, d.prototype.lte = function(p) {
      return this.cmp(p) <= 0;
    }, d.prototype.eqn = function(p) {
      return this.cmpn(p) === 0;
    }, d.prototype.eq = function(p) {
      return this.cmp(p) === 0;
    }, d.red = function(p) {
      return new X(p);
    }, d.prototype.toRed = function(p) {
      return h(!this.red, "Already a number in reduction context"), h(this.negative === 0, "red works only with positives"), p.convertTo(this)._forceRed(p);
    }, d.prototype.fromRed = function() {
      return h(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, d.prototype._forceRed = function(p) {
      return this.red = p, this;
    }, d.prototype.forceRed = function(p) {
      return h(!this.red, "Already a number in reduction context"), this._forceRed(p);
    }, d.prototype.redAdd = function(p) {
      return h(this.red, "redAdd works only with red numbers"), this.red.add(this, p);
    }, d.prototype.redIAdd = function(p) {
      return h(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, p);
    }, d.prototype.redSub = function(p) {
      return h(this.red, "redSub works only with red numbers"), this.red.sub(this, p);
    }, d.prototype.redISub = function(p) {
      return h(this.red, "redISub works only with red numbers"), this.red.isub(this, p);
    }, d.prototype.redShl = function(p) {
      return h(this.red, "redShl works only with red numbers"), this.red.shl(this, p);
    }, d.prototype.redMul = function(p) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.mul(this, p);
    }, d.prototype.redIMul = function(p) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.imul(this, p);
    }, d.prototype.redSqr = function() {
      return h(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, d.prototype.redISqr = function() {
      return h(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, d.prototype.redSqrt = function() {
      return h(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, d.prototype.redInvm = function() {
      return h(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, d.prototype.redNeg = function() {
      return h(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, d.prototype.redPow = function(p) {
      return h(this.red && !p.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, p);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function we(k, p) {
      this.name = k, this.p = new d(p, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    we.prototype._tmp = function() {
      var p = new d(null);
      return p.words = new Array(Math.ceil(this.n / 13)), p;
    }, we.prototype.ireduce = function(p) {
      var x = p, S;
      do
        this.split(x, this.tmp), x = this.imulK(x), x = x.iadd(this.tmp), S = x.bitLength();
      while (S > this.n);
      var B = S < this.n ? -1 : x.ucmp(this.p);
      return B === 0 ? (x.words[0] = 0, x.length = 1) : B > 0 ? x.isub(this.p) : x.strip !== void 0 ? x.strip() : x._strip(), x;
    }, we.prototype.split = function(p, x) {
      p.iushrn(this.n, 0, x);
    }, we.prototype.imulK = function(p) {
      return p.imul(this.k);
    };
    function Ee() {
      we.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    m(Ee, we), Ee.prototype.split = function(p, x) {
      for (var S = 4194303, B = Math.min(p.length, 9), L = 0; L < B; L++)
        x.words[L] = p.words[L];
      if (x.length = B, p.length <= 9) {
        p.words[0] = 0, p.length = 1;
        return;
      }
      var C = p.words[9];
      for (x.words[x.length++] = C & S, L = 10; L < p.length; L++) {
        var G = p.words[L] | 0;
        p.words[L - 10] = (G & S) << 4 | C >>> 22, C = G;
      }
      C >>>= 22, p.words[L - 10] = C, C === 0 && p.length > 10 ? p.length -= 10 : p.length -= 9;
    }, Ee.prototype.imulK = function(p) {
      p.words[p.length] = 0, p.words[p.length + 1] = 0, p.length += 2;
      for (var x = 0, S = 0; S < p.length; S++) {
        var B = p.words[S] | 0;
        x += B * 977, p.words[S] = x & 67108863, x = B * 64 + (x / 67108864 | 0);
      }
      return p.words[p.length - 1] === 0 && (p.length--, p.words[p.length - 1] === 0 && p.length--), p;
    };
    function Te() {
      we.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    m(Te, we);
    function Ke() {
      we.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    m(Ke, we);
    function Se() {
      we.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    m(Se, we), Se.prototype.imulK = function(p) {
      for (var x = 0, S = 0; S < p.length; S++) {
        var B = (p.words[S] | 0) * 19 + x, L = B & 67108863;
        B >>>= 26, p.words[S] = L, x = B;
      }
      return x !== 0 && (p.words[p.length++] = x), p;
    }, d._prime = function(p) {
      if (ge[p])
        return ge[p];
      var x;
      if (p === "k256")
        x = new Ee();
      else if (p === "p224")
        x = new Te();
      else if (p === "p192")
        x = new Ke();
      else if (p === "p25519")
        x = new Se();
      else
        throw new Error("Unknown prime " + p);
      return ge[p] = x, x;
    };
    function X(k) {
      if (typeof k == "string") {
        var p = d._prime(k);
        this.m = p.p, this.prime = p;
      } else
        h(k.gtn(1), "modulus must be greater than 1"), this.m = k, this.prime = null;
    }
    X.prototype._verify1 = function(p) {
      h(p.negative === 0, "red works only with positives"), h(p.red, "red works only with red numbers");
    }, X.prototype._verify2 = function(p, x) {
      h((p.negative | x.negative) === 0, "red works only with positives"), h(
        p.red && p.red === x.red,
        "red works only with red numbers"
      );
    }, X.prototype.imod = function(p) {
      return this.prime ? this.prime.ireduce(p)._forceRed(this) : (J(p, p.umod(this.m)._forceRed(this)), p);
    }, X.prototype.neg = function(p) {
      return p.isZero() ? p.clone() : this.m.sub(p)._forceRed(this);
    }, X.prototype.add = function(p, x) {
      this._verify2(p, x);
      var S = p.add(x);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S._forceRed(this);
    }, X.prototype.iadd = function(p, x) {
      this._verify2(p, x);
      var S = p.iadd(x);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S;
    }, X.prototype.sub = function(p, x) {
      this._verify2(p, x);
      var S = p.sub(x);
      return S.cmpn(0) < 0 && S.iadd(this.m), S._forceRed(this);
    }, X.prototype.isub = function(p, x) {
      this._verify2(p, x);
      var S = p.isub(x);
      return S.cmpn(0) < 0 && S.iadd(this.m), S;
    }, X.prototype.shl = function(p, x) {
      return this._verify1(p), this.imod(p.ushln(x));
    }, X.prototype.imul = function(p, x) {
      return this._verify2(p, x), this.imod(p.imul(x));
    }, X.prototype.mul = function(p, x) {
      return this._verify2(p, x), this.imod(p.mul(x));
    }, X.prototype.isqr = function(p) {
      return this.imul(p, p.clone());
    }, X.prototype.sqr = function(p) {
      return this.mul(p, p);
    }, X.prototype.sqrt = function(p) {
      if (p.isZero())
        return p.clone();
      var x = this.m.andln(3);
      if (h(x % 2 === 1), x === 3) {
        var S = this.m.add(new d(1)).iushrn(2);
        return this.pow(p, S);
      }
      for (var B = this.m.subn(1), L = 0; !B.isZero() && B.andln(1) === 0; )
        L++, B.iushrn(1);
      h(!B.isZero());
      var C = new d(1).toRed(this), G = C.redNeg(), R = this.m.subn(1).iushrn(1), y = this.m.bitLength();
      for (y = new d(2 * y * y).toRed(this); this.pow(y, R).cmp(G) !== 0; )
        y.redIAdd(G);
      for (var j = this.pow(y, B), ye = this.pow(p, B.addn(1).iushrn(1)), ee = this.pow(p, B), xe = L; ee.cmp(C) !== 0; ) {
        for (var $e = ee, ke = 0; $e.cmp(C) !== 0; ke++)
          $e = $e.redSqr();
        h(ke < xe);
        var Ce = this.pow(j, new d(1).iushln(xe - ke - 1));
        ye = ye.redMul(Ce), j = Ce.redSqr(), ee = ee.redMul(j), xe = ke;
      }
      return ye;
    }, X.prototype.invm = function(p) {
      var x = p._invmp(this.m);
      return x.negative !== 0 ? (x.negative = 0, this.imod(x).redNeg()) : this.imod(x);
    }, X.prototype.pow = function(p, x) {
      if (x.isZero())
        return new d(1).toRed(this);
      if (x.cmpn(1) === 0)
        return p.clone();
      var S = 4, B = new Array(1 << S);
      B[0] = new d(1).toRed(this), B[1] = p;
      for (var L = 2; L < B.length; L++)
        B[L] = this.mul(B[L - 1], p);
      var C = B[0], G = 0, R = 0, y = x.bitLength() % 26;
      for (y === 0 && (y = 26), L = x.length - 1; L >= 0; L--) {
        for (var j = x.words[L], ye = y - 1; ye >= 0; ye--) {
          var ee = j >> ye & 1;
          if (C !== B[0] && (C = this.sqr(C)), ee === 0 && G === 0) {
            R = 0;
            continue;
          }
          G <<= 1, G |= ee, R++, !(R !== S && (L !== 0 || ye !== 0)) && (C = this.mul(C, B[G]), R = 0, G = 0);
        }
        y = 26;
      }
      return C;
    }, X.prototype.convertTo = function(p) {
      var x = p.umod(this.m);
      return x === p ? x.clone() : x;
    }, X.prototype.convertFrom = function(p) {
      var x = p.clone();
      return x.red = null, x;
    }, d.mont = function(p) {
      return new fe(p);
    };
    function fe(k) {
      X.call(this, k), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    m(fe, X), fe.prototype.convertTo = function(p) {
      return this.imod(p.ushln(this.shift));
    }, fe.prototype.convertFrom = function(p) {
      var x = this.imod(p.mul(this.rinv));
      return x.red = null, x;
    }, fe.prototype.imul = function(p, x) {
      if (p.isZero() || x.isZero())
        return p.words[0] = 0, p.length = 1, p;
      var S = p.imul(x), B = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = S.isub(B).iushrn(this.shift), C = L;
      return L.cmp(this.m) >= 0 ? C = L.isub(this.m) : L.cmpn(0) < 0 && (C = L.iadd(this.m)), C._forceRed(this);
    }, fe.prototype.mul = function(p, x) {
      if (p.isZero() || x.isZero())
        return new d(0)._forceRed(this);
      var S = p.mul(x), B = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = S.isub(B).iushrn(this.shift), C = L;
      return L.cmp(this.m) >= 0 ? C = L.isub(this.m) : L.cmpn(0) < 0 && (C = L.iadd(this.m)), C._forceRed(this);
    }, fe.prototype.invm = function(p) {
      var x = this.imod(p._invmp(this.m).mul(this.r2));
      return x._forceRed(this);
    };
  })(l, commonjsGlobal);
})(bn$2);
var safeBuffer = { exports: {} }, buffer$1 = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(l) {
  const t = base64Js, s = ieee754, h = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  l.Buffer = _, l.SlowBuffer = pe, l.INSPECT_MAX_BYTES = 50;
  const m = 2147483647;
  l.kMaxLength = m, _.TYPED_ARRAY_SUPPORT = d(), !_.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function d() {
    try {
      const Q = new Uint8Array(1), W = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(W, Uint8Array.prototype), Object.setPrototypeOf(Q, W), Q.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(_.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (!!_.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(_.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (!!_.isBuffer(this))
        return this.byteOffset;
    }
  });
  function v(Q) {
    if (Q > m)
      throw new RangeError('The value "' + Q + '" is invalid for option "size"');
    const W = new Uint8Array(Q);
    return Object.setPrototypeOf(W, _.prototype), W;
  }
  function _(Q, W, V) {
    if (typeof Q == "number") {
      if (typeof W == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Y(Q);
    }
    return T(Q, W, V);
  }
  _.poolSize = 8192;
  function T(Q, W, V) {
    if (typeof Q == "string")
      return ie(Q, W);
    if (ArrayBuffer.isView(Q))
      return de(Q);
    if (Q == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Q
      );
    if (it(Q, ArrayBuffer) || Q && it(Q.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (it(Q, SharedArrayBuffer) || Q && it(Q.buffer, SharedArrayBuffer)))
      return ce(Q, W, V);
    if (typeof Q == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const se = Q.valueOf && Q.valueOf();
    if (se != null && se !== Q)
      return _.from(se, W, V);
    const Ae = re(Q);
    if (Ae)
      return Ae;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Q[Symbol.toPrimitive] == "function")
      return _.from(Q[Symbol.toPrimitive]("string"), W, V);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Q
    );
  }
  _.from = function(Q, W, V) {
    return T(Q, W, V);
  }, Object.setPrototypeOf(_.prototype, Uint8Array.prototype), Object.setPrototypeOf(_, Uint8Array);
  function z(Q) {
    if (typeof Q != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Q < 0)
      throw new RangeError('The value "' + Q + '" is invalid for option "size"');
  }
  function J(Q, W, V) {
    return z(Q), Q <= 0 ? v(Q) : W !== void 0 ? typeof V == "string" ? v(Q).fill(W, V) : v(Q).fill(W) : v(Q);
  }
  _.alloc = function(Q, W, V) {
    return J(Q, W, V);
  };
  function Y(Q) {
    return z(Q), v(Q < 0 ? 0 : oe(Q) | 0);
  }
  _.allocUnsafe = function(Q) {
    return Y(Q);
  }, _.allocUnsafeSlow = function(Q) {
    return Y(Q);
  };
  function ie(Q, W) {
    if ((typeof W != "string" || W === "") && (W = "utf8"), !_.isEncoding(W))
      throw new TypeError("Unknown encoding: " + W);
    const V = ae(Q, W) | 0;
    let se = v(V);
    const Ae = se.write(Q, W);
    return Ae !== V && (se = se.slice(0, Ae)), se;
  }
  function ne(Q) {
    const W = Q.length < 0 ? 0 : oe(Q.length) | 0, V = v(W);
    for (let se = 0; se < W; se += 1)
      V[se] = Q[se] & 255;
    return V;
  }
  function de(Q) {
    if (it(Q, Uint8Array)) {
      const W = new Uint8Array(Q);
      return ce(W.buffer, W.byteOffset, W.byteLength);
    }
    return ne(Q);
  }
  function ce(Q, W, V) {
    if (W < 0 || Q.byteLength < W)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Q.byteLength < W + (V || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let se;
    return W === void 0 && V === void 0 ? se = new Uint8Array(Q) : V === void 0 ? se = new Uint8Array(Q, W) : se = new Uint8Array(Q, W, V), Object.setPrototypeOf(se, _.prototype), se;
  }
  function re(Q) {
    if (_.isBuffer(Q)) {
      const W = oe(Q.length) | 0, V = v(W);
      return V.length === 0 || Q.copy(V, 0, 0, W), V;
    }
    if (Q.length !== void 0)
      return typeof Q.length != "number" || Ve(Q.length) ? v(0) : ne(Q);
    if (Q.type === "Buffer" && Array.isArray(Q.data))
      return ne(Q.data);
  }
  function oe(Q) {
    if (Q >= m)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + m.toString(16) + " bytes");
    return Q | 0;
  }
  function pe(Q) {
    return +Q != Q && (Q = 0), _.alloc(+Q);
  }
  _.isBuffer = function(W) {
    return W != null && W._isBuffer === !0 && W !== _.prototype;
  }, _.compare = function(W, V) {
    if (it(W, Uint8Array) && (W = _.from(W, W.offset, W.byteLength)), it(V, Uint8Array) && (V = _.from(V, V.offset, V.byteLength)), !_.isBuffer(W) || !_.isBuffer(V))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (W === V)
      return 0;
    let se = W.length, Ae = V.length;
    for (let _e = 0, Re = Math.min(se, Ae); _e < Re; ++_e)
      if (W[_e] !== V[_e]) {
        se = W[_e], Ae = V[_e];
        break;
      }
    return se < Ae ? -1 : Ae < se ? 1 : 0;
  }, _.isEncoding = function(W) {
    switch (String(W).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, _.concat = function(W, V) {
    if (!Array.isArray(W))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (W.length === 0)
      return _.alloc(0);
    let se;
    if (V === void 0)
      for (V = 0, se = 0; se < W.length; ++se)
        V += W[se].length;
    const Ae = _.allocUnsafe(V);
    let _e = 0;
    for (se = 0; se < W.length; ++se) {
      let Re = W[se];
      if (it(Re, Uint8Array))
        _e + Re.length > Ae.length ? (_.isBuffer(Re) || (Re = _.from(Re)), Re.copy(Ae, _e)) : Uint8Array.prototype.set.call(
          Ae,
          Re,
          _e
        );
      else if (_.isBuffer(Re))
        Re.copy(Ae, _e);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      _e += Re.length;
    }
    return Ae;
  };
  function ae(Q, W) {
    if (_.isBuffer(Q))
      return Q.length;
    if (ArrayBuffer.isView(Q) || it(Q, ArrayBuffer))
      return Q.byteLength;
    if (typeof Q != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Q
      );
    const V = Q.length, se = arguments.length > 2 && arguments[2] === !0;
    if (!se && V === 0)
      return 0;
    let Ae = !1;
    for (; ; )
      switch (W) {
        case "ascii":
        case "latin1":
        case "binary":
          return V;
        case "utf8":
        case "utf-8":
          return ue(Q).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return V * 2;
        case "hex":
          return V >>> 1;
        case "base64":
          return Be(Q).length;
        default:
          if (Ae)
            return se ? -1 : ue(Q).length;
          W = ("" + W).toLowerCase(), Ae = !0;
      }
  }
  _.byteLength = ae;
  function me(Q, W, V) {
    let se = !1;
    if ((W === void 0 || W < 0) && (W = 0), W > this.length || ((V === void 0 || V > this.length) && (V = this.length), V <= 0) || (V >>>= 0, W >>>= 0, V <= W))
      return "";
    for (Q || (Q = "utf8"); ; )
      switch (Q) {
        case "hex":
          return C(this, W, V);
        case "utf8":
        case "utf-8":
          return p(this, W, V);
        case "ascii":
          return B(this, W, V);
        case "latin1":
        case "binary":
          return L(this, W, V);
        case "base64":
          return k(this, W, V);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return G(this, W, V);
        default:
          if (se)
            throw new TypeError("Unknown encoding: " + Q);
          Q = (Q + "").toLowerCase(), se = !0;
      }
  }
  _.prototype._isBuffer = !0;
  function ge(Q, W, V) {
    const se = Q[W];
    Q[W] = Q[V], Q[V] = se;
  }
  _.prototype.swap16 = function() {
    const W = this.length;
    if (W % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let V = 0; V < W; V += 2)
      ge(this, V, V + 1);
    return this;
  }, _.prototype.swap32 = function() {
    const W = this.length;
    if (W % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let V = 0; V < W; V += 4)
      ge(this, V, V + 3), ge(this, V + 1, V + 2);
    return this;
  }, _.prototype.swap64 = function() {
    const W = this.length;
    if (W % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let V = 0; V < W; V += 8)
      ge(this, V, V + 7), ge(this, V + 1, V + 6), ge(this, V + 2, V + 5), ge(this, V + 3, V + 4);
    return this;
  }, _.prototype.toString = function() {
    const W = this.length;
    return W === 0 ? "" : arguments.length === 0 ? p(this, 0, W) : me.apply(this, arguments);
  }, _.prototype.toLocaleString = _.prototype.toString, _.prototype.equals = function(W) {
    if (!_.isBuffer(W))
      throw new TypeError("Argument must be a Buffer");
    return this === W ? !0 : _.compare(this, W) === 0;
  }, _.prototype.inspect = function() {
    let W = "";
    const V = l.INSPECT_MAX_BYTES;
    return W = this.toString("hex", 0, V).replace(/(.{2})/g, "$1 ").trim(), this.length > V && (W += " ... "), "<Buffer " + W + ">";
  }, h && (_.prototype[h] = _.prototype.inspect), _.prototype.compare = function(W, V, se, Ae, _e) {
    if (it(W, Uint8Array) && (W = _.from(W, W.offset, W.byteLength)), !_.isBuffer(W))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof W
      );
    if (V === void 0 && (V = 0), se === void 0 && (se = W ? W.length : 0), Ae === void 0 && (Ae = 0), _e === void 0 && (_e = this.length), V < 0 || se > W.length || Ae < 0 || _e > this.length)
      throw new RangeError("out of range index");
    if (Ae >= _e && V >= se)
      return 0;
    if (Ae >= _e)
      return -1;
    if (V >= se)
      return 1;
    if (V >>>= 0, se >>>= 0, Ae >>>= 0, _e >>>= 0, this === W)
      return 0;
    let Re = _e - Ae, mt = se - V;
    const We = Math.min(Re, mt), ze = this.slice(Ae, _e), kt = W.slice(V, se);
    for (let je = 0; je < We; ++je)
      if (ze[je] !== kt[je]) {
        Re = ze[je], mt = kt[je];
        break;
      }
    return Re < mt ? -1 : mt < Re ? 1 : 0;
  };
  function we(Q, W, V, se, Ae) {
    if (Q.length === 0)
      return -1;
    if (typeof V == "string" ? (se = V, V = 0) : V > 2147483647 ? V = 2147483647 : V < -2147483648 && (V = -2147483648), V = +V, Ve(V) && (V = Ae ? 0 : Q.length - 1), V < 0 && (V = Q.length + V), V >= Q.length) {
      if (Ae)
        return -1;
      V = Q.length - 1;
    } else if (V < 0)
      if (Ae)
        V = 0;
      else
        return -1;
    if (typeof W == "string" && (W = _.from(W, se)), _.isBuffer(W))
      return W.length === 0 ? -1 : Ee(Q, W, V, se, Ae);
    if (typeof W == "number")
      return W = W & 255, typeof Uint8Array.prototype.indexOf == "function" ? Ae ? Uint8Array.prototype.indexOf.call(Q, W, V) : Uint8Array.prototype.lastIndexOf.call(Q, W, V) : Ee(Q, [W], V, se, Ae);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Ee(Q, W, V, se, Ae) {
    let _e = 1, Re = Q.length, mt = W.length;
    if (se !== void 0 && (se = String(se).toLowerCase(), se === "ucs2" || se === "ucs-2" || se === "utf16le" || se === "utf-16le")) {
      if (Q.length < 2 || W.length < 2)
        return -1;
      _e = 2, Re /= 2, mt /= 2, V /= 2;
    }
    function We(kt, je) {
      return _e === 1 ? kt[je] : kt.readUInt16BE(je * _e);
    }
    let ze;
    if (Ae) {
      let kt = -1;
      for (ze = V; ze < Re; ze++)
        if (We(Q, ze) === We(W, kt === -1 ? 0 : ze - kt)) {
          if (kt === -1 && (kt = ze), ze - kt + 1 === mt)
            return kt * _e;
        } else
          kt !== -1 && (ze -= ze - kt), kt = -1;
    } else
      for (V + mt > Re && (V = Re - mt), ze = V; ze >= 0; ze--) {
        let kt = !0;
        for (let je = 0; je < mt; je++)
          if (We(Q, ze + je) !== We(W, je)) {
            kt = !1;
            break;
          }
        if (kt)
          return ze;
      }
    return -1;
  }
  _.prototype.includes = function(W, V, se) {
    return this.indexOf(W, V, se) !== -1;
  }, _.prototype.indexOf = function(W, V, se) {
    return we(this, W, V, se, !0);
  }, _.prototype.lastIndexOf = function(W, V, se) {
    return we(this, W, V, se, !1);
  };
  function Te(Q, W, V, se) {
    V = Number(V) || 0;
    const Ae = Q.length - V;
    se ? (se = Number(se), se > Ae && (se = Ae)) : se = Ae;
    const _e = W.length;
    se > _e / 2 && (se = _e / 2);
    let Re;
    for (Re = 0; Re < se; ++Re) {
      const mt = parseInt(W.substr(Re * 2, 2), 16);
      if (Ve(mt))
        return Re;
      Q[V + Re] = mt;
    }
    return Re;
  }
  function Ke(Q, W, V, se) {
    return Oe(ue(W, Q.length - V), Q, V, se);
  }
  function Se(Q, W, V, se) {
    return Oe(he(W), Q, V, se);
  }
  function X(Q, W, V, se) {
    return Oe(Be(W), Q, V, se);
  }
  function fe(Q, W, V, se) {
    return Oe(Ne(W, Q.length - V), Q, V, se);
  }
  _.prototype.write = function(W, V, se, Ae) {
    if (V === void 0)
      Ae = "utf8", se = this.length, V = 0;
    else if (se === void 0 && typeof V == "string")
      Ae = V, se = this.length, V = 0;
    else if (isFinite(V))
      V = V >>> 0, isFinite(se) ? (se = se >>> 0, Ae === void 0 && (Ae = "utf8")) : (Ae = se, se = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const _e = this.length - V;
    if ((se === void 0 || se > _e) && (se = _e), W.length > 0 && (se < 0 || V < 0) || V > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Ae || (Ae = "utf8");
    let Re = !1;
    for (; ; )
      switch (Ae) {
        case "hex":
          return Te(this, W, V, se);
        case "utf8":
        case "utf-8":
          return Ke(this, W, V, se);
        case "ascii":
        case "latin1":
        case "binary":
          return Se(this, W, V, se);
        case "base64":
          return X(this, W, V, se);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return fe(this, W, V, se);
        default:
          if (Re)
            throw new TypeError("Unknown encoding: " + Ae);
          Ae = ("" + Ae).toLowerCase(), Re = !0;
      }
  }, _.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function k(Q, W, V) {
    return W === 0 && V === Q.length ? t.fromByteArray(Q) : t.fromByteArray(Q.slice(W, V));
  }
  function p(Q, W, V) {
    V = Math.min(Q.length, V);
    const se = [];
    let Ae = W;
    for (; Ae < V; ) {
      const _e = Q[Ae];
      let Re = null, mt = _e > 239 ? 4 : _e > 223 ? 3 : _e > 191 ? 2 : 1;
      if (Ae + mt <= V) {
        let We, ze, kt, je;
        switch (mt) {
          case 1:
            _e < 128 && (Re = _e);
            break;
          case 2:
            We = Q[Ae + 1], (We & 192) === 128 && (je = (_e & 31) << 6 | We & 63, je > 127 && (Re = je));
            break;
          case 3:
            We = Q[Ae + 1], ze = Q[Ae + 2], (We & 192) === 128 && (ze & 192) === 128 && (je = (_e & 15) << 12 | (We & 63) << 6 | ze & 63, je > 2047 && (je < 55296 || je > 57343) && (Re = je));
            break;
          case 4:
            We = Q[Ae + 1], ze = Q[Ae + 2], kt = Q[Ae + 3], (We & 192) === 128 && (ze & 192) === 128 && (kt & 192) === 128 && (je = (_e & 15) << 18 | (We & 63) << 12 | (ze & 63) << 6 | kt & 63, je > 65535 && je < 1114112 && (Re = je));
        }
      }
      Re === null ? (Re = 65533, mt = 1) : Re > 65535 && (Re -= 65536, se.push(Re >>> 10 & 1023 | 55296), Re = 56320 | Re & 1023), se.push(Re), Ae += mt;
    }
    return S(se);
  }
  const x = 4096;
  function S(Q) {
    const W = Q.length;
    if (W <= x)
      return String.fromCharCode.apply(String, Q);
    let V = "", se = 0;
    for (; se < W; )
      V += String.fromCharCode.apply(
        String,
        Q.slice(se, se += x)
      );
    return V;
  }
  function B(Q, W, V) {
    let se = "";
    V = Math.min(Q.length, V);
    for (let Ae = W; Ae < V; ++Ae)
      se += String.fromCharCode(Q[Ae] & 127);
    return se;
  }
  function L(Q, W, V) {
    let se = "";
    V = Math.min(Q.length, V);
    for (let Ae = W; Ae < V; ++Ae)
      se += String.fromCharCode(Q[Ae]);
    return se;
  }
  function C(Q, W, V) {
    const se = Q.length;
    (!W || W < 0) && (W = 0), (!V || V < 0 || V > se) && (V = se);
    let Ae = "";
    for (let _e = W; _e < V; ++_e)
      Ae += Ye[Q[_e]];
    return Ae;
  }
  function G(Q, W, V) {
    const se = Q.slice(W, V);
    let Ae = "";
    for (let _e = 0; _e < se.length - 1; _e += 2)
      Ae += String.fromCharCode(se[_e] + se[_e + 1] * 256);
    return Ae;
  }
  _.prototype.slice = function(W, V) {
    const se = this.length;
    W = ~~W, V = V === void 0 ? se : ~~V, W < 0 ? (W += se, W < 0 && (W = 0)) : W > se && (W = se), V < 0 ? (V += se, V < 0 && (V = 0)) : V > se && (V = se), V < W && (V = W);
    const Ae = this.subarray(W, V);
    return Object.setPrototypeOf(Ae, _.prototype), Ae;
  };
  function R(Q, W, V) {
    if (Q % 1 !== 0 || Q < 0)
      throw new RangeError("offset is not uint");
    if (Q + W > V)
      throw new RangeError("Trying to access beyond buffer length");
  }
  _.prototype.readUintLE = _.prototype.readUIntLE = function(W, V, se) {
    W = W >>> 0, V = V >>> 0, se || R(W, V, this.length);
    let Ae = this[W], _e = 1, Re = 0;
    for (; ++Re < V && (_e *= 256); )
      Ae += this[W + Re] * _e;
    return Ae;
  }, _.prototype.readUintBE = _.prototype.readUIntBE = function(W, V, se) {
    W = W >>> 0, V = V >>> 0, se || R(W, V, this.length);
    let Ae = this[W + --V], _e = 1;
    for (; V > 0 && (_e *= 256); )
      Ae += this[W + --V] * _e;
    return Ae;
  }, _.prototype.readUint8 = _.prototype.readUInt8 = function(W, V) {
    return W = W >>> 0, V || R(W, 1, this.length), this[W];
  }, _.prototype.readUint16LE = _.prototype.readUInt16LE = function(W, V) {
    return W = W >>> 0, V || R(W, 2, this.length), this[W] | this[W + 1] << 8;
  }, _.prototype.readUint16BE = _.prototype.readUInt16BE = function(W, V) {
    return W = W >>> 0, V || R(W, 2, this.length), this[W] << 8 | this[W + 1];
  }, _.prototype.readUint32LE = _.prototype.readUInt32LE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), (this[W] | this[W + 1] << 8 | this[W + 2] << 16) + this[W + 3] * 16777216;
  }, _.prototype.readUint32BE = _.prototype.readUInt32BE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), this[W] * 16777216 + (this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3]);
  }, _.prototype.readBigUInt64LE = Pt(function(W) {
    W = W >>> 0, wt(W, "offset");
    const V = this[W], se = this[W + 7];
    (V === void 0 || se === void 0) && He(W, this.length - 8);
    const Ae = V + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24, _e = this[++W] + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + se * 2 ** 24;
    return BigInt(Ae) + (BigInt(_e) << BigInt(32));
  }), _.prototype.readBigUInt64BE = Pt(function(W) {
    W = W >>> 0, wt(W, "offset");
    const V = this[W], se = this[W + 7];
    (V === void 0 || se === void 0) && He(W, this.length - 8);
    const Ae = V * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W], _e = this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + se;
    return (BigInt(Ae) << BigInt(32)) + BigInt(_e);
  }), _.prototype.readIntLE = function(W, V, se) {
    W = W >>> 0, V = V >>> 0, se || R(W, V, this.length);
    let Ae = this[W], _e = 1, Re = 0;
    for (; ++Re < V && (_e *= 256); )
      Ae += this[W + Re] * _e;
    return _e *= 128, Ae >= _e && (Ae -= Math.pow(2, 8 * V)), Ae;
  }, _.prototype.readIntBE = function(W, V, se) {
    W = W >>> 0, V = V >>> 0, se || R(W, V, this.length);
    let Ae = V, _e = 1, Re = this[W + --Ae];
    for (; Ae > 0 && (_e *= 256); )
      Re += this[W + --Ae] * _e;
    return _e *= 128, Re >= _e && (Re -= Math.pow(2, 8 * V)), Re;
  }, _.prototype.readInt8 = function(W, V) {
    return W = W >>> 0, V || R(W, 1, this.length), this[W] & 128 ? (255 - this[W] + 1) * -1 : this[W];
  }, _.prototype.readInt16LE = function(W, V) {
    W = W >>> 0, V || R(W, 2, this.length);
    const se = this[W] | this[W + 1] << 8;
    return se & 32768 ? se | 4294901760 : se;
  }, _.prototype.readInt16BE = function(W, V) {
    W = W >>> 0, V || R(W, 2, this.length);
    const se = this[W + 1] | this[W] << 8;
    return se & 32768 ? se | 4294901760 : se;
  }, _.prototype.readInt32LE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), this[W] | this[W + 1] << 8 | this[W + 2] << 16 | this[W + 3] << 24;
  }, _.prototype.readInt32BE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), this[W] << 24 | this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3];
  }, _.prototype.readBigInt64LE = Pt(function(W) {
    W = W >>> 0, wt(W, "offset");
    const V = this[W], se = this[W + 7];
    (V === void 0 || se === void 0) && He(W, this.length - 8);
    const Ae = this[W + 4] + this[W + 5] * 2 ** 8 + this[W + 6] * 2 ** 16 + (se << 24);
    return (BigInt(Ae) << BigInt(32)) + BigInt(V + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24);
  }), _.prototype.readBigInt64BE = Pt(function(W) {
    W = W >>> 0, wt(W, "offset");
    const V = this[W], se = this[W + 7];
    (V === void 0 || se === void 0) && He(W, this.length - 8);
    const Ae = (V << 24) + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W];
    return (BigInt(Ae) << BigInt(32)) + BigInt(this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + se);
  }), _.prototype.readFloatLE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), s.read(this, W, !0, 23, 4);
  }, _.prototype.readFloatBE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), s.read(this, W, !1, 23, 4);
  }, _.prototype.readDoubleLE = function(W, V) {
    return W = W >>> 0, V || R(W, 8, this.length), s.read(this, W, !0, 52, 8);
  }, _.prototype.readDoubleBE = function(W, V) {
    return W = W >>> 0, V || R(W, 8, this.length), s.read(this, W, !1, 52, 8);
  };
  function y(Q, W, V, se, Ae, _e) {
    if (!_.isBuffer(Q))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (W > Ae || W < _e)
      throw new RangeError('"value" argument is out of bounds');
    if (V + se > Q.length)
      throw new RangeError("Index out of range");
  }
  _.prototype.writeUintLE = _.prototype.writeUIntLE = function(W, V, se, Ae) {
    if (W = +W, V = V >>> 0, se = se >>> 0, !Ae) {
      const mt = Math.pow(2, 8 * se) - 1;
      y(this, W, V, se, mt, 0);
    }
    let _e = 1, Re = 0;
    for (this[V] = W & 255; ++Re < se && (_e *= 256); )
      this[V + Re] = W / _e & 255;
    return V + se;
  }, _.prototype.writeUintBE = _.prototype.writeUIntBE = function(W, V, se, Ae) {
    if (W = +W, V = V >>> 0, se = se >>> 0, !Ae) {
      const mt = Math.pow(2, 8 * se) - 1;
      y(this, W, V, se, mt, 0);
    }
    let _e = se - 1, Re = 1;
    for (this[V + _e] = W & 255; --_e >= 0 && (Re *= 256); )
      this[V + _e] = W / Re & 255;
    return V + se;
  }, _.prototype.writeUint8 = _.prototype.writeUInt8 = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 1, 255, 0), this[V] = W & 255, V + 1;
  }, _.prototype.writeUint16LE = _.prototype.writeUInt16LE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 2, 65535, 0), this[V] = W & 255, this[V + 1] = W >>> 8, V + 2;
  }, _.prototype.writeUint16BE = _.prototype.writeUInt16BE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 2, 65535, 0), this[V] = W >>> 8, this[V + 1] = W & 255, V + 2;
  }, _.prototype.writeUint32LE = _.prototype.writeUInt32LE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 4, 4294967295, 0), this[V + 3] = W >>> 24, this[V + 2] = W >>> 16, this[V + 1] = W >>> 8, this[V] = W & 255, V + 4;
  }, _.prototype.writeUint32BE = _.prototype.writeUInt32BE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 4, 4294967295, 0), this[V] = W >>> 24, this[V + 1] = W >>> 16, this[V + 2] = W >>> 8, this[V + 3] = W & 255, V + 4;
  };
  function j(Q, W, V, se, Ae) {
    De(W, se, Ae, Q, V, 7);
    let _e = Number(W & BigInt(4294967295));
    Q[V++] = _e, _e = _e >> 8, Q[V++] = _e, _e = _e >> 8, Q[V++] = _e, _e = _e >> 8, Q[V++] = _e;
    let Re = Number(W >> BigInt(32) & BigInt(4294967295));
    return Q[V++] = Re, Re = Re >> 8, Q[V++] = Re, Re = Re >> 8, Q[V++] = Re, Re = Re >> 8, Q[V++] = Re, V;
  }
  function ye(Q, W, V, se, Ae) {
    De(W, se, Ae, Q, V, 7);
    let _e = Number(W & BigInt(4294967295));
    Q[V + 7] = _e, _e = _e >> 8, Q[V + 6] = _e, _e = _e >> 8, Q[V + 5] = _e, _e = _e >> 8, Q[V + 4] = _e;
    let Re = Number(W >> BigInt(32) & BigInt(4294967295));
    return Q[V + 3] = Re, Re = Re >> 8, Q[V + 2] = Re, Re = Re >> 8, Q[V + 1] = Re, Re = Re >> 8, Q[V] = Re, V + 8;
  }
  _.prototype.writeBigUInt64LE = Pt(function(W, V = 0) {
    return j(this, W, V, BigInt(0), BigInt("0xffffffffffffffff"));
  }), _.prototype.writeBigUInt64BE = Pt(function(W, V = 0) {
    return ye(this, W, V, BigInt(0), BigInt("0xffffffffffffffff"));
  }), _.prototype.writeIntLE = function(W, V, se, Ae) {
    if (W = +W, V = V >>> 0, !Ae) {
      const We = Math.pow(2, 8 * se - 1);
      y(this, W, V, se, We - 1, -We);
    }
    let _e = 0, Re = 1, mt = 0;
    for (this[V] = W & 255; ++_e < se && (Re *= 256); )
      W < 0 && mt === 0 && this[V + _e - 1] !== 0 && (mt = 1), this[V + _e] = (W / Re >> 0) - mt & 255;
    return V + se;
  }, _.prototype.writeIntBE = function(W, V, se, Ae) {
    if (W = +W, V = V >>> 0, !Ae) {
      const We = Math.pow(2, 8 * se - 1);
      y(this, W, V, se, We - 1, -We);
    }
    let _e = se - 1, Re = 1, mt = 0;
    for (this[V + _e] = W & 255; --_e >= 0 && (Re *= 256); )
      W < 0 && mt === 0 && this[V + _e + 1] !== 0 && (mt = 1), this[V + _e] = (W / Re >> 0) - mt & 255;
    return V + se;
  }, _.prototype.writeInt8 = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 1, 127, -128), W < 0 && (W = 255 + W + 1), this[V] = W & 255, V + 1;
  }, _.prototype.writeInt16LE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 2, 32767, -32768), this[V] = W & 255, this[V + 1] = W >>> 8, V + 2;
  }, _.prototype.writeInt16BE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 2, 32767, -32768), this[V] = W >>> 8, this[V + 1] = W & 255, V + 2;
  }, _.prototype.writeInt32LE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 4, 2147483647, -2147483648), this[V] = W & 255, this[V + 1] = W >>> 8, this[V + 2] = W >>> 16, this[V + 3] = W >>> 24, V + 4;
  }, _.prototype.writeInt32BE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 4, 2147483647, -2147483648), W < 0 && (W = 4294967295 + W + 1), this[V] = W >>> 24, this[V + 1] = W >>> 16, this[V + 2] = W >>> 8, this[V + 3] = W & 255, V + 4;
  }, _.prototype.writeBigInt64LE = Pt(function(W, V = 0) {
    return j(this, W, V, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), _.prototype.writeBigInt64BE = Pt(function(W, V = 0) {
    return ye(this, W, V, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ee(Q, W, V, se, Ae, _e) {
    if (V + se > Q.length)
      throw new RangeError("Index out of range");
    if (V < 0)
      throw new RangeError("Index out of range");
  }
  function xe(Q, W, V, se, Ae) {
    return W = +W, V = V >>> 0, Ae || ee(Q, W, V, 4), s.write(Q, W, V, se, 23, 4), V + 4;
  }
  _.prototype.writeFloatLE = function(W, V, se) {
    return xe(this, W, V, !0, se);
  }, _.prototype.writeFloatBE = function(W, V, se) {
    return xe(this, W, V, !1, se);
  };
  function $e(Q, W, V, se, Ae) {
    return W = +W, V = V >>> 0, Ae || ee(Q, W, V, 8), s.write(Q, W, V, se, 52, 8), V + 8;
  }
  _.prototype.writeDoubleLE = function(W, V, se) {
    return $e(this, W, V, !0, se);
  }, _.prototype.writeDoubleBE = function(W, V, se) {
    return $e(this, W, V, !1, se);
  }, _.prototype.copy = function(W, V, se, Ae) {
    if (!_.isBuffer(W))
      throw new TypeError("argument should be a Buffer");
    if (se || (se = 0), !Ae && Ae !== 0 && (Ae = this.length), V >= W.length && (V = W.length), V || (V = 0), Ae > 0 && Ae < se && (Ae = se), Ae === se || W.length === 0 || this.length === 0)
      return 0;
    if (V < 0)
      throw new RangeError("targetStart out of bounds");
    if (se < 0 || se >= this.length)
      throw new RangeError("Index out of range");
    if (Ae < 0)
      throw new RangeError("sourceEnd out of bounds");
    Ae > this.length && (Ae = this.length), W.length - V < Ae - se && (Ae = W.length - V + se);
    const _e = Ae - se;
    return this === W && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(V, se, Ae) : Uint8Array.prototype.set.call(
      W,
      this.subarray(se, Ae),
      V
    ), _e;
  }, _.prototype.fill = function(W, V, se, Ae) {
    if (typeof W == "string") {
      if (typeof V == "string" ? (Ae = V, V = 0, se = this.length) : typeof se == "string" && (Ae = se, se = this.length), Ae !== void 0 && typeof Ae != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Ae == "string" && !_.isEncoding(Ae))
        throw new TypeError("Unknown encoding: " + Ae);
      if (W.length === 1) {
        const Re = W.charCodeAt(0);
        (Ae === "utf8" && Re < 128 || Ae === "latin1") && (W = Re);
      }
    } else
      typeof W == "number" ? W = W & 255 : typeof W == "boolean" && (W = Number(W));
    if (V < 0 || this.length < V || this.length < se)
      throw new RangeError("Out of range index");
    if (se <= V)
      return this;
    V = V >>> 0, se = se === void 0 ? this.length : se >>> 0, W || (W = 0);
    let _e;
    if (typeof W == "number")
      for (_e = V; _e < se; ++_e)
        this[_e] = W;
    else {
      const Re = _.isBuffer(W) ? W : _.from(W, Ae), mt = Re.length;
      if (mt === 0)
        throw new TypeError('The value "' + W + '" is invalid for argument "value"');
      for (_e = 0; _e < se - V; ++_e)
        this[_e + V] = Re[_e % mt];
    }
    return this;
  };
  const ke = {};
  function Ce(Q, W, V) {
    ke[Q] = class extends V {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: W.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Q}]`, this.stack, delete this.name;
      }
      get code() {
        return Q;
      }
      set code(Ae) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Ae,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Q}]: ${this.message}`;
      }
    };
  }
  Ce(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Q) {
      return Q ? `${Q} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Ce(
    "ERR_INVALID_ARG_TYPE",
    function(Q, W) {
      return `The "${Q}" argument must be of type number. Received type ${typeof W}`;
    },
    TypeError
  ), Ce(
    "ERR_OUT_OF_RANGE",
    function(Q, W, V) {
      let se = `The value of "${Q}" is out of range.`, Ae = V;
      return Number.isInteger(V) && Math.abs(V) > 2 ** 32 ? Ae = ht(String(V)) : typeof V == "bigint" && (Ae = String(V), (V > BigInt(2) ** BigInt(32) || V < -(BigInt(2) ** BigInt(32))) && (Ae = ht(Ae)), Ae += "n"), se += ` It must be ${W}. Received ${Ae}`, se;
    },
    RangeError
  );
  function ht(Q) {
    let W = "", V = Q.length;
    const se = Q[0] === "-" ? 1 : 0;
    for (; V >= se + 4; V -= 3)
      W = `_${Q.slice(V - 3, V)}${W}`;
    return `${Q.slice(0, V)}${W}`;
  }
  function Ue(Q, W, V) {
    wt(W, "offset"), (Q[W] === void 0 || Q[W + V] === void 0) && He(W, Q.length - (V + 1));
  }
  function De(Q, W, V, se, Ae, _e) {
    if (Q > V || Q < W) {
      const Re = typeof W == "bigint" ? "n" : "";
      let mt;
      throw _e > 3 ? W === 0 || W === BigInt(0) ? mt = `>= 0${Re} and < 2${Re} ** ${(_e + 1) * 8}${Re}` : mt = `>= -(2${Re} ** ${(_e + 1) * 8 - 1}${Re}) and < 2 ** ${(_e + 1) * 8 - 1}${Re}` : mt = `>= ${W}${Re} and <= ${V}${Re}`, new ke.ERR_OUT_OF_RANGE("value", mt, Q);
    }
    Ue(se, Ae, _e);
  }
  function wt(Q, W) {
    if (typeof Q != "number")
      throw new ke.ERR_INVALID_ARG_TYPE(W, "number", Q);
  }
  function He(Q, W, V) {
    throw Math.floor(Q) !== Q ? (wt(Q, V), new ke.ERR_OUT_OF_RANGE(V || "offset", "an integer", Q)) : W < 0 ? new ke.ERR_BUFFER_OUT_OF_BOUNDS() : new ke.ERR_OUT_OF_RANGE(
      V || "offset",
      `>= ${V ? 1 : 0} and <= ${W}`,
      Q
    );
  }
  const Ze = /[^+/0-9A-Za-z-_]/g;
  function Ie(Q) {
    if (Q = Q.split("=")[0], Q = Q.trim().replace(Ze, ""), Q.length < 2)
      return "";
    for (; Q.length % 4 !== 0; )
      Q = Q + "=";
    return Q;
  }
  function ue(Q, W) {
    W = W || 1 / 0;
    let V;
    const se = Q.length;
    let Ae = null;
    const _e = [];
    for (let Re = 0; Re < se; ++Re) {
      if (V = Q.charCodeAt(Re), V > 55295 && V < 57344) {
        if (!Ae) {
          if (V > 56319) {
            (W -= 3) > -1 && _e.push(239, 191, 189);
            continue;
          } else if (Re + 1 === se) {
            (W -= 3) > -1 && _e.push(239, 191, 189);
            continue;
          }
          Ae = V;
          continue;
        }
        if (V < 56320) {
          (W -= 3) > -1 && _e.push(239, 191, 189), Ae = V;
          continue;
        }
        V = (Ae - 55296 << 10 | V - 56320) + 65536;
      } else
        Ae && (W -= 3) > -1 && _e.push(239, 191, 189);
      if (Ae = null, V < 128) {
        if ((W -= 1) < 0)
          break;
        _e.push(V);
      } else if (V < 2048) {
        if ((W -= 2) < 0)
          break;
        _e.push(
          V >> 6 | 192,
          V & 63 | 128
        );
      } else if (V < 65536) {
        if ((W -= 3) < 0)
          break;
        _e.push(
          V >> 12 | 224,
          V >> 6 & 63 | 128,
          V & 63 | 128
        );
      } else if (V < 1114112) {
        if ((W -= 4) < 0)
          break;
        _e.push(
          V >> 18 | 240,
          V >> 12 & 63 | 128,
          V >> 6 & 63 | 128,
          V & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return _e;
  }
  function he(Q) {
    const W = [];
    for (let V = 0; V < Q.length; ++V)
      W.push(Q.charCodeAt(V) & 255);
    return W;
  }
  function Ne(Q, W) {
    let V, se, Ae;
    const _e = [];
    for (let Re = 0; Re < Q.length && !((W -= 2) < 0); ++Re)
      V = Q.charCodeAt(Re), se = V >> 8, Ae = V % 256, _e.push(Ae), _e.push(se);
    return _e;
  }
  function Be(Q) {
    return t.toByteArray(Ie(Q));
  }
  function Oe(Q, W, V, se) {
    let Ae;
    for (Ae = 0; Ae < se && !(Ae + V >= W.length || Ae >= Q.length); ++Ae)
      W[Ae + V] = Q[Ae];
    return Ae;
  }
  function it(Q, W) {
    return Q instanceof W || Q != null && Q.constructor != null && Q.constructor.name != null && Q.constructor.name === W.name;
  }
  function Ve(Q) {
    return Q !== Q;
  }
  const Ye = function() {
    const Q = "0123456789abcdef", W = new Array(256);
    for (let V = 0; V < 16; ++V) {
      const se = V * 16;
      for (let Ae = 0; Ae < 16; ++Ae)
        W[se + Ae] = Q[V] + Q[Ae];
    }
    return W;
  }();
  function Pt(Q) {
    return typeof BigInt > "u" ? et : Q;
  }
  function et() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(l, t) {
  var s = buffer$1, h = s.Buffer;
  function m(v, _) {
    for (var T in v)
      _[T] = v[T];
  }
  h.from && h.alloc && h.allocUnsafe && h.allocUnsafeSlow ? l.exports = s : (m(s, t), t.Buffer = d);
  function d(v, _, T) {
    return h(v, _, T);
  }
  d.prototype = Object.create(h.prototype), m(h, d), d.from = function(v, _, T) {
    if (typeof v == "number")
      throw new TypeError("Argument must not be a number");
    return h(v, _, T);
  }, d.alloc = function(v, _, T) {
    if (typeof v != "number")
      throw new TypeError("Argument must be a number");
    var z = h(v);
    return _ !== void 0 ? typeof T == "string" ? z.fill(_, T) : z.fill(_) : z.fill(0), z;
  }, d.allocUnsafe = function(v) {
    if (typeof v != "number")
      throw new TypeError("Argument must be a number");
    return h(v);
  }, d.allocUnsafeSlow = function(v) {
    if (typeof v != "number")
      throw new TypeError("Argument must be a number");
    return s.SlowBuffer(v);
  };
})(safeBuffer, safeBuffer.exports);
var _Buffer = safeBuffer.exports.Buffer;
function base(l) {
  if (l.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s = 0; s < t.length; s++)
    t[s] = 255;
  for (var h = 0; h < l.length; h++) {
    var m = l.charAt(h), d = m.charCodeAt(0);
    if (t[d] !== 255)
      throw new TypeError(m + " is ambiguous");
    t[d] = h;
  }
  var v = l.length, _ = l.charAt(0), T = Math.log(v) / Math.log(256), z = Math.log(256) / Math.log(v);
  function J(ne) {
    if ((Array.isArray(ne) || ne instanceof Uint8Array) && (ne = _Buffer.from(ne)), !_Buffer.isBuffer(ne))
      throw new TypeError("Expected Buffer");
    if (ne.length === 0)
      return "";
    for (var de = 0, ce = 0, re = 0, oe = ne.length; re !== oe && ne[re] === 0; )
      re++, de++;
    for (var pe = (oe - re) * z + 1 >>> 0, ae = new Uint8Array(pe); re !== oe; ) {
      for (var me = ne[re], ge = 0, we = pe - 1; (me !== 0 || ge < ce) && we !== -1; we--, ge++)
        me += 256 * ae[we] >>> 0, ae[we] = me % v >>> 0, me = me / v >>> 0;
      if (me !== 0)
        throw new Error("Non-zero carry");
      ce = ge, re++;
    }
    for (var Ee = pe - ce; Ee !== pe && ae[Ee] === 0; )
      Ee++;
    for (var Te = _.repeat(de); Ee < pe; ++Ee)
      Te += l.charAt(ae[Ee]);
    return Te;
  }
  function Y(ne) {
    if (typeof ne != "string")
      throw new TypeError("Expected String");
    if (ne.length === 0)
      return _Buffer.alloc(0);
    for (var de = 0, ce = 0, re = 0; ne[de] === _; )
      ce++, de++;
    for (var oe = (ne.length - de) * T + 1 >>> 0, pe = new Uint8Array(oe); ne[de]; ) {
      var ae = t[ne.charCodeAt(de)];
      if (ae === 255)
        return;
      for (var me = 0, ge = oe - 1; (ae !== 0 || me < re) && ge !== -1; ge--, me++)
        ae += v * pe[ge] >>> 0, pe[ge] = ae % 256 >>> 0, ae = ae / 256 >>> 0;
      if (ae !== 0)
        throw new Error("Non-zero carry");
      re = me, de++;
    }
    for (var we = oe - re; we !== oe && pe[we] === 0; )
      we++;
    var Ee = _Buffer.allocUnsafe(ce + (oe - we));
    Ee.fill(0, 0, ce);
    for (var Te = ce; we !== oe; )
      Ee[Te++] = pe[we++];
    return Ee;
  }
  function ie(ne) {
    var de = Y(ne);
    if (de)
      return de;
    throw new Error("Non-base" + v + " character");
  }
  return {
    encode: J,
    decodeUnsafe: Y,
    decode: ie
  };
}
var src = base, basex = src, ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", bs58 = basex(ALPHABET);
function inRange(l, t, s) {
  return t <= l && l <= s;
}
function ToDictionary(l) {
  if (l === void 0)
    return {};
  if (l === Object(l))
    return l;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(l) {
  for (var t = String(l), s = t.length, h = 0, m = []; h < s; ) {
    var d = t.charCodeAt(h);
    if (d < 55296 || d > 57343)
      m.push(d);
    else if (56320 <= d && d <= 57343)
      m.push(65533);
    else if (55296 <= d && d <= 56319)
      if (h === s - 1)
        m.push(65533);
      else {
        var v = l.charCodeAt(h + 1);
        if (56320 <= v && v <= 57343) {
          var _ = d & 1023, T = v & 1023;
          m.push(65536 + (_ << 10) + T), h += 1;
        } else
          m.push(65533);
      }
    h += 1;
  }
  return m;
}
function codePointsToString(l) {
  for (var t = "", s = 0; s < l.length; ++s) {
    var h = l[s];
    h <= 65535 ? t += String.fromCharCode(h) : (h -= 65536, t += String.fromCharCode(
      (h >> 10) + 55296,
      (h & 1023) + 56320
    ));
  }
  return t;
}
var end_of_stream = -1;
function Stream(l) {
  this.tokens = [].slice.call(l);
}
Stream.prototype = {
  endOfStream: function() {
    return !this.tokens.length;
  },
  read: function() {
    return this.tokens.length ? this.tokens.shift() : end_of_stream;
  },
  prepend: function(l) {
    if (Array.isArray(l))
      for (var t = l; t.length; )
        this.tokens.unshift(t.pop());
    else
      this.tokens.unshift(l);
  },
  push: function(l) {
    if (Array.isArray(l))
      for (var t = l; t.length; )
        this.tokens.push(t.shift());
    else
      this.tokens.push(l);
  }
};
var finished = -1;
function decoderError(l, t) {
  if (l)
    throw TypeError("Decoder error");
  return t || 65533;
}
var DEFAULT_ENCODING = "utf-8";
function TextDecoder$1(l, t) {
  if (!(this instanceof TextDecoder$1))
    return new TextDecoder$1(l, t);
  if (l = l !== void 0 ? String(l).toLowerCase() : DEFAULT_ENCODING, l !== DEFAULT_ENCODING)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  t = ToDictionary(t), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = Boolean(t.fatal), this._ignoreBOM = Boolean(t.ignoreBOM), Object.defineProperty(this, "encoding", { value: "utf-8" }), Object.defineProperty(this, "fatal", { value: this._fatal }), Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
TextDecoder$1.prototype = {
  decode: function(t, s) {
    var h;
    typeof t == "object" && t instanceof ArrayBuffer ? h = new Uint8Array(t) : typeof t == "object" && "buffer" in t && t.buffer instanceof ArrayBuffer ? h = new Uint8Array(
      t.buffer,
      t.byteOffset,
      t.byteLength
    ) : h = new Uint8Array(0), s = ToDictionary(s), this._streaming || (this._decoder = new UTF8Decoder({ fatal: this._fatal }), this._BOMseen = !1), this._streaming = Boolean(s.stream);
    for (var m = new Stream(h), d = [], v; !m.endOfStream() && (v = this._decoder.handler(m, m.read()), v !== finished); )
      v !== null && (Array.isArray(v) ? d.push.apply(d, v) : d.push(v));
    if (!this._streaming) {
      do {
        if (v = this._decoder.handler(m, m.read()), v === finished)
          break;
        v !== null && (Array.isArray(v) ? d.push.apply(d, v) : d.push(v));
      } while (!m.endOfStream());
      this._decoder = null;
    }
    return d.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (d[0] === 65279 ? (this._BOMseen = !0, d.shift()) : this._BOMseen = !0), codePointsToString(d);
  }
};
function TextEncoder$1(l, t) {
  if (!(this instanceof TextEncoder$1))
    return new TextEncoder$1(l, t);
  if (l = l !== void 0 ? String(l).toLowerCase() : DEFAULT_ENCODING, l !== DEFAULT_ENCODING)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  t = ToDictionary(t), this._streaming = !1, this._encoder = null, this._options = { fatal: Boolean(t.fatal) }, Object.defineProperty(this, "encoding", { value: "utf-8" });
}
TextEncoder$1.prototype = {
  encode: function(t, s) {
    t = t ? String(t) : "", s = ToDictionary(s), this._streaming || (this._encoder = new UTF8Encoder(this._options)), this._streaming = Boolean(s.stream);
    for (var h = [], m = new Stream(stringToCodePoints(t)), d; !m.endOfStream() && (d = this._encoder.handler(m, m.read()), d !== finished); )
      Array.isArray(d) ? h.push.apply(h, d) : h.push(d);
    if (!this._streaming) {
      for (; d = this._encoder.handler(m, m.read()), d !== finished; )
        Array.isArray(d) ? h.push.apply(h, d) : h.push(d);
      this._encoder = null;
    }
    return new Uint8Array(h);
  }
};
function UTF8Decoder(l) {
  var t = l.fatal, s = 0, h = 0, m = 0, d = 128, v = 191;
  this.handler = function(_, T) {
    if (T === end_of_stream && m !== 0)
      return m = 0, decoderError(t);
    if (T === end_of_stream)
      return finished;
    if (m === 0) {
      if (inRange(T, 0, 127))
        return T;
      if (inRange(T, 194, 223))
        m = 1, s = T - 192;
      else if (inRange(T, 224, 239))
        T === 224 && (d = 160), T === 237 && (v = 159), m = 2, s = T - 224;
      else if (inRange(T, 240, 244))
        T === 240 && (d = 144), T === 244 && (v = 143), m = 3, s = T - 240;
      else
        return decoderError(t);
      return s = s << 6 * m, null;
    }
    if (!inRange(T, d, v))
      return s = m = h = 0, d = 128, v = 191, _.prepend(T), decoderError(t);
    if (d = 128, v = 191, h += 1, s += T - 128 << 6 * (m - h), h !== m)
      return null;
    var z = s;
    return s = m = h = 0, z;
  };
}
function UTF8Encoder(l) {
  l.fatal, this.handler = function(t, s) {
    if (s === end_of_stream)
      return finished;
    if (inRange(s, 0, 127))
      return s;
    var h, m;
    inRange(s, 128, 2047) ? (h = 1, m = 192) : inRange(s, 2048, 65535) ? (h = 2, m = 224) : inRange(s, 65536, 1114111) && (h = 3, m = 240);
    for (var d = [(s >> 6 * h) + m]; h > 0; ) {
      var v = s >> 6 * (h - 1);
      d.push(128 | v & 63), h -= 1;
    }
    return d;
  };
}
var encoding_lib = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1
}), require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(encoding_lib), __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(l, t, s, h) {
  h === void 0 && (h = s), Object.defineProperty(l, h, { enumerable: !0, get: function() {
    return t[s];
  } });
} : function(l, t, s, h) {
  h === void 0 && (h = s), l[h] = t[s];
}), __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(l, t) {
  Object.defineProperty(l, "default", { enumerable: !0, value: t });
} : function(l, t) {
  l.default = t;
}), __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(l, t, s, h) {
  var m = arguments.length, d = m < 3 ? t : h === null ? h = Object.getOwnPropertyDescriptor(t, s) : h, v;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    d = Reflect.decorate(l, t, s, h);
  else
    for (var _ = l.length - 1; _ >= 0; _--)
      (v = l[_]) && (d = (m < 3 ? v(d) : m > 3 ? v(t, s, d) : v(t, s)) || d);
  return m > 3 && d && Object.defineProperty(t, s, d), d;
}, __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(l) {
  if (l && l.__esModule)
    return l;
  var t = {};
  if (l != null)
    for (var s in l)
      s !== "default" && Object.hasOwnProperty.call(l, s) && __createBinding$1(t, l, s);
  return __setModuleDefault$1(t, l), t;
}, __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(l) {
  return l && l.__esModule ? l : { default: l };
};
Object.defineProperty(lib$4, "__esModule", { value: !0 });
var deserializeUnchecked_1 = lib$4.deserializeUnchecked = deserialize_1 = lib$4.deserialize = serialize_1 = lib$4.serialize = lib$4.BinaryReader = lib$4.BinaryWriter = lib$4.BorshError = lib$4.baseDecode = lib$4.baseEncode = void 0;
const bn_js_1$2 = __importDefault$3(bn$2.exports), bs58_1 = __importDefault$3(bs58), encoding = __importStar$1(require$$2$2), ResolvedTextDecoder = typeof TextDecoder != "function" ? encoding.TextDecoder : TextDecoder, textDecoder = new ResolvedTextDecoder("utf-8", { fatal: !0 });
function baseEncode(l) {
  return typeof l == "string" && (l = Buffer.from(l, "utf8")), bs58_1.default.encode(Buffer.from(l));
}
lib$4.baseEncode = baseEncode;
function baseDecode(l) {
  return Buffer.from(bs58_1.default.decode(l));
}
lib$4.baseDecode = baseDecode;
const INITIAL_LENGTH = 1024;
class BorshError extends Error {
  constructor(t) {
    super(t), this.fieldPath = [], this.originalMessage = t;
  }
  addToFieldPath(t) {
    this.fieldPath.splice(0, 0, t), this.message = this.originalMessage + ": " + this.fieldPath.join(".");
  }
}
lib$4.BorshError = BorshError;
class BinaryWriter {
  constructor() {
    this.buf = Buffer.alloc(INITIAL_LENGTH), this.length = 0;
  }
  maybeResize() {
    this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]));
  }
  writeU8(t) {
    this.maybeResize(), this.buf.writeUInt8(t, this.length), this.length += 1;
  }
  writeU16(t) {
    this.maybeResize(), this.buf.writeUInt16LE(t, this.length), this.length += 2;
  }
  writeU32(t) {
    this.maybeResize(), this.buf.writeUInt32LE(t, this.length), this.length += 4;
  }
  writeU64(t) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$2.default(t).toArray("le", 8)));
  }
  writeU128(t) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$2.default(t).toArray("le", 16)));
  }
  writeU256(t) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$2.default(t).toArray("le", 32)));
  }
  writeU512(t) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1$2.default(t).toArray("le", 64)));
  }
  writeBuffer(t) {
    this.buf = Buffer.concat([
      Buffer.from(this.buf.subarray(0, this.length)),
      t,
      Buffer.alloc(INITIAL_LENGTH)
    ]), this.length += t.length;
  }
  writeString(t) {
    this.maybeResize();
    const s = Buffer.from(t, "utf8");
    this.writeU32(s.length), this.writeBuffer(s);
  }
  writeFixedArray(t) {
    this.writeBuffer(Buffer.from(t));
  }
  writeArray(t, s) {
    this.maybeResize(), this.writeU32(t.length);
    for (const h of t)
      this.maybeResize(), s(h);
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
lib$4.BinaryWriter = BinaryWriter;
function handlingRangeError(l, t, s) {
  const h = s.value;
  s.value = function(...m) {
    try {
      return h.apply(this, m);
    } catch (d) {
      if (d instanceof RangeError) {
        const v = d.code;
        if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(v) >= 0)
          throw new BorshError("Reached the end of buffer when deserializing");
      }
      throw d;
    }
  };
}
class BinaryReader {
  constructor(t) {
    this.buf = t, this.offset = 0;
  }
  readU8() {
    const t = this.buf.readUInt8(this.offset);
    return this.offset += 1, t;
  }
  readU16() {
    const t = this.buf.readUInt16LE(this.offset);
    return this.offset += 2, t;
  }
  readU32() {
    const t = this.buf.readUInt32LE(this.offset);
    return this.offset += 4, t;
  }
  readU64() {
    const t = this.readBuffer(8);
    return new bn_js_1$2.default(t, "le");
  }
  readU128() {
    const t = this.readBuffer(16);
    return new bn_js_1$2.default(t, "le");
  }
  readU256() {
    const t = this.readBuffer(32);
    return new bn_js_1$2.default(t, "le");
  }
  readU512() {
    const t = this.readBuffer(64);
    return new bn_js_1$2.default(t, "le");
  }
  readBuffer(t) {
    if (this.offset + t > this.buf.length)
      throw new BorshError(`Expected buffer length ${t} isn't within bounds`);
    const s = this.buf.slice(this.offset, this.offset + t);
    return this.offset += t, s;
  }
  readString() {
    const t = this.readU32(), s = this.readBuffer(t);
    try {
      return textDecoder.decode(s);
    } catch (h) {
      throw new BorshError(`Error decoding UTF-8 string: ${h}`);
    }
  }
  readFixedArray(t) {
    return new Uint8Array(this.readBuffer(t));
  }
  readArray(t) {
    const s = this.readU32(), h = Array();
    for (let m = 0; m < s; ++m)
      h.push(t());
    return h;
  }
}
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU8", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU16", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU32", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU64", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU128", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU256", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU512", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readString", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readFixedArray", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readArray", null);
lib$4.BinaryReader = BinaryReader;
function capitalizeFirstLetter(l) {
  return l.charAt(0).toUpperCase() + l.slice(1);
}
function serializeField(l, t, s, h, m) {
  try {
    if (typeof h == "string")
      m[`write${capitalizeFirstLetter(h)}`](s);
    else if (h instanceof Array)
      if (typeof h[0] == "number") {
        if (s.length !== h[0])
          throw new BorshError(`Expecting byte array of length ${h[0]}, but got ${s.length} bytes`);
        m.writeFixedArray(s);
      } else if (h.length === 2 && typeof h[1] == "number") {
        if (s.length !== h[1])
          throw new BorshError(`Expecting byte array of length ${h[1]}, but got ${s.length} bytes`);
        for (let d = 0; d < h[1]; d++)
          serializeField(l, null, s[d], h[0], m);
      } else
        m.writeArray(s, (d) => {
          serializeField(l, t, d, h[0], m);
        });
    else if (h.kind !== void 0)
      switch (h.kind) {
        case "option": {
          s == null ? m.writeU8(0) : (m.writeU8(1), serializeField(l, t, s, h.type, m));
          break;
        }
        case "map": {
          m.writeU32(s.size), s.forEach((d, v) => {
            serializeField(l, t, v, h.key, m), serializeField(l, t, d, h.value, m);
          });
          break;
        }
        default:
          throw new BorshError(`FieldType ${h} unrecognized`);
      }
    else
      serializeStruct(l, s, m);
  } catch (d) {
    throw d instanceof BorshError && d.addToFieldPath(t), d;
  }
}
function serializeStruct(l, t, s) {
  if (typeof t.borshSerialize == "function") {
    t.borshSerialize(s);
    return;
  }
  const h = l.get(t.constructor);
  if (!h)
    throw new BorshError(`Class ${t.constructor.name} is missing in schema`);
  if (h.kind === "struct")
    h.fields.map(([m, d]) => {
      serializeField(l, m, t[m], d, s);
    });
  else if (h.kind === "enum") {
    const m = t[h.field];
    for (let d = 0; d < h.values.length; ++d) {
      const [v, _] = h.values[d];
      if (v === m) {
        s.writeU8(d), serializeField(l, v, t[v], _, s);
        break;
      }
    }
  } else
    throw new BorshError(`Unexpected schema kind: ${h.kind} for ${t.constructor.name}`);
}
function serialize(l, t, s = BinaryWriter) {
  const h = new s();
  return serializeStruct(l, t, h), h.toArray();
}
var serialize_1 = lib$4.serialize = serialize;
function deserializeField(l, t, s, h) {
  try {
    if (typeof s == "string")
      return h[`read${capitalizeFirstLetter(s)}`]();
    if (s instanceof Array) {
      if (typeof s[0] == "number")
        return h.readFixedArray(s[0]);
      if (typeof s[1] == "number") {
        const m = [];
        for (let d = 0; d < s[1]; d++)
          m.push(deserializeField(l, null, s[0], h));
        return m;
      } else
        return h.readArray(() => deserializeField(l, t, s[0], h));
    }
    if (s.kind === "option")
      return h.readU8() ? deserializeField(l, t, s.type, h) : void 0;
    if (s.kind === "map") {
      let m = /* @__PURE__ */ new Map();
      const d = h.readU32();
      for (let v = 0; v < d; v++) {
        const _ = deserializeField(l, t, s.key, h), T = deserializeField(l, t, s.value, h);
        m.set(_, T);
      }
      return m;
    }
    return deserializeStruct(l, s, h);
  } catch (m) {
    throw m instanceof BorshError && m.addToFieldPath(t), m;
  }
}
function deserializeStruct(l, t, s) {
  if (typeof t.borshDeserialize == "function")
    return t.borshDeserialize(s);
  const h = l.get(t);
  if (!h)
    throw new BorshError(`Class ${t.name} is missing in schema`);
  if (h.kind === "struct") {
    const m = {};
    for (const [d, v] of l.get(t).fields)
      m[d] = deserializeField(l, d, v, s);
    return new t(m);
  }
  if (h.kind === "enum") {
    const m = s.readU8();
    if (m >= h.values.length)
      throw new BorshError(`Enum index: ${m} is out of range`);
    const [d, v] = h.values[m], _ = deserializeField(l, d, v, s);
    return new t({ [d]: _ });
  }
  throw new BorshError(`Unexpected schema kind: ${h.kind} for ${t.constructor.name}`);
}
function deserialize(l, t, s, h = BinaryReader) {
  const m = new h(s), d = deserializeStruct(l, t, m);
  if (m.offset < s.length)
    throw new BorshError(`Unexpected ${s.length - m.offset} bytes after deserialized data`);
  return d;
}
var deserialize_1 = lib$4.deserialize = deserialize;
function deserializeUnchecked(l, t, s, h = BinaryReader) {
  const m = new h(s);
  return deserializeStruct(l, t, m);
}
deserializeUnchecked_1 = lib$4.deserializeUnchecked = deserializeUnchecked;
(function(l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.BinaryReader = l.BinaryWriter = l.BorshError = l.deserialize = l.serialize = l.base_decode = l.base_encode = void 0;
  var t = lib$4;
  Object.defineProperty(l, "base_encode", { enumerable: !0, get: function() {
    return t.baseEncode;
  } }), Object.defineProperty(l, "base_decode", { enumerable: !0, get: function() {
    return t.baseDecode;
  } }), Object.defineProperty(l, "serialize", { enumerable: !0, get: function() {
    return t.serialize;
  } }), Object.defineProperty(l, "deserialize", { enumerable: !0, get: function() {
    return t.deserialize;
  } }), Object.defineProperty(l, "BorshError", { enumerable: !0, get: function() {
    return t.BorshError;
  } }), Object.defineProperty(l, "BinaryWriter", { enumerable: !0, get: function() {
    return t.BinaryWriter;
  } }), Object.defineProperty(l, "BinaryReader", { enumerable: !0, get: function() {
    return t.BinaryReader;
  } });
})(serialize$1);
var enums = {};
Object.defineProperty(enums, "__esModule", { value: !0 });
enums.Assignable = enums.Enum = void 0;
let Enum$1 = class {
  constructor(t) {
    if (Object.keys(t).length !== 1)
      throw new Error("Enum can only take single value");
    Object.keys(t).map((s) => {
      this[s] = t[s], this.enum = s;
    });
  }
};
enums.Enum = Enum$1;
class Assignable {
  constructor(t) {
    Object.keys(t).map((s) => {
      this[s] = t[s];
    });
  }
}
enums.Assignable = Assignable;
(function(l) {
  var t = commonjsGlobal && commonjsGlobal.__importDefault || function(Y) {
    return Y && Y.__esModule ? Y : { default: Y };
  };
  Object.defineProperty(l, "__esModule", { value: !0 }), l.KeyPairEd25519 = l.KeyPair = l.PublicKey = l.KeyType = void 0;
  const s = t(naclFast.exports), h = serialize$1, m = enums;
  var d;
  (function(Y) {
    Y[Y.ED25519 = 0] = "ED25519";
  })(d = l.KeyType || (l.KeyType = {}));
  function v(Y) {
    switch (Y) {
      case d.ED25519:
        return "ed25519";
      default:
        throw new Error(`Unknown key type ${Y}`);
    }
  }
  function _(Y) {
    switch (Y.toLowerCase()) {
      case "ed25519":
        return d.ED25519;
      default:
        throw new Error(`Unknown key type ${Y}`);
    }
  }
  class T extends m.Assignable {
    static from(ie) {
      return typeof ie == "string" ? T.fromString(ie) : ie;
    }
    static fromString(ie) {
      const ne = ie.split(":");
      if (ne.length === 1)
        return new T({ keyType: d.ED25519, data: (0, h.base_decode)(ne[0]) });
      if (ne.length === 2)
        return new T({ keyType: _(ne[0]), data: (0, h.base_decode)(ne[1]) });
      throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
    }
    toString() {
      return `${v(this.keyType)}:${(0, h.base_encode)(this.data)}`;
    }
    verify(ie, ne) {
      switch (this.keyType) {
        case d.ED25519:
          return s.default.sign.detached.verify(ie, ne, this.data);
        default:
          throw new Error(`Unknown key type ${this.keyType}`);
      }
    }
  }
  l.PublicKey = T;
  class z {
    static fromRandom(ie) {
      switch (ie.toUpperCase()) {
        case "ED25519":
          return J.fromRandom();
        default:
          throw new Error(`Unknown curve ${ie}`);
      }
    }
    static fromString(ie) {
      const ne = ie.split(":");
      if (ne.length === 1)
        return new J(ne[0]);
      if (ne.length === 2)
        switch (ne[0].toUpperCase()) {
          case "ED25519":
            return new J(ne[1]);
          default:
            throw new Error(`Unknown curve: ${ne[0]}`);
        }
      else
        throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
    }
  }
  l.KeyPair = z;
  class J extends z {
    constructor(ie) {
      super();
      const ne = s.default.sign.keyPair.fromSecretKey((0, h.base_decode)(ie));
      this.publicKey = new T({ keyType: d.ED25519, data: ne.publicKey }), this.secretKey = ie;
    }
    static fromRandom() {
      const ie = s.default.sign.keyPair();
      return new J((0, h.base_encode)(ie.secretKey));
    }
    sign(ie) {
      return { signature: s.default.sign.detached(ie, (0, h.base_decode)(this.secretKey)), publicKey: this.publicKey };
    }
    verify(ie, ne) {
      return this.publicKey.verify(ie, ne);
    }
    toString() {
      return `ed25519:${this.secretKey}`;
    }
    getPublicKey() {
      return this.publicKey;
    }
  }
  l.KeyPairEd25519 = J;
})(key_pair);
var __awaiter$5 = commonjsGlobal && commonjsGlobal.__awaiter || function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
Object.defineProperty(in_memory_key_store, "__esModule", { value: !0 });
in_memory_key_store.InMemoryKeyStore = void 0;
const keystore_1$2 = keystore, key_pair_1$2 = key_pair;
class InMemoryKeyStore extends keystore_1$2.KeyStore {
  constructor() {
    super(), this.keys = {};
  }
  setKey(t, s, h) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this.keys[`${s}:${t}`] = h.toString();
    });
  }
  getKey(t, s) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const h = this.keys[`${s}:${t}`];
      return h ? key_pair_1$2.KeyPair.fromString(h) : null;
    });
  }
  removeKey(t, s) {
    return __awaiter$5(this, void 0, void 0, function* () {
      delete this.keys[`${s}:${t}`];
    });
  }
  clear() {
    return __awaiter$5(this, void 0, void 0, function* () {
      this.keys = {};
    });
  }
  getNetworks() {
    return __awaiter$5(this, void 0, void 0, function* () {
      const t = /* @__PURE__ */ new Set();
      return Object.keys(this.keys).forEach((s) => {
        const h = s.split(":");
        t.add(h[1]);
      }), Array.from(t.values());
    });
  }
  getAccounts(t) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const s = new Array();
      return Object.keys(this.keys).forEach((h) => {
        const m = h.split(":");
        m[m.length - 1] === t && s.push(m.slice(0, m.length - 1).join(":"));
      }), s;
    });
  }
  toString() {
    return "InMemoryKeyStore";
  }
}
in_memory_key_store.InMemoryKeyStore = InMemoryKeyStore;
var browser_local_storage_key_store = {}, __awaiter$4 = commonjsGlobal && commonjsGlobal.__awaiter || function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
Object.defineProperty(browser_local_storage_key_store, "__esModule", { value: !0 });
browser_local_storage_key_store.BrowserLocalStorageKeyStore = void 0;
const keystore_1$1 = keystore, key_pair_1$1 = key_pair, LOCAL_STORAGE_KEY_PREFIX = "near-api-js:keystore:";
class BrowserLocalStorageKeyStore extends keystore_1$1.KeyStore {
  constructor(t = window.localStorage, s = LOCAL_STORAGE_KEY_PREFIX) {
    super(), this.localStorage = t, this.prefix = s;
  }
  setKey(t, s, h) {
    return __awaiter$4(this, void 0, void 0, function* () {
      this.localStorage.setItem(this.storageKeyForSecretKey(t, s), h.toString());
    });
  }
  getKey(t, s) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const h = this.localStorage.getItem(this.storageKeyForSecretKey(t, s));
      return h ? key_pair_1$1.KeyPair.fromString(h) : null;
    });
  }
  removeKey(t, s) {
    return __awaiter$4(this, void 0, void 0, function* () {
      this.localStorage.removeItem(this.storageKeyForSecretKey(t, s));
    });
  }
  clear() {
    return __awaiter$4(this, void 0, void 0, function* () {
      for (const t of this.storageKeys())
        t.startsWith(this.prefix) && this.localStorage.removeItem(t);
    });
  }
  getNetworks() {
    return __awaiter$4(this, void 0, void 0, function* () {
      const t = /* @__PURE__ */ new Set();
      for (const s of this.storageKeys())
        if (s.startsWith(this.prefix)) {
          const h = s.substring(this.prefix.length).split(":");
          t.add(h[1]);
        }
      return Array.from(t.values());
    });
  }
  getAccounts(t) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const s = new Array();
      for (const h of this.storageKeys())
        if (h.startsWith(this.prefix)) {
          const m = h.substring(this.prefix.length).split(":");
          m[1] === t && s.push(m[0]);
        }
      return s;
    });
  }
  storageKeyForSecretKey(t, s) {
    return `${this.prefix}${s}:${t}`;
  }
  *storageKeys() {
    for (let t = 0; t < this.localStorage.length; t++)
      yield this.localStorage.key(t);
  }
}
browser_local_storage_key_store.BrowserLocalStorageKeyStore = BrowserLocalStorageKeyStore;
var merge_key_store = {}, __awaiter$3 = commonjsGlobal && commonjsGlobal.__awaiter || function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
Object.defineProperty(merge_key_store, "__esModule", { value: !0 });
merge_key_store.MergeKeyStore = void 0;
const keystore_1 = keystore;
class MergeKeyStore extends keystore_1.KeyStore {
  constructor(t, s = { writeKeyStoreIndex: 0 }) {
    super(), this.options = s, this.keyStores = t;
  }
  setKey(t, s, h) {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.keyStores[this.options.writeKeyStoreIndex].setKey(t, s, h);
    });
  }
  getKey(t, s) {
    return __awaiter$3(this, void 0, void 0, function* () {
      for (const h of this.keyStores) {
        const m = yield h.getKey(t, s);
        if (m)
          return m;
      }
      return null;
    });
  }
  removeKey(t, s) {
    return __awaiter$3(this, void 0, void 0, function* () {
      for (const h of this.keyStores)
        yield h.removeKey(t, s);
    });
  }
  clear() {
    return __awaiter$3(this, void 0, void 0, function* () {
      for (const t of this.keyStores)
        yield t.clear();
    });
  }
  getNetworks() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const t = /* @__PURE__ */ new Set();
      for (const s of this.keyStores)
        for (const h of yield s.getNetworks())
          t.add(h);
      return Array.from(t);
    });
  }
  getAccounts(t) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const s = /* @__PURE__ */ new Set();
      for (const h of this.keyStores)
        for (const m of yield h.getAccounts(t))
          s.add(m);
      return Array.from(s);
    });
  }
  toString() {
    return `MergeKeyStore(${this.keyStores.join(", ")})`;
  }
}
merge_key_store.MergeKeyStore = MergeKeyStore;
(function(l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.MergeKeyStore = l.BrowserLocalStorageKeyStore = l.InMemoryKeyStore = l.KeyStore = void 0;
  const t = keystore;
  Object.defineProperty(l, "KeyStore", { enumerable: !0, get: function() {
    return t.KeyStore;
  } });
  const s = in_memory_key_store;
  Object.defineProperty(l, "InMemoryKeyStore", { enumerable: !0, get: function() {
    return s.InMemoryKeyStore;
  } });
  const h = browser_local_storage_key_store;
  Object.defineProperty(l, "BrowserLocalStorageKeyStore", { enumerable: !0, get: function() {
    return h.BrowserLocalStorageKeyStore;
  } });
  const m = merge_key_store;
  Object.defineProperty(l, "MergeKeyStore", { enumerable: !0, get: function() {
    return m.MergeKeyStore;
  } });
})(browserIndex);
var commonIndex = {}, providers = {}, provider$1 = {};
(function(l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.getTransactionLastResult = l.Provider = l.IdType = l.FinalExecutionStatusBasic = l.ExecutionStatusBasic = void 0, function(h) {
    h.Unknown = "Unknown", h.Pending = "Pending", h.Failure = "Failure";
  }(l.ExecutionStatusBasic || (l.ExecutionStatusBasic = {})), function(h) {
    h.NotStarted = "NotStarted", h.Started = "Started", h.Failure = "Failure";
  }(l.FinalExecutionStatusBasic || (l.FinalExecutionStatusBasic = {})), function(h) {
    h.Transaction = "transaction", h.Receipt = "receipt";
  }(l.IdType || (l.IdType = {}));
  class t {
  }
  l.Provider = t;
  function s(h) {
    if (typeof h.status == "object" && typeof h.status.SuccessValue == "string") {
      const m = Buffer.from(h.status.SuccessValue, "base64").toString();
      try {
        return JSON.parse(m);
      } catch {
        return m;
      }
    }
    return null;
  }
  l.getTransactionLastResult = s;
})(provider$1);
var jsonRpcProvider = {}, web = {}, httpErrors = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var browser$3 = depd$1;
function depd$1(l) {
  if (!l)
    throw new TypeError("argument namespace is required");
  function t(s) {
  }
  return t._file = void 0, t._ignored = !0, t._namespace = l, t._traced = !1, t._warned = /* @__PURE__ */ Object.create(null), t.function = wrapfunction$1, t.property = wrapproperty$1, t;
}
function wrapfunction$1(l, t) {
  if (typeof l != "function")
    throw new TypeError("argument fn must be a function");
  return l;
}
function wrapproperty$1(l, t, s) {
  if (!l || typeof l != "object" && typeof l != "function")
    throw new TypeError("argument obj must be object");
  var h = Object.getOwnPropertyDescriptor(l, t);
  if (!h)
    throw new TypeError("must call property on owner object");
  if (!h.configurable)
    throw new TypeError("property must be configurable");
}
var setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(l, t) {
  return l.__proto__ = t, l;
}
function mixinProperties(l, t) {
  for (var s in t)
    Object.prototype.hasOwnProperty.call(l, s) || (l[s] = t[s]);
  return l;
}
var require$$0$2 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  306: "(Unused)",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Unordered Collection",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var codes = require$$0$2, statuses = status;
status.STATUS_CODES = codes;
status.codes = populateStatusesMap(status, codes);
status.redirect = {
  300: !0,
  301: !0,
  302: !0,
  303: !0,
  305: !0,
  307: !0,
  308: !0
};
status.empty = {
  204: !0,
  205: !0,
  304: !0
};
status.retry = {
  502: !0,
  503: !0,
  504: !0
};
function populateStatusesMap(l, t) {
  var s = [];
  return Object.keys(t).forEach(function(m) {
    var d = t[m], v = Number(m);
    l[v] = d, l[d] = v, l[d.toLowerCase()] = v, s.push(v);
  }), s;
}
function status(l) {
  if (typeof l == "number") {
    if (!status[l])
      throw new Error("invalid status code: " + l);
    return l;
  }
  if (typeof l != "string")
    throw new TypeError("code must be a number or string");
  var t = parseInt(l, 10);
  if (!isNaN(t)) {
    if (!status[t])
      throw new Error("invalid status code: " + t);
    return t;
  }
  if (t = status[l.toLowerCase()], !t)
    throw new Error('invalid status message: "' + l + '"');
  return t;
}
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier = toIdentifier;
function toIdentifier(l) {
  return l.split(" ").map(function(t) {
    return t.slice(0, 1).toUpperCase() + t.slice(1);
  }).join("").replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(l) {
  var t = browser$3("http-errors"), s = setprototypeof, h = statuses, m = inherits_browser$1.exports, d = toidentifier;
  l.exports = _, l.exports.HttpError = T(), l.exports.isHttpError = J(l.exports.HttpError), ne(l.exports, h.codes, l.exports.HttpError);
  function v(ce) {
    return Number(String(ce).charAt(0) + "00");
  }
  function _() {
    for (var ce, re, oe = 500, pe = {}, ae = 0; ae < arguments.length; ae++) {
      var me = arguments[ae];
      if (me instanceof Error) {
        ce = me, oe = ce.status || ce.statusCode || oe;
        continue;
      }
      switch (typeof me) {
        case "string":
          re = me;
          break;
        case "number":
          oe = me;
          break;
        case "object":
          pe = me;
          break;
      }
    }
    (typeof oe != "number" || !h[oe] && (oe < 400 || oe >= 600)) && (oe = 500);
    var ge = _[oe] || _[v(oe)];
    ce || (ce = ge ? new ge(re) : new Error(re || h[oe]), Error.captureStackTrace(ce, _)), (!ge || !(ce instanceof ge) || ce.status !== oe) && (ce.expose = oe < 500, ce.status = ce.statusCode = oe);
    for (var we in pe)
      we !== "status" && we !== "statusCode" && (ce[we] = pe[we]);
    return ce;
  }
  function T() {
    function ce() {
      throw new TypeError("cannot construct abstract class");
    }
    return m(ce, Error), ce;
  }
  function z(ce, re, oe) {
    var pe = de(re);
    function ae(me) {
      var ge = me != null ? me : h[oe], we = new Error(ge);
      return Error.captureStackTrace(we, ae), s(we, ae.prototype), Object.defineProperty(we, "message", {
        enumerable: !0,
        configurable: !0,
        value: ge,
        writable: !0
      }), Object.defineProperty(we, "name", {
        enumerable: !1,
        configurable: !0,
        value: pe,
        writable: !0
      }), we;
    }
    return m(ae, ce), ie(ae, pe), ae.prototype.status = oe, ae.prototype.statusCode = oe, ae.prototype.expose = !0, ae;
  }
  function J(ce) {
    return function(oe) {
      return !oe || typeof oe != "object" ? !1 : oe instanceof ce ? !0 : oe instanceof Error && typeof oe.expose == "boolean" && typeof oe.statusCode == "number" && oe.status === oe.statusCode;
    };
  }
  function Y(ce, re, oe) {
    var pe = de(re);
    function ae(me) {
      var ge = me != null ? me : h[oe], we = new Error(ge);
      return Error.captureStackTrace(we, ae), s(we, ae.prototype), Object.defineProperty(we, "message", {
        enumerable: !0,
        configurable: !0,
        value: ge,
        writable: !0
      }), Object.defineProperty(we, "name", {
        enumerable: !1,
        configurable: !0,
        value: pe,
        writable: !0
      }), we;
    }
    return m(ae, ce), ie(ae, pe), ae.prototype.status = oe, ae.prototype.statusCode = oe, ae.prototype.expose = !1, ae;
  }
  function ie(ce, re) {
    var oe = Object.getOwnPropertyDescriptor(ce, "name");
    oe && oe.configurable && (oe.value = re, Object.defineProperty(ce, "name", oe));
  }
  function ne(ce, re, oe) {
    re.forEach(function(ae) {
      var me, ge = d(h[ae]);
      switch (v(ae)) {
        case 400:
          me = z(oe, ge, ae);
          break;
        case 500:
          me = Y(oe, ge, ae);
          break;
      }
      me && (ce[ae] = me, ce[ge] = me);
    }), ce["I'mateapot"] = t.function(
      ce.ImATeapot,
      `"I'mateapot"; use "ImATeapot" instead`
    );
  }
  function de(ce) {
    return ce.substr(-5) !== "Error" ? ce + "Error" : ce;
  }
})(httpErrors);
var exponentialBackoff$1 = {}, __awaiter$2 = commonjsGlobal && commonjsGlobal.__awaiter || function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
Object.defineProperty(exponentialBackoff$1, "__esModule", { value: !0 });
function exponentialBackoff(l, t, s, h) {
  return __awaiter$2(this, void 0, void 0, function* () {
    let m = l;
    for (let d = 0; d < t; d++) {
      const v = yield h();
      if (v)
        return v;
      yield sleep$1(m), m *= s;
    }
    return null;
  });
}
exponentialBackoff$1.default = exponentialBackoff;
function sleep$1(l) {
  return new Promise((t) => setTimeout(t, l));
}
var errors = {};
Object.defineProperty(errors, "__esModule", { value: !0 });
errors.logWarning = errors.ErrorContext = errors.TypedError = errors.ArgumentTypeError = errors.PositionalArgsError = void 0;
class PositionalArgsError extends Error {
  constructor() {
    super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
  }
}
errors.PositionalArgsError = PositionalArgsError;
class ArgumentTypeError extends Error {
  constructor(t, s, h) {
    super(`Expected ${s} for '${t}' argument, but got '${JSON.stringify(h)}'`);
  }
}
errors.ArgumentTypeError = ArgumentTypeError;
class TypedError extends Error {
  constructor(t, s, h) {
    super(t), this.type = s || "UntypedError", this.context = h;
  }
}
errors.TypedError = TypedError;
class ErrorContext {
  constructor(t) {
    this.transactionHash = t;
  }
}
errors.ErrorContext = ErrorContext;
function logWarning(...l) {
  process.env.NEAR_NO_LOGS || console.warn(...l);
}
errors.logWarning = logWarning;
var hasRequiredWeb;
function requireWeb() {
  if (hasRequiredWeb)
    return web;
  hasRequiredWeb = 1;
  var l = commonjsGlobal && commonjsGlobal.__awaiter || function(J, Y, ie, ne) {
    function de(ce) {
      return ce instanceof ie ? ce : new ie(function(re) {
        re(ce);
      });
    }
    return new (ie || (ie = Promise))(function(ce, re) {
      function oe(me) {
        try {
          ae(ne.next(me));
        } catch (ge) {
          re(ge);
        }
      }
      function pe(me) {
        try {
          ae(ne.throw(me));
        } catch (ge) {
          re(ge);
        }
      }
      function ae(me) {
        me.done ? ce(me.value) : de(me.value).then(oe, pe);
      }
      ae((ne = ne.apply(J, Y || [])).next());
    });
  }, t = commonjsGlobal && commonjsGlobal.__importDefault || function(J) {
    return J && J.__esModule ? J : { default: J };
  };
  Object.defineProperty(web, "__esModule", { value: !0 }), web.fetchJson = void 0;
  const s = t(httpErrors.exports), h = t(exponentialBackoff$1), m = requireProviders(), d = errors, v = 1e3, _ = 1.5, T = 10;
  function z(J, Y) {
    return l(this, void 0, void 0, function* () {
      let ie = { url: null };
      typeof J == "string" ? ie.url = J : ie = J;
      const ne = yield (0, h.default)(v, T, _, () => l(this, void 0, void 0, function* () {
        try {
          const de = yield fetch(ie.url, {
            method: Y ? "POST" : "GET",
            body: Y || void 0,
            headers: Object.assign(Object.assign({}, ie.headers), { "Content-Type": "application/json" })
          });
          if (!de.ok) {
            if (de.status === 503)
              return (0, d.logWarning)(`Retrying HTTP request for ${ie.url} as it's not available now`), null;
            throw (0, s.default)(de.status, yield de.text());
          }
          return de;
        } catch (de) {
          if (de.toString().includes("FetchError") || de.toString().includes("Failed to fetch"))
            return (0, d.logWarning)(`Retrying HTTP request for ${ie.url} because of error: ${de}`), null;
          throw de;
        }
      }));
      if (!ne)
        throw new m.TypedError(`Exceeded ${T} attempts for ${ie.url}.`, "RetriesExceeded");
      return yield ne.json();
    });
  }
  return web.fetchJson = z, web;
}
var rpc_errors = {}, mustache = { exports: {} };
(function(l, t) {
  (function(s, h) {
    l.exports = h();
  })(commonjsGlobal, function() {
    /*!
     * mustache.js - Logic-less {{mustache}} templates with JavaScript
     * http://github.com/janl/mustache.js
     */
    var s = Object.prototype.toString, h = Array.isArray || function(k) {
      return s.call(k) === "[object Array]";
    };
    function m(fe) {
      return typeof fe == "function";
    }
    function d(fe) {
      return h(fe) ? "array" : typeof fe;
    }
    function v(fe) {
      return fe.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function _(fe, k) {
      return fe != null && typeof fe == "object" && k in fe;
    }
    function T(fe, k) {
      return fe != null && typeof fe != "object" && fe.hasOwnProperty && fe.hasOwnProperty(k);
    }
    var z = RegExp.prototype.test;
    function J(fe, k) {
      return z.call(fe, k);
    }
    var Y = /\S/;
    function ie(fe) {
      return !J(Y, fe);
    }
    var ne = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    function de(fe) {
      return String(fe).replace(/[&<>"'`=\/]/g, function(p) {
        return ne[p];
      });
    }
    var ce = /\s*/, re = /\s+/, oe = /\s*=/, pe = /\s*\}/, ae = /#|\^|\/|>|\{|&|=|!/;
    function me(fe, k) {
      if (!fe)
        return [];
      var p = !1, x = [], S = [], B = [], L = !1, C = !1, G = "", R = 0;
      function y() {
        if (L && !C)
          for (; B.length; )
            delete S[B.pop()];
        else
          B = [];
        L = !1, C = !1;
      }
      var j, ye, ee;
      function xe(Ie) {
        if (typeof Ie == "string" && (Ie = Ie.split(re, 2)), !h(Ie) || Ie.length !== 2)
          throw new Error("Invalid tags: " + Ie);
        j = new RegExp(v(Ie[0]) + "\\s*"), ye = new RegExp("\\s*" + v(Ie[1])), ee = new RegExp("\\s*" + v("}" + Ie[1]));
      }
      xe(k || Se.tags);
      for (var $e = new Ee(fe), ke, Ce, ht, Ue, De, wt; !$e.eos(); ) {
        if (ke = $e.pos, ht = $e.scanUntil(j), ht)
          for (var He = 0, Ze = ht.length; He < Ze; ++He)
            Ue = ht.charAt(He), ie(Ue) ? (B.push(S.length), G += Ue) : (C = !0, p = !0, G += " "), S.push(["text", Ue, ke, ke + 1]), ke += 1, Ue === `
` && (y(), G = "", R = 0, p = !1);
        if (!$e.scan(j))
          break;
        if (L = !0, Ce = $e.scan(ae) || "name", $e.scan(ce), Ce === "=" ? (ht = $e.scanUntil(oe), $e.scan(oe), $e.scanUntil(ye)) : Ce === "{" ? (ht = $e.scanUntil(ee), $e.scan(pe), $e.scanUntil(ye), Ce = "&") : ht = $e.scanUntil(ye), !$e.scan(ye))
          throw new Error("Unclosed tag at " + $e.pos);
        if (Ce == ">" ? De = [Ce, ht, ke, $e.pos, G, R, p] : De = [Ce, ht, ke, $e.pos], R++, S.push(De), Ce === "#" || Ce === "^")
          x.push(De);
        else if (Ce === "/") {
          if (wt = x.pop(), !wt)
            throw new Error('Unopened section "' + ht + '" at ' + ke);
          if (wt[1] !== ht)
            throw new Error('Unclosed section "' + wt[1] + '" at ' + ke);
        } else
          Ce === "name" || Ce === "{" || Ce === "&" ? C = !0 : Ce === "=" && xe(ht);
      }
      if (y(), wt = x.pop(), wt)
        throw new Error('Unclosed section "' + wt[1] + '" at ' + $e.pos);
      return we(ge(S));
    }
    function ge(fe) {
      for (var k = [], p, x, S = 0, B = fe.length; S < B; ++S)
        p = fe[S], p && (p[0] === "text" && x && x[0] === "text" ? (x[1] += p[1], x[3] = p[3]) : (k.push(p), x = p));
      return k;
    }
    function we(fe) {
      for (var k = [], p = k, x = [], S, B, L = 0, C = fe.length; L < C; ++L)
        switch (S = fe[L], S[0]) {
          case "#":
          case "^":
            p.push(S), x.push(S), p = S[4] = [];
            break;
          case "/":
            B = x.pop(), B[5] = S[2], p = x.length > 0 ? x[x.length - 1][4] : k;
            break;
          default:
            p.push(S);
        }
      return k;
    }
    function Ee(fe) {
      this.string = fe, this.tail = fe, this.pos = 0;
    }
    Ee.prototype.eos = function() {
      return this.tail === "";
    }, Ee.prototype.scan = function(k) {
      var p = this.tail.match(k);
      if (!p || p.index !== 0)
        return "";
      var x = p[0];
      return this.tail = this.tail.substring(x.length), this.pos += x.length, x;
    }, Ee.prototype.scanUntil = function(k) {
      var p = this.tail.search(k), x;
      switch (p) {
        case -1:
          x = this.tail, this.tail = "";
          break;
        case 0:
          x = "";
          break;
        default:
          x = this.tail.substring(0, p), this.tail = this.tail.substring(p);
      }
      return this.pos += x.length, x;
    };
    function Te(fe, k) {
      this.view = fe, this.cache = { ".": this.view }, this.parent = k;
    }
    Te.prototype.push = function(k) {
      return new Te(k, this);
    }, Te.prototype.lookup = function(k) {
      var p = this.cache, x;
      if (p.hasOwnProperty(k))
        x = p[k];
      else {
        for (var S = this, B, L, C, G = !1; S; ) {
          if (k.indexOf(".") > 0)
            for (B = S.view, L = k.split("."), C = 0; B != null && C < L.length; )
              C === L.length - 1 && (G = _(B, L[C]) || T(B, L[C])), B = B[L[C++]];
          else
            B = S.view[k], G = _(S.view, k);
          if (G) {
            x = B;
            break;
          }
          S = S.parent;
        }
        p[k] = x;
      }
      return m(x) && (x = x.call(this.view)), x;
    };
    function Ke() {
      this.templateCache = {
        _cache: {},
        set: function(k, p) {
          this._cache[k] = p;
        },
        get: function(k) {
          return this._cache[k];
        },
        clear: function() {
          this._cache = {};
        }
      };
    }
    Ke.prototype.clearCache = function() {
      typeof this.templateCache < "u" && this.templateCache.clear();
    }, Ke.prototype.parse = function(k, p) {
      var x = this.templateCache, S = k + ":" + (p || Se.tags).join(":"), B = typeof x < "u", L = B ? x.get(S) : void 0;
      return L == null && (L = me(k, p), B && x.set(S, L)), L;
    }, Ke.prototype.render = function(k, p, x, S) {
      var B = this.getConfigTags(S), L = this.parse(k, B), C = p instanceof Te ? p : new Te(p, void 0);
      return this.renderTokens(L, C, x, k, S);
    }, Ke.prototype.renderTokens = function(k, p, x, S, B) {
      for (var L = "", C, G, R, y = 0, j = k.length; y < j; ++y)
        R = void 0, C = k[y], G = C[0], G === "#" ? R = this.renderSection(C, p, x, S, B) : G === "^" ? R = this.renderInverted(C, p, x, S, B) : G === ">" ? R = this.renderPartial(C, p, x, B) : G === "&" ? R = this.unescapedValue(C, p) : G === "name" ? R = this.escapedValue(C, p, B) : G === "text" && (R = this.rawValue(C)), R !== void 0 && (L += R);
      return L;
    }, Ke.prototype.renderSection = function(k, p, x, S, B) {
      var L = this, C = "", G = p.lookup(k[1]);
      function R(ye) {
        return L.render(ye, p, x, B);
      }
      if (!!G) {
        if (h(G))
          for (var y = 0, j = G.length; y < j; ++y)
            C += this.renderTokens(k[4], p.push(G[y]), x, S, B);
        else if (typeof G == "object" || typeof G == "string" || typeof G == "number")
          C += this.renderTokens(k[4], p.push(G), x, S, B);
        else if (m(G)) {
          if (typeof S != "string")
            throw new Error("Cannot use higher-order sections without the original template");
          G = G.call(p.view, S.slice(k[3], k[5]), R), G != null && (C += G);
        } else
          C += this.renderTokens(k[4], p, x, S, B);
        return C;
      }
    }, Ke.prototype.renderInverted = function(k, p, x, S, B) {
      var L = p.lookup(k[1]);
      if (!L || h(L) && L.length === 0)
        return this.renderTokens(k[4], p, x, S, B);
    }, Ke.prototype.indentPartial = function(k, p, x) {
      for (var S = p.replace(/[^ \t]/g, ""), B = k.split(`
`), L = 0; L < B.length; L++)
        B[L].length && (L > 0 || !x) && (B[L] = S + B[L]);
      return B.join(`
`);
    }, Ke.prototype.renderPartial = function(k, p, x, S) {
      if (!!x) {
        var B = this.getConfigTags(S), L = m(x) ? x(k[1]) : x[k[1]];
        if (L != null) {
          var C = k[6], G = k[5], R = k[4], y = L;
          G == 0 && R && (y = this.indentPartial(L, R, C));
          var j = this.parse(y, B);
          return this.renderTokens(j, p, x, y, S);
        }
      }
    }, Ke.prototype.unescapedValue = function(k, p) {
      var x = p.lookup(k[1]);
      if (x != null)
        return x;
    }, Ke.prototype.escapedValue = function(k, p, x) {
      var S = this.getConfigEscape(x) || Se.escape, B = p.lookup(k[1]);
      if (B != null)
        return typeof B == "number" && S === Se.escape ? String(B) : S(B);
    }, Ke.prototype.rawValue = function(k) {
      return k[1];
    }, Ke.prototype.getConfigTags = function(k) {
      return h(k) ? k : k && typeof k == "object" ? k.tags : void 0;
    }, Ke.prototype.getConfigEscape = function(k) {
      if (k && typeof k == "object" && !h(k))
        return k.escape;
    };
    var Se = {
      name: "mustache.js",
      version: "4.2.0",
      tags: ["{{", "}}"],
      clearCache: void 0,
      escape: void 0,
      parse: void 0,
      render: void 0,
      Scanner: void 0,
      Context: void 0,
      Writer: void 0,
      set templateCache(fe) {
        X.templateCache = fe;
      },
      get templateCache() {
        return X.templateCache;
      }
    }, X = new Ke();
    return Se.clearCache = function() {
      return X.clearCache();
    }, Se.parse = function(k, p) {
      return X.parse(k, p);
    }, Se.render = function(k, p, x, S) {
      if (typeof k != "string")
        throw new TypeError('Invalid template! Template should be a "string" but "' + d(k) + '" was given as the first argument for mustache#render(template, view, partials)');
      return X.render(k, p, x, S);
    }, Se.escape = de, Se.Scanner = Ee, Se.Context = Te, Se.Writer = Ke, Se;
  });
})(mustache);
var schema = {
  BadUTF16: {
    name: "BadUTF16",
    subtypes: [],
    props: {}
  },
  BadUTF8: {
    name: "BadUTF8",
    subtypes: [],
    props: {}
  },
  BalanceExceeded: {
    name: "BalanceExceeded",
    subtypes: [],
    props: {}
  },
  BreakpointTrap: {
    name: "BreakpointTrap",
    subtypes: [],
    props: {}
  },
  CacheError: {
    name: "CacheError",
    subtypes: [
      "ReadError",
      "WriteError",
      "DeserializationError",
      "SerializationError"
    ],
    props: {}
  },
  CallIndirectOOB: {
    name: "CallIndirectOOB",
    subtypes: [],
    props: {}
  },
  CannotAppendActionToJointPromise: {
    name: "CannotAppendActionToJointPromise",
    subtypes: [],
    props: {}
  },
  CannotReturnJointPromise: {
    name: "CannotReturnJointPromise",
    subtypes: [],
    props: {}
  },
  CodeDoesNotExist: {
    name: "CodeDoesNotExist",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  CompilationError: {
    name: "CompilationError",
    subtypes: [
      "CodeDoesNotExist",
      "PrepareError",
      "WasmerCompileError"
    ],
    props: {}
  },
  ContractSizeExceeded: {
    name: "ContractSizeExceeded",
    subtypes: [],
    props: {
      limit: "",
      size: ""
    }
  },
  Deprecated: {
    name: "Deprecated",
    subtypes: [],
    props: {
      method_name: ""
    }
  },
  Deserialization: {
    name: "Deserialization",
    subtypes: [],
    props: {}
  },
  DeserializationError: {
    name: "DeserializationError",
    subtypes: [],
    props: {}
  },
  EmptyMethodName: {
    name: "EmptyMethodName",
    subtypes: [],
    props: {}
  },
  FunctionCallError: {
    name: "FunctionCallError",
    subtypes: [
      "CompilationError",
      "LinkError",
      "MethodResolveError",
      "WasmTrap",
      "WasmUnknownError",
      "HostError",
      "EvmError"
    ],
    props: {}
  },
  GasExceeded: {
    name: "GasExceeded",
    subtypes: [],
    props: {}
  },
  GasInstrumentation: {
    name: "GasInstrumentation",
    subtypes: [],
    props: {}
  },
  GasLimitExceeded: {
    name: "GasLimitExceeded",
    subtypes: [],
    props: {}
  },
  GenericTrap: {
    name: "GenericTrap",
    subtypes: [],
    props: {}
  },
  GuestPanic: {
    name: "GuestPanic",
    subtypes: [],
    props: {
      panic_msg: ""
    }
  },
  HostError: {
    name: "HostError",
    subtypes: [
      "BadUTF16",
      "BadUTF8",
      "GasExceeded",
      "GasLimitExceeded",
      "BalanceExceeded",
      "EmptyMethodName",
      "GuestPanic",
      "IntegerOverflow",
      "InvalidPromiseIndex",
      "CannotAppendActionToJointPromise",
      "CannotReturnJointPromise",
      "InvalidPromiseResultIndex",
      "InvalidRegisterId",
      "IteratorWasInvalidated",
      "MemoryAccessViolation",
      "InvalidReceiptIndex",
      "InvalidIteratorIndex",
      "InvalidAccountId",
      "InvalidMethodName",
      "InvalidPublicKey",
      "ProhibitedInView",
      "NumberOfLogsExceeded",
      "KeyLengthExceeded",
      "ValueLengthExceeded",
      "TotalLogLengthExceeded",
      "NumberPromisesExceeded",
      "NumberInputDataDependenciesExceeded",
      "ReturnedValueLengthExceeded",
      "ContractSizeExceeded",
      "Deprecated"
    ],
    props: {}
  },
  IllegalArithmetic: {
    name: "IllegalArithmetic",
    subtypes: [],
    props: {}
  },
  IncorrectCallIndirectSignature: {
    name: "IncorrectCallIndirectSignature",
    subtypes: [],
    props: {}
  },
  Instantiate: {
    name: "Instantiate",
    subtypes: [],
    props: {}
  },
  IntegerOverflow: {
    name: "IntegerOverflow",
    subtypes: [],
    props: {}
  },
  InternalMemoryDeclared: {
    name: "InternalMemoryDeclared",
    subtypes: [],
    props: {}
  },
  InvalidAccountId: {
    name: "InvalidAccountId",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  InvalidIteratorIndex: {
    name: "InvalidIteratorIndex",
    subtypes: [],
    props: {
      iterator_index: ""
    }
  },
  InvalidMethodName: {
    name: "InvalidMethodName",
    subtypes: [],
    props: {}
  },
  InvalidPromiseIndex: {
    name: "InvalidPromiseIndex",
    subtypes: [],
    props: {
      promise_idx: ""
    }
  },
  InvalidPromiseResultIndex: {
    name: "InvalidPromiseResultIndex",
    subtypes: [],
    props: {
      result_idx: ""
    }
  },
  InvalidPublicKey: {
    name: "InvalidPublicKey",
    subtypes: [],
    props: {}
  },
  InvalidReceiptIndex: {
    name: "InvalidReceiptIndex",
    subtypes: [],
    props: {
      receipt_index: ""
    }
  },
  InvalidRegisterId: {
    name: "InvalidRegisterId",
    subtypes: [],
    props: {
      register_id: ""
    }
  },
  IteratorWasInvalidated: {
    name: "IteratorWasInvalidated",
    subtypes: [],
    props: {
      iterator_index: ""
    }
  },
  KeyLengthExceeded: {
    name: "KeyLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  LinkError: {
    name: "LinkError",
    subtypes: [],
    props: {
      msg: ""
    }
  },
  Memory: {
    name: "Memory",
    subtypes: [],
    props: {}
  },
  MemoryAccessViolation: {
    name: "MemoryAccessViolation",
    subtypes: [],
    props: {}
  },
  MemoryOutOfBounds: {
    name: "MemoryOutOfBounds",
    subtypes: [],
    props: {}
  },
  MethodEmptyName: {
    name: "MethodEmptyName",
    subtypes: [],
    props: {}
  },
  MethodInvalidSignature: {
    name: "MethodInvalidSignature",
    subtypes: [],
    props: {}
  },
  MethodNotFound: {
    name: "MethodNotFound",
    subtypes: [],
    props: {}
  },
  MethodResolveError: {
    name: "MethodResolveError",
    subtypes: [
      "MethodEmptyName",
      "MethodUTF8Error",
      "MethodNotFound",
      "MethodInvalidSignature"
    ],
    props: {}
  },
  MethodUTF8Error: {
    name: "MethodUTF8Error",
    subtypes: [],
    props: {}
  },
  MisalignedAtomicAccess: {
    name: "MisalignedAtomicAccess",
    subtypes: [],
    props: {}
  },
  NumberInputDataDependenciesExceeded: {
    name: "NumberInputDataDependenciesExceeded",
    subtypes: [],
    props: {
      limit: "",
      number_of_input_data_dependencies: ""
    }
  },
  NumberOfLogsExceeded: {
    name: "NumberOfLogsExceeded",
    subtypes: [],
    props: {
      limit: ""
    }
  },
  NumberPromisesExceeded: {
    name: "NumberPromisesExceeded",
    subtypes: [],
    props: {
      limit: "",
      number_of_promises: ""
    }
  },
  PrepareError: {
    name: "PrepareError",
    subtypes: [
      "Serialization",
      "Deserialization",
      "InternalMemoryDeclared",
      "GasInstrumentation",
      "StackHeightInstrumentation",
      "Instantiate",
      "Memory"
    ],
    props: {}
  },
  ProhibitedInView: {
    name: "ProhibitedInView",
    subtypes: [],
    props: {
      method_name: ""
    }
  },
  ReadError: {
    name: "ReadError",
    subtypes: [],
    props: {}
  },
  ReturnedValueLengthExceeded: {
    name: "ReturnedValueLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  Serialization: {
    name: "Serialization",
    subtypes: [],
    props: {}
  },
  SerializationError: {
    name: "SerializationError",
    subtypes: [],
    props: {
      hash: ""
    }
  },
  StackHeightInstrumentation: {
    name: "StackHeightInstrumentation",
    subtypes: [],
    props: {}
  },
  StackOverflow: {
    name: "StackOverflow",
    subtypes: [],
    props: {}
  },
  TotalLogLengthExceeded: {
    name: "TotalLogLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  Unreachable: {
    name: "Unreachable",
    subtypes: [],
    props: {}
  },
  ValueLengthExceeded: {
    name: "ValueLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  WasmTrap: {
    name: "WasmTrap",
    subtypes: [
      "Unreachable",
      "IncorrectCallIndirectSignature",
      "MemoryOutOfBounds",
      "CallIndirectOOB",
      "IllegalArithmetic",
      "MisalignedAtomicAccess",
      "BreakpointTrap",
      "StackOverflow",
      "GenericTrap"
    ],
    props: {}
  },
  WasmUnknownError: {
    name: "WasmUnknownError",
    subtypes: [],
    props: {}
  },
  WasmerCompileError: {
    name: "WasmerCompileError",
    subtypes: [],
    props: {
      msg: ""
    }
  },
  WriteError: {
    name: "WriteError",
    subtypes: [],
    props: {}
  },
  AccessKeyNotFound: {
    name: "AccessKeyNotFound",
    subtypes: [],
    props: {
      account_id: "",
      public_key: ""
    }
  },
  AccountAlreadyExists: {
    name: "AccountAlreadyExists",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  AccountDoesNotExist: {
    name: "AccountDoesNotExist",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  ActionError: {
    name: "ActionError",
    subtypes: [
      "AccountAlreadyExists",
      "AccountDoesNotExist",
      "CreateAccountOnlyByRegistrar",
      "CreateAccountNotAllowed",
      "ActorNoPermission",
      "DeleteKeyDoesNotExist",
      "AddKeyAlreadyExists",
      "DeleteAccountStaking",
      "LackBalanceForState",
      "TriesToUnstake",
      "TriesToStake",
      "InsufficientStake",
      "FunctionCallError",
      "NewReceiptValidationError",
      "OnlyImplicitAccountCreationAllowed"
    ],
    props: {
      index: ""
    }
  },
  ActionsValidationError: {
    name: "ActionsValidationError",
    subtypes: [
      "DeleteActionMustBeFinal",
      "TotalPrepaidGasExceeded",
      "TotalNumberOfActionsExceeded",
      "AddKeyMethodNamesNumberOfBytesExceeded",
      "AddKeyMethodNameLengthExceeded",
      "IntegerOverflow",
      "InvalidAccountId",
      "ContractSizeExceeded",
      "FunctionCallMethodNameLengthExceeded",
      "FunctionCallArgumentsLengthExceeded",
      "UnsuitableStakingKey",
      "FunctionCallZeroAttachedGas"
    ],
    props: {}
  },
  ActorNoPermission: {
    name: "ActorNoPermission",
    subtypes: [],
    props: {
      account_id: "",
      actor_id: ""
    }
  },
  AddKeyAlreadyExists: {
    name: "AddKeyAlreadyExists",
    subtypes: [],
    props: {
      account_id: "",
      public_key: ""
    }
  },
  AddKeyMethodNameLengthExceeded: {
    name: "AddKeyMethodNameLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  AddKeyMethodNamesNumberOfBytesExceeded: {
    name: "AddKeyMethodNamesNumberOfBytesExceeded",
    subtypes: [],
    props: {
      limit: "",
      total_number_of_bytes: ""
    }
  },
  BalanceMismatchError: {
    name: "BalanceMismatchError",
    subtypes: [],
    props: {
      final_accounts_balance: "",
      final_postponed_receipts_balance: "",
      incoming_receipts_balance: "",
      incoming_validator_rewards: "",
      initial_accounts_balance: "",
      initial_postponed_receipts_balance: "",
      new_delayed_receipts_balance: "",
      other_burnt_amount: "",
      outgoing_receipts_balance: "",
      processed_delayed_receipts_balance: "",
      slashed_burnt_amount: "",
      tx_burnt_amount: ""
    }
  },
  CostOverflow: {
    name: "CostOverflow",
    subtypes: [],
    props: {}
  },
  CreateAccountNotAllowed: {
    name: "CreateAccountNotAllowed",
    subtypes: [],
    props: {
      account_id: "",
      predecessor_id: ""
    }
  },
  CreateAccountOnlyByRegistrar: {
    name: "CreateAccountOnlyByRegistrar",
    subtypes: [],
    props: {
      account_id: "",
      predecessor_id: "",
      registrar_account_id: ""
    }
  },
  DeleteAccountStaking: {
    name: "DeleteAccountStaking",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  DeleteActionMustBeFinal: {
    name: "DeleteActionMustBeFinal",
    subtypes: [],
    props: {}
  },
  DeleteKeyDoesNotExist: {
    name: "DeleteKeyDoesNotExist",
    subtypes: [],
    props: {
      account_id: "",
      public_key: ""
    }
  },
  DepositWithFunctionCall: {
    name: "DepositWithFunctionCall",
    subtypes: [],
    props: {}
  },
  Expired: {
    name: "Expired",
    subtypes: [],
    props: {}
  },
  FunctionCallArgumentsLengthExceeded: {
    name: "FunctionCallArgumentsLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  FunctionCallMethodNameLengthExceeded: {
    name: "FunctionCallMethodNameLengthExceeded",
    subtypes: [],
    props: {
      length: "",
      limit: ""
    }
  },
  FunctionCallZeroAttachedGas: {
    name: "FunctionCallZeroAttachedGas",
    subtypes: [],
    props: {}
  },
  InsufficientStake: {
    name: "InsufficientStake",
    subtypes: [],
    props: {
      account_id: "",
      minimum_stake: "",
      stake: ""
    }
  },
  InvalidAccessKeyError: {
    name: "InvalidAccessKeyError",
    subtypes: [
      "AccessKeyNotFound",
      "ReceiverMismatch",
      "MethodNameMismatch",
      "RequiresFullAccess",
      "NotEnoughAllowance",
      "DepositWithFunctionCall"
    ],
    props: {}
  },
  InvalidChain: {
    name: "InvalidChain",
    subtypes: [],
    props: {}
  },
  InvalidDataReceiverId: {
    name: "InvalidDataReceiverId",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  InvalidNonce: {
    name: "InvalidNonce",
    subtypes: [],
    props: {
      ak_nonce: "",
      tx_nonce: ""
    }
  },
  InvalidPredecessorId: {
    name: "InvalidPredecessorId",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  InvalidReceiverId: {
    name: "InvalidReceiverId",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  InvalidSignature: {
    name: "InvalidSignature",
    subtypes: [],
    props: {}
  },
  InvalidSignerId: {
    name: "InvalidSignerId",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  InvalidTxError: {
    name: "InvalidTxError",
    subtypes: [
      "InvalidAccessKeyError",
      "InvalidSignerId",
      "SignerDoesNotExist",
      "InvalidNonce",
      "InvalidReceiverId",
      "InvalidSignature",
      "NotEnoughBalance",
      "LackBalanceForState",
      "CostOverflow",
      "InvalidChain",
      "Expired",
      "ActionsValidation"
    ],
    props: {}
  },
  LackBalanceForState: {
    name: "LackBalanceForState",
    subtypes: [],
    props: {
      account_id: "",
      amount: ""
    }
  },
  MethodNameMismatch: {
    name: "MethodNameMismatch",
    subtypes: [],
    props: {
      method_name: ""
    }
  },
  NotEnoughAllowance: {
    name: "NotEnoughAllowance",
    subtypes: [],
    props: {
      account_id: "",
      allowance: "",
      cost: "",
      public_key: ""
    }
  },
  NotEnoughBalance: {
    name: "NotEnoughBalance",
    subtypes: [],
    props: {
      balance: "",
      cost: "",
      signer_id: ""
    }
  },
  OnlyImplicitAccountCreationAllowed: {
    name: "OnlyImplicitAccountCreationAllowed",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  ReceiptValidationError: {
    name: "ReceiptValidationError",
    subtypes: [
      "InvalidPredecessorId",
      "InvalidReceiverId",
      "InvalidSignerId",
      "InvalidDataReceiverId",
      "ReturnedValueLengthExceeded",
      "NumberInputDataDependenciesExceeded",
      "ActionsValidation"
    ],
    props: {}
  },
  ReceiverMismatch: {
    name: "ReceiverMismatch",
    subtypes: [],
    props: {
      ak_receiver: "",
      tx_receiver: ""
    }
  },
  RequiresFullAccess: {
    name: "RequiresFullAccess",
    subtypes: [],
    props: {}
  },
  SignerDoesNotExist: {
    name: "SignerDoesNotExist",
    subtypes: [],
    props: {
      signer_id: ""
    }
  },
  TotalNumberOfActionsExceeded: {
    name: "TotalNumberOfActionsExceeded",
    subtypes: [],
    props: {
      limit: "",
      total_number_of_actions: ""
    }
  },
  TotalPrepaidGasExceeded: {
    name: "TotalPrepaidGasExceeded",
    subtypes: [],
    props: {
      limit: "",
      total_prepaid_gas: ""
    }
  },
  TriesToStake: {
    name: "TriesToStake",
    subtypes: [],
    props: {
      account_id: "",
      balance: "",
      locked: "",
      stake: ""
    }
  },
  TriesToUnstake: {
    name: "TriesToUnstake",
    subtypes: [],
    props: {
      account_id: ""
    }
  },
  TxExecutionError: {
    name: "TxExecutionError",
    subtypes: [
      "ActionError",
      "InvalidTxError"
    ],
    props: {}
  },
  UnsuitableStakingKey: {
    name: "UnsuitableStakingKey",
    subtypes: [],
    props: {
      public_key: ""
    }
  },
  Closed: {
    name: "Closed",
    subtypes: [],
    props: {}
  },
  InternalError: {
    name: "InternalError",
    subtypes: [],
    props: {}
  },
  ServerError: {
    name: "ServerError",
    subtypes: [
      "TxExecutionError",
      "Timeout",
      "Closed",
      "InternalError"
    ],
    props: {}
  },
  Timeout: {
    name: "Timeout",
    subtypes: [],
    props: {}
  }
}, require$$1$2 = {
  schema
}, GasLimitExceeded = "Exceeded the maximum amount of gas allowed to burn per contract", MethodEmptyName = "Method name is empty", WasmerCompileError = "Wasmer compilation error: {{msg}}", GuestPanic = "Smart contract panicked: {{panic_msg}}", Memory = "Error creating Wasm memory", GasExceeded = "Exceeded the prepaid gas", MethodUTF8Error = "Method name is not valid UTF8 string", BadUTF16 = "String encoding is bad UTF-16 sequence", WasmTrap = "WebAssembly trap: {{msg}}", GasInstrumentation = "Gas instrumentation failed or contract has denied instructions.", InvalidPromiseIndex = "{{promise_idx}} does not correspond to existing promises", InvalidPromiseResultIndex = "Accessed invalid promise result index: {{result_idx}}", Deserialization = "Error happened while deserializing the module", MethodNotFound = "Contract method is not found", InvalidRegisterId = "Accessed invalid register id: {{register_id}}", InvalidReceiptIndex = "VM Logic returned an invalid receipt index: {{receipt_index}}", EmptyMethodName = "Method name is empty in contract call", CannotReturnJointPromise = "Returning joint promise is currently prohibited", StackHeightInstrumentation = "Stack instrumentation failed", CodeDoesNotExist = "Cannot find contract code for account {{account_id}}", MethodInvalidSignature = "Invalid method signature", IntegerOverflow = "Integer overflow happened during contract execution", MemoryAccessViolation = "MemoryAccessViolation", InvalidIteratorIndex = "Iterator index {{iterator_index}} does not exist", IteratorWasInvalidated = "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie", InvalidAccountId = "VM Logic returned an invalid account id", Serialization = "Error happened while serializing the module", CannotAppendActionToJointPromise = "Actions can only be appended to non-joint promise.", InternalMemoryDeclared = "Internal memory declaration has been found in the module", Instantiate = "Error happened during instantiation", ProhibitedInView = "{{method_name}} is not allowed in view calls", InvalidMethodName = "VM Logic returned an invalid method name", BadUTF8 = "String encoding is bad UTF-8 sequence", BalanceExceeded = "Exceeded the account balance", LinkError = "Wasm contract link error: {{msg}}", InvalidPublicKey = "VM Logic provided an invalid public key", ActorNoPermission = "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action", LackBalanceForState = "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more", ReceiverMismatch = "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.", CostOverflow = "Transaction gas or balance cost is too high", InvalidSignature = "Transaction is not signed with the given public key", AccessKeyNotFound = `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`, NotEnoughBalance = "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}", NotEnoughAllowance = "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}", Expired = "Transaction has expired", DeleteAccountStaking = "Account {{account_id}} is staking and can not be deleted", SignerDoesNotExist = "Signer {{signer_id}} does not exist", TriesToStake = "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}", AddKeyAlreadyExists = "The public key {{public_key}} is already used for an existing access key", InvalidSigner = "Invalid signer account ID {{signer_id}} according to requirements", CreateAccountNotAllowed = "The new account_id {{account_id}} can't be created by {{predecessor_id}}", RequiresFullAccess = "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key", TriesToUnstake = "Account {{account_id}} is not yet staked, but tried to unstake", InvalidNonce = "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}", AccountAlreadyExists = "Can't create a new account {{account_id}}, because it already exists", InvalidChain = "Transaction parent block hash doesn't belong to the current chain", AccountDoesNotExist = "Can't complete the action because account {{account_id}} doesn't exist", MethodNameMismatch = "Transaction method name {{method_name}} isn't allowed by the access key", DeleteAccountHasRent = "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent", DeleteAccountHasEnoughBalance = "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage", InvalidReceiver = "Invalid receiver account ID {{receiver_id}} according to requirements", DeleteKeyDoesNotExist = "Account {{account_id}} tries to remove an access key that doesn't exist", Timeout = "Timeout exceeded", Closed = "Connection closed", require$$2$1 = {
  GasLimitExceeded,
  MethodEmptyName,
  WasmerCompileError,
  GuestPanic,
  Memory,
  GasExceeded,
  MethodUTF8Error,
  BadUTF16,
  WasmTrap,
  GasInstrumentation,
  InvalidPromiseIndex,
  InvalidPromiseResultIndex,
  Deserialization,
  MethodNotFound,
  InvalidRegisterId,
  InvalidReceiptIndex,
  EmptyMethodName,
  CannotReturnJointPromise,
  StackHeightInstrumentation,
  CodeDoesNotExist,
  MethodInvalidSignature,
  IntegerOverflow,
  MemoryAccessViolation,
  InvalidIteratorIndex,
  IteratorWasInvalidated,
  InvalidAccountId,
  Serialization,
  CannotAppendActionToJointPromise,
  InternalMemoryDeclared,
  Instantiate,
  ProhibitedInView,
  InvalidMethodName,
  BadUTF8,
  BalanceExceeded,
  LinkError,
  InvalidPublicKey,
  ActorNoPermission,
  LackBalanceForState,
  ReceiverMismatch,
  CostOverflow,
  InvalidSignature,
  AccessKeyNotFound,
  NotEnoughBalance,
  NotEnoughAllowance,
  Expired,
  DeleteAccountStaking,
  SignerDoesNotExist,
  TriesToStake,
  AddKeyAlreadyExists,
  InvalidSigner,
  CreateAccountNotAllowed,
  RequiresFullAccess,
  TriesToUnstake,
  InvalidNonce,
  AccountAlreadyExists,
  InvalidChain,
  AccountDoesNotExist,
  MethodNameMismatch,
  DeleteAccountHasRent,
  DeleteAccountHasEnoughBalance,
  InvalidReceiver,
  DeleteKeyDoesNotExist,
  Timeout,
  Closed
}, hasRequiredRpc_errors;
function requireRpc_errors() {
  if (hasRequiredRpc_errors)
    return rpc_errors;
  hasRequiredRpc_errors = 1;
  var l = commonjsGlobal && commonjsGlobal.__importDefault || function(ce) {
    return ce && ce.__esModule ? ce : { default: ce };
  };
  Object.defineProperty(rpc_errors, "__esModule", { value: !0 }), rpc_errors.formatError = rpc_errors.parseResultError = rpc_errors.parseRpcError = rpc_errors.ServerError = void 0;
  const t = l(mustache.exports), s = l(require$$1$2), h = l(require$$2$1), m = requireCommonIndex(), d = errors, v = {
    formatNear: () => (ce, re) => m.utils.format.formatNearAmount(re(ce))
  };
  class _ extends d.TypedError {
  }
  rpc_errors.ServerError = _;
  class T extends _ {
  }
  function z(ce) {
    const re = {}, oe = ie(ce, s.default.schema, re, ""), pe = new _(Y(oe, re), oe);
    return Object.assign(pe, re), pe;
  }
  rpc_errors.parseRpcError = z;
  function J(ce) {
    const re = z(ce.status.Failure), oe = new T();
    return Object.assign(oe, re), oe.type = re.type, oe.message = re.message, oe.transaction_outcome = ce.transaction_outcome, oe;
  }
  rpc_errors.parseResultError = J;
  function Y(ce, re) {
    return typeof h.default[ce] == "string" ? t.default.render(h.default[ce], Object.assign(Object.assign({}, re), v)) : JSON.stringify(re);
  }
  rpc_errors.formatError = Y;
  function ie(ce, re, oe, pe) {
    let ae, me, ge;
    for (const we in re) {
      if (de(ce[we]))
        return ce[we];
      if (ne(ce[we]))
        ae = ce[we], me = re[we], ge = we;
      else if (ne(ce.kind) && ne(ce.kind[we]))
        ae = ce.kind[we], me = re[we], ge = we;
      else
        continue;
    }
    if (ae && me) {
      for (const we of Object.keys(me.props))
        oe[we] = ae[we];
      return ie(ae, re, oe, ge);
    } else
      return oe.kind = ce, pe;
  }
  function ne(ce) {
    return Object.prototype.toString.call(ce) === "[object Object]";
  }
  function de(ce) {
    return Object.prototype.toString.call(ce) === "[object String]";
  }
  return rpc_errors;
}
var hasRequiredJsonRpcProvider;
function requireJsonRpcProvider() {
  return hasRequiredJsonRpcProvider || (hasRequiredJsonRpcProvider = 1, function(l) {
    var t = commonjsGlobal && commonjsGlobal.__awaiter || function(ce, re, oe, pe) {
      function ae(me) {
        return me instanceof oe ? me : new oe(function(ge) {
          ge(me);
        });
      }
      return new (oe || (oe = Promise))(function(me, ge) {
        function we(Ke) {
          try {
            Te(pe.next(Ke));
          } catch (Se) {
            ge(Se);
          }
        }
        function Ee(Ke) {
          try {
            Te(pe.throw(Ke));
          } catch (Se) {
            ge(Se);
          }
        }
        function Te(Ke) {
          Ke.done ? me(Ke.value) : ae(Ke.value).then(we, Ee);
        }
        Te((pe = pe.apply(ce, re || [])).next());
      });
    }, s = commonjsGlobal && commonjsGlobal.__rest || function(ce, re) {
      var oe = {};
      for (var pe in ce)
        Object.prototype.hasOwnProperty.call(ce, pe) && re.indexOf(pe) < 0 && (oe[pe] = ce[pe]);
      if (ce != null && typeof Object.getOwnPropertySymbols == "function")
        for (var ae = 0, pe = Object.getOwnPropertySymbols(ce); ae < pe.length; ae++)
          re.indexOf(pe[ae]) < 0 && Object.prototype.propertyIsEnumerable.call(ce, pe[ae]) && (oe[pe[ae]] = ce[pe[ae]]);
      return oe;
    }, h = commonjsGlobal && commonjsGlobal.__importDefault || function(ce) {
      return ce && ce.__esModule ? ce : { default: ce };
    };
    Object.defineProperty(l, "__esModule", { value: !0 }), l.JsonRpcProvider = l.ErrorContext = l.TypedError = void 0;
    const m = provider$1, d = requireWeb(), v = errors;
    Object.defineProperty(l, "TypedError", { enumerable: !0, get: function() {
      return v.TypedError;
    } }), Object.defineProperty(l, "ErrorContext", { enumerable: !0, get: function() {
      return v.ErrorContext;
    } });
    const _ = lib$4, T = h(exponentialBackoff$1), z = requireRpc_errors(), J = 12, Y = 500, ie = 1.5;
    let ne = 123;
    class de extends m.Provider {
      constructor(re) {
        super(), this.connection = re || { url: "" };
      }
      status() {
        return t(this, void 0, void 0, function* () {
          return this.sendJsonRpc("status", []);
        });
      }
      sendTransaction(re) {
        return t(this, void 0, void 0, function* () {
          const oe = re.encode();
          return this.sendJsonRpc("broadcast_tx_commit", [Buffer.from(oe).toString("base64")]);
        });
      }
      sendTransactionAsync(re) {
        return t(this, void 0, void 0, function* () {
          const oe = re.encode();
          return this.sendJsonRpc("broadcast_tx_async", [Buffer.from(oe).toString("base64")]);
        });
      }
      txStatus(re, oe) {
        return t(this, void 0, void 0, function* () {
          return typeof re == "string" ? this.txStatusString(re, oe) : this.txStatusUint8Array(re, oe);
        });
      }
      txStatusUint8Array(re, oe) {
        return t(this, void 0, void 0, function* () {
          return this.sendJsonRpc("tx", [(0, _.baseEncode)(re), oe]);
        });
      }
      txStatusString(re, oe) {
        return t(this, void 0, void 0, function* () {
          return this.sendJsonRpc("tx", [re, oe]);
        });
      }
      txStatusReceipts(re, oe) {
        return t(this, void 0, void 0, function* () {
          return typeof re == "string" ? this.sendJsonRpc("EXPERIMENTAL_tx_status", [re, oe]) : this.sendJsonRpc("EXPERIMENTAL_tx_status", [(0, _.baseEncode)(re), oe]);
        });
      }
      query(...re) {
        return t(this, void 0, void 0, function* () {
          let oe;
          if (re.length === 1) {
            const pe = re[0], { block_id: ae, blockId: me } = pe, ge = s(pe, ["block_id", "blockId"]);
            oe = yield this.sendJsonRpc("query", Object.assign(Object.assign({}, ge), { block_id: ae || me }));
          } else {
            const [pe, ae] = re;
            oe = yield this.sendJsonRpc("query", [pe, ae]);
          }
          if (oe && oe.error)
            throw new v.TypedError(`Querying failed: ${oe.error}.
${JSON.stringify(oe, null, 2)}`, oe.error.name);
          return oe;
        });
      }
      block(re) {
        return t(this, void 0, void 0, function* () {
          const { finality: oe } = re, { blockId: pe } = re;
          return this.sendJsonRpc("block", { block_id: pe, finality: oe });
        });
      }
      blockChanges(re) {
        return t(this, void 0, void 0, function* () {
          const { finality: oe } = re, { blockId: pe } = re;
          return this.sendJsonRpc("EXPERIMENTAL_changes_in_block", { block_id: pe, finality: oe });
        });
      }
      chunk(re) {
        return t(this, void 0, void 0, function* () {
          return this.sendJsonRpc("chunk", [re]);
        });
      }
      validators(re) {
        return t(this, void 0, void 0, function* () {
          return this.sendJsonRpc("validators", [re]);
        });
      }
      experimental_protocolConfig(re) {
        return t(this, void 0, void 0, function* () {
          const oe = re, { blockId: pe } = oe, ae = s(oe, ["blockId"]);
          return yield this.sendJsonRpc("EXPERIMENTAL_protocol_config", Object.assign(Object.assign({}, ae), { block_id: pe }));
        });
      }
      lightClientProof(re) {
        return t(this, void 0, void 0, function* () {
          return yield this.sendJsonRpc("EXPERIMENTAL_light_client_proof", re);
        });
      }
      accessKeyChanges(re, oe) {
        return t(this, void 0, void 0, function* () {
          const { finality: pe } = oe, { blockId: ae } = oe;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "all_access_key_changes",
            account_ids: re,
            block_id: ae,
            finality: pe
          });
        });
      }
      singleAccessKeyChanges(re, oe) {
        return t(this, void 0, void 0, function* () {
          const { finality: pe } = oe, { blockId: ae } = oe;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "single_access_key_changes",
            keys: re,
            block_id: ae,
            finality: pe
          });
        });
      }
      accountChanges(re, oe) {
        return t(this, void 0, void 0, function* () {
          const { finality: pe } = oe, { blockId: ae } = oe;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "account_changes",
            account_ids: re,
            block_id: ae,
            finality: pe
          });
        });
      }
      contractStateChanges(re, oe, pe = "") {
        return t(this, void 0, void 0, function* () {
          const { finality: ae } = oe, { blockId: me } = oe;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "data_changes",
            account_ids: re,
            key_prefix_base64: pe,
            block_id: me,
            finality: ae
          });
        });
      }
      contractCodeChanges(re, oe) {
        return t(this, void 0, void 0, function* () {
          const { finality: pe } = oe, { blockId: ae } = oe;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "contract_code_changes",
            account_ids: re,
            block_id: ae,
            finality: pe
          });
        });
      }
      gasPrice(re) {
        return t(this, void 0, void 0, function* () {
          return yield this.sendJsonRpc("gas_price", [re]);
        });
      }
      sendJsonRpc(re, oe) {
        return t(this, void 0, void 0, function* () {
          const pe = yield (0, T.default)(Y, J, ie, () => t(this, void 0, void 0, function* () {
            try {
              const me = {
                method: re,
                params: oe,
                id: ne++,
                jsonrpc: "2.0"
              }, ge = yield (0, d.fetchJson)(this.connection, JSON.stringify(me));
              if (ge.error) {
                if (typeof ge.error.data == "object")
                  throw typeof ge.error.data.error_message == "string" && typeof ge.error.data.error_type == "string" ? new v.TypedError(ge.error.data.error_message, ge.error.data.error_type) : (0, z.parseRpcError)(ge.error.data);
                {
                  const we = `[${ge.error.code}] ${ge.error.message}: ${ge.error.data}`;
                  throw ge.error.data === "Timeout" || we.includes("Timeout error") || we.includes("query has timed out") ? new v.TypedError(we, "TimeoutError") : new v.TypedError(we, ge.error.name);
                }
              }
              return ge;
            } catch (me) {
              if (me.type === "TimeoutError")
                return process.env.NEAR_NO_LOGS || console.warn(`Retrying request to ${re} as it has timed out`, oe), null;
              throw me;
            }
          })), { result: ae } = pe;
          if (typeof ae > "u")
            throw new v.TypedError(`Exceeded ${J} attempts for request to ${re}.`, "RetriesExceeded");
          return ae;
        });
      }
    }
    l.JsonRpcProvider = de;
  }(jsonRpcProvider)), jsonRpcProvider;
}
var hasRequiredProviders;
function requireProviders() {
  return hasRequiredProviders || (hasRequiredProviders = 1, function(l) {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.ErrorContext = l.TypedError = l.getTransactionLastResult = l.FinalExecutionStatusBasic = l.JsonRpcProvider = l.Provider = void 0;
    const t = provider$1;
    Object.defineProperty(l, "Provider", { enumerable: !0, get: function() {
      return t.Provider;
    } }), Object.defineProperty(l, "getTransactionLastResult", { enumerable: !0, get: function() {
      return t.getTransactionLastResult;
    } }), Object.defineProperty(l, "FinalExecutionStatusBasic", { enumerable: !0, get: function() {
      return t.FinalExecutionStatusBasic;
    } });
    const s = requireJsonRpcProvider();
    Object.defineProperty(l, "JsonRpcProvider", { enumerable: !0, get: function() {
      return s.JsonRpcProvider;
    } }), Object.defineProperty(l, "TypedError", { enumerable: !0, get: function() {
      return s.TypedError;
    } }), Object.defineProperty(l, "ErrorContext", { enumerable: !0, get: function() {
      return s.ErrorContext;
    } });
  }(providers)), providers;
}
var utils$3 = {}, format = {}, bn$1 = { exports: {} };
(function(l) {
  (function(t, s) {
    function h(k, p) {
      if (!k)
        throw new Error(p || "Assertion failed");
    }
    function m(k, p) {
      k.super_ = p;
      var x = function() {
      };
      x.prototype = p.prototype, k.prototype = new x(), k.prototype.constructor = k;
    }
    function d(k, p, x) {
      if (d.isBN(k))
        return k;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, k !== null && ((p === "le" || p === "be") && (x = p, p = 10), this._init(k || 0, p || 10, x || "be"));
    }
    typeof t == "object" ? t.exports = d : s.BN = d, d.BN = d, d.wordSize = 26;
    var v;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? v = window.Buffer : v = require$$0$5.Buffer;
    } catch {
    }
    d.isBN = function(p) {
      return p instanceof d ? !0 : p !== null && typeof p == "object" && p.constructor.wordSize === d.wordSize && Array.isArray(p.words);
    }, d.max = function(p, x) {
      return p.cmp(x) > 0 ? p : x;
    }, d.min = function(p, x) {
      return p.cmp(x) < 0 ? p : x;
    }, d.prototype._init = function(p, x, S) {
      if (typeof p == "number")
        return this._initNumber(p, x, S);
      if (typeof p == "object")
        return this._initArray(p, x, S);
      x === "hex" && (x = 16), h(x === (x | 0) && x >= 2 && x <= 36), p = p.toString().replace(/\s+/g, "");
      var B = 0;
      p[0] === "-" && (B++, this.negative = 1), B < p.length && (x === 16 ? this._parseHex(p, B, S) : (this._parseBase(p, x, B), S === "le" && this._initArray(this.toArray(), x, S)));
    }, d.prototype._initNumber = function(p, x, S) {
      p < 0 && (this.negative = 1, p = -p), p < 67108864 ? (this.words = [p & 67108863], this.length = 1) : p < 4503599627370496 ? (this.words = [
        p & 67108863,
        p / 67108864 & 67108863
      ], this.length = 2) : (h(p < 9007199254740992), this.words = [
        p & 67108863,
        p / 67108864 & 67108863,
        1
      ], this.length = 3), S === "le" && this._initArray(this.toArray(), x, S);
    }, d.prototype._initArray = function(p, x, S) {
      if (h(typeof p.length == "number"), p.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(p.length / 3), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var L, C, G = 0;
      if (S === "be")
        for (B = p.length - 1, L = 0; B >= 0; B -= 3)
          C = p[B] | p[B - 1] << 8 | p[B - 2] << 16, this.words[L] |= C << G & 67108863, this.words[L + 1] = C >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, L++);
      else if (S === "le")
        for (B = 0, L = 0; B < p.length; B += 3)
          C = p[B] | p[B + 1] << 8 | p[B + 2] << 16, this.words[L] |= C << G & 67108863, this.words[L + 1] = C >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, L++);
      return this._strip();
    };
    function _(k, p) {
      var x = k.charCodeAt(p);
      if (x >= 48 && x <= 57)
        return x - 48;
      if (x >= 65 && x <= 70)
        return x - 55;
      if (x >= 97 && x <= 102)
        return x - 87;
      h(!1, "Invalid character in " + k);
    }
    function T(k, p, x) {
      var S = _(k, x);
      return x - 1 >= p && (S |= _(k, x - 1) << 4), S;
    }
    d.prototype._parseHex = function(p, x, S) {
      this.length = Math.ceil((p.length - x) / 6), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var L = 0, C = 0, G;
      if (S === "be")
        for (B = p.length - 1; B >= x; B -= 2)
          G = T(p, x, B) << L, this.words[C] |= G & 67108863, L >= 18 ? (L -= 18, C += 1, this.words[C] |= G >>> 26) : L += 8;
      else {
        var R = p.length - x;
        for (B = R % 2 === 0 ? x + 1 : x; B < p.length; B += 2)
          G = T(p, x, B) << L, this.words[C] |= G & 67108863, L >= 18 ? (L -= 18, C += 1, this.words[C] |= G >>> 26) : L += 8;
      }
      this._strip();
    };
    function z(k, p, x, S) {
      for (var B = 0, L = 0, C = Math.min(k.length, x), G = p; G < C; G++) {
        var R = k.charCodeAt(G) - 48;
        B *= S, R >= 49 ? L = R - 49 + 10 : R >= 17 ? L = R - 17 + 10 : L = R, h(R >= 0 && L < S, "Invalid character"), B += L;
      }
      return B;
    }
    d.prototype._parseBase = function(p, x, S) {
      this.words = [0], this.length = 1;
      for (var B = 0, L = 1; L <= 67108863; L *= x)
        B++;
      B--, L = L / x | 0;
      for (var C = p.length - S, G = C % B, R = Math.min(C, C - G) + S, y = 0, j = S; j < R; j += B)
        y = z(p, j, j + B, x), this.imuln(L), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      if (G !== 0) {
        var ye = 1;
        for (y = z(p, j, p.length, x), j = 0; j < G; j++)
          ye *= x;
        this.imuln(ye), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      }
      this._strip();
    }, d.prototype.copy = function(p) {
      p.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        p.words[x] = this.words[x];
      p.length = this.length, p.negative = this.negative, p.red = this.red;
    };
    function J(k, p) {
      k.words = p.words, k.length = p.length, k.negative = p.negative, k.red = p.red;
    }
    if (d.prototype._move = function(p) {
      J(p, this);
    }, d.prototype.clone = function() {
      var p = new d(null);
      return this.copy(p), p;
    }, d.prototype._expand = function(p) {
      for (; this.length < p; )
        this.words[this.length++] = 0;
      return this;
    }, d.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, d.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        d.prototype[Symbol.for("nodejs.util.inspect.custom")] = Y;
      } catch {
        d.prototype.inspect = Y;
      }
    else
      d.prototype.inspect = Y;
    function Y() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var ie = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ne = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], de = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    d.prototype.toString = function(p, x) {
      p = p || 10, x = x | 0 || 1;
      var S;
      if (p === 16 || p === "hex") {
        S = "";
        for (var B = 0, L = 0, C = 0; C < this.length; C++) {
          var G = this.words[C], R = ((G << B | L) & 16777215).toString(16);
          L = G >>> 24 - B & 16777215, B += 2, B >= 26 && (B -= 26, C--), L !== 0 || C !== this.length - 1 ? S = ie[6 - R.length] + R + S : S = R + S;
        }
        for (L !== 0 && (S = L.toString(16) + S); S.length % x !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      if (p === (p | 0) && p >= 2 && p <= 36) {
        var y = ne[p], j = de[p];
        S = "";
        var ye = this.clone();
        for (ye.negative = 0; !ye.isZero(); ) {
          var ee = ye.modrn(j).toString(p);
          ye = ye.idivn(j), ye.isZero() ? S = ee + S : S = ie[y - ee.length] + ee + S;
        }
        for (this.isZero() && (S = "0" + S); S.length % x !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      h(!1, "Base should be between 2 and 36");
    }, d.prototype.toNumber = function() {
      var p = this.words[0];
      return this.length === 2 ? p += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? p += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && h(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -p : p;
    }, d.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, v && (d.prototype.toBuffer = function(p, x) {
      return this.toArrayLike(v, p, x);
    }), d.prototype.toArray = function(p, x) {
      return this.toArrayLike(Array, p, x);
    };
    var ce = function(p, x) {
      return p.allocUnsafe ? p.allocUnsafe(x) : new p(x);
    };
    d.prototype.toArrayLike = function(p, x, S) {
      this._strip();
      var B = this.byteLength(), L = S || Math.max(1, B);
      h(B <= L, "byte array longer than desired length"), h(L > 0, "Requested array length <= 0");
      var C = ce(p, L), G = x === "le" ? "LE" : "BE";
      return this["_toArrayLike" + G](C, B), C;
    }, d.prototype._toArrayLikeLE = function(p, x) {
      for (var S = 0, B = 0, L = 0, C = 0; L < this.length; L++) {
        var G = this.words[L] << C | B;
        p[S++] = G & 255, S < p.length && (p[S++] = G >> 8 & 255), S < p.length && (p[S++] = G >> 16 & 255), C === 6 ? (S < p.length && (p[S++] = G >> 24 & 255), B = 0, C = 0) : (B = G >>> 24, C += 2);
      }
      if (S < p.length)
        for (p[S++] = B; S < p.length; )
          p[S++] = 0;
    }, d.prototype._toArrayLikeBE = function(p, x) {
      for (var S = p.length - 1, B = 0, L = 0, C = 0; L < this.length; L++) {
        var G = this.words[L] << C | B;
        p[S--] = G & 255, S >= 0 && (p[S--] = G >> 8 & 255), S >= 0 && (p[S--] = G >> 16 & 255), C === 6 ? (S >= 0 && (p[S--] = G >> 24 & 255), B = 0, C = 0) : (B = G >>> 24, C += 2);
      }
      if (S >= 0)
        for (p[S--] = B; S >= 0; )
          p[S--] = 0;
    }, Math.clz32 ? d.prototype._countBits = function(p) {
      return 32 - Math.clz32(p);
    } : d.prototype._countBits = function(p) {
      var x = p, S = 0;
      return x >= 4096 && (S += 13, x >>>= 13), x >= 64 && (S += 7, x >>>= 7), x >= 8 && (S += 4, x >>>= 4), x >= 2 && (S += 2, x >>>= 2), S + x;
    }, d.prototype._zeroBits = function(p) {
      if (p === 0)
        return 26;
      var x = p, S = 0;
      return (x & 8191) === 0 && (S += 13, x >>>= 13), (x & 127) === 0 && (S += 7, x >>>= 7), (x & 15) === 0 && (S += 4, x >>>= 4), (x & 3) === 0 && (S += 2, x >>>= 2), (x & 1) === 0 && S++, S;
    }, d.prototype.bitLength = function() {
      var p = this.words[this.length - 1], x = this._countBits(p);
      return (this.length - 1) * 26 + x;
    };
    function re(k) {
      for (var p = new Array(k.bitLength()), x = 0; x < p.length; x++) {
        var S = x / 26 | 0, B = x % 26;
        p[x] = k.words[S] >>> B & 1;
      }
      return p;
    }
    d.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var p = 0, x = 0; x < this.length; x++) {
        var S = this._zeroBits(this.words[x]);
        if (p += S, S !== 26)
          break;
      }
      return p;
    }, d.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, d.prototype.toTwos = function(p) {
      return this.negative !== 0 ? this.abs().inotn(p).iaddn(1) : this.clone();
    }, d.prototype.fromTwos = function(p) {
      return this.testn(p - 1) ? this.notn(p).iaddn(1).ineg() : this.clone();
    }, d.prototype.isNeg = function() {
      return this.negative !== 0;
    }, d.prototype.neg = function() {
      return this.clone().ineg();
    }, d.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, d.prototype.iuor = function(p) {
      for (; this.length < p.length; )
        this.words[this.length++] = 0;
      for (var x = 0; x < p.length; x++)
        this.words[x] = this.words[x] | p.words[x];
      return this._strip();
    }, d.prototype.ior = function(p) {
      return h((this.negative | p.negative) === 0), this.iuor(p);
    }, d.prototype.or = function(p) {
      return this.length > p.length ? this.clone().ior(p) : p.clone().ior(this);
    }, d.prototype.uor = function(p) {
      return this.length > p.length ? this.clone().iuor(p) : p.clone().iuor(this);
    }, d.prototype.iuand = function(p) {
      var x;
      this.length > p.length ? x = p : x = this;
      for (var S = 0; S < x.length; S++)
        this.words[S] = this.words[S] & p.words[S];
      return this.length = x.length, this._strip();
    }, d.prototype.iand = function(p) {
      return h((this.negative | p.negative) === 0), this.iuand(p);
    }, d.prototype.and = function(p) {
      return this.length > p.length ? this.clone().iand(p) : p.clone().iand(this);
    }, d.prototype.uand = function(p) {
      return this.length > p.length ? this.clone().iuand(p) : p.clone().iuand(this);
    }, d.prototype.iuxor = function(p) {
      var x, S;
      this.length > p.length ? (x = this, S = p) : (x = p, S = this);
      for (var B = 0; B < S.length; B++)
        this.words[B] = x.words[B] ^ S.words[B];
      if (this !== x)
        for (; B < x.length; B++)
          this.words[B] = x.words[B];
      return this.length = x.length, this._strip();
    }, d.prototype.ixor = function(p) {
      return h((this.negative | p.negative) === 0), this.iuxor(p);
    }, d.prototype.xor = function(p) {
      return this.length > p.length ? this.clone().ixor(p) : p.clone().ixor(this);
    }, d.prototype.uxor = function(p) {
      return this.length > p.length ? this.clone().iuxor(p) : p.clone().iuxor(this);
    }, d.prototype.inotn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = Math.ceil(p / 26) | 0, S = p % 26;
      this._expand(x), S > 0 && x--;
      for (var B = 0; B < x; B++)
        this.words[B] = ~this.words[B] & 67108863;
      return S > 0 && (this.words[B] = ~this.words[B] & 67108863 >> 26 - S), this._strip();
    }, d.prototype.notn = function(p) {
      return this.clone().inotn(p);
    }, d.prototype.setn = function(p, x) {
      h(typeof p == "number" && p >= 0);
      var S = p / 26 | 0, B = p % 26;
      return this._expand(S + 1), x ? this.words[S] = this.words[S] | 1 << B : this.words[S] = this.words[S] & ~(1 << B), this._strip();
    }, d.prototype.iadd = function(p) {
      var x;
      if (this.negative !== 0 && p.negative === 0)
        return this.negative = 0, x = this.isub(p), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && p.negative !== 0)
        return p.negative = 0, x = this.isub(p), p.negative = 1, x._normSign();
      var S, B;
      this.length > p.length ? (S = this, B = p) : (S = p, B = this);
      for (var L = 0, C = 0; C < B.length; C++)
        x = (S.words[C] | 0) + (B.words[C] | 0) + L, this.words[C] = x & 67108863, L = x >>> 26;
      for (; L !== 0 && C < S.length; C++)
        x = (S.words[C] | 0) + L, this.words[C] = x & 67108863, L = x >>> 26;
      if (this.length = S.length, L !== 0)
        this.words[this.length] = L, this.length++;
      else if (S !== this)
        for (; C < S.length; C++)
          this.words[C] = S.words[C];
      return this;
    }, d.prototype.add = function(p) {
      var x;
      return p.negative !== 0 && this.negative === 0 ? (p.negative = 0, x = this.sub(p), p.negative ^= 1, x) : p.negative === 0 && this.negative !== 0 ? (this.negative = 0, x = p.sub(this), this.negative = 1, x) : this.length > p.length ? this.clone().iadd(p) : p.clone().iadd(this);
    }, d.prototype.isub = function(p) {
      if (p.negative !== 0) {
        p.negative = 0;
        var x = this.iadd(p);
        return p.negative = 1, x._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(p), this.negative = 1, this._normSign();
      var S = this.cmp(p);
      if (S === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var B, L;
      S > 0 ? (B = this, L = p) : (B = p, L = this);
      for (var C = 0, G = 0; G < L.length; G++)
        x = (B.words[G] | 0) - (L.words[G] | 0) + C, C = x >> 26, this.words[G] = x & 67108863;
      for (; C !== 0 && G < B.length; G++)
        x = (B.words[G] | 0) + C, C = x >> 26, this.words[G] = x & 67108863;
      if (C === 0 && G < B.length && B !== this)
        for (; G < B.length; G++)
          this.words[G] = B.words[G];
      return this.length = Math.max(this.length, G), B !== this && (this.negative = 1), this._strip();
    }, d.prototype.sub = function(p) {
      return this.clone().isub(p);
    };
    function oe(k, p, x) {
      x.negative = p.negative ^ k.negative;
      var S = k.length + p.length | 0;
      x.length = S, S = S - 1 | 0;
      var B = k.words[0] | 0, L = p.words[0] | 0, C = B * L, G = C & 67108863, R = C / 67108864 | 0;
      x.words[0] = G;
      for (var y = 1; y < S; y++) {
        for (var j = R >>> 26, ye = R & 67108863, ee = Math.min(y, p.length - 1), xe = Math.max(0, y - k.length + 1); xe <= ee; xe++) {
          var $e = y - xe | 0;
          B = k.words[$e] | 0, L = p.words[xe] | 0, C = B * L + ye, j += C / 67108864 | 0, ye = C & 67108863;
        }
        x.words[y] = ye | 0, R = j | 0;
      }
      return R !== 0 ? x.words[y] = R | 0 : x.length--, x._strip();
    }
    var pe = function(p, x, S) {
      var B = p.words, L = x.words, C = S.words, G = 0, R, y, j, ye = B[0] | 0, ee = ye & 8191, xe = ye >>> 13, $e = B[1] | 0, ke = $e & 8191, Ce = $e >>> 13, ht = B[2] | 0, Ue = ht & 8191, De = ht >>> 13, wt = B[3] | 0, He = wt & 8191, Ze = wt >>> 13, Ie = B[4] | 0, ue = Ie & 8191, he = Ie >>> 13, Ne = B[5] | 0, Be = Ne & 8191, Oe = Ne >>> 13, it = B[6] | 0, Ve = it & 8191, Ye = it >>> 13, Pt = B[7] | 0, et = Pt & 8191, Q = Pt >>> 13, W = B[8] | 0, V = W & 8191, se = W >>> 13, Ae = B[9] | 0, _e = Ae & 8191, Re = Ae >>> 13, mt = L[0] | 0, We = mt & 8191, ze = mt >>> 13, kt = L[1] | 0, je = kt & 8191, ot = kt >>> 13, Vt = L[2] | 0, ct = Vt & 8191, ut = Vt >>> 13, Zt = L[3] | 0, rt = Zt & 8191, nt = Zt >>> 13, Gt = L[4] | 0, st = Gt & 8191, at = Gt >>> 13, Jt = L[5] | 0, lt = Jt & 8191, tt = Jt >>> 13, Yt = L[6] | 0, le = Yt & 8191, be = Yt >>> 13, Me = L[7] | 0, te = Me & 8191, ve = Me >>> 13, qe = L[8] | 0, Pe = qe & 8191, Le = qe >>> 13, pt = L[9] | 0, Je = pt & 8191, Ge = pt >>> 13;
      S.negative = p.negative ^ x.negative, S.length = 19, R = Math.imul(ee, We), y = Math.imul(ee, ze), y = y + Math.imul(xe, We) | 0, j = Math.imul(xe, ze);
      var $t = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, R = Math.imul(ke, We), y = Math.imul(ke, ze), y = y + Math.imul(Ce, We) | 0, j = Math.imul(Ce, ze), R = R + Math.imul(ee, je) | 0, y = y + Math.imul(ee, ot) | 0, y = y + Math.imul(xe, je) | 0, j = j + Math.imul(xe, ot) | 0;
      var bt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, R = Math.imul(Ue, We), y = Math.imul(Ue, ze), y = y + Math.imul(De, We) | 0, j = Math.imul(De, ze), R = R + Math.imul(ke, je) | 0, y = y + Math.imul(ke, ot) | 0, y = y + Math.imul(Ce, je) | 0, j = j + Math.imul(Ce, ot) | 0, R = R + Math.imul(ee, ct) | 0, y = y + Math.imul(ee, ut) | 0, y = y + Math.imul(xe, ct) | 0, j = j + Math.imul(xe, ut) | 0;
      var Mt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, R = Math.imul(He, We), y = Math.imul(He, ze), y = y + Math.imul(Ze, We) | 0, j = Math.imul(Ze, ze), R = R + Math.imul(Ue, je) | 0, y = y + Math.imul(Ue, ot) | 0, y = y + Math.imul(De, je) | 0, j = j + Math.imul(De, ot) | 0, R = R + Math.imul(ke, ct) | 0, y = y + Math.imul(ke, ut) | 0, y = y + Math.imul(Ce, ct) | 0, j = j + Math.imul(Ce, ut) | 0, R = R + Math.imul(ee, rt) | 0, y = y + Math.imul(ee, nt) | 0, y = y + Math.imul(xe, rt) | 0, j = j + Math.imul(xe, nt) | 0;
      var Rt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, R = Math.imul(ue, We), y = Math.imul(ue, ze), y = y + Math.imul(he, We) | 0, j = Math.imul(he, ze), R = R + Math.imul(He, je) | 0, y = y + Math.imul(He, ot) | 0, y = y + Math.imul(Ze, je) | 0, j = j + Math.imul(Ze, ot) | 0, R = R + Math.imul(Ue, ct) | 0, y = y + Math.imul(Ue, ut) | 0, y = y + Math.imul(De, ct) | 0, j = j + Math.imul(De, ut) | 0, R = R + Math.imul(ke, rt) | 0, y = y + Math.imul(ke, nt) | 0, y = y + Math.imul(Ce, rt) | 0, j = j + Math.imul(Ce, nt) | 0, R = R + Math.imul(ee, st) | 0, y = y + Math.imul(ee, at) | 0, y = y + Math.imul(xe, st) | 0, j = j + Math.imul(xe, at) | 0;
      var Tt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, R = Math.imul(Be, We), y = Math.imul(Be, ze), y = y + Math.imul(Oe, We) | 0, j = Math.imul(Oe, ze), R = R + Math.imul(ue, je) | 0, y = y + Math.imul(ue, ot) | 0, y = y + Math.imul(he, je) | 0, j = j + Math.imul(he, ot) | 0, R = R + Math.imul(He, ct) | 0, y = y + Math.imul(He, ut) | 0, y = y + Math.imul(Ze, ct) | 0, j = j + Math.imul(Ze, ut) | 0, R = R + Math.imul(Ue, rt) | 0, y = y + Math.imul(Ue, nt) | 0, y = y + Math.imul(De, rt) | 0, j = j + Math.imul(De, nt) | 0, R = R + Math.imul(ke, st) | 0, y = y + Math.imul(ke, at) | 0, y = y + Math.imul(Ce, st) | 0, j = j + Math.imul(Ce, at) | 0, R = R + Math.imul(ee, lt) | 0, y = y + Math.imul(ee, tt) | 0, y = y + Math.imul(xe, lt) | 0, j = j + Math.imul(xe, tt) | 0;
      var Nt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, R = Math.imul(Ve, We), y = Math.imul(Ve, ze), y = y + Math.imul(Ye, We) | 0, j = Math.imul(Ye, ze), R = R + Math.imul(Be, je) | 0, y = y + Math.imul(Be, ot) | 0, y = y + Math.imul(Oe, je) | 0, j = j + Math.imul(Oe, ot) | 0, R = R + Math.imul(ue, ct) | 0, y = y + Math.imul(ue, ut) | 0, y = y + Math.imul(he, ct) | 0, j = j + Math.imul(he, ut) | 0, R = R + Math.imul(He, rt) | 0, y = y + Math.imul(He, nt) | 0, y = y + Math.imul(Ze, rt) | 0, j = j + Math.imul(Ze, nt) | 0, R = R + Math.imul(Ue, st) | 0, y = y + Math.imul(Ue, at) | 0, y = y + Math.imul(De, st) | 0, j = j + Math.imul(De, at) | 0, R = R + Math.imul(ke, lt) | 0, y = y + Math.imul(ke, tt) | 0, y = y + Math.imul(Ce, lt) | 0, j = j + Math.imul(Ce, tt) | 0, R = R + Math.imul(ee, le) | 0, y = y + Math.imul(ee, be) | 0, y = y + Math.imul(xe, le) | 0, j = j + Math.imul(xe, be) | 0;
      var It = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, R = Math.imul(et, We), y = Math.imul(et, ze), y = y + Math.imul(Q, We) | 0, j = Math.imul(Q, ze), R = R + Math.imul(Ve, je) | 0, y = y + Math.imul(Ve, ot) | 0, y = y + Math.imul(Ye, je) | 0, j = j + Math.imul(Ye, ot) | 0, R = R + Math.imul(Be, ct) | 0, y = y + Math.imul(Be, ut) | 0, y = y + Math.imul(Oe, ct) | 0, j = j + Math.imul(Oe, ut) | 0, R = R + Math.imul(ue, rt) | 0, y = y + Math.imul(ue, nt) | 0, y = y + Math.imul(he, rt) | 0, j = j + Math.imul(he, nt) | 0, R = R + Math.imul(He, st) | 0, y = y + Math.imul(He, at) | 0, y = y + Math.imul(Ze, st) | 0, j = j + Math.imul(Ze, at) | 0, R = R + Math.imul(Ue, lt) | 0, y = y + Math.imul(Ue, tt) | 0, y = y + Math.imul(De, lt) | 0, j = j + Math.imul(De, tt) | 0, R = R + Math.imul(ke, le) | 0, y = y + Math.imul(ke, be) | 0, y = y + Math.imul(Ce, le) | 0, j = j + Math.imul(Ce, be) | 0, R = R + Math.imul(ee, te) | 0, y = y + Math.imul(ee, ve) | 0, y = y + Math.imul(xe, te) | 0, j = j + Math.imul(xe, ve) | 0;
      var Ct = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, R = Math.imul(V, We), y = Math.imul(V, ze), y = y + Math.imul(se, We) | 0, j = Math.imul(se, ze), R = R + Math.imul(et, je) | 0, y = y + Math.imul(et, ot) | 0, y = y + Math.imul(Q, je) | 0, j = j + Math.imul(Q, ot) | 0, R = R + Math.imul(Ve, ct) | 0, y = y + Math.imul(Ve, ut) | 0, y = y + Math.imul(Ye, ct) | 0, j = j + Math.imul(Ye, ut) | 0, R = R + Math.imul(Be, rt) | 0, y = y + Math.imul(Be, nt) | 0, y = y + Math.imul(Oe, rt) | 0, j = j + Math.imul(Oe, nt) | 0, R = R + Math.imul(ue, st) | 0, y = y + Math.imul(ue, at) | 0, y = y + Math.imul(he, st) | 0, j = j + Math.imul(he, at) | 0, R = R + Math.imul(He, lt) | 0, y = y + Math.imul(He, tt) | 0, y = y + Math.imul(Ze, lt) | 0, j = j + Math.imul(Ze, tt) | 0, R = R + Math.imul(Ue, le) | 0, y = y + Math.imul(Ue, be) | 0, y = y + Math.imul(De, le) | 0, j = j + Math.imul(De, be) | 0, R = R + Math.imul(ke, te) | 0, y = y + Math.imul(ke, ve) | 0, y = y + Math.imul(Ce, te) | 0, j = j + Math.imul(Ce, ve) | 0, R = R + Math.imul(ee, Pe) | 0, y = y + Math.imul(ee, Le) | 0, y = y + Math.imul(xe, Pe) | 0, j = j + Math.imul(xe, Le) | 0;
      var Bt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, R = Math.imul(_e, We), y = Math.imul(_e, ze), y = y + Math.imul(Re, We) | 0, j = Math.imul(Re, ze), R = R + Math.imul(V, je) | 0, y = y + Math.imul(V, ot) | 0, y = y + Math.imul(se, je) | 0, j = j + Math.imul(se, ot) | 0, R = R + Math.imul(et, ct) | 0, y = y + Math.imul(et, ut) | 0, y = y + Math.imul(Q, ct) | 0, j = j + Math.imul(Q, ut) | 0, R = R + Math.imul(Ve, rt) | 0, y = y + Math.imul(Ve, nt) | 0, y = y + Math.imul(Ye, rt) | 0, j = j + Math.imul(Ye, nt) | 0, R = R + Math.imul(Be, st) | 0, y = y + Math.imul(Be, at) | 0, y = y + Math.imul(Oe, st) | 0, j = j + Math.imul(Oe, at) | 0, R = R + Math.imul(ue, lt) | 0, y = y + Math.imul(ue, tt) | 0, y = y + Math.imul(he, lt) | 0, j = j + Math.imul(he, tt) | 0, R = R + Math.imul(He, le) | 0, y = y + Math.imul(He, be) | 0, y = y + Math.imul(Ze, le) | 0, j = j + Math.imul(Ze, be) | 0, R = R + Math.imul(Ue, te) | 0, y = y + Math.imul(Ue, ve) | 0, y = y + Math.imul(De, te) | 0, j = j + Math.imul(De, ve) | 0, R = R + Math.imul(ke, Pe) | 0, y = y + Math.imul(ke, Le) | 0, y = y + Math.imul(Ce, Pe) | 0, j = j + Math.imul(Ce, Le) | 0, R = R + Math.imul(ee, Je) | 0, y = y + Math.imul(ee, Ge) | 0, y = y + Math.imul(xe, Je) | 0, j = j + Math.imul(xe, Ge) | 0;
      var _t = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, R = Math.imul(_e, je), y = Math.imul(_e, ot), y = y + Math.imul(Re, je) | 0, j = Math.imul(Re, ot), R = R + Math.imul(V, ct) | 0, y = y + Math.imul(V, ut) | 0, y = y + Math.imul(se, ct) | 0, j = j + Math.imul(se, ut) | 0, R = R + Math.imul(et, rt) | 0, y = y + Math.imul(et, nt) | 0, y = y + Math.imul(Q, rt) | 0, j = j + Math.imul(Q, nt) | 0, R = R + Math.imul(Ve, st) | 0, y = y + Math.imul(Ve, at) | 0, y = y + Math.imul(Ye, st) | 0, j = j + Math.imul(Ye, at) | 0, R = R + Math.imul(Be, lt) | 0, y = y + Math.imul(Be, tt) | 0, y = y + Math.imul(Oe, lt) | 0, j = j + Math.imul(Oe, tt) | 0, R = R + Math.imul(ue, le) | 0, y = y + Math.imul(ue, be) | 0, y = y + Math.imul(he, le) | 0, j = j + Math.imul(he, be) | 0, R = R + Math.imul(He, te) | 0, y = y + Math.imul(He, ve) | 0, y = y + Math.imul(Ze, te) | 0, j = j + Math.imul(Ze, ve) | 0, R = R + Math.imul(Ue, Pe) | 0, y = y + Math.imul(Ue, Le) | 0, y = y + Math.imul(De, Pe) | 0, j = j + Math.imul(De, Le) | 0, R = R + Math.imul(ke, Je) | 0, y = y + Math.imul(ke, Ge) | 0, y = y + Math.imul(Ce, Je) | 0, j = j + Math.imul(Ce, Ge) | 0;
      var St = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, R = Math.imul(_e, ct), y = Math.imul(_e, ut), y = y + Math.imul(Re, ct) | 0, j = Math.imul(Re, ut), R = R + Math.imul(V, rt) | 0, y = y + Math.imul(V, nt) | 0, y = y + Math.imul(se, rt) | 0, j = j + Math.imul(se, nt) | 0, R = R + Math.imul(et, st) | 0, y = y + Math.imul(et, at) | 0, y = y + Math.imul(Q, st) | 0, j = j + Math.imul(Q, at) | 0, R = R + Math.imul(Ve, lt) | 0, y = y + Math.imul(Ve, tt) | 0, y = y + Math.imul(Ye, lt) | 0, j = j + Math.imul(Ye, tt) | 0, R = R + Math.imul(Be, le) | 0, y = y + Math.imul(Be, be) | 0, y = y + Math.imul(Oe, le) | 0, j = j + Math.imul(Oe, be) | 0, R = R + Math.imul(ue, te) | 0, y = y + Math.imul(ue, ve) | 0, y = y + Math.imul(he, te) | 0, j = j + Math.imul(he, ve) | 0, R = R + Math.imul(He, Pe) | 0, y = y + Math.imul(He, Le) | 0, y = y + Math.imul(Ze, Pe) | 0, j = j + Math.imul(Ze, Le) | 0, R = R + Math.imul(Ue, Je) | 0, y = y + Math.imul(Ue, Ge) | 0, y = y + Math.imul(De, Je) | 0, j = j + Math.imul(De, Ge) | 0;
      var vt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, R = Math.imul(_e, rt), y = Math.imul(_e, nt), y = y + Math.imul(Re, rt) | 0, j = Math.imul(Re, nt), R = R + Math.imul(V, st) | 0, y = y + Math.imul(V, at) | 0, y = y + Math.imul(se, st) | 0, j = j + Math.imul(se, at) | 0, R = R + Math.imul(et, lt) | 0, y = y + Math.imul(et, tt) | 0, y = y + Math.imul(Q, lt) | 0, j = j + Math.imul(Q, tt) | 0, R = R + Math.imul(Ve, le) | 0, y = y + Math.imul(Ve, be) | 0, y = y + Math.imul(Ye, le) | 0, j = j + Math.imul(Ye, be) | 0, R = R + Math.imul(Be, te) | 0, y = y + Math.imul(Be, ve) | 0, y = y + Math.imul(Oe, te) | 0, j = j + Math.imul(Oe, ve) | 0, R = R + Math.imul(ue, Pe) | 0, y = y + Math.imul(ue, Le) | 0, y = y + Math.imul(he, Pe) | 0, j = j + Math.imul(he, Le) | 0, R = R + Math.imul(He, Je) | 0, y = y + Math.imul(He, Ge) | 0, y = y + Math.imul(Ze, Je) | 0, j = j + Math.imul(Ze, Ge) | 0;
      var At = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, R = Math.imul(_e, st), y = Math.imul(_e, at), y = y + Math.imul(Re, st) | 0, j = Math.imul(Re, at), R = R + Math.imul(V, lt) | 0, y = y + Math.imul(V, tt) | 0, y = y + Math.imul(se, lt) | 0, j = j + Math.imul(se, tt) | 0, R = R + Math.imul(et, le) | 0, y = y + Math.imul(et, be) | 0, y = y + Math.imul(Q, le) | 0, j = j + Math.imul(Q, be) | 0, R = R + Math.imul(Ve, te) | 0, y = y + Math.imul(Ve, ve) | 0, y = y + Math.imul(Ye, te) | 0, j = j + Math.imul(Ye, ve) | 0, R = R + Math.imul(Be, Pe) | 0, y = y + Math.imul(Be, Le) | 0, y = y + Math.imul(Oe, Pe) | 0, j = j + Math.imul(Oe, Le) | 0, R = R + Math.imul(ue, Je) | 0, y = y + Math.imul(ue, Ge) | 0, y = y + Math.imul(he, Je) | 0, j = j + Math.imul(he, Ge) | 0;
      var Et = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, R = Math.imul(_e, lt), y = Math.imul(_e, tt), y = y + Math.imul(Re, lt) | 0, j = Math.imul(Re, tt), R = R + Math.imul(V, le) | 0, y = y + Math.imul(V, be) | 0, y = y + Math.imul(se, le) | 0, j = j + Math.imul(se, be) | 0, R = R + Math.imul(et, te) | 0, y = y + Math.imul(et, ve) | 0, y = y + Math.imul(Q, te) | 0, j = j + Math.imul(Q, ve) | 0, R = R + Math.imul(Ve, Pe) | 0, y = y + Math.imul(Ve, Le) | 0, y = y + Math.imul(Ye, Pe) | 0, j = j + Math.imul(Ye, Le) | 0, R = R + Math.imul(Be, Je) | 0, y = y + Math.imul(Be, Ge) | 0, y = y + Math.imul(Oe, Je) | 0, j = j + Math.imul(Oe, Ge) | 0;
      var yt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, R = Math.imul(_e, le), y = Math.imul(_e, be), y = y + Math.imul(Re, le) | 0, j = Math.imul(Re, be), R = R + Math.imul(V, te) | 0, y = y + Math.imul(V, ve) | 0, y = y + Math.imul(se, te) | 0, j = j + Math.imul(se, ve) | 0, R = R + Math.imul(et, Pe) | 0, y = y + Math.imul(et, Le) | 0, y = y + Math.imul(Q, Pe) | 0, j = j + Math.imul(Q, Le) | 0, R = R + Math.imul(Ve, Je) | 0, y = y + Math.imul(Ve, Ge) | 0, y = y + Math.imul(Ye, Je) | 0, j = j + Math.imul(Ye, Ge) | 0;
      var Xe = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, R = Math.imul(_e, te), y = Math.imul(_e, ve), y = y + Math.imul(Re, te) | 0, j = Math.imul(Re, ve), R = R + Math.imul(V, Pe) | 0, y = y + Math.imul(V, Le) | 0, y = y + Math.imul(se, Pe) | 0, j = j + Math.imul(se, Le) | 0, R = R + Math.imul(et, Je) | 0, y = y + Math.imul(et, Ge) | 0, y = y + Math.imul(Q, Je) | 0, j = j + Math.imul(Q, Ge) | 0;
      var Qe = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, R = Math.imul(_e, Pe), y = Math.imul(_e, Le), y = y + Math.imul(Re, Pe) | 0, j = Math.imul(Re, Le), R = R + Math.imul(V, Je) | 0, y = y + Math.imul(V, Ge) | 0, y = y + Math.imul(se, Je) | 0, j = j + Math.imul(se, Ge) | 0;
      var dt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, R = Math.imul(_e, Je), y = Math.imul(_e, Ge), y = y + Math.imul(Re, Je) | 0, j = Math.imul(Re, Ge);
      var ft = (G + R | 0) + ((y & 8191) << 13) | 0;
      return G = (j + (y >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, C[0] = $t, C[1] = bt, C[2] = Mt, C[3] = Rt, C[4] = Tt, C[5] = Nt, C[6] = It, C[7] = Ct, C[8] = Bt, C[9] = _t, C[10] = St, C[11] = vt, C[12] = At, C[13] = Et, C[14] = yt, C[15] = Xe, C[16] = Qe, C[17] = dt, C[18] = ft, G !== 0 && (C[19] = G, S.length++), S;
    };
    Math.imul || (pe = oe);
    function ae(k, p, x) {
      x.negative = p.negative ^ k.negative, x.length = k.length + p.length;
      for (var S = 0, B = 0, L = 0; L < x.length - 1; L++) {
        var C = B;
        B = 0;
        for (var G = S & 67108863, R = Math.min(L, p.length - 1), y = Math.max(0, L - k.length + 1); y <= R; y++) {
          var j = L - y, ye = k.words[j] | 0, ee = p.words[y] | 0, xe = ye * ee, $e = xe & 67108863;
          C = C + (xe / 67108864 | 0) | 0, $e = $e + G | 0, G = $e & 67108863, C = C + ($e >>> 26) | 0, B += C >>> 26, C &= 67108863;
        }
        x.words[L] = G, S = C, C = B;
      }
      return S !== 0 ? x.words[L] = S : x.length--, x._strip();
    }
    function me(k, p, x) {
      return ae(k, p, x);
    }
    d.prototype.mulTo = function(p, x) {
      var S, B = this.length + p.length;
      return this.length === 10 && p.length === 10 ? S = pe(this, p, x) : B < 63 ? S = oe(this, p, x) : B < 1024 ? S = ae(this, p, x) : S = me(this, p, x), S;
    }, d.prototype.mul = function(p) {
      var x = new d(null);
      return x.words = new Array(this.length + p.length), this.mulTo(p, x);
    }, d.prototype.mulf = function(p) {
      var x = new d(null);
      return x.words = new Array(this.length + p.length), me(this, p, x);
    }, d.prototype.imul = function(p) {
      return this.clone().mulTo(p, this);
    }, d.prototype.imuln = function(p) {
      var x = p < 0;
      x && (p = -p), h(typeof p == "number"), h(p < 67108864);
      for (var S = 0, B = 0; B < this.length; B++) {
        var L = (this.words[B] | 0) * p, C = (L & 67108863) + (S & 67108863);
        S >>= 26, S += L / 67108864 | 0, S += C >>> 26, this.words[B] = C & 67108863;
      }
      return S !== 0 && (this.words[B] = S, this.length++), x ? this.ineg() : this;
    }, d.prototype.muln = function(p) {
      return this.clone().imuln(p);
    }, d.prototype.sqr = function() {
      return this.mul(this);
    }, d.prototype.isqr = function() {
      return this.imul(this.clone());
    }, d.prototype.pow = function(p) {
      var x = re(p);
      if (x.length === 0)
        return new d(1);
      for (var S = this, B = 0; B < x.length && x[B] === 0; B++, S = S.sqr())
        ;
      if (++B < x.length)
        for (var L = S.sqr(); B < x.length; B++, L = L.sqr())
          x[B] !== 0 && (S = S.mul(L));
      return S;
    }, d.prototype.iushln = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26, B = 67108863 >>> 26 - x << 26 - x, L;
      if (x !== 0) {
        var C = 0;
        for (L = 0; L < this.length; L++) {
          var G = this.words[L] & B, R = (this.words[L] | 0) - G << x;
          this.words[L] = R | C, C = G >>> 26 - x;
        }
        C && (this.words[L] = C, this.length++);
      }
      if (S !== 0) {
        for (L = this.length - 1; L >= 0; L--)
          this.words[L + S] = this.words[L];
        for (L = 0; L < S; L++)
          this.words[L] = 0;
        this.length += S;
      }
      return this._strip();
    }, d.prototype.ishln = function(p) {
      return h(this.negative === 0), this.iushln(p);
    }, d.prototype.iushrn = function(p, x, S) {
      h(typeof p == "number" && p >= 0);
      var B;
      x ? B = (x - x % 26) / 26 : B = 0;
      var L = p % 26, C = Math.min((p - L) / 26, this.length), G = 67108863 ^ 67108863 >>> L << L, R = S;
      if (B -= C, B = Math.max(0, B), R) {
        for (var y = 0; y < C; y++)
          R.words[y] = this.words[y];
        R.length = C;
      }
      if (C !== 0)
        if (this.length > C)
          for (this.length -= C, y = 0; y < this.length; y++)
            this.words[y] = this.words[y + C];
        else
          this.words[0] = 0, this.length = 1;
      var j = 0;
      for (y = this.length - 1; y >= 0 && (j !== 0 || y >= B); y--) {
        var ye = this.words[y] | 0;
        this.words[y] = j << 26 - L | ye >>> L, j = ye & G;
      }
      return R && j !== 0 && (R.words[R.length++] = j), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, d.prototype.ishrn = function(p, x, S) {
      return h(this.negative === 0), this.iushrn(p, x, S);
    }, d.prototype.shln = function(p) {
      return this.clone().ishln(p);
    }, d.prototype.ushln = function(p) {
      return this.clone().iushln(p);
    }, d.prototype.shrn = function(p) {
      return this.clone().ishrn(p);
    }, d.prototype.ushrn = function(p) {
      return this.clone().iushrn(p);
    }, d.prototype.testn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26, B = 1 << x;
      if (this.length <= S)
        return !1;
      var L = this.words[S];
      return !!(L & B);
    }, d.prototype.imaskn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26;
      if (h(this.negative === 0, "imaskn works only with positive numbers"), this.length <= S)
        return this;
      if (x !== 0 && S++, this.length = Math.min(S, this.length), x !== 0) {
        var B = 67108863 ^ 67108863 >>> x << x;
        this.words[this.length - 1] &= B;
      }
      return this._strip();
    }, d.prototype.maskn = function(p) {
      return this.clone().imaskn(p);
    }, d.prototype.iaddn = function(p) {
      return h(typeof p == "number"), h(p < 67108864), p < 0 ? this.isubn(-p) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= p ? (this.words[0] = p - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(p), this.negative = 1, this) : this._iaddn(p);
    }, d.prototype._iaddn = function(p) {
      this.words[0] += p;
      for (var x = 0; x < this.length && this.words[x] >= 67108864; x++)
        this.words[x] -= 67108864, x === this.length - 1 ? this.words[x + 1] = 1 : this.words[x + 1]++;
      return this.length = Math.max(this.length, x + 1), this;
    }, d.prototype.isubn = function(p) {
      if (h(typeof p == "number"), h(p < 67108864), p < 0)
        return this.iaddn(-p);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(p), this.negative = 1, this;
      if (this.words[0] -= p, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var x = 0; x < this.length && this.words[x] < 0; x++)
          this.words[x] += 67108864, this.words[x + 1] -= 1;
      return this._strip();
    }, d.prototype.addn = function(p) {
      return this.clone().iaddn(p);
    }, d.prototype.subn = function(p) {
      return this.clone().isubn(p);
    }, d.prototype.iabs = function() {
      return this.negative = 0, this;
    }, d.prototype.abs = function() {
      return this.clone().iabs();
    }, d.prototype._ishlnsubmul = function(p, x, S) {
      var B = p.length + S, L;
      this._expand(B);
      var C, G = 0;
      for (L = 0; L < p.length; L++) {
        C = (this.words[L + S] | 0) + G;
        var R = (p.words[L] | 0) * x;
        C -= R & 67108863, G = (C >> 26) - (R / 67108864 | 0), this.words[L + S] = C & 67108863;
      }
      for (; L < this.length - S; L++)
        C = (this.words[L + S] | 0) + G, G = C >> 26, this.words[L + S] = C & 67108863;
      if (G === 0)
        return this._strip();
      for (h(G === -1), G = 0, L = 0; L < this.length; L++)
        C = -(this.words[L] | 0) + G, G = C >> 26, this.words[L] = C & 67108863;
      return this.negative = 1, this._strip();
    }, d.prototype._wordDiv = function(p, x) {
      var S = this.length - p.length, B = this.clone(), L = p, C = L.words[L.length - 1] | 0, G = this._countBits(C);
      S = 26 - G, S !== 0 && (L = L.ushln(S), B.iushln(S), C = L.words[L.length - 1] | 0);
      var R = B.length - L.length, y;
      if (x !== "mod") {
        y = new d(null), y.length = R + 1, y.words = new Array(y.length);
        for (var j = 0; j < y.length; j++)
          y.words[j] = 0;
      }
      var ye = B.clone()._ishlnsubmul(L, 1, R);
      ye.negative === 0 && (B = ye, y && (y.words[R] = 1));
      for (var ee = R - 1; ee >= 0; ee--) {
        var xe = (B.words[L.length + ee] | 0) * 67108864 + (B.words[L.length + ee - 1] | 0);
        for (xe = Math.min(xe / C | 0, 67108863), B._ishlnsubmul(L, xe, ee); B.negative !== 0; )
          xe--, B.negative = 0, B._ishlnsubmul(L, 1, ee), B.isZero() || (B.negative ^= 1);
        y && (y.words[ee] = xe);
      }
      return y && y._strip(), B._strip(), x !== "div" && S !== 0 && B.iushrn(S), {
        div: y || null,
        mod: B
      };
    }, d.prototype.divmod = function(p, x, S) {
      if (h(!p.isZero()), this.isZero())
        return {
          div: new d(0),
          mod: new d(0)
        };
      var B, L, C;
      return this.negative !== 0 && p.negative === 0 ? (C = this.neg().divmod(p, x), x !== "mod" && (B = C.div.neg()), x !== "div" && (L = C.mod.neg(), S && L.negative !== 0 && L.iadd(p)), {
        div: B,
        mod: L
      }) : this.negative === 0 && p.negative !== 0 ? (C = this.divmod(p.neg(), x), x !== "mod" && (B = C.div.neg()), {
        div: B,
        mod: C.mod
      }) : (this.negative & p.negative) !== 0 ? (C = this.neg().divmod(p.neg(), x), x !== "div" && (L = C.mod.neg(), S && L.negative !== 0 && L.isub(p)), {
        div: C.div,
        mod: L
      }) : p.length > this.length || this.cmp(p) < 0 ? {
        div: new d(0),
        mod: this
      } : p.length === 1 ? x === "div" ? {
        div: this.divn(p.words[0]),
        mod: null
      } : x === "mod" ? {
        div: null,
        mod: new d(this.modrn(p.words[0]))
      } : {
        div: this.divn(p.words[0]),
        mod: new d(this.modrn(p.words[0]))
      } : this._wordDiv(p, x);
    }, d.prototype.div = function(p) {
      return this.divmod(p, "div", !1).div;
    }, d.prototype.mod = function(p) {
      return this.divmod(p, "mod", !1).mod;
    }, d.prototype.umod = function(p) {
      return this.divmod(p, "mod", !0).mod;
    }, d.prototype.divRound = function(p) {
      var x = this.divmod(p);
      if (x.mod.isZero())
        return x.div;
      var S = x.div.negative !== 0 ? x.mod.isub(p) : x.mod, B = p.ushrn(1), L = p.andln(1), C = S.cmp(B);
      return C < 0 || L === 1 && C === 0 ? x.div : x.div.negative !== 0 ? x.div.isubn(1) : x.div.iaddn(1);
    }, d.prototype.modrn = function(p) {
      var x = p < 0;
      x && (p = -p), h(p <= 67108863);
      for (var S = (1 << 26) % p, B = 0, L = this.length - 1; L >= 0; L--)
        B = (S * B + (this.words[L] | 0)) % p;
      return x ? -B : B;
    }, d.prototype.modn = function(p) {
      return this.modrn(p);
    }, d.prototype.idivn = function(p) {
      var x = p < 0;
      x && (p = -p), h(p <= 67108863);
      for (var S = 0, B = this.length - 1; B >= 0; B--) {
        var L = (this.words[B] | 0) + S * 67108864;
        this.words[B] = L / p | 0, S = L % p;
      }
      return this._strip(), x ? this.ineg() : this;
    }, d.prototype.divn = function(p) {
      return this.clone().idivn(p);
    }, d.prototype.egcd = function(p) {
      h(p.negative === 0), h(!p.isZero());
      var x = this, S = p.clone();
      x.negative !== 0 ? x = x.umod(p) : x = x.clone();
      for (var B = new d(1), L = new d(0), C = new d(0), G = new d(1), R = 0; x.isEven() && S.isEven(); )
        x.iushrn(1), S.iushrn(1), ++R;
      for (var y = S.clone(), j = x.clone(); !x.isZero(); ) {
        for (var ye = 0, ee = 1; (x.words[0] & ee) === 0 && ye < 26; ++ye, ee <<= 1)
          ;
        if (ye > 0)
          for (x.iushrn(ye); ye-- > 0; )
            (B.isOdd() || L.isOdd()) && (B.iadd(y), L.isub(j)), B.iushrn(1), L.iushrn(1);
        for (var xe = 0, $e = 1; (S.words[0] & $e) === 0 && xe < 26; ++xe, $e <<= 1)
          ;
        if (xe > 0)
          for (S.iushrn(xe); xe-- > 0; )
            (C.isOdd() || G.isOdd()) && (C.iadd(y), G.isub(j)), C.iushrn(1), G.iushrn(1);
        x.cmp(S) >= 0 ? (x.isub(S), B.isub(C), L.isub(G)) : (S.isub(x), C.isub(B), G.isub(L));
      }
      return {
        a: C,
        b: G,
        gcd: S.iushln(R)
      };
    }, d.prototype._invmp = function(p) {
      h(p.negative === 0), h(!p.isZero());
      var x = this, S = p.clone();
      x.negative !== 0 ? x = x.umod(p) : x = x.clone();
      for (var B = new d(1), L = new d(0), C = S.clone(); x.cmpn(1) > 0 && S.cmpn(1) > 0; ) {
        for (var G = 0, R = 1; (x.words[0] & R) === 0 && G < 26; ++G, R <<= 1)
          ;
        if (G > 0)
          for (x.iushrn(G); G-- > 0; )
            B.isOdd() && B.iadd(C), B.iushrn(1);
        for (var y = 0, j = 1; (S.words[0] & j) === 0 && y < 26; ++y, j <<= 1)
          ;
        if (y > 0)
          for (S.iushrn(y); y-- > 0; )
            L.isOdd() && L.iadd(C), L.iushrn(1);
        x.cmp(S) >= 0 ? (x.isub(S), B.isub(L)) : (S.isub(x), L.isub(B));
      }
      var ye;
      return x.cmpn(1) === 0 ? ye = B : ye = L, ye.cmpn(0) < 0 && ye.iadd(p), ye;
    }, d.prototype.gcd = function(p) {
      if (this.isZero())
        return p.abs();
      if (p.isZero())
        return this.abs();
      var x = this.clone(), S = p.clone();
      x.negative = 0, S.negative = 0;
      for (var B = 0; x.isEven() && S.isEven(); B++)
        x.iushrn(1), S.iushrn(1);
      do {
        for (; x.isEven(); )
          x.iushrn(1);
        for (; S.isEven(); )
          S.iushrn(1);
        var L = x.cmp(S);
        if (L < 0) {
          var C = x;
          x = S, S = C;
        } else if (L === 0 || S.cmpn(1) === 0)
          break;
        x.isub(S);
      } while (!0);
      return S.iushln(B);
    }, d.prototype.invm = function(p) {
      return this.egcd(p).a.umod(p);
    }, d.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, d.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, d.prototype.andln = function(p) {
      return this.words[0] & p;
    }, d.prototype.bincn = function(p) {
      h(typeof p == "number");
      var x = p % 26, S = (p - x) / 26, B = 1 << x;
      if (this.length <= S)
        return this._expand(S + 1), this.words[S] |= B, this;
      for (var L = B, C = S; L !== 0 && C < this.length; C++) {
        var G = this.words[C] | 0;
        G += L, L = G >>> 26, G &= 67108863, this.words[C] = G;
      }
      return L !== 0 && (this.words[C] = L, this.length++), this;
    }, d.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, d.prototype.cmpn = function(p) {
      var x = p < 0;
      if (this.negative !== 0 && !x)
        return -1;
      if (this.negative === 0 && x)
        return 1;
      this._strip();
      var S;
      if (this.length > 1)
        S = 1;
      else {
        x && (p = -p), h(p <= 67108863, "Number is too big");
        var B = this.words[0] | 0;
        S = B === p ? 0 : B < p ? -1 : 1;
      }
      return this.negative !== 0 ? -S | 0 : S;
    }, d.prototype.cmp = function(p) {
      if (this.negative !== 0 && p.negative === 0)
        return -1;
      if (this.negative === 0 && p.negative !== 0)
        return 1;
      var x = this.ucmp(p);
      return this.negative !== 0 ? -x | 0 : x;
    }, d.prototype.ucmp = function(p) {
      if (this.length > p.length)
        return 1;
      if (this.length < p.length)
        return -1;
      for (var x = 0, S = this.length - 1; S >= 0; S--) {
        var B = this.words[S] | 0, L = p.words[S] | 0;
        if (B !== L) {
          B < L ? x = -1 : B > L && (x = 1);
          break;
        }
      }
      return x;
    }, d.prototype.gtn = function(p) {
      return this.cmpn(p) === 1;
    }, d.prototype.gt = function(p) {
      return this.cmp(p) === 1;
    }, d.prototype.gten = function(p) {
      return this.cmpn(p) >= 0;
    }, d.prototype.gte = function(p) {
      return this.cmp(p) >= 0;
    }, d.prototype.ltn = function(p) {
      return this.cmpn(p) === -1;
    }, d.prototype.lt = function(p) {
      return this.cmp(p) === -1;
    }, d.prototype.lten = function(p) {
      return this.cmpn(p) <= 0;
    }, d.prototype.lte = function(p) {
      return this.cmp(p) <= 0;
    }, d.prototype.eqn = function(p) {
      return this.cmpn(p) === 0;
    }, d.prototype.eq = function(p) {
      return this.cmp(p) === 0;
    }, d.red = function(p) {
      return new X(p);
    }, d.prototype.toRed = function(p) {
      return h(!this.red, "Already a number in reduction context"), h(this.negative === 0, "red works only with positives"), p.convertTo(this)._forceRed(p);
    }, d.prototype.fromRed = function() {
      return h(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, d.prototype._forceRed = function(p) {
      return this.red = p, this;
    }, d.prototype.forceRed = function(p) {
      return h(!this.red, "Already a number in reduction context"), this._forceRed(p);
    }, d.prototype.redAdd = function(p) {
      return h(this.red, "redAdd works only with red numbers"), this.red.add(this, p);
    }, d.prototype.redIAdd = function(p) {
      return h(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, p);
    }, d.prototype.redSub = function(p) {
      return h(this.red, "redSub works only with red numbers"), this.red.sub(this, p);
    }, d.prototype.redISub = function(p) {
      return h(this.red, "redISub works only with red numbers"), this.red.isub(this, p);
    }, d.prototype.redShl = function(p) {
      return h(this.red, "redShl works only with red numbers"), this.red.shl(this, p);
    }, d.prototype.redMul = function(p) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.mul(this, p);
    }, d.prototype.redIMul = function(p) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.imul(this, p);
    }, d.prototype.redSqr = function() {
      return h(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, d.prototype.redISqr = function() {
      return h(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, d.prototype.redSqrt = function() {
      return h(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, d.prototype.redInvm = function() {
      return h(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, d.prototype.redNeg = function() {
      return h(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, d.prototype.redPow = function(p) {
      return h(this.red && !p.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, p);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function we(k, p) {
      this.name = k, this.p = new d(p, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    we.prototype._tmp = function() {
      var p = new d(null);
      return p.words = new Array(Math.ceil(this.n / 13)), p;
    }, we.prototype.ireduce = function(p) {
      var x = p, S;
      do
        this.split(x, this.tmp), x = this.imulK(x), x = x.iadd(this.tmp), S = x.bitLength();
      while (S > this.n);
      var B = S < this.n ? -1 : x.ucmp(this.p);
      return B === 0 ? (x.words[0] = 0, x.length = 1) : B > 0 ? x.isub(this.p) : x.strip !== void 0 ? x.strip() : x._strip(), x;
    }, we.prototype.split = function(p, x) {
      p.iushrn(this.n, 0, x);
    }, we.prototype.imulK = function(p) {
      return p.imul(this.k);
    };
    function Ee() {
      we.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    m(Ee, we), Ee.prototype.split = function(p, x) {
      for (var S = 4194303, B = Math.min(p.length, 9), L = 0; L < B; L++)
        x.words[L] = p.words[L];
      if (x.length = B, p.length <= 9) {
        p.words[0] = 0, p.length = 1;
        return;
      }
      var C = p.words[9];
      for (x.words[x.length++] = C & S, L = 10; L < p.length; L++) {
        var G = p.words[L] | 0;
        p.words[L - 10] = (G & S) << 4 | C >>> 22, C = G;
      }
      C >>>= 22, p.words[L - 10] = C, C === 0 && p.length > 10 ? p.length -= 10 : p.length -= 9;
    }, Ee.prototype.imulK = function(p) {
      p.words[p.length] = 0, p.words[p.length + 1] = 0, p.length += 2;
      for (var x = 0, S = 0; S < p.length; S++) {
        var B = p.words[S] | 0;
        x += B * 977, p.words[S] = x & 67108863, x = B * 64 + (x / 67108864 | 0);
      }
      return p.words[p.length - 1] === 0 && (p.length--, p.words[p.length - 1] === 0 && p.length--), p;
    };
    function Te() {
      we.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    m(Te, we);
    function Ke() {
      we.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    m(Ke, we);
    function Se() {
      we.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    m(Se, we), Se.prototype.imulK = function(p) {
      for (var x = 0, S = 0; S < p.length; S++) {
        var B = (p.words[S] | 0) * 19 + x, L = B & 67108863;
        B >>>= 26, p.words[S] = L, x = B;
      }
      return x !== 0 && (p.words[p.length++] = x), p;
    }, d._prime = function(p) {
      if (ge[p])
        return ge[p];
      var x;
      if (p === "k256")
        x = new Ee();
      else if (p === "p224")
        x = new Te();
      else if (p === "p192")
        x = new Ke();
      else if (p === "p25519")
        x = new Se();
      else
        throw new Error("Unknown prime " + p);
      return ge[p] = x, x;
    };
    function X(k) {
      if (typeof k == "string") {
        var p = d._prime(k);
        this.m = p.p, this.prime = p;
      } else
        h(k.gtn(1), "modulus must be greater than 1"), this.m = k, this.prime = null;
    }
    X.prototype._verify1 = function(p) {
      h(p.negative === 0, "red works only with positives"), h(p.red, "red works only with red numbers");
    }, X.prototype._verify2 = function(p, x) {
      h((p.negative | x.negative) === 0, "red works only with positives"), h(
        p.red && p.red === x.red,
        "red works only with red numbers"
      );
    }, X.prototype.imod = function(p) {
      return this.prime ? this.prime.ireduce(p)._forceRed(this) : (J(p, p.umod(this.m)._forceRed(this)), p);
    }, X.prototype.neg = function(p) {
      return p.isZero() ? p.clone() : this.m.sub(p)._forceRed(this);
    }, X.prototype.add = function(p, x) {
      this._verify2(p, x);
      var S = p.add(x);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S._forceRed(this);
    }, X.prototype.iadd = function(p, x) {
      this._verify2(p, x);
      var S = p.iadd(x);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S;
    }, X.prototype.sub = function(p, x) {
      this._verify2(p, x);
      var S = p.sub(x);
      return S.cmpn(0) < 0 && S.iadd(this.m), S._forceRed(this);
    }, X.prototype.isub = function(p, x) {
      this._verify2(p, x);
      var S = p.isub(x);
      return S.cmpn(0) < 0 && S.iadd(this.m), S;
    }, X.prototype.shl = function(p, x) {
      return this._verify1(p), this.imod(p.ushln(x));
    }, X.prototype.imul = function(p, x) {
      return this._verify2(p, x), this.imod(p.imul(x));
    }, X.prototype.mul = function(p, x) {
      return this._verify2(p, x), this.imod(p.mul(x));
    }, X.prototype.isqr = function(p) {
      return this.imul(p, p.clone());
    }, X.prototype.sqr = function(p) {
      return this.mul(p, p);
    }, X.prototype.sqrt = function(p) {
      if (p.isZero())
        return p.clone();
      var x = this.m.andln(3);
      if (h(x % 2 === 1), x === 3) {
        var S = this.m.add(new d(1)).iushrn(2);
        return this.pow(p, S);
      }
      for (var B = this.m.subn(1), L = 0; !B.isZero() && B.andln(1) === 0; )
        L++, B.iushrn(1);
      h(!B.isZero());
      var C = new d(1).toRed(this), G = C.redNeg(), R = this.m.subn(1).iushrn(1), y = this.m.bitLength();
      for (y = new d(2 * y * y).toRed(this); this.pow(y, R).cmp(G) !== 0; )
        y.redIAdd(G);
      for (var j = this.pow(y, B), ye = this.pow(p, B.addn(1).iushrn(1)), ee = this.pow(p, B), xe = L; ee.cmp(C) !== 0; ) {
        for (var $e = ee, ke = 0; $e.cmp(C) !== 0; ke++)
          $e = $e.redSqr();
        h(ke < xe);
        var Ce = this.pow(j, new d(1).iushln(xe - ke - 1));
        ye = ye.redMul(Ce), j = Ce.redSqr(), ee = ee.redMul(j), xe = ke;
      }
      return ye;
    }, X.prototype.invm = function(p) {
      var x = p._invmp(this.m);
      return x.negative !== 0 ? (x.negative = 0, this.imod(x).redNeg()) : this.imod(x);
    }, X.prototype.pow = function(p, x) {
      if (x.isZero())
        return new d(1).toRed(this);
      if (x.cmpn(1) === 0)
        return p.clone();
      var S = 4, B = new Array(1 << S);
      B[0] = new d(1).toRed(this), B[1] = p;
      for (var L = 2; L < B.length; L++)
        B[L] = this.mul(B[L - 1], p);
      var C = B[0], G = 0, R = 0, y = x.bitLength() % 26;
      for (y === 0 && (y = 26), L = x.length - 1; L >= 0; L--) {
        for (var j = x.words[L], ye = y - 1; ye >= 0; ye--) {
          var ee = j >> ye & 1;
          if (C !== B[0] && (C = this.sqr(C)), ee === 0 && G === 0) {
            R = 0;
            continue;
          }
          G <<= 1, G |= ee, R++, !(R !== S && (L !== 0 || ye !== 0)) && (C = this.mul(C, B[G]), R = 0, G = 0);
        }
        y = 26;
      }
      return C;
    }, X.prototype.convertTo = function(p) {
      var x = p.umod(this.m);
      return x === p ? x.clone() : x;
    }, X.prototype.convertFrom = function(p) {
      var x = p.clone();
      return x.red = null, x;
    }, d.mont = function(p) {
      return new fe(p);
    };
    function fe(k) {
      X.call(this, k), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    m(fe, X), fe.prototype.convertTo = function(p) {
      return this.imod(p.ushln(this.shift));
    }, fe.prototype.convertFrom = function(p) {
      var x = this.imod(p.mul(this.rinv));
      return x.red = null, x;
    }, fe.prototype.imul = function(p, x) {
      if (p.isZero() || x.isZero())
        return p.words[0] = 0, p.length = 1, p;
      var S = p.imul(x), B = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = S.isub(B).iushrn(this.shift), C = L;
      return L.cmp(this.m) >= 0 ? C = L.isub(this.m) : L.cmpn(0) < 0 && (C = L.iadd(this.m)), C._forceRed(this);
    }, fe.prototype.mul = function(p, x) {
      if (p.isZero() || x.isZero())
        return new d(0)._forceRed(this);
      var S = p.mul(x), B = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = S.isub(B).iushrn(this.shift), C = L;
      return L.cmp(this.m) >= 0 ? C = L.isub(this.m) : L.cmpn(0) < 0 && (C = L.iadd(this.m)), C._forceRed(this);
    }, fe.prototype.invm = function(p) {
      var x = this.imod(p._invmp(this.m).mul(this.r2));
      return x._forceRed(this);
    };
  })(l, commonjsGlobal);
})(bn$1);
(function(l) {
  var t = commonjsGlobal && commonjsGlobal.__importDefault || function(Y) {
    return Y && Y.__esModule ? Y : { default: Y };
  };
  Object.defineProperty(l, "__esModule", { value: !0 }), l.parseNearAmount = l.formatNearAmount = l.NEAR_NOMINATION = l.NEAR_NOMINATION_EXP = void 0;
  const s = t(bn$1.exports);
  l.NEAR_NOMINATION_EXP = 24, l.NEAR_NOMINATION = new s.default("10", 10).pow(new s.default(l.NEAR_NOMINATION_EXP, 10));
  const h = [], m = new s.default(10);
  for (let Y = 0, ie = new s.default(5); Y < l.NEAR_NOMINATION_EXP; Y++, ie = ie.mul(m))
    h[Y] = ie;
  function d(Y, ie = l.NEAR_NOMINATION_EXP) {
    const ne = new s.default(Y, 10);
    if (ie !== l.NEAR_NOMINATION_EXP) {
      const re = l.NEAR_NOMINATION_EXP - ie - 1;
      re > 0 && ne.iadd(h[re]);
    }
    Y = ne.toString();
    const de = Y.substring(0, Y.length - l.NEAR_NOMINATION_EXP) || "0", ce = Y.substring(Y.length - l.NEAR_NOMINATION_EXP).padStart(l.NEAR_NOMINATION_EXP, "0").substring(0, ie);
    return T(`${J(de)}.${ce}`);
  }
  l.formatNearAmount = d;
  function v(Y) {
    if (!Y)
      return null;
    Y = _(Y);
    const ie = Y.split("."), ne = ie[0], de = ie[1] || "";
    if (ie.length > 2 || de.length > l.NEAR_NOMINATION_EXP)
      throw new Error(`Cannot parse '${Y}' as NEAR amount`);
    return z(ne + de.padEnd(l.NEAR_NOMINATION_EXP, "0"));
  }
  l.parseNearAmount = v;
  function _(Y) {
    return Y.replace(/,/g, "").trim();
  }
  function T(Y) {
    return Y.replace(/\.?0*$/, "");
  }
  function z(Y) {
    return Y = Y.replace(/^0+/, ""), Y === "" ? "0" : Y;
  }
  function J(Y) {
    const ie = /(-?\d+)(\d{3})/;
    for (; ie.test(Y); )
      Y = Y.replace(ie, "$1,$2");
    return Y;
  }
})(format);
var hasRequiredUtils;
function requireUtils() {
  return hasRequiredUtils || (hasRequiredUtils = 1, function(l) {
    var t = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ie, ne, de, ce) {
      ce === void 0 && (ce = de);
      var re = Object.getOwnPropertyDescriptor(ne, de);
      (!re || ("get" in re ? !ne.__esModule : re.writable || re.configurable)) && (re = { enumerable: !0, get: function() {
        return ne[de];
      } }), Object.defineProperty(ie, ce, re);
    } : function(ie, ne, de, ce) {
      ce === void 0 && (ce = de), ie[ce] = ne[de];
    }), s = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(ie, ne) {
      Object.defineProperty(ie, "default", { enumerable: !0, value: ne });
    } : function(ie, ne) {
      ie.default = ne;
    }), h = commonjsGlobal && commonjsGlobal.__importStar || function(ie) {
      if (ie && ie.__esModule)
        return ie;
      var ne = {};
      if (ie != null)
        for (var de in ie)
          de !== "default" && Object.prototype.hasOwnProperty.call(ie, de) && t(ne, ie, de);
      return s(ne, ie), ne;
    };
    Object.defineProperty(l, "__esModule", { value: !0 }), l.logWarning = l.rpc_errors = l.KeyPairEd25519 = l.KeyPair = l.PublicKey = l.format = l.enums = l.web = l.serialize = l.key_pair = void 0;
    const m = h(key_pair);
    l.key_pair = m;
    const d = h(serialize$1);
    l.serialize = d;
    const v = h(requireWeb());
    l.web = v;
    const _ = h(enums);
    l.enums = _;
    const T = h(format);
    l.format = T;
    const z = h(requireRpc_errors());
    l.rpc_errors = z;
    const J = key_pair;
    Object.defineProperty(l, "PublicKey", { enumerable: !0, get: function() {
      return J.PublicKey;
    } }), Object.defineProperty(l, "KeyPair", { enumerable: !0, get: function() {
      return J.KeyPair;
    } }), Object.defineProperty(l, "KeyPairEd25519", { enumerable: !0, get: function() {
      return J.KeyPairEd25519;
    } });
    const Y = errors;
    Object.defineProperty(l, "logWarning", { enumerable: !0, get: function() {
      return Y.logWarning;
    } });
  }(utils$3)), utils$3;
}
var transaction = {}, sha256$1 = { exports: {} };
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
(function(module) {
  (function() {
    var ERROR = "input is invalid type", WINDOW = typeof window == "object", root = WINDOW ? window : {};
    root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
    var WEB_WORKER = !WINDOW && typeof self == "object", NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    NODE_JS ? root = commonjsGlobal : WEB_WORKER && (root = self);
    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && !0 && module.exports, ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [-2147483648, 8388608, 32768, 128], SHIFT = [24, 16, 8, 0], K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ], OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"], blocks = [];
    (root.JS_SHA256_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(l) {
      return Object.prototype.toString.call(l) === "[object Array]";
    }), ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(l) {
      return typeof l == "object" && l.buffer && l.buffer.constructor === ArrayBuffer;
    });
    var createOutputMethod = function(l, t) {
      return function(s) {
        return new Sha256(t, !0).update(s)[l]();
      };
    }, createMethod = function(l) {
      var t = createOutputMethod("hex", l);
      NODE_JS && (t = nodeWrap(t, l)), t.create = function() {
        return new Sha256(l);
      }, t.update = function(m) {
        return t.create().update(m);
      };
      for (var s = 0; s < OUTPUT_TYPES.length; ++s) {
        var h = OUTPUT_TYPES[s];
        t[h] = createOutputMethod(h, l);
      }
      return t;
    }, nodeWrap = function(method, is224) {
      var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), algorithm = is224 ? "sha224" : "sha256", nodeMethod = function(l) {
        if (typeof l == "string")
          return crypto.createHash(algorithm).update(l, "utf8").digest("hex");
        if (l == null)
          throw new Error(ERROR);
        return l.constructor === ArrayBuffer && (l = new Uint8Array(l)), Array.isArray(l) || ArrayBuffer.isView(l) || l.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(l)).digest("hex") : method(l);
      };
      return nodeMethod;
    }, createHmacOutputMethod = function(l, t) {
      return function(s, h) {
        return new HmacSha256(s, t, !0).update(h)[l]();
      };
    }, createHmacMethod = function(l) {
      var t = createHmacOutputMethod("hex", l);
      t.create = function(m) {
        return new HmacSha256(m, l);
      }, t.update = function(m, d) {
        return t.create(m).update(d);
      };
      for (var s = 0; s < OUTPUT_TYPES.length; ++s) {
        var h = OUTPUT_TYPES[s];
        t[h] = createHmacOutputMethod(h, l);
      }
      return t;
    };
    function Sha256(l, t) {
      t ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], l ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = l;
    }
    Sha256.prototype.update = function(l) {
      if (!this.finalized) {
        var t, s = typeof l;
        if (s !== "string") {
          if (s === "object") {
            if (l === null)
              throw new Error(ERROR);
            if (ARRAY_BUFFER && l.constructor === ArrayBuffer)
              l = new Uint8Array(l);
            else if (!Array.isArray(l) && (!ARRAY_BUFFER || !ArrayBuffer.isView(l)))
              throw new Error(ERROR);
          } else
            throw new Error(ERROR);
          t = !0;
        }
        for (var h, m = 0, d, v = l.length, _ = this.blocks; m < v; ) {
          if (this.hashed && (this.hashed = !1, _[0] = this.block, _[16] = _[1] = _[2] = _[3] = _[4] = _[5] = _[6] = _[7] = _[8] = _[9] = _[10] = _[11] = _[12] = _[13] = _[14] = _[15] = 0), t)
            for (d = this.start; m < v && d < 64; ++m)
              _[d >> 2] |= l[m] << SHIFT[d++ & 3];
          else
            for (d = this.start; m < v && d < 64; ++m)
              h = l.charCodeAt(m), h < 128 ? _[d >> 2] |= h << SHIFT[d++ & 3] : h < 2048 ? (_[d >> 2] |= (192 | h >> 6) << SHIFT[d++ & 3], _[d >> 2] |= (128 | h & 63) << SHIFT[d++ & 3]) : h < 55296 || h >= 57344 ? (_[d >> 2] |= (224 | h >> 12) << SHIFT[d++ & 3], _[d >> 2] |= (128 | h >> 6 & 63) << SHIFT[d++ & 3], _[d >> 2] |= (128 | h & 63) << SHIFT[d++ & 3]) : (h = 65536 + ((h & 1023) << 10 | l.charCodeAt(++m) & 1023), _[d >> 2] |= (240 | h >> 18) << SHIFT[d++ & 3], _[d >> 2] |= (128 | h >> 12 & 63) << SHIFT[d++ & 3], _[d >> 2] |= (128 | h >> 6 & 63) << SHIFT[d++ & 3], _[d >> 2] |= (128 | h & 63) << SHIFT[d++ & 3]);
          this.lastByteIndex = d, this.bytes += d - this.start, d >= 64 ? (this.block = _[16], this.start = d - 64, this.hash(), this.hashed = !0) : this.start = d;
        }
        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
      }
    }, Sha256.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var l = this.blocks, t = this.lastByteIndex;
        l[16] = this.block, l[t >> 2] |= EXTRA[t & 3], this.block = l[16], t >= 56 && (this.hashed || this.hash(), l[0] = this.block, l[16] = l[1] = l[2] = l[3] = l[4] = l[5] = l[6] = l[7] = l[8] = l[9] = l[10] = l[11] = l[12] = l[13] = l[14] = l[15] = 0), l[14] = this.hBytes << 3 | this.bytes >>> 29, l[15] = this.bytes << 3, this.hash();
      }
    }, Sha256.prototype.hash = function() {
      var l = this.h0, t = this.h1, s = this.h2, h = this.h3, m = this.h4, d = this.h5, v = this.h6, _ = this.h7, T = this.blocks, z, J, Y, ie, ne, de, ce, re, oe, pe, ae;
      for (z = 16; z < 64; ++z)
        ne = T[z - 15], J = (ne >>> 7 | ne << 25) ^ (ne >>> 18 | ne << 14) ^ ne >>> 3, ne = T[z - 2], Y = (ne >>> 17 | ne << 15) ^ (ne >>> 19 | ne << 13) ^ ne >>> 10, T[z] = T[z - 16] + J + T[z - 7] + Y << 0;
      for (ae = t & s, z = 0; z < 64; z += 4)
        this.first ? (this.is224 ? (re = 300032, ne = T[0] - 1413257819, _ = ne - 150054599 << 0, h = ne + 24177077 << 0) : (re = 704751109, ne = T[0] - 210244248, _ = ne - 1521486534 << 0, h = ne + 143694565 << 0), this.first = !1) : (J = (l >>> 2 | l << 30) ^ (l >>> 13 | l << 19) ^ (l >>> 22 | l << 10), Y = (m >>> 6 | m << 26) ^ (m >>> 11 | m << 21) ^ (m >>> 25 | m << 7), re = l & t, ie = re ^ l & s ^ ae, ce = m & d ^ ~m & v, ne = _ + Y + ce + K[z] + T[z], de = J + ie, _ = h + ne << 0, h = ne + de << 0), J = (h >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10), Y = (_ >>> 6 | _ << 26) ^ (_ >>> 11 | _ << 21) ^ (_ >>> 25 | _ << 7), oe = h & l, ie = oe ^ h & t ^ re, ce = _ & m ^ ~_ & d, ne = v + Y + ce + K[z + 1] + T[z + 1], de = J + ie, v = s + ne << 0, s = ne + de << 0, J = (s >>> 2 | s << 30) ^ (s >>> 13 | s << 19) ^ (s >>> 22 | s << 10), Y = (v >>> 6 | v << 26) ^ (v >>> 11 | v << 21) ^ (v >>> 25 | v << 7), pe = s & h, ie = pe ^ s & l ^ oe, ce = v & _ ^ ~v & m, ne = d + Y + ce + K[z + 2] + T[z + 2], de = J + ie, d = t + ne << 0, t = ne + de << 0, J = (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10), Y = (d >>> 6 | d << 26) ^ (d >>> 11 | d << 21) ^ (d >>> 25 | d << 7), ae = t & s, ie = ae ^ t & h ^ pe, ce = d & v ^ ~d & _, ne = m + Y + ce + K[z + 3] + T[z + 3], de = J + ie, m = l + ne << 0, l = ne + de << 0;
      this.h0 = this.h0 + l << 0, this.h1 = this.h1 + t << 0, this.h2 = this.h2 + s << 0, this.h3 = this.h3 + h << 0, this.h4 = this.h4 + m << 0, this.h5 = this.h5 + d << 0, this.h6 = this.h6 + v << 0, this.h7 = this.h7 + _ << 0;
    }, Sha256.prototype.hex = function() {
      this.finalize();
      var l = this.h0, t = this.h1, s = this.h2, h = this.h3, m = this.h4, d = this.h5, v = this.h6, _ = this.h7, T = HEX_CHARS[l >> 28 & 15] + HEX_CHARS[l >> 24 & 15] + HEX_CHARS[l >> 20 & 15] + HEX_CHARS[l >> 16 & 15] + HEX_CHARS[l >> 12 & 15] + HEX_CHARS[l >> 8 & 15] + HEX_CHARS[l >> 4 & 15] + HEX_CHARS[l & 15] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[t & 15] + HEX_CHARS[s >> 28 & 15] + HEX_CHARS[s >> 24 & 15] + HEX_CHARS[s >> 20 & 15] + HEX_CHARS[s >> 16 & 15] + HEX_CHARS[s >> 12 & 15] + HEX_CHARS[s >> 8 & 15] + HEX_CHARS[s >> 4 & 15] + HEX_CHARS[s & 15] + HEX_CHARS[h >> 28 & 15] + HEX_CHARS[h >> 24 & 15] + HEX_CHARS[h >> 20 & 15] + HEX_CHARS[h >> 16 & 15] + HEX_CHARS[h >> 12 & 15] + HEX_CHARS[h >> 8 & 15] + HEX_CHARS[h >> 4 & 15] + HEX_CHARS[h & 15] + HEX_CHARS[m >> 28 & 15] + HEX_CHARS[m >> 24 & 15] + HEX_CHARS[m >> 20 & 15] + HEX_CHARS[m >> 16 & 15] + HEX_CHARS[m >> 12 & 15] + HEX_CHARS[m >> 8 & 15] + HEX_CHARS[m >> 4 & 15] + HEX_CHARS[m & 15] + HEX_CHARS[d >> 28 & 15] + HEX_CHARS[d >> 24 & 15] + HEX_CHARS[d >> 20 & 15] + HEX_CHARS[d >> 16 & 15] + HEX_CHARS[d >> 12 & 15] + HEX_CHARS[d >> 8 & 15] + HEX_CHARS[d >> 4 & 15] + HEX_CHARS[d & 15] + HEX_CHARS[v >> 28 & 15] + HEX_CHARS[v >> 24 & 15] + HEX_CHARS[v >> 20 & 15] + HEX_CHARS[v >> 16 & 15] + HEX_CHARS[v >> 12 & 15] + HEX_CHARS[v >> 8 & 15] + HEX_CHARS[v >> 4 & 15] + HEX_CHARS[v & 15];
      return this.is224 || (T += HEX_CHARS[_ >> 28 & 15] + HEX_CHARS[_ >> 24 & 15] + HEX_CHARS[_ >> 20 & 15] + HEX_CHARS[_ >> 16 & 15] + HEX_CHARS[_ >> 12 & 15] + HEX_CHARS[_ >> 8 & 15] + HEX_CHARS[_ >> 4 & 15] + HEX_CHARS[_ & 15]), T;
    }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
      this.finalize();
      var l = this.h0, t = this.h1, s = this.h2, h = this.h3, m = this.h4, d = this.h5, v = this.h6, _ = this.h7, T = [
        l >> 24 & 255,
        l >> 16 & 255,
        l >> 8 & 255,
        l & 255,
        t >> 24 & 255,
        t >> 16 & 255,
        t >> 8 & 255,
        t & 255,
        s >> 24 & 255,
        s >> 16 & 255,
        s >> 8 & 255,
        s & 255,
        h >> 24 & 255,
        h >> 16 & 255,
        h >> 8 & 255,
        h & 255,
        m >> 24 & 255,
        m >> 16 & 255,
        m >> 8 & 255,
        m & 255,
        d >> 24 & 255,
        d >> 16 & 255,
        d >> 8 & 255,
        d & 255,
        v >> 24 & 255,
        v >> 16 & 255,
        v >> 8 & 255,
        v & 255
      ];
      return this.is224 || T.push(_ >> 24 & 255, _ >> 16 & 255, _ >> 8 & 255, _ & 255), T;
    }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var l = new ArrayBuffer(this.is224 ? 28 : 32), t = new DataView(l);
      return t.setUint32(0, this.h0), t.setUint32(4, this.h1), t.setUint32(8, this.h2), t.setUint32(12, this.h3), t.setUint32(16, this.h4), t.setUint32(20, this.h5), t.setUint32(24, this.h6), this.is224 || t.setUint32(28, this.h7), l;
    };
    function HmacSha256(l, t, s) {
      var h, m = typeof l;
      if (m === "string") {
        var d = [], v = l.length, _ = 0, T;
        for (h = 0; h < v; ++h)
          T = l.charCodeAt(h), T < 128 ? d[_++] = T : T < 2048 ? (d[_++] = 192 | T >> 6, d[_++] = 128 | T & 63) : T < 55296 || T >= 57344 ? (d[_++] = 224 | T >> 12, d[_++] = 128 | T >> 6 & 63, d[_++] = 128 | T & 63) : (T = 65536 + ((T & 1023) << 10 | l.charCodeAt(++h) & 1023), d[_++] = 240 | T >> 18, d[_++] = 128 | T >> 12 & 63, d[_++] = 128 | T >> 6 & 63, d[_++] = 128 | T & 63);
        l = d;
      } else if (m === "object") {
        if (l === null)
          throw new Error(ERROR);
        if (ARRAY_BUFFER && l.constructor === ArrayBuffer)
          l = new Uint8Array(l);
        else if (!Array.isArray(l) && (!ARRAY_BUFFER || !ArrayBuffer.isView(l)))
          throw new Error(ERROR);
      } else
        throw new Error(ERROR);
      l.length > 64 && (l = new Sha256(t, !0).update(l).array());
      var z = [], J = [];
      for (h = 0; h < 64; ++h) {
        var Y = l[h] || 0;
        z[h] = 92 ^ Y, J[h] = 54 ^ Y;
      }
      Sha256.call(this, t, s), this.update(J), this.oKeyPad = z, this.inner = !0, this.sharedMemory = s;
    }
    HmacSha256.prototype = new Sha256(), HmacSha256.prototype.finalize = function() {
      if (Sha256.prototype.finalize.call(this), this.inner) {
        this.inner = !1;
        var l = this.array();
        Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(l), Sha256.prototype.finalize.call(this);
      }
    };
    var exports = createMethod();
    exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224);
  })();
})(sha256$1);
(function(l) {
  var t = commonjsGlobal && commonjsGlobal.__awaiter || function(y, j, ye, ee) {
    function xe($e) {
      return $e instanceof ye ? $e : new ye(function(ke) {
        ke($e);
      });
    }
    return new (ye || (ye = Promise))(function($e, ke) {
      function Ce(De) {
        try {
          Ue(ee.next(De));
        } catch (wt) {
          ke(wt);
        }
      }
      function ht(De) {
        try {
          Ue(ee.throw(De));
        } catch (wt) {
          ke(wt);
        }
      }
      function Ue(De) {
        De.done ? $e(De.value) : xe(De.value).then(Ce, ht);
      }
      Ue((ee = ee.apply(y, j || [])).next());
    });
  }, s = commonjsGlobal && commonjsGlobal.__importDefault || function(y) {
    return y && y.__esModule ? y : { default: y };
  };
  Object.defineProperty(l, "__esModule", { value: !0 }), l.signTransaction = l.createTransaction = l.SCHEMA = l.Action = l.SignedTransaction = l.Transaction = l.Signature = l.deleteAccount = l.deleteKey = l.addKey = l.stake = l.transfer = l.functionCall = l.stringifyJsonOrBytes = l.deployContract = l.createAccount = l.DeleteAccount = l.DeleteKey = l.AddKey = l.Stake = l.Transfer = l.FunctionCall = l.DeployContract = l.CreateAccount = l.IAction = l.functionCallAccessKey = l.fullAccessKey = l.AccessKey = l.AccessKeyPermission = l.FullAccessPermission = l.FunctionCallPermission = void 0;
  const h = s(sha256$1.exports), m = enums, d = lib$4, v = key_pair;
  class _ extends m.Assignable {
  }
  l.FunctionCallPermission = _;
  class T extends m.Assignable {
  }
  l.FullAccessPermission = T;
  class z extends m.Enum {
  }
  l.AccessKeyPermission = z;
  class J extends m.Assignable {
  }
  l.AccessKey = J;
  function Y() {
    return new J({ permission: new z({ fullAccess: new T({}) }) });
  }
  l.fullAccessKey = Y;
  function ie(y, j, ye) {
    return new J({ permission: new z({ functionCall: new _({ receiverId: y, allowance: ye, methodNames: j }) }) });
  }
  l.functionCallAccessKey = ie;
  class ne extends m.Assignable {
  }
  l.IAction = ne;
  class de extends ne {
  }
  l.CreateAccount = de;
  class ce extends ne {
  }
  l.DeployContract = ce;
  class re extends ne {
  }
  l.FunctionCall = re;
  class oe extends ne {
  }
  l.Transfer = oe;
  class pe extends ne {
  }
  l.Stake = pe;
  class ae extends ne {
  }
  l.AddKey = ae;
  class me extends ne {
  }
  l.DeleteKey = me;
  class ge extends ne {
  }
  l.DeleteAccount = ge;
  function we() {
    return new L({ createAccount: new de({}) });
  }
  l.createAccount = we;
  function Ee(y) {
    return new L({ deployContract: new ce({ code: y }) });
  }
  l.deployContract = Ee;
  function Te(y) {
    return y.byteLength !== void 0 && y.byteLength === y.length ? y : Buffer.from(JSON.stringify(y));
  }
  l.stringifyJsonOrBytes = Te;
  function Ke(y, j, ye, ee, xe = Te, $e = !1) {
    return $e ? new L({ functionCall: new re({ methodName: y, args: j, gas: ye, deposit: ee }) }) : new L({ functionCall: new re({ methodName: y, args: xe(j), gas: ye, deposit: ee }) });
  }
  l.functionCall = Ke;
  function Se(y) {
    return new L({ transfer: new oe({ deposit: y }) });
  }
  l.transfer = Se;
  function X(y, j) {
    return new L({ stake: new pe({ stake: y, publicKey: j }) });
  }
  l.stake = X;
  function fe(y, j) {
    return new L({ addKey: new ae({ publicKey: y, accessKey: j }) });
  }
  l.addKey = fe;
  function k(y) {
    return new L({ deleteKey: new me({ publicKey: y }) });
  }
  l.deleteKey = k;
  function p(y) {
    return new L({ deleteAccount: new ge({ beneficiaryId: y }) });
  }
  l.deleteAccount = p;
  class x extends m.Assignable {
  }
  l.Signature = x;
  class S extends m.Assignable {
    encode() {
      return (0, d.serialize)(l.SCHEMA, this);
    }
    static decode(j) {
      return (0, d.deserialize)(l.SCHEMA, S, j);
    }
  }
  l.Transaction = S;
  class B extends m.Assignable {
    encode() {
      return (0, d.serialize)(l.SCHEMA, this);
    }
    static decode(j) {
      return (0, d.deserialize)(l.SCHEMA, B, j);
    }
  }
  l.SignedTransaction = B;
  class L extends m.Enum {
  }
  l.Action = L, l.SCHEMA = /* @__PURE__ */ new Map([
    [x, { kind: "struct", fields: [
      ["keyType", "u8"],
      ["data", [64]]
    ] }],
    [B, { kind: "struct", fields: [
      ["transaction", S],
      ["signature", x]
    ] }],
    [S, { kind: "struct", fields: [
      ["signerId", "string"],
      ["publicKey", v.PublicKey],
      ["nonce", "u64"],
      ["receiverId", "string"],
      ["blockHash", [32]],
      ["actions", [L]]
    ] }],
    [v.PublicKey, { kind: "struct", fields: [
      ["keyType", "u8"],
      ["data", [32]]
    ] }],
    [J, { kind: "struct", fields: [
      ["nonce", "u64"],
      ["permission", z]
    ] }],
    [z, { kind: "enum", field: "enum", values: [
      ["functionCall", _],
      ["fullAccess", T]
    ] }],
    [_, { kind: "struct", fields: [
      ["allowance", { kind: "option", type: "u128" }],
      ["receiverId", "string"],
      ["methodNames", ["string"]]
    ] }],
    [T, { kind: "struct", fields: [] }],
    [L, { kind: "enum", field: "enum", values: [
      ["createAccount", de],
      ["deployContract", ce],
      ["functionCall", re],
      ["transfer", oe],
      ["stake", pe],
      ["addKey", ae],
      ["deleteKey", me],
      ["deleteAccount", ge]
    ] }],
    [de, { kind: "struct", fields: [] }],
    [ce, { kind: "struct", fields: [
      ["code", ["u8"]]
    ] }],
    [re, { kind: "struct", fields: [
      ["methodName", "string"],
      ["args", ["u8"]],
      ["gas", "u64"],
      ["deposit", "u128"]
    ] }],
    [oe, { kind: "struct", fields: [
      ["deposit", "u128"]
    ] }],
    [pe, { kind: "struct", fields: [
      ["stake", "u128"],
      ["publicKey", v.PublicKey]
    ] }],
    [ae, { kind: "struct", fields: [
      ["publicKey", v.PublicKey],
      ["accessKey", J]
    ] }],
    [me, { kind: "struct", fields: [
      ["publicKey", v.PublicKey]
    ] }],
    [ge, { kind: "struct", fields: [
      ["beneficiaryId", "string"]
    ] }]
  ]);
  function C(y, j, ye, ee, xe, $e) {
    return new S({ signerId: y, publicKey: j, nonce: ee, receiverId: ye, actions: xe, blockHash: $e });
  }
  l.createTransaction = C;
  function G(y, j, ye, ee) {
    return t(this, void 0, void 0, function* () {
      const xe = (0, d.serialize)(l.SCHEMA, y), $e = new Uint8Array(h.default.sha256.array(xe)), ke = yield j.signMessage(xe, ye, ee), Ce = new B({
        transaction: y,
        signature: new x({ keyType: y.publicKey.keyType, data: ke.signature })
      });
      return [$e, Ce];
    });
  }
  function R(...y) {
    return t(this, void 0, void 0, function* () {
      if (y[0].constructor === S) {
        const [j, ye, ee, xe] = y;
        return G(j, ye, ee, xe);
      } else {
        const [j, ye, ee, xe, $e, ke, Ce] = y, ht = yield $e.getPublicKey(ke, Ce), Ue = C(ke, ht, j, ye, ee, xe);
        return G(Ue, $e, ke, Ce);
      }
    });
  }
  l.signTransaction = R;
})(transaction);
var validators = {};
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var browser$2 = depd;
function depd(l) {
  if (!l)
    throw new TypeError("argument namespace is required");
  function t(s) {
  }
  return t._file = void 0, t._ignored = !0, t._namespace = l, t._traced = !1, t._warned = /* @__PURE__ */ Object.create(null), t.function = wrapfunction, t.property = wrapproperty, t;
}
function wrapfunction(l, t) {
  if (typeof l != "function")
    throw new TypeError("argument fn must be a function");
  return l;
}
function wrapproperty(l, t, s) {
  if (!l || typeof l != "object" && typeof l != "function")
    throw new TypeError("argument obj must be object");
  var h = Object.getOwnPropertyDescriptor(l, t);
  if (!h)
    throw new TypeError("must call property on owner object");
  if (!h.configurable)
    throw new TypeError("property must be configurable");
}
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(l) {
  return l && l.__esModule ? l : { default: l };
};
Object.defineProperty(validators, "__esModule", { value: !0 });
validators.diffEpochValidators = validators.findSeatPrice = void 0;
const bn_js_1$1 = __importDefault$2(bn$1.exports), depd_1 = __importDefault$2(browser$2);
function findSeatPrice(l, t, s, h) {
  return h && h < 49 ? findSeatPriceForProtocolBefore49(l, t) : (s || ((0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)")("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead"), s = [1, 6250]), findSeatPriceForProtocolAfter49(l, t, s));
}
validators.findSeatPrice = findSeatPrice;
function findSeatPriceForProtocolBefore49(l, t) {
  const s = l.map((_) => new bn_js_1$1.default(_.stake, 10)).sort((_, T) => _.cmp(T)), h = new bn_js_1$1.default(t), m = s.reduce((_, T) => _.add(T));
  if (m.lt(h))
    throw new Error("Stakes are below seats");
  let d = new bn_js_1$1.default(1), v = m.add(new bn_js_1$1.default(1));
  for (; !d.eq(v.sub(new bn_js_1$1.default(1))); ) {
    const _ = d.add(v).div(new bn_js_1$1.default(2));
    let T = !1, z = new bn_js_1$1.default(0);
    for (let J = 0; J < s.length; ++J)
      if (z = z.add(s[J].div(_)), z.gte(h)) {
        d = _, T = !0;
        break;
      }
    T || (v = _);
  }
  return d;
}
function findSeatPriceForProtocolAfter49(l, t, s) {
  if (s.length != 2)
    throw Error("minimumStakeRatio should have 2 elements");
  const h = l.map((d) => new bn_js_1$1.default(d.stake, 10)).sort((d, v) => d.cmp(v)), m = h.reduce((d, v) => d.add(v));
  return l.length < t ? m.mul(new bn_js_1$1.default(s[0])).div(new bn_js_1$1.default(s[1])) : h[0].add(new bn_js_1$1.default(1));
}
function diffEpochValidators(l, t) {
  const s = /* @__PURE__ */ new Map();
  l.forEach((m) => s.set(m.account_id, m));
  const h = new Set(t.map((m) => m.account_id));
  return {
    newValidators: t.filter((m) => !s.has(m.account_id)),
    removedValidators: l.filter((m) => !h.has(m.account_id)),
    changedValidators: t.filter((m) => s.has(m.account_id) && s.get(m.account_id).stake != m.stake).map((m) => ({ current: s.get(m.account_id), next: m }))
  };
}
validators.diffEpochValidators = diffEpochValidators;
var account = {}, constants = {}, __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(l) {
  return l && l.__esModule ? l : { default: l };
};
Object.defineProperty(constants, "__esModule", { value: !0 });
constants.DEFAULT_FUNCTION_CALL_GAS = void 0;
const bn_js_1 = __importDefault$1(bn$1.exports);
constants.DEFAULT_FUNCTION_CALL_GAS = new bn_js_1.default("30000000000000");
var hasRequiredAccount;
function requireAccount() {
  if (hasRequiredAccount)
    return account;
  hasRequiredAccount = 1;
  var l = commonjsGlobal && commonjsGlobal.__awaiter || function(pe, ae, me, ge) {
    function we(Ee) {
      return Ee instanceof me ? Ee : new me(function(Te) {
        Te(Ee);
      });
    }
    return new (me || (me = Promise))(function(Ee, Te) {
      function Ke(fe) {
        try {
          X(ge.next(fe));
        } catch (k) {
          Te(k);
        }
      }
      function Se(fe) {
        try {
          X(ge.throw(fe));
        } catch (k) {
          Te(k);
        }
      }
      function X(fe) {
        fe.done ? Ee(fe.value) : we(fe.value).then(Ke, Se);
      }
      X((ge = ge.apply(pe, ae || [])).next());
    });
  }, t = commonjsGlobal && commonjsGlobal.__importDefault || function(pe) {
    return pe && pe.__esModule ? pe : { default: pe };
  };
  Object.defineProperty(account, "__esModule", { value: !0 }), account.Account = void 0;
  const s = t(bn$1.exports), h = t(browser$2), m = transaction, d = requireProviders(), v = lib$4, _ = key_pair, T = errors, z = requireRpc_errors(), J = constants, Y = t(exponentialBackoff$1), ie = 12, ne = 500, de = 1.5;
  function ce(pe) {
    return JSON.parse(Buffer.from(pe).toString());
  }
  function re(pe) {
    return Buffer.from(JSON.stringify(pe));
  }
  class oe {
    constructor(ae, me) {
      this.accessKeyByPublicKeyCache = {}, this.connection = ae, this.accountId = me;
    }
    state() {
      return l(this, void 0, void 0, function* () {
        return this.connection.provider.query({
          request_type: "view_account",
          account_id: this.accountId,
          finality: "optimistic"
        });
      });
    }
    printLogsAndFailures(ae, me) {
      if (!process.env.NEAR_NO_LOGS)
        for (const ge of me)
          console.log(`Receipt${ge.receiptIds.length > 1 ? "s" : ""}: ${ge.receiptIds.join(", ")}`), this.printLogs(ae, ge.logs, "	"), ge.failure && console.warn(`	Failure [${ae}]: ${ge.failure}`);
    }
    printLogs(ae, me, ge = "") {
      if (!process.env.NEAR_NO_LOGS)
        for (const we of me)
          console.log(`${ge}Log [${ae}]: ${we}`);
    }
    signTransaction(ae, me) {
      return l(this, void 0, void 0, function* () {
        const ge = yield this.findAccessKey(ae, me);
        if (!ge)
          throw new d.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`, "KeyNotFound");
        const { accessKey: we } = ge, Te = (yield this.connection.provider.block({ finality: "final" })).header.hash, Ke = we.nonce.add(new s.default(1));
        return yield (0, m.signTransaction)(ae, Ke, me, (0, v.baseDecode)(Te), this.connection.signer, this.accountId, this.connection.networkId);
      });
    }
    signAndSendTransaction({ receiverId: ae, actions: me, returnError: ge }) {
      return l(this, void 0, void 0, function* () {
        let we, Ee;
        const Te = yield (0, Y.default)(ne, ie, de, () => l(this, void 0, void 0, function* () {
          [we, Ee] = yield this.signTransaction(ae, me);
          const Se = Ee.transaction.publicKey;
          try {
            return yield this.connection.provider.sendTransaction(Ee);
          } catch (X) {
            if (X.type === "InvalidNonce")
              return (0, T.logWarning)(`Retrying transaction ${ae}:${(0, v.baseEncode)(we)} with new nonce.`), delete this.accessKeyByPublicKeyCache[Se.toString()], null;
            if (X.type === "Expired")
              return (0, T.logWarning)(`Retrying transaction ${ae}:${(0, v.baseEncode)(we)} due to expired block hash`), null;
            throw X.context = new d.ErrorContext((0, v.baseEncode)(we)), X;
          }
        }));
        if (!Te)
          throw new d.TypedError("nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.", "RetriesExceeded");
        const Ke = [Te.transaction_outcome, ...Te.receipts_outcome].reduce((Se, X) => X.outcome.logs.length || typeof X.outcome.status == "object" && typeof X.outcome.status.Failure == "object" ? Se.concat({
          receiptIds: X.outcome.receipt_ids,
          logs: X.outcome.logs,
          failure: typeof X.outcome.status.Failure < "u" ? (0, z.parseRpcError)(X.outcome.status.Failure) : null
        }) : Se, []);
        if (this.printLogsAndFailures(Ee.transaction.receiverId, Ke), !ge && typeof Te.status == "object" && typeof Te.status.Failure == "object" && Te.status.Failure !== null)
          throw Te.status.Failure.error_message && Te.status.Failure.error_type ? new d.TypedError(`Transaction ${Te.transaction_outcome.id} failed. ${Te.status.Failure.error_message}`, Te.status.Failure.error_type) : (0, z.parseResultError)(Te);
        return Te;
      });
    }
    findAccessKey(ae, me) {
      return l(this, void 0, void 0, function* () {
        const ge = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
        if (!ge)
          throw new d.TypedError(`no matching key pair found in ${this.connection.signer}`, "PublicKeyNotFound");
        const we = this.accessKeyByPublicKeyCache[ge.toString()];
        if (we !== void 0)
          return { publicKey: ge, accessKey: we };
        try {
          const Ee = yield this.connection.provider.query({
            request_type: "view_access_key",
            account_id: this.accountId,
            public_key: ge.toString(),
            finality: "optimistic"
          }), Te = Object.assign(Object.assign({}, Ee), { nonce: new s.default(Ee.nonce) });
          return this.accessKeyByPublicKeyCache[ge.toString()] ? { publicKey: ge, accessKey: this.accessKeyByPublicKeyCache[ge.toString()] } : (this.accessKeyByPublicKeyCache[ge.toString()] = Te, { publicKey: ge, accessKey: Te });
        } catch (Ee) {
          if (Ee.type == "AccessKeyDoesNotExist")
            return null;
          throw Ee;
        }
      });
    }
    createAndDeployContract(ae, me, ge, we) {
      return l(this, void 0, void 0, function* () {
        const Ee = (0, m.fullAccessKey)();
        return yield this.signAndSendTransaction({
          receiverId: ae,
          actions: [(0, m.createAccount)(), (0, m.transfer)(we), (0, m.addKey)(_.PublicKey.from(me), Ee), (0, m.deployContract)(ge)]
        }), new oe(this.connection, ae);
      });
    }
    sendMoney(ae, me) {
      return l(this, void 0, void 0, function* () {
        return this.signAndSendTransaction({
          receiverId: ae,
          actions: [(0, m.transfer)(me)]
        });
      });
    }
    createAccount(ae, me, ge) {
      return l(this, void 0, void 0, function* () {
        const we = (0, m.fullAccessKey)();
        return this.signAndSendTransaction({
          receiverId: ae,
          actions: [(0, m.createAccount)(), (0, m.transfer)(ge), (0, m.addKey)(_.PublicKey.from(me), we)]
        });
      });
    }
    deleteAccount(ae) {
      return l(this, void 0, void 0, function* () {
        return process.env.NEAR_NO_LOGS || console.log("Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting."), this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, m.deleteAccount)(ae)]
        });
      });
    }
    deployContract(ae) {
      return l(this, void 0, void 0, function* () {
        return this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, m.deployContract)(ae)]
        });
      });
    }
    encodeJSContractArgs(ae, me, ge) {
      return Buffer.concat([Buffer.from(ae), Buffer.from([0]), Buffer.from(me), Buffer.from([0]), Buffer.from(ge)]);
    }
    functionCall({ contractId: ae, methodName: me, args: ge = {}, gas: we = J.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit: Ee, walletMeta: Te, walletCallbackUrl: Ke, stringify: Se, jsContract: X }) {
      return l(this, void 0, void 0, function* () {
        this.validateArgs(ge);
        let fe;
        if (X)
          fe = ["call_js_contract", this.encodeJSContractArgs(ae, me, JSON.stringify(ge)), we, Ee, null, !0];
        else {
          const k = Se === void 0 ? m.stringifyJsonOrBytes : Se;
          fe = [me, ge, we, Ee, k, !1];
        }
        return this.signAndSendTransaction({
          receiverId: X ? this.connection.jsvmAccountId : ae,
          actions: [m.functionCall.apply(void 0, fe)],
          walletMeta: Te,
          walletCallbackUrl: Ke
        });
      });
    }
    addKey(ae, me, ge, we) {
      return l(this, void 0, void 0, function* () {
        ge || (ge = []), Array.isArray(ge) || (ge = [ge]);
        let Ee;
        return me ? Ee = (0, m.functionCallAccessKey)(me, ge, we) : Ee = (0, m.fullAccessKey)(), this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, m.addKey)(_.PublicKey.from(ae), Ee)]
        });
      });
    }
    deleteKey(ae) {
      return l(this, void 0, void 0, function* () {
        return this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, m.deleteKey)(_.PublicKey.from(ae))]
        });
      });
    }
    stake(ae, me) {
      return l(this, void 0, void 0, function* () {
        return this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, m.stake)(me, _.PublicKey.from(ae))]
        });
      });
    }
    validateArgs(ae) {
      if (!(ae.byteLength !== void 0 && ae.byteLength === ae.length) && (Array.isArray(ae) || typeof ae != "object"))
        throw new T.PositionalArgsError();
    }
    viewFunction(...ae) {
      return l(this, void 0, void 0, function* () {
        if (typeof ae[0] == "string") {
          const me = ae[0], ge = ae[1], we = ae[2], Ee = ae[3];
          return yield this.viewFunctionV1(me, ge, we, Ee);
        } else
          return yield this.viewFunctionV2(ae[0]);
      });
    }
    viewFunctionV1(ae, me, ge = {}, { parse: we = ce, stringify: Ee = re, jsContract: Te = !1, blockQuery: Ke = { finality: "optimistic" } } = {}) {
      return l(this, void 0, void 0, function* () {
        return (0, h.default)("Account.viewFunction(contractId, methodName, args, options)")("use `Account.viewFunction(ViewFunctionCallOptions)` instead"), this.viewFunctionV2({ contractId: ae, methodName: me, args: ge, parse: we, stringify: Ee, jsContract: Te, blockQuery: Ke });
      });
    }
    viewFunctionV2({ contractId: ae, methodName: me, args: ge, parse: we = ce, stringify: Ee = re, jsContract: Te = !1, blockQuery: Ke = { finality: "optimistic" } }) {
      return l(this, void 0, void 0, function* () {
        let Se;
        this.validateArgs(ge), Te ? Se = this.encodeJSContractArgs(ae, me, Object.keys(ge).length > 0 ? JSON.stringify(ge) : "") : Se = Ee(ge);
        const X = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: "call_function" }, Ke), { account_id: Te ? this.connection.jsvmAccountId : ae, method_name: Te ? "view_js_contract" : me, args_base64: Se.toString("base64") }));
        return X.logs && this.printLogs(ae, X.logs), X.result && X.result.length > 0 && we(Buffer.from(X.result));
      });
    }
    viewState(ae, me = { finality: "optimistic" }) {
      return l(this, void 0, void 0, function* () {
        const { values: ge } = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: "view_state" }, me), { account_id: this.accountId, prefix_base64: Buffer.from(ae).toString("base64") }));
        return ge.map(({ key: we, value: Ee }) => ({
          key: Buffer.from(we, "base64"),
          value: Buffer.from(Ee, "base64")
        }));
      });
    }
    getAccessKeys() {
      var ae;
      return l(this, void 0, void 0, function* () {
        const me = yield this.connection.provider.query({
          request_type: "view_access_key_list",
          account_id: this.accountId,
          finality: "optimistic"
        });
        return (ae = me == null ? void 0 : me.keys) === null || ae === void 0 ? void 0 : ae.map((ge) => Object.assign(Object.assign({}, ge), { access_key: Object.assign(Object.assign({}, ge.access_key), { nonce: new s.default(ge.access_key.nonce) }) }));
      });
    }
    getAccountDetails() {
      return l(this, void 0, void 0, function* () {
        return { authorizedApps: (yield this.getAccessKeys()).filter((ge) => ge.access_key.permission !== "FullAccess").map((ge) => {
          const we = ge.access_key.permission;
          return {
            contractId: we.FunctionCall.receiver_id,
            amount: we.FunctionCall.allowance,
            publicKey: ge.public_key
          };
        }) };
      });
    }
    getAccountBalance() {
      return l(this, void 0, void 0, function* () {
        const ae = yield this.connection.provider.experimental_protocolConfig({ finality: "final" }), me = yield this.state(), ge = new s.default(ae.runtime_config.storage_amount_per_byte), we = new s.default(me.storage_usage).mul(ge), Ee = new s.default(me.locked), Te = new s.default(me.amount).add(Ee), Ke = Te.sub(s.default.max(Ee, we));
        return {
          total: Te.toString(),
          stateStaked: we.toString(),
          staked: Ee.toString(),
          available: Ke.toString()
        };
      });
    }
    getActiveDelegatedStakeBalance() {
      return l(this, void 0, void 0, function* () {
        const ae = yield this.connection.provider.block({ finality: "final" }), me = ae.header.hash, ge = ae.header.epoch_id, { current_validators: we, next_validators: Ee, current_proposals: Te } = yield this.connection.provider.validators(ge), Ke = /* @__PURE__ */ new Set();
        [...we, ...Ee, ...Te].forEach((x) => Ke.add(x.account_id));
        const Se = [...Ke], X = Se.map((x) => this.viewFunction({
          contractId: x,
          methodName: "get_account_total_balance",
          args: { account_id: this.accountId },
          blockQuery: { blockId: me }
        })), fe = yield Promise.allSettled(X);
        if (fe.some((x) => x.status === "rejected" && x.reason.type === "TimeoutError"))
          throw new Error("Failed to get delegated stake balance");
        const p = fe.reduce((x, S, B) => {
          const L = Se[B];
          if (S.status === "fulfilled") {
            const C = new s.default(S.value);
            if (!C.isZero())
              return Object.assign(Object.assign({}, x), { stakedValidators: [...x.stakedValidators, { validatorId: L, amount: C.toString() }], total: x.total.add(C) });
          }
          return S.status === "rejected" ? Object.assign(Object.assign({}, x), { failedValidators: [...x.failedValidators, { validatorId: L, error: S.reason }] }) : x;
        }, { stakedValidators: [], failedValidators: [], total: new s.default(0) });
        return Object.assign(Object.assign({}, p), { total: p.total.toString() });
      });
    }
  }
  return account.Account = oe, account;
}
var account_multisig = {}, hasRequiredAccount_multisig;
function requireAccount_multisig() {
  return hasRequiredAccount_multisig || (hasRequiredAccount_multisig = 1, function(l) {
    var t = commonjsGlobal && commonjsGlobal.__awaiter || function(ae, me, ge, we) {
      function Ee(Te) {
        return Te instanceof ge ? Te : new ge(function(Ke) {
          Ke(Te);
        });
      }
      return new (ge || (ge = Promise))(function(Te, Ke) {
        function Se(k) {
          try {
            fe(we.next(k));
          } catch (p) {
            Ke(p);
          }
        }
        function X(k) {
          try {
            fe(we.throw(k));
          } catch (p) {
            Ke(p);
          }
        }
        function fe(k) {
          k.done ? Te(k.value) : Ee(k.value).then(Se, X);
        }
        fe((we = we.apply(ae, me || [])).next());
      });
    }, s = commonjsGlobal && commonjsGlobal.__importDefault || function(ae) {
      return ae && ae.__esModule ? ae : { default: ae };
    };
    Object.defineProperty(l, "__esModule", { value: !0 }), l.Account2FA = l.AccountMultisig = l.MultisigStateStatus = l.MultisigDeleteRequestRejectionError = l.MULTISIG_CONFIRM_METHODS = l.MULTISIG_CHANGE_METHODS = l.MULTISIG_DEPOSIT = l.MULTISIG_GAS = l.MULTISIG_ALLOWANCE = l.MULTISIG_STORAGE_KEY = void 0;
    const h = s(bn$1.exports), m = requireAccount(), d = format, v = key_pair, _ = transaction, T = requireProviders(), z = requireWeb();
    l.MULTISIG_STORAGE_KEY = "__multisigRequest", l.MULTISIG_ALLOWANCE = new h.default((0, d.parseNearAmount)("1")), l.MULTISIG_GAS = new h.default("100000000000000"), l.MULTISIG_DEPOSIT = new h.default("0"), l.MULTISIG_CHANGE_METHODS = ["add_request", "add_request_and_confirm", "delete_request", "confirm"], l.MULTISIG_CONFIRM_METHODS = ["confirm"];
    var J;
    (function(ae) {
      ae.CANNOT_DESERIALIZE_STATE = "Cannot deserialize the contract state", ae.MULTISIG_NOT_INITIALIZED = "Smart contract panicked: Multisig contract should be initialized before usage", ae.NO_SUCH_REQUEST = "Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'", ae.REQUEST_COOLDOWN_ERROR = "Request cannot be deleted immediately after creation.", ae.METHOD_NOT_FOUND = "Contract method is not found";
    })(J = l.MultisigDeleteRequestRejectionError || (l.MultisigDeleteRequestRejectionError = {}));
    var Y;
    (function(ae) {
      ae[ae.INVALID_STATE = 0] = "INVALID_STATE", ae[ae.STATE_NOT_INITIALIZED = 1] = "STATE_NOT_INITIALIZED", ae[ae.VALID_STATE = 2] = "VALID_STATE", ae[ae.UNKNOWN_STATE = 3] = "UNKNOWN_STATE";
    })(Y = l.MultisigStateStatus || (l.MultisigStateStatus = {}));
    var ie;
    (function(ae) {
      ae[ae.INVALID_CODE = 0] = "INVALID_CODE", ae[ae.VALID_CODE = 1] = "VALID_CODE", ae[ae.UNKNOWN_CODE = 2] = "UNKNOWN_CODE";
    })(ie || (ie = {}));
    const ne = {
      [l.MULTISIG_STORAGE_KEY]: null
    };
    class de extends m.Account {
      constructor(me, ge, we) {
        super(me, ge), this.storage = we.storage, this.onAddRequestResult = we.onAddRequestResult;
      }
      signAndSendTransactionWithAccount(me, ge) {
        const we = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction }
        });
        return t(this, void 0, void 0, function* () {
          return we.signAndSendTransaction.call(this, { receiverId: me, actions: ge });
        });
      }
      signAndSendTransaction({ receiverId: me, actions: ge }) {
        const we = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction }
        });
        return t(this, void 0, void 0, function* () {
          const { accountId: Ee } = this, Te = Buffer.from(JSON.stringify({
            request: {
              receiver_id: me,
              actions: pe(ge, Ee, me)
            }
          }));
          let Ke;
          try {
            Ke = yield we.signAndSendTransaction.call(this, {
              receiverId: Ee,
              actions: [
                (0, _.functionCall)("add_request_and_confirm", Te, l.MULTISIG_GAS, l.MULTISIG_DEPOSIT)
              ]
            });
          } catch (X) {
            if (X.toString().includes("Account has too many active requests. Confirm or delete some"))
              return yield this.deleteUnconfirmedRequests(), yield this.signAndSendTransaction({ receiverId: me, actions: ge });
            throw X;
          }
          if (!Ke.status)
            throw new Error("Request failed");
          const Se = Object.assign({}, Ke.status);
          if (!Se.SuccessValue || typeof Se.SuccessValue != "string")
            throw new Error("Request failed");
          return this.setRequest({
            accountId: Ee,
            actions: ge,
            requestId: parseInt(Buffer.from(Se.SuccessValue, "base64").toString("ascii"), 10)
          }), this.onAddRequestResult && (yield this.onAddRequestResult(Ke)), this.deleteUnconfirmedRequests(), Ke;
        });
      }
      checkMultisigCodeAndStateStatus(me) {
        const ge = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction }
        });
        return t(this, void 0, void 0, function* () {
          const Ee = me ? ie.UNKNOWN_CODE : ie.VALID_CODE;
          try {
            return me ? yield ge.signAndSendTransaction.call(this, {
              receiverId: this.accountId,
              actions: [
                (0, _.deployContract)(me),
                (0, _.functionCall)("delete_request", { request_id: 4294967295 }, l.MULTISIG_GAS, l.MULTISIG_DEPOSIT)
              ]
            }) : yield this.deleteRequest(4294967295), { codeStatus: ie.VALID_CODE, stateStatus: Y.VALID_STATE };
          } catch (Te) {
            if (new RegExp(J.CANNOT_DESERIALIZE_STATE).test(Te && Te.kind && Te.kind.ExecutionError))
              return { codeStatus: Ee, stateStatus: Y.INVALID_STATE };
            if (new RegExp(J.MULTISIG_NOT_INITIALIZED).test(Te && Te.kind && Te.kind.ExecutionError))
              return { codeStatus: Ee, stateStatus: Y.STATE_NOT_INITIALIZED };
            if (new RegExp(J.NO_SUCH_REQUEST).test(Te && Te.kind && Te.kind.ExecutionError))
              return { codeStatus: Ee, stateStatus: Y.VALID_STATE };
            if (new RegExp(J.METHOD_NOT_FOUND).test(Te && Te.message))
              return { codeStatus: ie.INVALID_CODE, stateStatus: Y.UNKNOWN_STATE };
            throw Te;
          }
        });
      }
      deleteRequest(me) {
        return super.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [(0, _.functionCall)("delete_request", { request_id: me }, l.MULTISIG_GAS, l.MULTISIG_DEPOSIT)]
        });
      }
      deleteAllRequests() {
        return t(this, void 0, void 0, function* () {
          const me = yield this.getRequestIds();
          me.length && (yield Promise.all(me.map((ge) => this.deleteRequest(ge))));
        });
      }
      deleteUnconfirmedRequests() {
        const me = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction }
        });
        return t(this, void 0, void 0, function* () {
          const ge = yield this.getRequestIds(), { requestId: we } = this.getRequest();
          for (const Ee of ge)
            if (Ee != we)
              try {
                yield me.signAndSendTransaction.call(this, {
                  receiverId: this.accountId,
                  actions: [(0, _.functionCall)("delete_request", { request_id: Ee }, l.MULTISIG_GAS, l.MULTISIG_DEPOSIT)]
                });
              } catch {
                console.warn("Attempt to delete an earlier request before 15 minutes failed. Will try again.");
              }
        });
      }
      getRequestIds() {
        return t(this, void 0, void 0, function* () {
          return this.viewFunction(this.accountId, "list_request_ids");
        });
      }
      getRequest() {
        return this.storage ? JSON.parse(this.storage.getItem(l.MULTISIG_STORAGE_KEY) || "{}") : ne[l.MULTISIG_STORAGE_KEY];
      }
      setRequest(me) {
        if (this.storage)
          return this.storage.setItem(l.MULTISIG_STORAGE_KEY, JSON.stringify(me));
        ne[l.MULTISIG_STORAGE_KEY] = me;
      }
    }
    l.AccountMultisig = de;
    class ce extends de {
      constructor(me, ge, we) {
        super(me, ge, we), this.helperUrl = "https://helper.testnet.near.org", this.helperUrl = we.helperUrl || this.helperUrl, this.storage = we.storage, this.sendCode = we.sendCode || this.sendCodeDefault, this.getCode = we.getCode || this.getCodeDefault, this.verifyCode = we.verifyCode || this.verifyCodeDefault, this.onConfirmResult = we.onConfirmResult;
      }
      signAndSendTransaction({ receiverId: me, actions: ge }) {
        const we = Object.create(null, {
          signAndSendTransaction: { get: () => super.signAndSendTransaction }
        });
        return t(this, void 0, void 0, function* () {
          yield we.signAndSendTransaction.call(this, { receiverId: me, actions: ge }), yield this.sendCode();
          const Ee = yield this.promptAndVerify();
          return this.onConfirmResult && (yield this.onConfirmResult(Ee)), Ee;
        });
      }
      deployMultisig(me) {
        const ge = Object.create(null, {
          signAndSendTransactionWithAccount: { get: () => super.signAndSendTransactionWithAccount }
        });
        return t(this, void 0, void 0, function* () {
          const { accountId: we } = this, Ee = (yield this.getRecoveryMethods()).data.filter(({ kind: p, publicKey: x }) => (p === "phrase" || p === "ledger") && x !== null).map((p) => p.publicKey), Te = (yield this.getAccessKeys()).filter(({ public_key: p, access_key: { permission: x } }) => x === "FullAccess" && !Ee.includes(p)).map((p) => p.public_key).map(re), Ke = re((yield this.postSignedJson("/2fa/getAccessKey", { accountId: we })).publicKey), Se = Buffer.from(JSON.stringify({ num_confirmations: 2 })), X = [
            ...Te.map((p) => (0, _.deleteKey)(p)),
            ...Te.map((p) => (0, _.addKey)(p, (0, _.functionCallAccessKey)(we, l.MULTISIG_CHANGE_METHODS, null))),
            (0, _.addKey)(Ke, (0, _.functionCallAccessKey)(we, l.MULTISIG_CONFIRM_METHODS, null)),
            (0, _.deployContract)(me)
          ], fe = X.concat((0, _.functionCall)("new", Se, l.MULTISIG_GAS, l.MULTISIG_DEPOSIT));
          console.log("deploying multisig contract for", we);
          const { stateStatus: k } = yield this.checkMultisigCodeAndStateStatus(me);
          switch (k) {
            case Y.STATE_NOT_INITIALIZED:
              return yield ge.signAndSendTransactionWithAccount.call(this, we, fe);
            case Y.VALID_STATE:
              return yield ge.signAndSendTransactionWithAccount.call(this, we, X);
            case Y.INVALID_STATE:
              throw new T.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState");
            default:
              throw new T.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
          }
        });
      }
      disableWithFAK({ contractBytes: me, cleanupContractBytes: ge }) {
        return t(this, void 0, void 0, function* () {
          let we = [];
          ge && (yield this.deleteAllRequests().catch((Se) => Se), we = yield this.get2faDisableCleanupActions(ge));
          const Ee = yield this.get2faDisableKeyConversionActions(), Te = [
            ...we,
            ...Ee,
            (0, _.deployContract)(me)
          ], Ke = yield this.findAccessKey(this.accountId, Te);
          if (Ke && Ke.accessKey && Ke.accessKey.permission !== "FullAccess")
            throw new T.TypedError("No full access key found in keystore. Unable to bypass multisig", "NoFAKFound");
          return this.signAndSendTransactionWithAccount(this.accountId, Te);
        });
      }
      get2faDisableCleanupActions(me) {
        return t(this, void 0, void 0, function* () {
          const ge = yield this.viewState("").catch((Ee) => {
            const Te = Ee.cause && Ee.cause.name;
            if (Te == "NO_CONTRACT_CODE")
              return [];
            throw Te == "TOO_LARGE_CONTRACT_STATE" ? new T.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState") : Ee;
          }), we = ge.map(({ key: Ee }) => Ee.toString("base64"));
          return ge.length ? [
            (0, _.deployContract)(me),
            (0, _.functionCall)("clean", { keys: we }, l.MULTISIG_GAS, new h.default("0"))
          ] : [];
        });
      }
      get2faDisableKeyConversionActions() {
        return t(this, void 0, void 0, function* () {
          const { accountId: me } = this, we = (yield this.getAccessKeys()).filter(({ access_key: Te }) => Te.permission !== "FullAccess").filter(({ access_key: Te }) => {
            const Ke = Te.permission.FunctionCall;
            return Ke.receiver_id === me && Ke.method_names.length === 4 && Ke.method_names.includes("add_request_and_confirm");
          }), Ee = v.PublicKey.from((yield this.postSignedJson("/2fa/getAccessKey", { accountId: me })).publicKey);
          return [
            (0, _.deleteKey)(Ee),
            ...we.map(({ public_key: Te }) => (0, _.deleteKey)(v.PublicKey.from(Te))),
            ...we.map(({ public_key: Te }) => (0, _.addKey)(v.PublicKey.from(Te), (0, _.fullAccessKey)()))
          ];
        });
      }
      disable(me, ge) {
        return t(this, void 0, void 0, function* () {
          const { stateStatus: we } = yield this.checkMultisigCodeAndStateStatus();
          if (we !== Y.VALID_STATE && we !== Y.STATE_NOT_INITIALIZED)
            throw new T.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
          let Ee;
          yield this.deleteAllRequests().catch((Se) => Ee = Se);
          const Ke = [
            ...yield this.get2faDisableCleanupActions(ge).catch((Se) => {
              throw Se.type === "ContractHasExistingState" && Ee || Se;
            }),
            ...yield this.get2faDisableKeyConversionActions(),
            (0, _.deployContract)(me)
          ];
          return console.log("disabling 2fa for", this.accountId), yield this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: Ke
          });
        });
      }
      sendCodeDefault() {
        return t(this, void 0, void 0, function* () {
          const { accountId: me } = this, { requestId: ge } = this.getRequest(), we = yield this.get2faMethod();
          return yield this.postSignedJson("/2fa/send", {
            accountId: me,
            method: we,
            requestId: ge
          }), ge;
        });
      }
      getCodeDefault() {
        return t(this, void 0, void 0, function* () {
          throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is "email" or "phone".');
        });
      }
      promptAndVerify() {
        return t(this, void 0, void 0, function* () {
          const me = yield this.get2faMethod(), ge = yield this.getCode(me);
          try {
            return yield this.verifyCode(ge);
          } catch (we) {
            if (console.warn("Error validating security code:", we), we.toString().includes("invalid 2fa code provided") || we.toString().includes("2fa code not valid"))
              return yield this.promptAndVerify();
            throw we;
          }
        });
      }
      verifyCodeDefault(me) {
        return t(this, void 0, void 0, function* () {
          const { accountId: ge } = this, we = this.getRequest();
          if (!we)
            throw new Error("no request pending");
          const { requestId: Ee } = we;
          return yield this.postSignedJson("/2fa/verify", {
            accountId: ge,
            securityCode: me,
            requestId: Ee
          });
        });
      }
      getRecoveryMethods() {
        return t(this, void 0, void 0, function* () {
          const { accountId: me } = this;
          return {
            accountId: me,
            data: yield this.postSignedJson("/account/recoveryMethods", { accountId: me })
          };
        });
      }
      get2faMethod() {
        return t(this, void 0, void 0, function* () {
          let { data: me } = yield this.getRecoveryMethods();
          if (me && me.length && (me = me.find((Ee) => Ee.kind.indexOf("2fa-") === 0)), !me)
            return null;
          const { kind: ge, detail: we } = me;
          return { kind: ge, detail: we };
        });
      }
      signatureFor() {
        return t(this, void 0, void 0, function* () {
          const { accountId: me } = this, we = (yield this.connection.provider.block({ finality: "final" })).header.height.toString(), Ee = yield this.connection.signer.signMessage(Buffer.from(we), me, this.connection.networkId), Te = Buffer.from(Ee.signature).toString("base64");
          return { blockNumber: we, blockNumberSignature: Te };
        });
      }
      postSignedJson(me, ge) {
        return t(this, void 0, void 0, function* () {
          return yield (0, z.fetchJson)(this.helperUrl + me, JSON.stringify(Object.assign(Object.assign({}, ge), yield this.signatureFor())));
        });
      }
    }
    l.Account2FA = ce;
    const re = (ae) => v.PublicKey.from(ae), oe = (ae) => ae.toString().replace("ed25519:", ""), pe = (ae, me, ge) => ae.map((we) => {
      const Ee = we.enum, { gas: Te, publicKey: Ke, methodName: Se, args: X, deposit: fe, accessKey: k, code: p } = we[Ee], x = {
        type: Ee[0].toUpperCase() + Ee.substr(1),
        gas: Te && Te.toString() || void 0,
        public_key: Ke && oe(Ke) || void 0,
        method_name: Se,
        args: X && Buffer.from(X).toString("base64") || void 0,
        code: p && Buffer.from(p).toString("base64") || void 0,
        amount: fe && fe.toString() || void 0,
        deposit: fe && fe.toString() || "0",
        permission: void 0
      };
      if (k && (ge === me && k.permission.enum !== "fullAccess" && (x.permission = {
        receiver_id: me,
        allowance: l.MULTISIG_ALLOWANCE.toString(),
        method_names: l.MULTISIG_CHANGE_METHODS
      }), k.permission.enum === "functionCall")) {
        const { receiverId: S, methodNames: B, allowance: L } = k.permission.functionCall;
        x.permission = {
          receiver_id: S,
          allowance: L && L.toString() || void 0,
          method_names: B
        };
      }
      return x;
    });
  }(account_multisig)), account_multisig;
}
var account_creator = {}, hasRequiredAccount_creator;
function requireAccount_creator() {
  if (hasRequiredAccount_creator)
    return account_creator;
  hasRequiredAccount_creator = 1;
  var l = commonjsGlobal && commonjsGlobal.__awaiter || function(d, v, _, T) {
    function z(J) {
      return J instanceof _ ? J : new _(function(Y) {
        Y(J);
      });
    }
    return new (_ || (_ = Promise))(function(J, Y) {
      function ie(ce) {
        try {
          de(T.next(ce));
        } catch (re) {
          Y(re);
        }
      }
      function ne(ce) {
        try {
          de(T.throw(ce));
        } catch (re) {
          Y(re);
        }
      }
      function de(ce) {
        ce.done ? J(ce.value) : z(ce.value).then(ie, ne);
      }
      de((T = T.apply(d, v || [])).next());
    });
  };
  Object.defineProperty(account_creator, "__esModule", { value: !0 }), account_creator.UrlAccountCreator = account_creator.LocalAccountCreator = account_creator.AccountCreator = void 0;
  const t = requireWeb();
  class s {
  }
  account_creator.AccountCreator = s;
  class h extends s {
    constructor(v, _) {
      super(), this.masterAccount = v, this.initialBalance = _;
    }
    createAccount(v, _) {
      return l(this, void 0, void 0, function* () {
        yield this.masterAccount.createAccount(v, _, this.initialBalance);
      });
    }
  }
  account_creator.LocalAccountCreator = h;
  class m extends s {
    constructor(v, _) {
      super(), this.connection = v, this.helperUrl = _;
    }
    createAccount(v, _) {
      return l(this, void 0, void 0, function* () {
        yield (0, t.fetchJson)(`${this.helperUrl}/account`, JSON.stringify({ newAccountId: v, newAccountPublicKey: _.toString() }));
      });
    }
  }
  return account_creator.UrlAccountCreator = m, account_creator;
}
var connection = {}, signer = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
}, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(l) {
  return l && l.__esModule ? l : { default: l };
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.InMemorySigner = signer.Signer = void 0;
const js_sha256_1 = __importDefault(sha256$1.exports), key_pair_1 = key_pair, in_memory_key_store_1 = in_memory_key_store;
class Signer {
}
signer.Signer = Signer;
class InMemorySigner extends Signer {
  constructor(t) {
    super(), this.keyStore = t;
  }
  static fromKeyPair(t, s, h) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const m = new in_memory_key_store_1.InMemoryKeyStore();
      return yield m.setKey(t, s, h), new InMemorySigner(m);
    });
  }
  createKey(t, s) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const h = key_pair_1.KeyPair.fromRandom("ed25519");
      return yield this.keyStore.setKey(s, t, h), h.getPublicKey();
    });
  }
  getPublicKey(t, s) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const h = yield this.keyStore.getKey(s, t);
      return h === null ? null : h.getPublicKey();
    });
  }
  signMessage(t, s, h) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const m = new Uint8Array(js_sha256_1.default.sha256.array(t));
      if (!s)
        throw new Error("InMemorySigner requires provided account id");
      const d = yield this.keyStore.getKey(h, s);
      if (d === null)
        throw new Error(`Key for ${s} not found in ${h}`);
      return d.sign(m);
    });
  }
  toString() {
    return `InMemorySigner(${this.keyStore})`;
  }
}
signer.InMemorySigner = InMemorySigner;
var hasRequiredConnection;
function requireConnection() {
  if (hasRequiredConnection)
    return connection;
  hasRequiredConnection = 1, Object.defineProperty(connection, "__esModule", { value: !0 }), connection.Connection = void 0;
  const l = requireProviders(), t = signer;
  function s(d) {
    switch (d.type) {
      case void 0:
        return d;
      case "JsonRpcProvider":
        return new l.JsonRpcProvider(Object.assign({}, d.args));
      default:
        throw new Error(`Unknown provider type ${d.type}`);
    }
  }
  function h(d) {
    switch (d.type) {
      case void 0:
        return d;
      case "InMemorySigner":
        return new t.InMemorySigner(d.keyStore);
      default:
        throw new Error(`Unknown signer type ${d.type}`);
    }
  }
  class m {
    constructor(v, _, T, z) {
      this.networkId = v, this.provider = _, this.signer = T, this.jsvmAccountId = z;
    }
    static fromConfig(v) {
      const _ = s(v.provider), T = h(v.signer);
      return new m(v.networkId, _, T, v.jsvmAccountId);
    }
  }
  return connection.Connection = m, connection;
}
var contract = {}, hasRequiredContract;
function requireContract() {
  if (hasRequiredContract)
    return contract;
  hasRequiredContract = 1;
  var l = commonjsGlobal && commonjsGlobal.__awaiter || function(Y, ie, ne, de) {
    function ce(re) {
      return re instanceof ne ? re : new ne(function(oe) {
        oe(re);
      });
    }
    return new (ne || (ne = Promise))(function(re, oe) {
      function pe(ge) {
        try {
          me(de.next(ge));
        } catch (we) {
          oe(we);
        }
      }
      function ae(ge) {
        try {
          me(de.throw(ge));
        } catch (we) {
          oe(we);
        }
      }
      function me(ge) {
        ge.done ? re(ge.value) : ce(ge.value).then(pe, ae);
      }
      me((de = de.apply(Y, ie || [])).next());
    });
  }, t = commonjsGlobal && commonjsGlobal.__importDefault || function(Y) {
    return Y && Y.__esModule ? Y : { default: Y };
  };
  Object.defineProperty(contract, "__esModule", { value: !0 }), contract.Contract = void 0;
  const s = t(bn$1.exports), h = t(browser$2), m = requireProviders(), d = errors;
  function v(Y, ie) {
    return {
      [Y](...ne) {
        return ie(...ne);
      }
    }[Y];
  }
  const _ = (Y) => Y && Y.byteLength !== void 0 && Y.byteLength === Y.length, T = (Y) => Object.prototype.toString.call(Y) === "[object Object]";
  class z {
    constructor(ie, ne, de) {
      this.account = ie, this.contractId = ne;
      const { viewMethods: ce = [], changeMethods: re = [] } = de;
      ce.forEach((oe) => {
        Object.defineProperty(this, oe, {
          writable: !1,
          enumerable: !0,
          value: v(oe, (pe = {}, ae = {}, ...me) => l(this, void 0, void 0, function* () {
            if (me.length || !(T(pe) || _(pe)) || !T(ae))
              throw new d.PositionalArgsError();
            return this.account.viewFunction(this.contractId, oe, pe, ae);
          }))
        });
      }), re.forEach((oe) => {
        Object.defineProperty(this, oe, {
          writable: !1,
          enumerable: !0,
          value: v(oe, (...pe) => l(this, void 0, void 0, function* () {
            if (pe.length && (pe.length > 3 || !(T(pe[0]) || _(pe[0]))))
              throw new d.PositionalArgsError();
            return pe.length > 1 || !(pe[0] && pe[0].args) ? ((0, h.default)("contract.methodName(args, gas, amount)")("use `contract.methodName({ args, gas?, amount?, callbackUrl?, meta? })` instead"), this._changeMethod({
              methodName: oe,
              args: pe[0],
              gas: pe[1],
              amount: pe[2]
            })) : this._changeMethod(Object.assign({ methodName: oe }, pe[0]));
          }))
        });
      });
    }
    _changeMethod({ args: ie, methodName: ne, gas: de, amount: ce, meta: re, callbackUrl: oe }) {
      return l(this, void 0, void 0, function* () {
        J({ gas: de, amount: ce });
        const pe = yield this.account.functionCall({
          contractId: this.contractId,
          methodName: ne,
          args: ie,
          gas: de,
          attachedDeposit: ce,
          walletMeta: re,
          walletCallbackUrl: oe
        });
        return (0, m.getTransactionLastResult)(pe);
      });
    }
  }
  contract.Contract = z;
  function J(Y) {
    const ie = "number, decimal string or BN";
    for (const ne of Object.keys(Y)) {
      const de = Y[ne];
      if (de && !s.default.isBN(de) && isNaN(de))
        throw new d.ArgumentTypeError(ne, ie, de);
    }
  }
  return contract;
}
var near = {}, hasRequiredNear;
function requireNear() {
  if (hasRequiredNear)
    return near;
  hasRequiredNear = 1;
  var l = commonjsGlobal && commonjsGlobal.__awaiter || function(_, T, z, J) {
    function Y(ie) {
      return ie instanceof z ? ie : new z(function(ne) {
        ne(ie);
      });
    }
    return new (z || (z = Promise))(function(ie, ne) {
      function de(oe) {
        try {
          re(J.next(oe));
        } catch (pe) {
          ne(pe);
        }
      }
      function ce(oe) {
        try {
          re(J.throw(oe));
        } catch (pe) {
          ne(pe);
        }
      }
      function re(oe) {
        oe.done ? ie(oe.value) : Y(oe.value).then(de, ce);
      }
      re((J = J.apply(_, T || [])).next());
    });
  }, t = commonjsGlobal && commonjsGlobal.__importDefault || function(_) {
    return _ && _.__esModule ? _ : { default: _ };
  };
  Object.defineProperty(near, "__esModule", { value: !0 }), near.Near = void 0;
  const s = t(bn$1.exports), h = requireAccount(), m = requireConnection(), d = requireAccount_creator();
  class v {
    constructor(T) {
      if (this.config = T, this.connection = m.Connection.fromConfig({
        networkId: T.networkId,
        provider: { type: "JsonRpcProvider", args: { url: T.nodeUrl, headers: T.headers } },
        signer: T.signer || { type: "InMemorySigner", keyStore: T.keyStore },
        jsvmAccountId: T.jsvmAccountId || `jsvm.${T.networkId}`
      }), T.masterAccount) {
        const z = T.initialBalance ? new s.default(T.initialBalance) : new s.default("500000000000000000000000000");
        this.accountCreator = new d.LocalAccountCreator(new h.Account(this.connection, T.masterAccount), z);
      } else
        T.helperUrl ? this.accountCreator = new d.UrlAccountCreator(this.connection, T.helperUrl) : this.accountCreator = null;
    }
    account(T) {
      return l(this, void 0, void 0, function* () {
        return new h.Account(this.connection, T);
      });
    }
    createAccount(T, z) {
      return l(this, void 0, void 0, function* () {
        if (!this.accountCreator)
          throw new Error("Must specify account creator, either via masterAccount or helperUrl configuration settings.");
        return yield this.accountCreator.createAccount(T, z), new h.Account(this.connection, T);
      });
    }
  }
  return near.Near = v, near;
}
var walletAccount = {}, hasRequiredWalletAccount;
function requireWalletAccount() {
  if (hasRequiredWalletAccount)
    return walletAccount;
  hasRequiredWalletAccount = 1;
  var l = commonjsGlobal && commonjsGlobal.__awaiter || function(de, ce, re, oe) {
    function pe(ae) {
      return ae instanceof re ? ae : new re(function(me) {
        me(ae);
      });
    }
    return new (re || (re = Promise))(function(ae, me) {
      function ge(Te) {
        try {
          Ee(oe.next(Te));
        } catch (Ke) {
          me(Ke);
        }
      }
      function we(Te) {
        try {
          Ee(oe.throw(Te));
        } catch (Ke) {
          me(Ke);
        }
      }
      function Ee(Te) {
        Te.done ? ae(Te.value) : pe(Te.value).then(ge, we);
      }
      Ee((oe = oe.apply(de, ce || [])).next());
    });
  }, t = commonjsGlobal && commonjsGlobal.__importDefault || function(de) {
    return de && de.__esModule ? de : { default: de };
  };
  Object.defineProperty(walletAccount, "__esModule", { value: !0 }), walletAccount.ConnectedWalletAccount = walletAccount.WalletConnection = void 0;
  const s = requireAccount(), h = transaction, m = requireUtils(), d = lib$4, v = lib$4, _ = t(bn$1.exports), T = "/login/", z = "add_request_and_confirm", J = "_wallet_auth_key", Y = "pending_key";
  class ie {
    constructor(ce, re) {
      if (typeof window > "u")
        return new Proxy(this, {
          get(ae, me) {
            return me === "isSignedIn" ? () => !1 : me === "getAccountId" ? () => "" : ae[me] && typeof ae[me] == "function" ? () => {
              throw new Error("No window found in context, please ensure you are using WalletConnection on the browser");
            } : ae[me];
          }
        });
      this._near = ce;
      const oe = re + J, pe = JSON.parse(window.localStorage.getItem(oe));
      this._networkId = ce.config.networkId, this._walletBaseUrl = ce.config.walletUrl, re = re || ce.config.contractName || "default", this._keyStore = ce.connection.signer.keyStore, this._authData = pe || { allKeys: [] }, this._authDataKey = oe, this.isSignedIn() || (this._completeSignInPromise = this._completeSignInWithAccessKey());
    }
    isSignedIn() {
      return !!this._authData.accountId;
    }
    isSignedInAsync() {
      return l(this, void 0, void 0, function* () {
        return this._completeSignInPromise ? (yield this._completeSignInPromise, this.isSignedIn()) : this.isSignedIn();
      });
    }
    getAccountId() {
      return this._authData.accountId || "";
    }
    requestSignIn({ contractId: ce, methodNames: re, successUrl: oe, failureUrl: pe }) {
      return l(this, void 0, void 0, function* () {
        const ae = new URL(window.location.href), me = new URL(this._walletBaseUrl + T);
        if (me.searchParams.set("success_url", oe || ae.href), me.searchParams.set("failure_url", pe || ae.href), ce) {
          yield (yield this._near.account(ce)).state(), me.searchParams.set("contract_id", ce);
          const we = m.KeyPair.fromRandom("ed25519");
          me.searchParams.set("public_key", we.getPublicKey().toString()), yield this._keyStore.setKey(this._networkId, Y + we.getPublicKey(), we);
        }
        re && re.forEach((ge) => {
          me.searchParams.append("methodNames", ge);
        }), window.location.assign(me.toString());
      });
    }
    requestSignTransactions({ transactions: ce, meta: re, callbackUrl: oe }) {
      return l(this, void 0, void 0, function* () {
        const pe = new URL(window.location.href), ae = new URL("sign", this._walletBaseUrl);
        ae.searchParams.set("transactions", ce.map((me) => (0, v.serialize)(h.SCHEMA, me)).map((me) => Buffer.from(me).toString("base64")).join(",")), ae.searchParams.set("callbackUrl", oe || pe.href), re && ae.searchParams.set("meta", re), window.location.assign(ae.toString());
      });
    }
    _completeSignInWithAccessKey() {
      return l(this, void 0, void 0, function* () {
        const ce = new URL(window.location.href), re = ce.searchParams.get("public_key") || "", oe = (ce.searchParams.get("all_keys") || "").split(","), pe = ce.searchParams.get("account_id") || "";
        if (pe) {
          const ae = {
            accountId: pe,
            allKeys: oe
          };
          window.localStorage.setItem(this._authDataKey, JSON.stringify(ae)), re && (yield this._moveKeyFromTempToPermanent(pe, re)), this._authData = ae;
        }
        ce.searchParams.delete("public_key"), ce.searchParams.delete("all_keys"), ce.searchParams.delete("account_id"), ce.searchParams.delete("meta"), ce.searchParams.delete("transactionHashes"), window.history.replaceState({}, document.title, ce.toString());
      });
    }
    _moveKeyFromTempToPermanent(ce, re) {
      return l(this, void 0, void 0, function* () {
        const oe = yield this._keyStore.getKey(this._networkId, Y + re);
        yield this._keyStore.setKey(this._networkId, ce, oe), yield this._keyStore.removeKey(this._networkId, Y + re);
      });
    }
    signOut() {
      this._authData = {}, window.localStorage.removeItem(this._authDataKey);
    }
    account() {
      return this._connectedAccount || (this._connectedAccount = new ne(this, this._near.connection, this._authData.accountId)), this._connectedAccount;
    }
  }
  walletAccount.WalletConnection = ie;
  class ne extends s.Account {
    constructor(ce, re, oe) {
      super(re, oe), this.walletConnection = ce;
    }
    signAndSendTransaction({ receiverId: ce, actions: re, walletMeta: oe, walletCallbackUrl: pe = window.location.href }) {
      const ae = Object.create(null, {
        signAndSendTransaction: { get: () => super.signAndSendTransaction }
      });
      return l(this, void 0, void 0, function* () {
        const me = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
        let ge = yield this.accessKeyForTransaction(ce, re, me);
        if (!ge)
          throw new Error(`Cannot find matching key for transaction sent to ${ce}`);
        if (me && me.toString() === ge.public_key)
          try {
            return yield ae.signAndSendTransaction.call(this, { receiverId: ce, actions: re });
          } catch (X) {
            if (X.type === "NotEnoughAllowance")
              ge = yield this.accessKeyForTransaction(ce, re);
            else
              throw X;
          }
        const we = yield this.connection.provider.block({ finality: "final" }), Ee = (0, d.baseDecode)(we.header.hash), Te = m.PublicKey.from(ge.public_key), Ke = ge.access_key.nonce.add(new _.default(1)), Se = (0, h.createTransaction)(this.accountId, Te, ce, Ke, re, Ee);
        return yield this.walletConnection.requestSignTransactions({
          transactions: [Se],
          meta: oe,
          callbackUrl: pe
        }), new Promise((X, fe) => {
          setTimeout(() => {
            fe(new Error("Failed to redirect to sign transaction"));
          }, 1e3);
        });
      });
    }
    accessKeyMatchesTransaction(ce, re, oe) {
      return l(this, void 0, void 0, function* () {
        const { access_key: { permission: pe } } = ce;
        if (pe === "FullAccess")
          return !0;
        if (pe.FunctionCall) {
          const { receiver_id: ae, method_names: me } = pe.FunctionCall;
          if (ae === this.accountId && me.includes(z))
            return !0;
          if (ae === re) {
            if (oe.length !== 1)
              return !1;
            const [{ functionCall: ge }] = oe;
            return ge && (!ge.deposit || ge.deposit.toString() === "0") && (me.length === 0 || me.includes(ge.methodName));
          }
        }
        return !1;
      });
    }
    accessKeyForTransaction(ce, re, oe) {
      return l(this, void 0, void 0, function* () {
        const pe = yield this.getAccessKeys();
        if (oe) {
          const me = pe.find((ge) => ge.public_key.toString() === oe.toString());
          if (me && (yield this.accessKeyMatchesTransaction(me, ce, re)))
            return me;
        }
        const ae = this.walletConnection._authData.allKeys;
        for (const me of pe)
          if (ae.indexOf(me.public_key) !== -1 && (yield this.accessKeyMatchesTransaction(me, ce, re)))
            return me;
        return null;
      });
    }
  }
  return walletAccount.ConnectedWalletAccount = ne, walletAccount;
}
var hasRequiredCommonIndex;
function requireCommonIndex() {
  return hasRequiredCommonIndex || (hasRequiredCommonIndex = 1, function(l) {
    var t = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(oe, pe, ae, me) {
      me === void 0 && (me = ae);
      var ge = Object.getOwnPropertyDescriptor(pe, ae);
      (!ge || ("get" in ge ? !pe.__esModule : ge.writable || ge.configurable)) && (ge = { enumerable: !0, get: function() {
        return pe[ae];
      } }), Object.defineProperty(oe, me, ge);
    } : function(oe, pe, ae, me) {
      me === void 0 && (me = ae), oe[me] = pe[ae];
    }), s = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(oe, pe) {
      Object.defineProperty(oe, "default", { enumerable: !0, value: pe });
    } : function(oe, pe) {
      oe.default = pe;
    }), h = commonjsGlobal && commonjsGlobal.__importStar || function(oe) {
      if (oe && oe.__esModule)
        return oe;
      var pe = {};
      if (oe != null)
        for (var ae in oe)
          ae !== "default" && Object.prototype.hasOwnProperty.call(oe, ae) && t(pe, oe, ae);
      return s(pe, oe), pe;
    };
    Object.defineProperty(l, "__esModule", { value: !0 }), l.WalletConnection = l.ConnectedWalletAccount = l.Near = l.KeyPair = l.Signer = l.InMemorySigner = l.Contract = l.Connection = l.Account = l.multisig = l.validators = l.transactions = l.utils = l.providers = l.accountCreator = void 0;
    const m = h(requireProviders());
    l.providers = m;
    const d = h(requireUtils());
    l.utils = d;
    const v = h(transaction);
    l.transactions = v;
    const _ = h(validators);
    l.validators = _;
    const T = requireAccount();
    Object.defineProperty(l, "Account", { enumerable: !0, get: function() {
      return T.Account;
    } });
    const z = h(requireAccount_multisig());
    l.multisig = z;
    const J = h(requireAccount_creator());
    l.accountCreator = J;
    const Y = requireConnection();
    Object.defineProperty(l, "Connection", { enumerable: !0, get: function() {
      return Y.Connection;
    } });
    const ie = signer;
    Object.defineProperty(l, "Signer", { enumerable: !0, get: function() {
      return ie.Signer;
    } }), Object.defineProperty(l, "InMemorySigner", { enumerable: !0, get: function() {
      return ie.InMemorySigner;
    } });
    const ne = requireContract();
    Object.defineProperty(l, "Contract", { enumerable: !0, get: function() {
      return ne.Contract;
    } });
    const de = key_pair;
    Object.defineProperty(l, "KeyPair", { enumerable: !0, get: function() {
      return de.KeyPair;
    } });
    const ce = requireNear();
    Object.defineProperty(l, "Near", { enumerable: !0, get: function() {
      return ce.Near;
    } });
    const re = requireWalletAccount();
    Object.defineProperty(l, "ConnectedWalletAccount", { enumerable: !0, get: function() {
      return re.ConnectedWalletAccount;
    } }), Object.defineProperty(l, "WalletConnection", { enumerable: !0, get: function() {
      return re.WalletConnection;
    } });
  }(commonIndex)), commonIndex;
}
var browserConnect = {}, __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(l, t, s, h) {
  function m(d) {
    return d instanceof s ? d : new s(function(v) {
      v(d);
    });
  }
  return new (s || (s = Promise))(function(d, v) {
    function _(J) {
      try {
        z(h.next(J));
      } catch (Y) {
        v(Y);
      }
    }
    function T(J) {
      try {
        z(h.throw(J));
      } catch (Y) {
        v(Y);
      }
    }
    function z(J) {
      J.done ? d(J.value) : m(J.value).then(_, T);
    }
    z((h = h.apply(l, t || [])).next());
  });
};
Object.defineProperty(browserConnect, "__esModule", { value: !0 });
browserConnect.connect = void 0;
const near_1 = requireNear();
function connect(l) {
  return __awaiter(this, void 0, void 0, function* () {
    return new near_1.Near(l);
  });
}
browserConnect.connect = connect;
var errorPolyfill = { exports: {} }, capability$3 = { exports: {} }, CapabilityDetector$1 = function() {
  this.tests = {}, this.cache = {};
};
CapabilityDetector$1.prototype = {
  constructor: CapabilityDetector$1,
  define: function(l, t) {
    if (typeof l != "string" || !(t instanceof Function))
      throw new Error("Invalid capability definition.");
    if (this.tests[l])
      throw new Error('Duplicated capability definition by "' + l + '".');
    this.tests[l] = t;
  },
  check: function(l) {
    if (!this.test(l))
      throw new Error('The current environment does not support "' + l + '", therefore we cannot continue.');
  },
  test: function(l) {
    if (this.cache[l] !== void 0)
      return this.cache[l];
    if (!this.tests[l])
      throw new Error('Unknown capability with name "' + l + '".');
    var t = this.tests[l];
    return this.cache[l] = !!t(), this.cache[l];
  }
};
var CapabilityDetector_1 = CapabilityDetector$1, CapabilityDetector = CapabilityDetector_1, detector = new CapabilityDetector(), capability$2 = function(l) {
  return detector.test(l);
};
capability$2.define = function(l, t) {
  detector.define(l, t);
};
capability$2.check = function(l) {
  detector.check(l);
};
capability$2.test = capability$2;
var lib$3 = capability$2, capability$1 = lib$3, define$1 = capability$1.define, test = capability$1.test;
define$1("strict mode", function() {
  return this === void 0;
});
define$1("arguments.callee.caller", function() {
  try {
    return function() {
      return arguments.callee.caller;
    }() === arguments.callee;
  } catch {
    return !1;
  }
});
define$1("es5", function() {
  return test("Array.prototype.forEach") && test("Array.prototype.map") && test("Function.prototype.bind") && test("Object.create") && test("Object.defineProperties") && test("Object.defineProperty") && test("Object.prototype.hasOwnProperty");
});
define$1("Array.prototype.forEach", function() {
  return Array.prototype.forEach;
});
define$1("Array.prototype.map", function() {
  return Array.prototype.map;
});
define$1("Function.prototype.bind", function() {
  return Function.prototype.bind;
});
define$1("Object.create", function() {
  return Object.create;
});
define$1("Object.defineProperties", function() {
  return Object.defineProperties;
});
define$1("Object.defineProperty", function() {
  return Object.defineProperty;
});
define$1("Object.prototype.hasOwnProperty", function() {
  return Object.prototype.hasOwnProperty;
});
define$1("Error.captureStackTrace", function() {
  return Error.captureStackTrace;
});
define$1("Error.prototype.stack", function() {
  try {
    throw new Error();
  } catch (l) {
    return l.stack || l.stacktrace;
  }
});
(function(l) {
  l.exports = lib$3;
})(capability$3);
capability$3.exports.check("es5");
var prepareStackTrace_1, hasRequiredPrepareStackTrace;
function requirePrepareStackTrace() {
  if (hasRequiredPrepareStackTrace)
    return prepareStackTrace_1;
  hasRequiredPrepareStackTrace = 1;
  var l = function(t, s, h) {
    var m = "";
    if (m += t.name || "Error", m += ": " + (t.message || ""), h instanceof Array)
      for (var d in h) {
        var v = h[d];
        m += `
   # ` + v;
      }
    for (var _ in s) {
      var T = s[_];
      m += `
   at ` + T.toString();
    }
    return m;
  };
  return prepareStackTrace_1 = l, prepareStackTrace_1;
}
var v8, hasRequiredV8;
function requireV8() {
  if (hasRequiredV8)
    return v8;
  hasRequiredV8 = 1;
  var l = requirePrepareStackTrace();
  return v8 = function() {
    return Error.getStackTrace = function(t) {
      return t.stack;
    }, {
      prepareStackTrace: l
    };
  }, v8;
}
var o3 = { exports: {} }, Class_1, hasRequiredClass;
function requireClass() {
  if (hasRequiredClass)
    return Class_1;
  hasRequiredClass = 1;
  var l = function() {
    var t = /* @__PURE__ */ Object.create({
      Source: Object,
      config: {},
      buildArgs: []
    });
    function s(T) {
      var z = "config";
      if (T instanceof Function)
        z = "Source";
      else if (T instanceof Array)
        z = "buildArgs";
      else if (T instanceof Object)
        z = "config";
      else
        throw new Error("Invalid configuration option.");
      if (t.hasOwnProperty(z))
        throw new Error("Duplicated configuration option: " + z + ".");
      t[z] = T;
    }
    for (var h = 0, m = arguments.length; h < m; ++h)
      s(arguments[h]);
    var d = t.Source, v = t.config, _ = t.buildArgs;
    return (d.extend || l.extend).call(d, v, _);
  };
  return l.factory = function() {
    return function() {
      var t = this;
      t.build instanceof Function && t.build.apply(t, arguments), t.init instanceof Function && t.init.apply(t, arguments);
    };
  }, l.extend = function(t, s) {
    var h = this;
    t || (t = {});
    var m;
    return t.prototype instanceof Object && t.prototype.constructor !== Object ? m = t.prototype.constructor : t.factory instanceof Function && (m = t.factory.call(h)), m = (h.clone || l.clone).call(h, m, s), (m.merge || l.merge).call(m, t), m;
  }, l.prototype.extend = function(t, s) {
    var h = this, m = (h.clone || l.prototype.clone).apply(h, s);
    return (m.merge || l.prototype.merge).call(m, t), m;
  }, l.clone = function(t, s) {
    var h = this;
    t instanceof Function || (t = (h.factory || l.factory).call(h)), t.prototype = (h.prototype.clone || l.prototype.clone).apply(h.prototype, s || []), t.prototype.constructor = t;
    for (var m in h)
      m !== "prototype" && (t[m] = h[m]);
    return t;
  }, l.prototype.clone = function() {
    var t = this, s = Object.create(t);
    return s.build instanceof Function && s.build.apply(s, arguments), s;
  }, l.merge = function(t) {
    var s = this;
    for (var h in t)
      h !== "prototype" && (s[h] = t[h]);
    return t.prototype instanceof Object && (s.prototype.merge || l.prototype.merge).call(s.prototype, t.prototype), s;
  }, l.prototype.merge = function(t) {
    var s = this;
    for (var h in t)
      h !== "constructor" && (s[h] = t[h]);
    return s;
  }, l.absorb = function(t) {
    var s = this;
    for (var h in t)
      h !== "prototype" && (s[h] === void 0 || s[h] === Function.prototype[h]) && (s[h] = t[h]);
    return t.prototype instanceof Object && (s.prototype.absorb || l.prototype.absorb).call(s.prototype, t.prototype), s;
  }, l.prototype.absorb = function(t) {
    var s = this;
    for (var h in t)
      h !== "constructor" && (s[h] === void 0 || s[h] === Object.prototype[h]) && (s[h] = t[h]);
    return s;
  }, l.getAncestor = function() {
    var t = this;
    if (t !== t.prototype.constructor)
      return t.prototype.constructor;
  }, l.newInstance = function() {
    var t = this, s = Object.create(this.prototype);
    return t.apply(s, arguments), s;
  }, Class_1 = l, Class_1;
}
var abstractMethod, hasRequiredAbstractMethod;
function requireAbstractMethod() {
  return hasRequiredAbstractMethod || (hasRequiredAbstractMethod = 1, abstractMethod = function() {
    throw new Error("Not implemented.");
  }), abstractMethod;
}
var lib$2, hasRequiredLib$1;
function requireLib$1() {
  return hasRequiredLib$1 || (hasRequiredLib$1 = 1, lib$2 = {
    Class: requireClass(),
    abstractMethod: requireAbstractMethod()
  }), lib$2;
}
var hasRequiredO3;
function requireO3() {
  return hasRequiredO3 || (hasRequiredO3 = 1, function(l) {
    l.exports = requireLib$1();
  }(o3)), o3.exports;
}
var u3 = { exports: {} }, cache_1, hasRequiredCache;
function requireCache() {
  if (hasRequiredCache)
    return cache_1;
  hasRequiredCache = 1;
  var l = function(t) {
    var s = !1, h;
    return t instanceof Function || (s = !0, h = t, t = null), function() {
      return s || (s = !0, h = t.apply(this, arguments), t = null), h;
    };
  };
  return cache_1 = l, cache_1;
}
var eachCombination, hasRequiredEachCombination;
function requireEachCombination() {
  return hasRequiredEachCombination || (hasRequiredEachCombination = 1, eachCombination = function l(t, s, h) {
    if (h || (h = []), h.length < t.length) {
      var m = t[h.length];
      for (var d in m)
        h[h.length] = m[d], l(t, s, h), --h.length;
    } else
      s.apply(null, h);
  }), eachCombination;
}
var lib$1, hasRequiredLib;
function requireLib() {
  return hasRequiredLib || (hasRequiredLib = 1, lib$1 = {
    cache: requireCache(),
    eachCombination: requireEachCombination()
  }), lib$1;
}
var hasRequiredU3;
function requireU3() {
  return hasRequiredU3 || (hasRequiredU3 = 1, function(l) {
    l.exports = requireLib();
  }(u3)), u3.exports;
}
var FrameStringSource, hasRequiredFrameStringSource;
function requireFrameStringSource() {
  if (hasRequiredFrameStringSource)
    return FrameStringSource;
  hasRequiredFrameStringSource = 1;
  var l = requireO3().Class, t = requireO3().abstractMethod, s = requireU3().eachCombination, h = requireU3().cache, m = capability$3.exports, d = l(Object, {
    prototype: {
      captureFrameStrings: function(_) {
        var T = this.createError();
        _.unshift(this.captureFrameStrings), _.unshift(this.createError);
        var z = this.getFrameStrings(T), J = z.slice(_.length), Y = [];
        if (m("arguments.callee.caller")) {
          var ie = [
            this.createError,
            this.captureFrameStrings
          ];
          try {
            for (var ne = arguments.callee; ne = ne.caller; )
              ie.push(ne);
          } catch {
          }
          Y = ie.slice(_.length);
        }
        return {
          frameStrings: J,
          functionValues: Y
        };
      },
      getFrameStrings: function(_) {
        var T = _.message || "", z = _.name || "", J = this.getStackString(_);
        if (J !== void 0) {
          var Y = J.split(`
`), ie = 0, ne = Y.length;
          return this.hasHeader && (ie += z.split(`
`).length + T.split(`
`).length - 1), this.hasFooter && (ne -= 1), Y.slice(ie, ne);
        }
      },
      createError: t,
      getStackString: t,
      hasHeader: void 0,
      hasFooter: void 0
    }
  }), v = l(Object, {
    prototype: {
      calibrateClass: function(_) {
        return this.calibrateMethods(_) && this.calibrateEnvelope(_);
      },
      calibrateMethods: function(_) {
        try {
          s([[
            function(T) {
              return new Error(T);
            },
            function(T) {
              try {
                throw new Error(T);
              } catch (z) {
                return z;
              }
            }
          ], [
            function(T) {
              return T.stack;
            },
            function(T) {
              return T.stacktrace;
            }
          ]], function(T, z) {
            if (z(T()))
              throw {
                getStackString: z,
                createError: T
              };
          });
        } catch (T) {
          return l.merge.call(_, {
            prototype: T
          }), !0;
        }
        return !1;
      },
      calibrateEnvelope: function(_) {
        var T = _.prototype.getStackString, z = _.prototype.createError, J = T(z("marker")), Y = J.split(`
`);
        return l.merge.call(_, {
          prototype: {
            hasHeader: /marker/.test(Y[0]),
            hasFooter: Y[Y.length - 1] === ""
          }
        }), !0;
      }
    }
  });
  return FrameStringSource = {
    getClass: h(function() {
      var _;
      if (_)
        return _;
      _ = l(d, {});
      var T = new v();
      if (!T.calibrateClass(_))
        throw new Error("Cannot read Error.prototype.stack in this environment.");
      return _;
    }),
    getInstance: h(function() {
      var _ = this.getClass(), T = new _();
      return T;
    })
  }, FrameStringSource;
}
var Frame_1, hasRequiredFrame;
function requireFrame() {
  if (hasRequiredFrame)
    return Frame_1;
  hasRequiredFrame = 1;
  var l = requireO3().Class, t = requireO3().abstractMethod, s = l(Object, {
    prototype: {
      init: l.prototype.merge,
      frameString: void 0,
      toString: function() {
        return this.frameString;
      },
      functionValue: void 0,
      getThis: t,
      getTypeName: t,
      getFunction: function() {
        return this.functionValue;
      },
      getFunctionName: t,
      getMethodName: t,
      getFileName: t,
      getLineNumber: t,
      getColumnNumber: t,
      getEvalOrigin: t,
      isTopLevel: t,
      isEval: t,
      isNative: t,
      isConstructor: t
    }
  });
  return Frame_1 = s, Frame_1;
}
var FrameStringParser_1, hasRequiredFrameStringParser;
function requireFrameStringParser() {
  if (hasRequiredFrameStringParser)
    return FrameStringParser_1;
  hasRequiredFrameStringParser = 1;
  var l = requireO3().Class, t = requireFrame(), s = requireU3().cache, h = l(Object, {
    prototype: {
      stackParser: null,
      frameParser: null,
      locationParsers: null,
      constructor: function(m) {
        l.prototype.merge.call(this, m);
      },
      getFrames: function(m, d) {
        for (var v = [], _ = 0, T = m.length; _ < T; ++_)
          v[_] = this.getFrame(m[_], d[_]);
        return v;
      },
      getFrame: function(m, d) {
        var v = {
          frameString: m,
          functionValue: d
        };
        return new t(v);
      }
    }
  });
  return FrameStringParser_1 = {
    getClass: s(function() {
      return h;
    }),
    getInstance: s(function() {
      var m = this.getClass(), d = new m();
      return d;
    })
  }, FrameStringParser_1;
}
var nonV8, hasRequiredNonV8;
function requireNonV8() {
  if (hasRequiredNonV8)
    return nonV8;
  hasRequiredNonV8 = 1;
  var l = requireFrameStringSource(), t = requireFrameStringParser(), s = requireU3().cache, h = requirePrepareStackTrace();
  return nonV8 = function() {
    return Error.captureStackTrace = function m(d, v) {
      var _, T = [
        m
      ];
      v && T.push(v);
      var z = l.getInstance().captureFrameStrings(T);
      Object.defineProperties(d, {
        stack: {
          configurable: !0,
          get: s(function() {
            var J = t.getInstance().getFrames(z.frameStrings, z.functionValues);
            return (Error.prepareStackTrace || h)(d, J, _);
          })
        },
        cachedStack: {
          configurable: !0,
          writable: !0,
          enumerable: !1,
          value: !0
        }
      });
    }, Error.getStackTrace = function(m) {
      if (m.cachedStack)
        return m.stack;
      var d = l.getInstance().getFrameStrings(m), v = [], _;
      d ? v = t.getInstance().getFrames(d, []) : _ = [
        "The stack is not readable by unthrown errors in this environment."
      ];
      var T = (Error.prepareStackTrace || h)(m, v, _);
      if (d)
        try {
          Object.defineProperties(m, {
            stack: {
              configurable: !0,
              writable: !0,
              enumerable: !1,
              value: T
            },
            cachedStack: {
              configurable: !0,
              writable: !0,
              enumerable: !1,
              value: !0
            }
          });
        } catch {
        }
      return T;
    }, {
      prepareStackTrace: h
    };
  }, nonV8;
}
var unsupported, hasRequiredUnsupported;
function requireUnsupported() {
  if (hasRequiredUnsupported)
    return unsupported;
  hasRequiredUnsupported = 1;
  var l = requireU3().cache, t = requirePrepareStackTrace();
  return unsupported = function() {
    return Error.captureStackTrace = function(s, h) {
      Object.defineProperties(s, {
        stack: {
          configurable: !0,
          get: l(function() {
            return (Error.prepareStackTrace || t)(s, []);
          })
        },
        cachedStack: {
          configurable: !0,
          writable: !0,
          enumerable: !1,
          value: !0
        }
      });
    }, Error.getStackTrace = function(s) {
      if (s.cachedStack)
        return s.stack;
      var h = (Error.prepareStackTrace || t)(s, []);
      try {
        Object.defineProperties(s, {
          stack: {
            configurable: !0,
            writable: !0,
            enumerable: !1,
            value: h
          },
          cachedStack: {
            configurable: !0,
            writable: !0,
            enumerable: !1,
            value: !0
          }
        });
      } catch {
      }
      return h;
    }, {
      prepareStackTrace: t
    };
  }, unsupported;
}
var capability = capability$3.exports, polyfill;
capability("Error.captureStackTrace") ? polyfill = requireV8() : capability("Error.prototype.stack") ? polyfill = requireNonV8() : polyfill = requireUnsupported();
var lib = polyfill();
(function(l) {
  l.exports = lib;
})(errorPolyfill);
(function(l) {
  var t = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(d, v, _, T) {
    T === void 0 && (T = _);
    var z = Object.getOwnPropertyDescriptor(v, _);
    (!z || ("get" in z ? !v.__esModule : z.writable || z.configurable)) && (z = { enumerable: !0, get: function() {
      return v[_];
    } }), Object.defineProperty(d, T, z);
  } : function(d, v, _, T) {
    T === void 0 && (T = _), d[T] = v[_];
  }), s = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(d, v) {
    Object.defineProperty(d, "default", { enumerable: !0, value: v });
  } : function(d, v) {
    d.default = v;
  }), h = commonjsGlobal && commonjsGlobal.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var v = {};
    if (d != null)
      for (var _ in d)
        _ !== "default" && Object.prototype.hasOwnProperty.call(d, _) && t(v, d, _);
    return s(v, d), v;
  }, m = commonjsGlobal && commonjsGlobal.__exportStar || function(d, v) {
    for (var _ in d)
      _ !== "default" && !Object.prototype.hasOwnProperty.call(v, _) && t(v, d, _);
  };
  Object.defineProperty(l, "__esModule", { value: !0 }), l.keyStores = void 0, l.keyStores = h(browserIndex), m(requireCommonIndex(), l), m(browserConnect, l);
})(browserIndex$1);
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(l, t, s, h) {
  h === void 0 && (h = s);
  var m = Object.getOwnPropertyDescriptor(t, s);
  (!m || ("get" in m ? !t.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
    return t[s];
  } }), Object.defineProperty(l, h, m);
} : function(l, t, s, h) {
  h === void 0 && (h = s), l[h] = t[s];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(l, t) {
  Object.defineProperty(l, "default", { enumerable: !0, value: t });
} : function(l, t) {
  l.default = t;
}), __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(l) {
  if (l && l.__esModule)
    return l;
  var t = {};
  if (l != null)
    for (var s in l)
      s !== "default" && Object.prototype.hasOwnProperty.call(l, s) && __createBinding(t, l, s);
  return __setModuleDefault(t, l), t;
};
Object.defineProperty(NearProvider$1, "__esModule", { value: !0 });
NearProvider$1.NearProvider = void 0;
const face_types_1$3 = dist, ethers_1 = require$$1$3, nearAPI = __importStar(browserIndex$1);
class NearProvider {
  constructor(t) {
    this.internal = t;
  }
  async getPublicKeys() {
    return (await this.internal.getAddresses(face_types_1$3.Blockchain.NEAR)).map((s) => nearAPI.utils.PublicKey.fromString(nearAPI.utils.serialize.base_encode(Buffer.from(s, "hex"))));
  }
  async getBalance(t, s) {
    const h = await this.internal.sendRpc({
      method: face_types_1$3.JsonRpcMethod.near_get_balance,
      params: [t, s]
    });
    return ethers_1.BigNumber.from(h);
  }
  async signAndSendTransaction(t) {
    const s = {
      serializedHex: Buffer.from(nearAPI.utils.serialize.serialize(nearAPI.transactions.SCHEMA, t)).toString("hex")
    };
    return await this.internal.sendRpc({
      method: "near_broadcast_tx_async",
      params: [s]
    });
  }
}
NearProvider$1.NearProvider = NearProvider;
Object.defineProperty(Near$1, "__esModule", { value: !0 });
Near$1.Near = void 0;
const NearProvider_1 = NearProvider$1;
class Near {
  constructor(t) {
    this.internal = t;
  }
  getProvider() {
    return new NearProvider_1.NearProvider(this.internal);
  }
}
Near$1.Near = Near;
var Solana$1 = {}, SolanaProvider$1 = {}, buffer = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(l) {
  const t = base64Js, s = ieee754, h = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  l.Buffer = _, l.SlowBuffer = pe, l.INSPECT_MAX_BYTES = 50;
  const m = 2147483647;
  l.kMaxLength = m, _.TYPED_ARRAY_SUPPORT = d(), !_.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function d() {
    try {
      const Q = new Uint8Array(1), W = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(W, Uint8Array.prototype), Object.setPrototypeOf(Q, W), Q.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(_.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (!!_.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(_.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (!!_.isBuffer(this))
        return this.byteOffset;
    }
  });
  function v(Q) {
    if (Q > m)
      throw new RangeError('The value "' + Q + '" is invalid for option "size"');
    const W = new Uint8Array(Q);
    return Object.setPrototypeOf(W, _.prototype), W;
  }
  function _(Q, W, V) {
    if (typeof Q == "number") {
      if (typeof W == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Y(Q);
    }
    return T(Q, W, V);
  }
  _.poolSize = 8192;
  function T(Q, W, V) {
    if (typeof Q == "string")
      return ie(Q, W);
    if (ArrayBuffer.isView(Q))
      return de(Q);
    if (Q == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Q
      );
    if (it(Q, ArrayBuffer) || Q && it(Q.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (it(Q, SharedArrayBuffer) || Q && it(Q.buffer, SharedArrayBuffer)))
      return ce(Q, W, V);
    if (typeof Q == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const se = Q.valueOf && Q.valueOf();
    if (se != null && se !== Q)
      return _.from(se, W, V);
    const Ae = re(Q);
    if (Ae)
      return Ae;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Q[Symbol.toPrimitive] == "function")
      return _.from(Q[Symbol.toPrimitive]("string"), W, V);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Q
    );
  }
  _.from = function(Q, W, V) {
    return T(Q, W, V);
  }, Object.setPrototypeOf(_.prototype, Uint8Array.prototype), Object.setPrototypeOf(_, Uint8Array);
  function z(Q) {
    if (typeof Q != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Q < 0)
      throw new RangeError('The value "' + Q + '" is invalid for option "size"');
  }
  function J(Q, W, V) {
    return z(Q), Q <= 0 ? v(Q) : W !== void 0 ? typeof V == "string" ? v(Q).fill(W, V) : v(Q).fill(W) : v(Q);
  }
  _.alloc = function(Q, W, V) {
    return J(Q, W, V);
  };
  function Y(Q) {
    return z(Q), v(Q < 0 ? 0 : oe(Q) | 0);
  }
  _.allocUnsafe = function(Q) {
    return Y(Q);
  }, _.allocUnsafeSlow = function(Q) {
    return Y(Q);
  };
  function ie(Q, W) {
    if ((typeof W != "string" || W === "") && (W = "utf8"), !_.isEncoding(W))
      throw new TypeError("Unknown encoding: " + W);
    const V = ae(Q, W) | 0;
    let se = v(V);
    const Ae = se.write(Q, W);
    return Ae !== V && (se = se.slice(0, Ae)), se;
  }
  function ne(Q) {
    const W = Q.length < 0 ? 0 : oe(Q.length) | 0, V = v(W);
    for (let se = 0; se < W; se += 1)
      V[se] = Q[se] & 255;
    return V;
  }
  function de(Q) {
    if (it(Q, Uint8Array)) {
      const W = new Uint8Array(Q);
      return ce(W.buffer, W.byteOffset, W.byteLength);
    }
    return ne(Q);
  }
  function ce(Q, W, V) {
    if (W < 0 || Q.byteLength < W)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Q.byteLength < W + (V || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let se;
    return W === void 0 && V === void 0 ? se = new Uint8Array(Q) : V === void 0 ? se = new Uint8Array(Q, W) : se = new Uint8Array(Q, W, V), Object.setPrototypeOf(se, _.prototype), se;
  }
  function re(Q) {
    if (_.isBuffer(Q)) {
      const W = oe(Q.length) | 0, V = v(W);
      return V.length === 0 || Q.copy(V, 0, 0, W), V;
    }
    if (Q.length !== void 0)
      return typeof Q.length != "number" || Ve(Q.length) ? v(0) : ne(Q);
    if (Q.type === "Buffer" && Array.isArray(Q.data))
      return ne(Q.data);
  }
  function oe(Q) {
    if (Q >= m)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + m.toString(16) + " bytes");
    return Q | 0;
  }
  function pe(Q) {
    return +Q != Q && (Q = 0), _.alloc(+Q);
  }
  _.isBuffer = function(W) {
    return W != null && W._isBuffer === !0 && W !== _.prototype;
  }, _.compare = function(W, V) {
    if (it(W, Uint8Array) && (W = _.from(W, W.offset, W.byteLength)), it(V, Uint8Array) && (V = _.from(V, V.offset, V.byteLength)), !_.isBuffer(W) || !_.isBuffer(V))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (W === V)
      return 0;
    let se = W.length, Ae = V.length;
    for (let _e = 0, Re = Math.min(se, Ae); _e < Re; ++_e)
      if (W[_e] !== V[_e]) {
        se = W[_e], Ae = V[_e];
        break;
      }
    return se < Ae ? -1 : Ae < se ? 1 : 0;
  }, _.isEncoding = function(W) {
    switch (String(W).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, _.concat = function(W, V) {
    if (!Array.isArray(W))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (W.length === 0)
      return _.alloc(0);
    let se;
    if (V === void 0)
      for (V = 0, se = 0; se < W.length; ++se)
        V += W[se].length;
    const Ae = _.allocUnsafe(V);
    let _e = 0;
    for (se = 0; se < W.length; ++se) {
      let Re = W[se];
      if (it(Re, Uint8Array))
        _e + Re.length > Ae.length ? (_.isBuffer(Re) || (Re = _.from(Re)), Re.copy(Ae, _e)) : Uint8Array.prototype.set.call(
          Ae,
          Re,
          _e
        );
      else if (_.isBuffer(Re))
        Re.copy(Ae, _e);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      _e += Re.length;
    }
    return Ae;
  };
  function ae(Q, W) {
    if (_.isBuffer(Q))
      return Q.length;
    if (ArrayBuffer.isView(Q) || it(Q, ArrayBuffer))
      return Q.byteLength;
    if (typeof Q != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Q
      );
    const V = Q.length, se = arguments.length > 2 && arguments[2] === !0;
    if (!se && V === 0)
      return 0;
    let Ae = !1;
    for (; ; )
      switch (W) {
        case "ascii":
        case "latin1":
        case "binary":
          return V;
        case "utf8":
        case "utf-8":
          return ue(Q).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return V * 2;
        case "hex":
          return V >>> 1;
        case "base64":
          return Be(Q).length;
        default:
          if (Ae)
            return se ? -1 : ue(Q).length;
          W = ("" + W).toLowerCase(), Ae = !0;
      }
  }
  _.byteLength = ae;
  function me(Q, W, V) {
    let se = !1;
    if ((W === void 0 || W < 0) && (W = 0), W > this.length || ((V === void 0 || V > this.length) && (V = this.length), V <= 0) || (V >>>= 0, W >>>= 0, V <= W))
      return "";
    for (Q || (Q = "utf8"); ; )
      switch (Q) {
        case "hex":
          return C(this, W, V);
        case "utf8":
        case "utf-8":
          return p(this, W, V);
        case "ascii":
          return B(this, W, V);
        case "latin1":
        case "binary":
          return L(this, W, V);
        case "base64":
          return k(this, W, V);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return G(this, W, V);
        default:
          if (se)
            throw new TypeError("Unknown encoding: " + Q);
          Q = (Q + "").toLowerCase(), se = !0;
      }
  }
  _.prototype._isBuffer = !0;
  function ge(Q, W, V) {
    const se = Q[W];
    Q[W] = Q[V], Q[V] = se;
  }
  _.prototype.swap16 = function() {
    const W = this.length;
    if (W % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let V = 0; V < W; V += 2)
      ge(this, V, V + 1);
    return this;
  }, _.prototype.swap32 = function() {
    const W = this.length;
    if (W % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let V = 0; V < W; V += 4)
      ge(this, V, V + 3), ge(this, V + 1, V + 2);
    return this;
  }, _.prototype.swap64 = function() {
    const W = this.length;
    if (W % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let V = 0; V < W; V += 8)
      ge(this, V, V + 7), ge(this, V + 1, V + 6), ge(this, V + 2, V + 5), ge(this, V + 3, V + 4);
    return this;
  }, _.prototype.toString = function() {
    const W = this.length;
    return W === 0 ? "" : arguments.length === 0 ? p(this, 0, W) : me.apply(this, arguments);
  }, _.prototype.toLocaleString = _.prototype.toString, _.prototype.equals = function(W) {
    if (!_.isBuffer(W))
      throw new TypeError("Argument must be a Buffer");
    return this === W ? !0 : _.compare(this, W) === 0;
  }, _.prototype.inspect = function() {
    let W = "";
    const V = l.INSPECT_MAX_BYTES;
    return W = this.toString("hex", 0, V).replace(/(.{2})/g, "$1 ").trim(), this.length > V && (W += " ... "), "<Buffer " + W + ">";
  }, h && (_.prototype[h] = _.prototype.inspect), _.prototype.compare = function(W, V, se, Ae, _e) {
    if (it(W, Uint8Array) && (W = _.from(W, W.offset, W.byteLength)), !_.isBuffer(W))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof W
      );
    if (V === void 0 && (V = 0), se === void 0 && (se = W ? W.length : 0), Ae === void 0 && (Ae = 0), _e === void 0 && (_e = this.length), V < 0 || se > W.length || Ae < 0 || _e > this.length)
      throw new RangeError("out of range index");
    if (Ae >= _e && V >= se)
      return 0;
    if (Ae >= _e)
      return -1;
    if (V >= se)
      return 1;
    if (V >>>= 0, se >>>= 0, Ae >>>= 0, _e >>>= 0, this === W)
      return 0;
    let Re = _e - Ae, mt = se - V;
    const We = Math.min(Re, mt), ze = this.slice(Ae, _e), kt = W.slice(V, se);
    for (let je = 0; je < We; ++je)
      if (ze[je] !== kt[je]) {
        Re = ze[je], mt = kt[je];
        break;
      }
    return Re < mt ? -1 : mt < Re ? 1 : 0;
  };
  function we(Q, W, V, se, Ae) {
    if (Q.length === 0)
      return -1;
    if (typeof V == "string" ? (se = V, V = 0) : V > 2147483647 ? V = 2147483647 : V < -2147483648 && (V = -2147483648), V = +V, Ve(V) && (V = Ae ? 0 : Q.length - 1), V < 0 && (V = Q.length + V), V >= Q.length) {
      if (Ae)
        return -1;
      V = Q.length - 1;
    } else if (V < 0)
      if (Ae)
        V = 0;
      else
        return -1;
    if (typeof W == "string" && (W = _.from(W, se)), _.isBuffer(W))
      return W.length === 0 ? -1 : Ee(Q, W, V, se, Ae);
    if (typeof W == "number")
      return W = W & 255, typeof Uint8Array.prototype.indexOf == "function" ? Ae ? Uint8Array.prototype.indexOf.call(Q, W, V) : Uint8Array.prototype.lastIndexOf.call(Q, W, V) : Ee(Q, [W], V, se, Ae);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Ee(Q, W, V, se, Ae) {
    let _e = 1, Re = Q.length, mt = W.length;
    if (se !== void 0 && (se = String(se).toLowerCase(), se === "ucs2" || se === "ucs-2" || se === "utf16le" || se === "utf-16le")) {
      if (Q.length < 2 || W.length < 2)
        return -1;
      _e = 2, Re /= 2, mt /= 2, V /= 2;
    }
    function We(kt, je) {
      return _e === 1 ? kt[je] : kt.readUInt16BE(je * _e);
    }
    let ze;
    if (Ae) {
      let kt = -1;
      for (ze = V; ze < Re; ze++)
        if (We(Q, ze) === We(W, kt === -1 ? 0 : ze - kt)) {
          if (kt === -1 && (kt = ze), ze - kt + 1 === mt)
            return kt * _e;
        } else
          kt !== -1 && (ze -= ze - kt), kt = -1;
    } else
      for (V + mt > Re && (V = Re - mt), ze = V; ze >= 0; ze--) {
        let kt = !0;
        for (let je = 0; je < mt; je++)
          if (We(Q, ze + je) !== We(W, je)) {
            kt = !1;
            break;
          }
        if (kt)
          return ze;
      }
    return -1;
  }
  _.prototype.includes = function(W, V, se) {
    return this.indexOf(W, V, se) !== -1;
  }, _.prototype.indexOf = function(W, V, se) {
    return we(this, W, V, se, !0);
  }, _.prototype.lastIndexOf = function(W, V, se) {
    return we(this, W, V, se, !1);
  };
  function Te(Q, W, V, se) {
    V = Number(V) || 0;
    const Ae = Q.length - V;
    se ? (se = Number(se), se > Ae && (se = Ae)) : se = Ae;
    const _e = W.length;
    se > _e / 2 && (se = _e / 2);
    let Re;
    for (Re = 0; Re < se; ++Re) {
      const mt = parseInt(W.substr(Re * 2, 2), 16);
      if (Ve(mt))
        return Re;
      Q[V + Re] = mt;
    }
    return Re;
  }
  function Ke(Q, W, V, se) {
    return Oe(ue(W, Q.length - V), Q, V, se);
  }
  function Se(Q, W, V, se) {
    return Oe(he(W), Q, V, se);
  }
  function X(Q, W, V, se) {
    return Oe(Be(W), Q, V, se);
  }
  function fe(Q, W, V, se) {
    return Oe(Ne(W, Q.length - V), Q, V, se);
  }
  _.prototype.write = function(W, V, se, Ae) {
    if (V === void 0)
      Ae = "utf8", se = this.length, V = 0;
    else if (se === void 0 && typeof V == "string")
      Ae = V, se = this.length, V = 0;
    else if (isFinite(V))
      V = V >>> 0, isFinite(se) ? (se = se >>> 0, Ae === void 0 && (Ae = "utf8")) : (Ae = se, se = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const _e = this.length - V;
    if ((se === void 0 || se > _e) && (se = _e), W.length > 0 && (se < 0 || V < 0) || V > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Ae || (Ae = "utf8");
    let Re = !1;
    for (; ; )
      switch (Ae) {
        case "hex":
          return Te(this, W, V, se);
        case "utf8":
        case "utf-8":
          return Ke(this, W, V, se);
        case "ascii":
        case "latin1":
        case "binary":
          return Se(this, W, V, se);
        case "base64":
          return X(this, W, V, se);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return fe(this, W, V, se);
        default:
          if (Re)
            throw new TypeError("Unknown encoding: " + Ae);
          Ae = ("" + Ae).toLowerCase(), Re = !0;
      }
  }, _.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function k(Q, W, V) {
    return W === 0 && V === Q.length ? t.fromByteArray(Q) : t.fromByteArray(Q.slice(W, V));
  }
  function p(Q, W, V) {
    V = Math.min(Q.length, V);
    const se = [];
    let Ae = W;
    for (; Ae < V; ) {
      const _e = Q[Ae];
      let Re = null, mt = _e > 239 ? 4 : _e > 223 ? 3 : _e > 191 ? 2 : 1;
      if (Ae + mt <= V) {
        let We, ze, kt, je;
        switch (mt) {
          case 1:
            _e < 128 && (Re = _e);
            break;
          case 2:
            We = Q[Ae + 1], (We & 192) === 128 && (je = (_e & 31) << 6 | We & 63, je > 127 && (Re = je));
            break;
          case 3:
            We = Q[Ae + 1], ze = Q[Ae + 2], (We & 192) === 128 && (ze & 192) === 128 && (je = (_e & 15) << 12 | (We & 63) << 6 | ze & 63, je > 2047 && (je < 55296 || je > 57343) && (Re = je));
            break;
          case 4:
            We = Q[Ae + 1], ze = Q[Ae + 2], kt = Q[Ae + 3], (We & 192) === 128 && (ze & 192) === 128 && (kt & 192) === 128 && (je = (_e & 15) << 18 | (We & 63) << 12 | (ze & 63) << 6 | kt & 63, je > 65535 && je < 1114112 && (Re = je));
        }
      }
      Re === null ? (Re = 65533, mt = 1) : Re > 65535 && (Re -= 65536, se.push(Re >>> 10 & 1023 | 55296), Re = 56320 | Re & 1023), se.push(Re), Ae += mt;
    }
    return S(se);
  }
  const x = 4096;
  function S(Q) {
    const W = Q.length;
    if (W <= x)
      return String.fromCharCode.apply(String, Q);
    let V = "", se = 0;
    for (; se < W; )
      V += String.fromCharCode.apply(
        String,
        Q.slice(se, se += x)
      );
    return V;
  }
  function B(Q, W, V) {
    let se = "";
    V = Math.min(Q.length, V);
    for (let Ae = W; Ae < V; ++Ae)
      se += String.fromCharCode(Q[Ae] & 127);
    return se;
  }
  function L(Q, W, V) {
    let se = "";
    V = Math.min(Q.length, V);
    for (let Ae = W; Ae < V; ++Ae)
      se += String.fromCharCode(Q[Ae]);
    return se;
  }
  function C(Q, W, V) {
    const se = Q.length;
    (!W || W < 0) && (W = 0), (!V || V < 0 || V > se) && (V = se);
    let Ae = "";
    for (let _e = W; _e < V; ++_e)
      Ae += Ye[Q[_e]];
    return Ae;
  }
  function G(Q, W, V) {
    const se = Q.slice(W, V);
    let Ae = "";
    for (let _e = 0; _e < se.length - 1; _e += 2)
      Ae += String.fromCharCode(se[_e] + se[_e + 1] * 256);
    return Ae;
  }
  _.prototype.slice = function(W, V) {
    const se = this.length;
    W = ~~W, V = V === void 0 ? se : ~~V, W < 0 ? (W += se, W < 0 && (W = 0)) : W > se && (W = se), V < 0 ? (V += se, V < 0 && (V = 0)) : V > se && (V = se), V < W && (V = W);
    const Ae = this.subarray(W, V);
    return Object.setPrototypeOf(Ae, _.prototype), Ae;
  };
  function R(Q, W, V) {
    if (Q % 1 !== 0 || Q < 0)
      throw new RangeError("offset is not uint");
    if (Q + W > V)
      throw new RangeError("Trying to access beyond buffer length");
  }
  _.prototype.readUintLE = _.prototype.readUIntLE = function(W, V, se) {
    W = W >>> 0, V = V >>> 0, se || R(W, V, this.length);
    let Ae = this[W], _e = 1, Re = 0;
    for (; ++Re < V && (_e *= 256); )
      Ae += this[W + Re] * _e;
    return Ae;
  }, _.prototype.readUintBE = _.prototype.readUIntBE = function(W, V, se) {
    W = W >>> 0, V = V >>> 0, se || R(W, V, this.length);
    let Ae = this[W + --V], _e = 1;
    for (; V > 0 && (_e *= 256); )
      Ae += this[W + --V] * _e;
    return Ae;
  }, _.prototype.readUint8 = _.prototype.readUInt8 = function(W, V) {
    return W = W >>> 0, V || R(W, 1, this.length), this[W];
  }, _.prototype.readUint16LE = _.prototype.readUInt16LE = function(W, V) {
    return W = W >>> 0, V || R(W, 2, this.length), this[W] | this[W + 1] << 8;
  }, _.prototype.readUint16BE = _.prototype.readUInt16BE = function(W, V) {
    return W = W >>> 0, V || R(W, 2, this.length), this[W] << 8 | this[W + 1];
  }, _.prototype.readUint32LE = _.prototype.readUInt32LE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), (this[W] | this[W + 1] << 8 | this[W + 2] << 16) + this[W + 3] * 16777216;
  }, _.prototype.readUint32BE = _.prototype.readUInt32BE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), this[W] * 16777216 + (this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3]);
  }, _.prototype.readBigUInt64LE = Pt(function(W) {
    W = W >>> 0, wt(W, "offset");
    const V = this[W], se = this[W + 7];
    (V === void 0 || se === void 0) && He(W, this.length - 8);
    const Ae = V + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24, _e = this[++W] + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + se * 2 ** 24;
    return BigInt(Ae) + (BigInt(_e) << BigInt(32));
  }), _.prototype.readBigUInt64BE = Pt(function(W) {
    W = W >>> 0, wt(W, "offset");
    const V = this[W], se = this[W + 7];
    (V === void 0 || se === void 0) && He(W, this.length - 8);
    const Ae = V * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W], _e = this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + se;
    return (BigInt(Ae) << BigInt(32)) + BigInt(_e);
  }), _.prototype.readIntLE = function(W, V, se) {
    W = W >>> 0, V = V >>> 0, se || R(W, V, this.length);
    let Ae = this[W], _e = 1, Re = 0;
    for (; ++Re < V && (_e *= 256); )
      Ae += this[W + Re] * _e;
    return _e *= 128, Ae >= _e && (Ae -= Math.pow(2, 8 * V)), Ae;
  }, _.prototype.readIntBE = function(W, V, se) {
    W = W >>> 0, V = V >>> 0, se || R(W, V, this.length);
    let Ae = V, _e = 1, Re = this[W + --Ae];
    for (; Ae > 0 && (_e *= 256); )
      Re += this[W + --Ae] * _e;
    return _e *= 128, Re >= _e && (Re -= Math.pow(2, 8 * V)), Re;
  }, _.prototype.readInt8 = function(W, V) {
    return W = W >>> 0, V || R(W, 1, this.length), this[W] & 128 ? (255 - this[W] + 1) * -1 : this[W];
  }, _.prototype.readInt16LE = function(W, V) {
    W = W >>> 0, V || R(W, 2, this.length);
    const se = this[W] | this[W + 1] << 8;
    return se & 32768 ? se | 4294901760 : se;
  }, _.prototype.readInt16BE = function(W, V) {
    W = W >>> 0, V || R(W, 2, this.length);
    const se = this[W + 1] | this[W] << 8;
    return se & 32768 ? se | 4294901760 : se;
  }, _.prototype.readInt32LE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), this[W] | this[W + 1] << 8 | this[W + 2] << 16 | this[W + 3] << 24;
  }, _.prototype.readInt32BE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), this[W] << 24 | this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3];
  }, _.prototype.readBigInt64LE = Pt(function(W) {
    W = W >>> 0, wt(W, "offset");
    const V = this[W], se = this[W + 7];
    (V === void 0 || se === void 0) && He(W, this.length - 8);
    const Ae = this[W + 4] + this[W + 5] * 2 ** 8 + this[W + 6] * 2 ** 16 + (se << 24);
    return (BigInt(Ae) << BigInt(32)) + BigInt(V + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24);
  }), _.prototype.readBigInt64BE = Pt(function(W) {
    W = W >>> 0, wt(W, "offset");
    const V = this[W], se = this[W + 7];
    (V === void 0 || se === void 0) && He(W, this.length - 8);
    const Ae = (V << 24) + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W];
    return (BigInt(Ae) << BigInt(32)) + BigInt(this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + se);
  }), _.prototype.readFloatLE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), s.read(this, W, !0, 23, 4);
  }, _.prototype.readFloatBE = function(W, V) {
    return W = W >>> 0, V || R(W, 4, this.length), s.read(this, W, !1, 23, 4);
  }, _.prototype.readDoubleLE = function(W, V) {
    return W = W >>> 0, V || R(W, 8, this.length), s.read(this, W, !0, 52, 8);
  }, _.prototype.readDoubleBE = function(W, V) {
    return W = W >>> 0, V || R(W, 8, this.length), s.read(this, W, !1, 52, 8);
  };
  function y(Q, W, V, se, Ae, _e) {
    if (!_.isBuffer(Q))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (W > Ae || W < _e)
      throw new RangeError('"value" argument is out of bounds');
    if (V + se > Q.length)
      throw new RangeError("Index out of range");
  }
  _.prototype.writeUintLE = _.prototype.writeUIntLE = function(W, V, se, Ae) {
    if (W = +W, V = V >>> 0, se = se >>> 0, !Ae) {
      const mt = Math.pow(2, 8 * se) - 1;
      y(this, W, V, se, mt, 0);
    }
    let _e = 1, Re = 0;
    for (this[V] = W & 255; ++Re < se && (_e *= 256); )
      this[V + Re] = W / _e & 255;
    return V + se;
  }, _.prototype.writeUintBE = _.prototype.writeUIntBE = function(W, V, se, Ae) {
    if (W = +W, V = V >>> 0, se = se >>> 0, !Ae) {
      const mt = Math.pow(2, 8 * se) - 1;
      y(this, W, V, se, mt, 0);
    }
    let _e = se - 1, Re = 1;
    for (this[V + _e] = W & 255; --_e >= 0 && (Re *= 256); )
      this[V + _e] = W / Re & 255;
    return V + se;
  }, _.prototype.writeUint8 = _.prototype.writeUInt8 = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 1, 255, 0), this[V] = W & 255, V + 1;
  }, _.prototype.writeUint16LE = _.prototype.writeUInt16LE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 2, 65535, 0), this[V] = W & 255, this[V + 1] = W >>> 8, V + 2;
  }, _.prototype.writeUint16BE = _.prototype.writeUInt16BE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 2, 65535, 0), this[V] = W >>> 8, this[V + 1] = W & 255, V + 2;
  }, _.prototype.writeUint32LE = _.prototype.writeUInt32LE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 4, 4294967295, 0), this[V + 3] = W >>> 24, this[V + 2] = W >>> 16, this[V + 1] = W >>> 8, this[V] = W & 255, V + 4;
  }, _.prototype.writeUint32BE = _.prototype.writeUInt32BE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 4, 4294967295, 0), this[V] = W >>> 24, this[V + 1] = W >>> 16, this[V + 2] = W >>> 8, this[V + 3] = W & 255, V + 4;
  };
  function j(Q, W, V, se, Ae) {
    De(W, se, Ae, Q, V, 7);
    let _e = Number(W & BigInt(4294967295));
    Q[V++] = _e, _e = _e >> 8, Q[V++] = _e, _e = _e >> 8, Q[V++] = _e, _e = _e >> 8, Q[V++] = _e;
    let Re = Number(W >> BigInt(32) & BigInt(4294967295));
    return Q[V++] = Re, Re = Re >> 8, Q[V++] = Re, Re = Re >> 8, Q[V++] = Re, Re = Re >> 8, Q[V++] = Re, V;
  }
  function ye(Q, W, V, se, Ae) {
    De(W, se, Ae, Q, V, 7);
    let _e = Number(W & BigInt(4294967295));
    Q[V + 7] = _e, _e = _e >> 8, Q[V + 6] = _e, _e = _e >> 8, Q[V + 5] = _e, _e = _e >> 8, Q[V + 4] = _e;
    let Re = Number(W >> BigInt(32) & BigInt(4294967295));
    return Q[V + 3] = Re, Re = Re >> 8, Q[V + 2] = Re, Re = Re >> 8, Q[V + 1] = Re, Re = Re >> 8, Q[V] = Re, V + 8;
  }
  _.prototype.writeBigUInt64LE = Pt(function(W, V = 0) {
    return j(this, W, V, BigInt(0), BigInt("0xffffffffffffffff"));
  }), _.prototype.writeBigUInt64BE = Pt(function(W, V = 0) {
    return ye(this, W, V, BigInt(0), BigInt("0xffffffffffffffff"));
  }), _.prototype.writeIntLE = function(W, V, se, Ae) {
    if (W = +W, V = V >>> 0, !Ae) {
      const We = Math.pow(2, 8 * se - 1);
      y(this, W, V, se, We - 1, -We);
    }
    let _e = 0, Re = 1, mt = 0;
    for (this[V] = W & 255; ++_e < se && (Re *= 256); )
      W < 0 && mt === 0 && this[V + _e - 1] !== 0 && (mt = 1), this[V + _e] = (W / Re >> 0) - mt & 255;
    return V + se;
  }, _.prototype.writeIntBE = function(W, V, se, Ae) {
    if (W = +W, V = V >>> 0, !Ae) {
      const We = Math.pow(2, 8 * se - 1);
      y(this, W, V, se, We - 1, -We);
    }
    let _e = se - 1, Re = 1, mt = 0;
    for (this[V + _e] = W & 255; --_e >= 0 && (Re *= 256); )
      W < 0 && mt === 0 && this[V + _e + 1] !== 0 && (mt = 1), this[V + _e] = (W / Re >> 0) - mt & 255;
    return V + se;
  }, _.prototype.writeInt8 = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 1, 127, -128), W < 0 && (W = 255 + W + 1), this[V] = W & 255, V + 1;
  }, _.prototype.writeInt16LE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 2, 32767, -32768), this[V] = W & 255, this[V + 1] = W >>> 8, V + 2;
  }, _.prototype.writeInt16BE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 2, 32767, -32768), this[V] = W >>> 8, this[V + 1] = W & 255, V + 2;
  }, _.prototype.writeInt32LE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 4, 2147483647, -2147483648), this[V] = W & 255, this[V + 1] = W >>> 8, this[V + 2] = W >>> 16, this[V + 3] = W >>> 24, V + 4;
  }, _.prototype.writeInt32BE = function(W, V, se) {
    return W = +W, V = V >>> 0, se || y(this, W, V, 4, 2147483647, -2147483648), W < 0 && (W = 4294967295 + W + 1), this[V] = W >>> 24, this[V + 1] = W >>> 16, this[V + 2] = W >>> 8, this[V + 3] = W & 255, V + 4;
  }, _.prototype.writeBigInt64LE = Pt(function(W, V = 0) {
    return j(this, W, V, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), _.prototype.writeBigInt64BE = Pt(function(W, V = 0) {
    return ye(this, W, V, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ee(Q, W, V, se, Ae, _e) {
    if (V + se > Q.length)
      throw new RangeError("Index out of range");
    if (V < 0)
      throw new RangeError("Index out of range");
  }
  function xe(Q, W, V, se, Ae) {
    return W = +W, V = V >>> 0, Ae || ee(Q, W, V, 4), s.write(Q, W, V, se, 23, 4), V + 4;
  }
  _.prototype.writeFloatLE = function(W, V, se) {
    return xe(this, W, V, !0, se);
  }, _.prototype.writeFloatBE = function(W, V, se) {
    return xe(this, W, V, !1, se);
  };
  function $e(Q, W, V, se, Ae) {
    return W = +W, V = V >>> 0, Ae || ee(Q, W, V, 8), s.write(Q, W, V, se, 52, 8), V + 8;
  }
  _.prototype.writeDoubleLE = function(W, V, se) {
    return $e(this, W, V, !0, se);
  }, _.prototype.writeDoubleBE = function(W, V, se) {
    return $e(this, W, V, !1, se);
  }, _.prototype.copy = function(W, V, se, Ae) {
    if (!_.isBuffer(W))
      throw new TypeError("argument should be a Buffer");
    if (se || (se = 0), !Ae && Ae !== 0 && (Ae = this.length), V >= W.length && (V = W.length), V || (V = 0), Ae > 0 && Ae < se && (Ae = se), Ae === se || W.length === 0 || this.length === 0)
      return 0;
    if (V < 0)
      throw new RangeError("targetStart out of bounds");
    if (se < 0 || se >= this.length)
      throw new RangeError("Index out of range");
    if (Ae < 0)
      throw new RangeError("sourceEnd out of bounds");
    Ae > this.length && (Ae = this.length), W.length - V < Ae - se && (Ae = W.length - V + se);
    const _e = Ae - se;
    return this === W && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(V, se, Ae) : Uint8Array.prototype.set.call(
      W,
      this.subarray(se, Ae),
      V
    ), _e;
  }, _.prototype.fill = function(W, V, se, Ae) {
    if (typeof W == "string") {
      if (typeof V == "string" ? (Ae = V, V = 0, se = this.length) : typeof se == "string" && (Ae = se, se = this.length), Ae !== void 0 && typeof Ae != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Ae == "string" && !_.isEncoding(Ae))
        throw new TypeError("Unknown encoding: " + Ae);
      if (W.length === 1) {
        const Re = W.charCodeAt(0);
        (Ae === "utf8" && Re < 128 || Ae === "latin1") && (W = Re);
      }
    } else
      typeof W == "number" ? W = W & 255 : typeof W == "boolean" && (W = Number(W));
    if (V < 0 || this.length < V || this.length < se)
      throw new RangeError("Out of range index");
    if (se <= V)
      return this;
    V = V >>> 0, se = se === void 0 ? this.length : se >>> 0, W || (W = 0);
    let _e;
    if (typeof W == "number")
      for (_e = V; _e < se; ++_e)
        this[_e] = W;
    else {
      const Re = _.isBuffer(W) ? W : _.from(W, Ae), mt = Re.length;
      if (mt === 0)
        throw new TypeError('The value "' + W + '" is invalid for argument "value"');
      for (_e = 0; _e < se - V; ++_e)
        this[_e + V] = Re[_e % mt];
    }
    return this;
  };
  const ke = {};
  function Ce(Q, W, V) {
    ke[Q] = class extends V {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: W.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Q}]`, this.stack, delete this.name;
      }
      get code() {
        return Q;
      }
      set code(Ae) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Ae,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Q}]: ${this.message}`;
      }
    };
  }
  Ce(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Q) {
      return Q ? `${Q} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Ce(
    "ERR_INVALID_ARG_TYPE",
    function(Q, W) {
      return `The "${Q}" argument must be of type number. Received type ${typeof W}`;
    },
    TypeError
  ), Ce(
    "ERR_OUT_OF_RANGE",
    function(Q, W, V) {
      let se = `The value of "${Q}" is out of range.`, Ae = V;
      return Number.isInteger(V) && Math.abs(V) > 2 ** 32 ? Ae = ht(String(V)) : typeof V == "bigint" && (Ae = String(V), (V > BigInt(2) ** BigInt(32) || V < -(BigInt(2) ** BigInt(32))) && (Ae = ht(Ae)), Ae += "n"), se += ` It must be ${W}. Received ${Ae}`, se;
    },
    RangeError
  );
  function ht(Q) {
    let W = "", V = Q.length;
    const se = Q[0] === "-" ? 1 : 0;
    for (; V >= se + 4; V -= 3)
      W = `_${Q.slice(V - 3, V)}${W}`;
    return `${Q.slice(0, V)}${W}`;
  }
  function Ue(Q, W, V) {
    wt(W, "offset"), (Q[W] === void 0 || Q[W + V] === void 0) && He(W, Q.length - (V + 1));
  }
  function De(Q, W, V, se, Ae, _e) {
    if (Q > V || Q < W) {
      const Re = typeof W == "bigint" ? "n" : "";
      let mt;
      throw _e > 3 ? W === 0 || W === BigInt(0) ? mt = `>= 0${Re} and < 2${Re} ** ${(_e + 1) * 8}${Re}` : mt = `>= -(2${Re} ** ${(_e + 1) * 8 - 1}${Re}) and < 2 ** ${(_e + 1) * 8 - 1}${Re}` : mt = `>= ${W}${Re} and <= ${V}${Re}`, new ke.ERR_OUT_OF_RANGE("value", mt, Q);
    }
    Ue(se, Ae, _e);
  }
  function wt(Q, W) {
    if (typeof Q != "number")
      throw new ke.ERR_INVALID_ARG_TYPE(W, "number", Q);
  }
  function He(Q, W, V) {
    throw Math.floor(Q) !== Q ? (wt(Q, V), new ke.ERR_OUT_OF_RANGE(V || "offset", "an integer", Q)) : W < 0 ? new ke.ERR_BUFFER_OUT_OF_BOUNDS() : new ke.ERR_OUT_OF_RANGE(
      V || "offset",
      `>= ${V ? 1 : 0} and <= ${W}`,
      Q
    );
  }
  const Ze = /[^+/0-9A-Za-z-_]/g;
  function Ie(Q) {
    if (Q = Q.split("=")[0], Q = Q.trim().replace(Ze, ""), Q.length < 2)
      return "";
    for (; Q.length % 4 !== 0; )
      Q = Q + "=";
    return Q;
  }
  function ue(Q, W) {
    W = W || 1 / 0;
    let V;
    const se = Q.length;
    let Ae = null;
    const _e = [];
    for (let Re = 0; Re < se; ++Re) {
      if (V = Q.charCodeAt(Re), V > 55295 && V < 57344) {
        if (!Ae) {
          if (V > 56319) {
            (W -= 3) > -1 && _e.push(239, 191, 189);
            continue;
          } else if (Re + 1 === se) {
            (W -= 3) > -1 && _e.push(239, 191, 189);
            continue;
          }
          Ae = V;
          continue;
        }
        if (V < 56320) {
          (W -= 3) > -1 && _e.push(239, 191, 189), Ae = V;
          continue;
        }
        V = (Ae - 55296 << 10 | V - 56320) + 65536;
      } else
        Ae && (W -= 3) > -1 && _e.push(239, 191, 189);
      if (Ae = null, V < 128) {
        if ((W -= 1) < 0)
          break;
        _e.push(V);
      } else if (V < 2048) {
        if ((W -= 2) < 0)
          break;
        _e.push(
          V >> 6 | 192,
          V & 63 | 128
        );
      } else if (V < 65536) {
        if ((W -= 3) < 0)
          break;
        _e.push(
          V >> 12 | 224,
          V >> 6 & 63 | 128,
          V & 63 | 128
        );
      } else if (V < 1114112) {
        if ((W -= 4) < 0)
          break;
        _e.push(
          V >> 18 | 240,
          V >> 12 & 63 | 128,
          V >> 6 & 63 | 128,
          V & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return _e;
  }
  function he(Q) {
    const W = [];
    for (let V = 0; V < Q.length; ++V)
      W.push(Q.charCodeAt(V) & 255);
    return W;
  }
  function Ne(Q, W) {
    let V, se, Ae;
    const _e = [];
    for (let Re = 0; Re < Q.length && !((W -= 2) < 0); ++Re)
      V = Q.charCodeAt(Re), se = V >> 8, Ae = V % 256, _e.push(Ae), _e.push(se);
    return _e;
  }
  function Be(Q) {
    return t.toByteArray(Ie(Q));
  }
  function Oe(Q, W, V, se) {
    let Ae;
    for (Ae = 0; Ae < se && !(Ae + V >= W.length || Ae >= Q.length); ++Ae)
      W[Ae + V] = Q[Ae];
    return Ae;
  }
  function it(Q, W) {
    return Q instanceof W || Q != null && Q.constructor != null && Q.constructor.name != null && Q.constructor.name === W.name;
  }
  function Ve(Q) {
    return Q !== Q;
  }
  const Ye = function() {
    const Q = "0123456789abcdef", W = new Array(256);
    for (let V = 0; V < 16; ++V) {
      const se = V * 16;
      for (let Ae = 0; Ae < 16; ++Ae)
        W[se + Ae] = Q[V] + Q[Ae];
    }
    return W;
  }();
  function Pt(Q) {
    return typeof BigInt > "u" ? et : Q;
  }
  function et() {
    throw new Error("BigInt not supported");
  }
})(buffer);
function number$1(l) {
  if (!Number.isSafeInteger(l) || l < 0)
    throw new Error(`Wrong positive integer: ${l}`);
}
function bool(l) {
  if (typeof l != "boolean")
    throw new Error(`Expected boolean, not ${l}`);
}
function bytes(l, ...t) {
  if (!(l instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(l.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${l.length}`);
}
function hash(l) {
  if (typeof l != "function" || typeof l.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(l.outputLen), number$1(l.blockLen);
}
function exists(l, t = !0) {
  if (l.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && l.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(l, t) {
  bytes(l);
  const s = t.outputLen;
  if (l.length < s)
    throw new Error(`digestInto() expects output buffer of length at least ${s}`);
}
const assert$2 = {
  number: number$1,
  bool,
  bytes,
  hash,
  exists,
  output
};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32$1 = (l) => new Uint32Array(l.buffer, l.byteOffset, Math.floor(l.byteLength / 4)), createView = (l) => new DataView(l.buffer, l.byteOffset, l.byteLength), rotr = (l, t) => l << 32 - t | l >>> t, isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (l, t) => t.toString(16).padStart(2, "0"));
function utf8ToBytes(l) {
  if (typeof l != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof l}`);
  return new TextEncoder().encode(l);
}
function toBytes(l) {
  if (typeof l == "string" && (l = utf8ToBytes(l)), !(l instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof l})`);
  return l;
}
class Hash {
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(l) {
  const t = (h) => l().update(toBytes(h)).digest(), s = l();
  return t.outputLen = s.outputLen, t.blockLen = s.blockLen, t.create = () => l(), t;
}
function wrapConstructorWithOpts(l) {
  const t = (h, m) => l(m).update(toBytes(h)).digest(), s = l({});
  return t.outputLen = s.outputLen, t.blockLen = s.blockLen, t.create = (h) => l(h), t;
}
function setBigUint64(l, t, s, h) {
  if (typeof l.setBigUint64 == "function")
    return l.setBigUint64(t, s, h);
  const m = BigInt(32), d = BigInt(4294967295), v = Number(s >> m & d), _ = Number(s & d), T = h ? 4 : 0, z = h ? 0 : 4;
  l.setUint32(t + T, v, h), l.setUint32(t + z, _, h);
}
class SHA2 extends Hash {
  constructor(t, s, h, m) {
    super(), this.blockLen = t, this.outputLen = s, this.padOffset = h, this.isLE = m, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = createView(this.buffer);
  }
  update(t) {
    assert$2.exists(this);
    const { view: s, buffer: h, blockLen: m } = this;
    t = toBytes(t);
    const d = t.length;
    for (let v = 0; v < d; ) {
      const _ = Math.min(m - this.pos, d - v);
      if (_ === m) {
        const T = createView(t);
        for (; m <= d - v; v += m)
          this.process(T, v);
        continue;
      }
      h.set(t.subarray(v, v + _), this.pos), this.pos += _, v += _, this.pos === m && (this.process(s, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    assert$2.exists(this), assert$2.output(t, this), this.finished = !0;
    const { buffer: s, view: h, blockLen: m, isLE: d } = this;
    let { pos: v } = this;
    s[v++] = 128, this.buffer.subarray(v).fill(0), this.padOffset > m - v && (this.process(h, 0), v = 0);
    for (let Y = v; Y < m; Y++)
      s[Y] = 0;
    setBigUint64(h, m - 8, BigInt(this.length * 8), d), this.process(h, 0);
    const _ = createView(t), T = this.outputLen;
    if (T % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const z = T / 4, J = this.get();
    if (z > J.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Y = 0; Y < z; Y++)
      _.setUint32(4 * Y, J[Y], d);
  }
  digest() {
    const { buffer: t, outputLen: s } = this;
    this.digestInto(t);
    const h = t.slice(0, s);
    return this.destroy(), h;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: s, buffer: h, length: m, finished: d, destroyed: v, pos: _ } = this;
    return t.length = m, t.pos = _, t.finished = d, t.destroyed = v, m % s && t.buffer.set(h), t;
  }
}
const U32_MASK64 = BigInt(2 ** 32 - 1), _32n = BigInt(32);
function fromBig(l, t = !1) {
  return t ? { h: Number(l & U32_MASK64), l: Number(l >> _32n & U32_MASK64) } : { h: Number(l >> _32n & U32_MASK64) | 0, l: Number(l & U32_MASK64) | 0 };
}
function split(l, t = !1) {
  let s = new Uint32Array(l.length), h = new Uint32Array(l.length);
  for (let m = 0; m < l.length; m++) {
    const { h: d, l: v } = fromBig(l[m], t);
    [s[m], h[m]] = [d, v];
  }
  return [s, h];
}
const toBig = (l, t) => BigInt(l >>> 0) << _32n | BigInt(t >>> 0), shrSH = (l, t, s) => l >>> s, shrSL = (l, t, s) => l << 32 - s | t >>> s, rotrSH = (l, t, s) => l >>> s | t << 32 - s, rotrSL = (l, t, s) => l << 32 - s | t >>> s, rotrBH = (l, t, s) => l << 64 - s | t >>> s - 32, rotrBL = (l, t, s) => l >>> s - 32 | t << 64 - s, rotr32H = (l, t) => t, rotr32L = (l, t) => l, rotlSH = (l, t, s) => l << s | t >>> 32 - s, rotlSL = (l, t, s) => t << s | l >>> 32 - s, rotlBH = (l, t, s) => t << s - 32 | l >>> 64 - s, rotlBL = (l, t, s) => l << s - 32 | t >>> 64 - s;
function add(l, t, s, h) {
  const m = (t >>> 0) + (h >>> 0);
  return { h: l + s + (m / 2 ** 32 | 0) | 0, l: m | 0 };
}
const add3L = (l, t, s) => (l >>> 0) + (t >>> 0) + (s >>> 0), add3H = (l, t, s, h) => t + s + h + (l / 2 ** 32 | 0) | 0, add4L = (l, t, s, h) => (l >>> 0) + (t >>> 0) + (s >>> 0) + (h >>> 0), add4H = (l, t, s, h, m) => t + s + h + m + (l / 2 ** 32 | 0) | 0, add5L = (l, t, s, h, m) => (l >>> 0) + (t >>> 0) + (s >>> 0) + (h >>> 0) + (m >>> 0), add5H = (l, t, s, h, m, d) => t + s + h + m + d + (l / 2 ** 32 | 0) | 0, u64$1 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
}, [SHA512_Kh, SHA512_Kl] = u64$1.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((l) => BigInt(l))), SHA512_W_H = new Uint32Array(80), SHA512_W_L = new Uint32Array(80);
class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: t, Al: s, Bh: h, Bl: m, Ch: d, Cl: v, Dh: _, Dl: T, Eh: z, El: J, Fh: Y, Fl: ie, Gh: ne, Gl: de, Hh: ce, Hl: re } = this;
    return [t, s, h, m, d, v, _, T, z, J, Y, ie, ne, de, ce, re];
  }
  set(t, s, h, m, d, v, _, T, z, J, Y, ie, ne, de, ce, re) {
    this.Ah = t | 0, this.Al = s | 0, this.Bh = h | 0, this.Bl = m | 0, this.Ch = d | 0, this.Cl = v | 0, this.Dh = _ | 0, this.Dl = T | 0, this.Eh = z | 0, this.El = J | 0, this.Fh = Y | 0, this.Fl = ie | 0, this.Gh = ne | 0, this.Gl = de | 0, this.Hh = ce | 0, this.Hl = re | 0;
  }
  process(t, s) {
    for (let ae = 0; ae < 16; ae++, s += 4)
      SHA512_W_H[ae] = t.getUint32(s), SHA512_W_L[ae] = t.getUint32(s += 4);
    for (let ae = 16; ae < 80; ae++) {
      const me = SHA512_W_H[ae - 15] | 0, ge = SHA512_W_L[ae - 15] | 0, we = u64$1.rotrSH(me, ge, 1) ^ u64$1.rotrSH(me, ge, 8) ^ u64$1.shrSH(me, ge, 7), Ee = u64$1.rotrSL(me, ge, 1) ^ u64$1.rotrSL(me, ge, 8) ^ u64$1.shrSL(me, ge, 7), Te = SHA512_W_H[ae - 2] | 0, Ke = SHA512_W_L[ae - 2] | 0, Se = u64$1.rotrSH(Te, Ke, 19) ^ u64$1.rotrBH(Te, Ke, 61) ^ u64$1.shrSH(Te, Ke, 6), X = u64$1.rotrSL(Te, Ke, 19) ^ u64$1.rotrBL(Te, Ke, 61) ^ u64$1.shrSL(Te, Ke, 6), fe = u64$1.add4L(Ee, X, SHA512_W_L[ae - 7], SHA512_W_L[ae - 16]), k = u64$1.add4H(fe, we, Se, SHA512_W_H[ae - 7], SHA512_W_H[ae - 16]);
      SHA512_W_H[ae] = k | 0, SHA512_W_L[ae] = fe | 0;
    }
    let { Ah: h, Al: m, Bh: d, Bl: v, Ch: _, Cl: T, Dh: z, Dl: J, Eh: Y, El: ie, Fh: ne, Fl: de, Gh: ce, Gl: re, Hh: oe, Hl: pe } = this;
    for (let ae = 0; ae < 80; ae++) {
      const me = u64$1.rotrSH(Y, ie, 14) ^ u64$1.rotrSH(Y, ie, 18) ^ u64$1.rotrBH(Y, ie, 41), ge = u64$1.rotrSL(Y, ie, 14) ^ u64$1.rotrSL(Y, ie, 18) ^ u64$1.rotrBL(Y, ie, 41), we = Y & ne ^ ~Y & ce, Ee = ie & de ^ ~ie & re, Te = u64$1.add5L(pe, ge, Ee, SHA512_Kl[ae], SHA512_W_L[ae]), Ke = u64$1.add5H(Te, oe, me, we, SHA512_Kh[ae], SHA512_W_H[ae]), Se = Te | 0, X = u64$1.rotrSH(h, m, 28) ^ u64$1.rotrBH(h, m, 34) ^ u64$1.rotrBH(h, m, 39), fe = u64$1.rotrSL(h, m, 28) ^ u64$1.rotrBL(h, m, 34) ^ u64$1.rotrBL(h, m, 39), k = h & d ^ h & _ ^ d & _, p = m & v ^ m & T ^ v & T;
      oe = ce | 0, pe = re | 0, ce = ne | 0, re = de | 0, ne = Y | 0, de = ie | 0, { h: Y, l: ie } = u64$1.add(z | 0, J | 0, Ke | 0, Se | 0), z = _ | 0, J = T | 0, _ = d | 0, T = v | 0, d = h | 0, v = m | 0;
      const x = u64$1.add3L(Se, fe, p);
      h = u64$1.add3H(x, Ke, X, k), m = x | 0;
    }
    ({ h, l: m } = u64$1.add(this.Ah | 0, this.Al | 0, h | 0, m | 0)), { h: d, l: v } = u64$1.add(this.Bh | 0, this.Bl | 0, d | 0, v | 0), { h: _, l: T } = u64$1.add(this.Ch | 0, this.Cl | 0, _ | 0, T | 0), { h: z, l: J } = u64$1.add(this.Dh | 0, this.Dl | 0, z | 0, J | 0), { h: Y, l: ie } = u64$1.add(this.Eh | 0, this.El | 0, Y | 0, ie | 0), { h: ne, l: de } = u64$1.add(this.Fh | 0, this.Fl | 0, ne | 0, de | 0), { h: ce, l: re } = u64$1.add(this.Gh | 0, this.Gl | 0, ce | 0, re | 0), { h: oe, l: pe } = u64$1.add(this.Hh | 0, this.Hl | 0, oe | 0, pe | 0), this.set(h, m, d, v, _, T, z, J, Y, ie, ne, de, ce, re, oe, pe);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class SHA512_224 extends SHA512 {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}
class SHA512_256 extends SHA512 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
class SHA384 extends SHA512 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
const sha512 = wrapConstructor(() => new SHA512());
wrapConstructor(() => new SHA512_224());
wrapConstructor(() => new SHA512_256());
wrapConstructor(() => new SHA384());
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$2 = BigInt(1), _2n$2 = BigInt(2), CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), CURVE$1 = Object.freeze({
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
  l: CU_O,
  n: CU_O,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
}), POW_2_256$1 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"), SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
const SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
class ExtendedPoint {
  constructor(t, s, h, m) {
    this.x = t, this.y = s, this.z = h, this.t = m;
  }
  static fromAffine(t) {
    if (!(t instanceof Point$1))
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    return t.equals(Point$1.ZERO) ? ExtendedPoint.ZERO : new ExtendedPoint(t.x, t.y, _1n$2, mod$1(t.x * t.y));
  }
  static toAffineBatch(t) {
    const s = invertBatch$1(t.map((h) => h.z));
    return t.map((h, m) => h.toAffine(s[m]));
  }
  static normalizeZ(t) {
    return this.toAffineBatch(t).map(this.fromAffine);
  }
  equals(t) {
    assertExtPoint(t);
    const { x: s, y: h, z: m } = this, { x: d, y: v, z: _ } = t, T = mod$1(s * _), z = mod$1(d * m), J = mod$1(h * _), Y = mod$1(v * m);
    return T === z && J === Y;
  }
  negate() {
    return new ExtendedPoint(mod$1(-this.x), this.y, this.z, mod$1(-this.t));
  }
  double() {
    const { x: t, y: s, z: h } = this, { a: m } = CURVE$1, d = mod$1(t * t), v = mod$1(s * s), _ = mod$1(_2n$2 * mod$1(h * h)), T = mod$1(m * d), z = t + s, J = mod$1(mod$1(z * z) - d - v), Y = T + v, ie = Y - _, ne = T - v, de = mod$1(J * ie), ce = mod$1(Y * ne), re = mod$1(J * ne), oe = mod$1(ie * Y);
    return new ExtendedPoint(de, ce, oe, re);
  }
  add(t) {
    assertExtPoint(t);
    const { x: s, y: h, z: m, t: d } = this, { x: v, y: _, z: T, t: z } = t, J = mod$1((h - s) * (_ + v)), Y = mod$1((h + s) * (_ - v)), ie = mod$1(Y - J);
    if (ie === _0n$2)
      return this.double();
    const ne = mod$1(m * _2n$2 * z), de = mod$1(d * _2n$2 * T), ce = de + ne, re = Y + J, oe = de - ne, pe = mod$1(ce * ie), ae = mod$1(re * oe), me = mod$1(ce * oe), ge = mod$1(ie * re);
    return new ExtendedPoint(pe, ae, ge, me);
  }
  subtract(t) {
    return this.add(t.negate());
  }
  precomputeWindow(t) {
    const s = 1 + 256 / t, h = [];
    let m = this, d = m;
    for (let v = 0; v < s; v++) {
      d = m, h.push(d);
      for (let _ = 1; _ < 2 ** (t - 1); _++)
        d = d.add(m), h.push(d);
      m = d.double();
    }
    return h;
  }
  wNAF(t, s) {
    !s && this.equals(ExtendedPoint.BASE) && (s = Point$1.BASE);
    const h = s && s._WINDOW_SIZE || 1;
    if (256 % h)
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    let m = s && pointPrecomputes$1.get(s);
    m || (m = this.precomputeWindow(h), s && h !== 1 && (m = ExtendedPoint.normalizeZ(m), pointPrecomputes$1.set(s, m)));
    let d = ExtendedPoint.ZERO, v = ExtendedPoint.ZERO;
    const _ = 1 + 256 / h, T = 2 ** (h - 1), z = BigInt(2 ** h - 1), J = 2 ** h, Y = BigInt(h);
    for (let ie = 0; ie < _; ie++) {
      const ne = ie * T;
      let de = Number(t & z);
      if (t >>= Y, de > T && (de -= J, t += _1n$2), de === 0) {
        let ce = m[ne];
        ie % 2 && (ce = ce.negate()), v = v.add(ce);
      } else {
        let ce = m[ne + Math.abs(de) - 1];
        de < 0 && (ce = ce.negate()), d = d.add(ce);
      }
    }
    return ExtendedPoint.normalizeZ([d, v])[0];
  }
  multiply(t, s) {
    return this.wNAF(normalizeScalar$1(t, CURVE$1.l), s);
  }
  multiplyUnsafe(t) {
    let s = normalizeScalar$1(t, CURVE$1.l, !1);
    const h = ExtendedPoint.BASE, m = ExtendedPoint.ZERO;
    if (s === _0n$2)
      return m;
    if (this.equals(m) || s === _1n$2)
      return this;
    if (this.equals(h))
      return this.wNAF(s);
    let d = m, v = this;
    for (; s > _0n$2; )
      s & _1n$2 && (d = d.add(v)), v = v.double(), s >>= _1n$2;
    return d;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    return this.multiplyUnsafe(CURVE$1.l).equals(ExtendedPoint.ZERO);
  }
  toAffine(t = invert$1(this.z)) {
    const { x: s, y: h, z: m } = this, d = mod$1(s * t), v = mod$1(h * t);
    if (mod$1(m * t) !== _1n$2)
      throw new Error("invZ was invalid");
    return new Point$1(d, v);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
}
ExtendedPoint.BASE = new ExtendedPoint(CURVE$1.Gx, CURVE$1.Gy, _1n$2, mod$1(CURVE$1.Gx * CURVE$1.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n$2, _1n$2, _1n$2, _0n$2);
function assertExtPoint(l) {
  if (!(l instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(l) {
  if (!(l instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
class RistrettoPoint {
  constructor(t) {
    this.ep = t;
  }
  static calcElligatorRistrettoMap(t) {
    const { d: s } = CURVE$1, h = mod$1(SQRT_M1 * t * t), m = mod$1((h + _1n$2) * ONE_MINUS_D_SQ);
    let d = BigInt(-1);
    const v = mod$1((d - s * h) * mod$1(h + s));
    let { isValid: _, value: T } = uvRatio(m, v), z = mod$1(T * t);
    edIsNegative(z) || (z = mod$1(-z)), _ || (T = z), _ || (d = h);
    const J = mod$1(d * (h - _1n$2) * D_MINUS_ONE_SQ - v), Y = T * T, ie = mod$1((T + T) * v), ne = mod$1(J * SQRT_AD_MINUS_ONE), de = mod$1(_1n$2 - Y), ce = mod$1(_1n$2 + Y);
    return new ExtendedPoint(mod$1(ie * ce), mod$1(de * ne), mod$1(ne * ce), mod$1(ie * de));
  }
  static hashToCurve(t) {
    t = ensureBytes$1(t, 64);
    const s = bytes255ToNumberLE(t.slice(0, 32)), h = this.calcElligatorRistrettoMap(s), m = bytes255ToNumberLE(t.slice(32, 64)), d = this.calcElligatorRistrettoMap(m);
    return new RistrettoPoint(h.add(d));
  }
  static fromHex(t) {
    t = ensureBytes$1(t, 32);
    const { a: s, d: h } = CURVE$1, m = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", d = bytes255ToNumberLE(t);
    if (!equalBytes(numberTo32BytesLE(d), t) || edIsNegative(d))
      throw new Error(m);
    const v = mod$1(d * d), _ = mod$1(_1n$2 + s * v), T = mod$1(_1n$2 - s * v), z = mod$1(_ * _), J = mod$1(T * T), Y = mod$1(s * h * z - J), { isValid: ie, value: ne } = invertSqrt(mod$1(Y * J)), de = mod$1(ne * T), ce = mod$1(ne * de * Y);
    let re = mod$1((d + d) * de);
    edIsNegative(re) && (re = mod$1(-re));
    const oe = mod$1(_ * ce), pe = mod$1(re * oe);
    if (!ie || edIsNegative(pe) || oe === _0n$2)
      throw new Error(m);
    return new RistrettoPoint(new ExtendedPoint(re, oe, _1n$2, pe));
  }
  toRawBytes() {
    let { x: t, y: s, z: h, t: m } = this.ep;
    const d = mod$1(mod$1(h + s) * mod$1(h - s)), v = mod$1(t * s), _ = mod$1(v * v), { value: T } = invertSqrt(mod$1(d * _)), z = mod$1(T * d), J = mod$1(T * v), Y = mod$1(z * J * m);
    let ie;
    if (edIsNegative(m * Y)) {
      let de = mod$1(s * SQRT_M1), ce = mod$1(t * SQRT_M1);
      t = de, s = ce, ie = mod$1(z * INVSQRT_A_MINUS_D);
    } else
      ie = J;
    edIsNegative(t * Y) && (s = mod$1(-s));
    let ne = mod$1((h - s) * ie);
    return edIsNegative(ne) && (ne = mod$1(-ne)), numberTo32BytesLE(ne);
  }
  toHex() {
    return bytesToHex$1(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(t) {
    assertRstPoint(t);
    const s = this.ep, h = t.ep, m = mod$1(s.x * h.y) === mod$1(s.y * h.x), d = mod$1(s.y * h.y) === mod$1(s.x * h.x);
    return m || d;
  }
  add(t) {
    return assertRstPoint(t), new RistrettoPoint(this.ep.add(t.ep));
  }
  subtract(t) {
    return assertRstPoint(t), new RistrettoPoint(this.ep.subtract(t.ep));
  }
  multiply(t) {
    return new RistrettoPoint(this.ep.multiply(t));
  }
  multiplyUnsafe(t) {
    return new RistrettoPoint(this.ep.multiplyUnsafe(t));
  }
}
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
const pointPrecomputes$1 = /* @__PURE__ */ new WeakMap();
let Point$1 = class {
  constructor(t, s) {
    this.x = t, this.y = s;
  }
  _setWindowSize(t) {
    this._WINDOW_SIZE = t, pointPrecomputes$1.delete(this);
  }
  static fromHex(t, s = !0) {
    const { d: h, P: m } = CURVE$1;
    t = ensureBytes$1(t, 32);
    const d = t.slice();
    d[31] = t[31] & -129;
    const v = bytesToNumberLE(d);
    if (s && v >= m)
      throw new Error("Expected 0 < hex < P");
    if (!s && v >= POW_2_256$1)
      throw new Error("Expected 0 < hex < 2**256");
    const _ = mod$1(v * v), T = mod$1(_ - _1n$2), z = mod$1(h * _ + _1n$2);
    let { isValid: J, value: Y } = uvRatio(T, z);
    if (!J)
      throw new Error("Point.fromHex: invalid y coordinate");
    const ie = (Y & _1n$2) === _1n$2;
    return (t[31] & 128) !== 0 !== ie && (Y = mod$1(-Y)), new Point$1(Y, v);
  }
  static async fromPrivateKey(t) {
    return (await getExtendedPublicKey(t)).point;
  }
  toRawBytes() {
    const t = numberTo32BytesLE(this.y);
    return t[31] |= this.x & _1n$2 ? 128 : 0, t;
  }
  toHex() {
    return bytesToHex$1(this.toRawBytes());
  }
  toX25519() {
    const { y: t } = this, s = mod$1((_1n$2 + t) * invert$1(_1n$2 - t));
    return numberTo32BytesLE(s);
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(t) {
    return this.x === t.x && this.y === t.y;
  }
  negate() {
    return new Point$1(mod$1(-this.x), this.y);
  }
  add(t) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(t)).toAffine();
  }
  subtract(t) {
    return this.add(t.negate());
  }
  multiply(t) {
    return ExtendedPoint.fromAffine(this).multiply(t, this).toAffine();
  }
};
Point$1.BASE = new Point$1(CURVE$1.Gx, CURVE$1.Gy);
Point$1.ZERO = new Point$1(_0n$2, _1n$2);
let Signature$1 = class {
  constructor(t, s) {
    this.r = t, this.s = s, this.assertValidity();
  }
  static fromHex(t) {
    const s = ensureBytes$1(t, 64), h = Point$1.fromHex(s.slice(0, 32), !1), m = bytesToNumberLE(s.slice(32, 64));
    return new Signature$1(h, m);
  }
  assertValidity() {
    const { r: t, s } = this;
    if (!(t instanceof Point$1))
      throw new Error("Expected Point instance");
    return normalizeScalar$1(s, CURVE$1.l, !1), this;
  }
  toRawBytes() {
    const t = new Uint8Array(64);
    return t.set(this.r.toRawBytes()), t.set(numberTo32BytesLE(this.s), 32), t;
  }
  toHex() {
    return bytesToHex$1(this.toRawBytes());
  }
};
function concatBytes$1(...l) {
  if (!l.every((h) => h instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (l.length === 1)
    return l[0];
  const t = l.reduce((h, m) => h + m.length, 0), s = new Uint8Array(t);
  for (let h = 0, m = 0; h < l.length; h++) {
    const d = l[h];
    s.set(d, m), m += d.length;
  }
  return s;
}
const hexes$1 = Array.from({ length: 256 }, (l, t) => t.toString(16).padStart(2, "0"));
function bytesToHex$1(l) {
  if (!(l instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let s = 0; s < l.length; s++)
    t += hexes$1[l[s]];
  return t;
}
function hexToBytes$1(l) {
  if (typeof l != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof l);
  if (l.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const t = new Uint8Array(l.length / 2);
  for (let s = 0; s < t.length; s++) {
    const h = s * 2, m = l.slice(h, h + 2), d = Number.parseInt(m, 16);
    if (Number.isNaN(d) || d < 0)
      throw new Error("Invalid byte sequence");
    t[s] = d;
  }
  return t;
}
function numberTo32BytesBE(l) {
  const s = l.toString(16).padStart(64, "0");
  return hexToBytes$1(s);
}
function numberTo32BytesLE(l) {
  return numberTo32BytesBE(l).reverse();
}
function edIsNegative(l) {
  return (mod$1(l) & _1n$2) === _1n$2;
}
function bytesToNumberLE(l) {
  if (!(l instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex$1(Uint8Array.from(l).reverse()));
}
const MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bytes255ToNumberLE(l) {
  return mod$1(bytesToNumberLE(l) & MAX_255B);
}
function mod$1(l, t = CURVE$1.P) {
  const s = l % t;
  return s >= _0n$2 ? s : t + s;
}
function invert$1(l, t = CURVE$1.P) {
  if (l === _0n$2 || t <= _0n$2)
    throw new Error(`invert: expected positive integers, got n=${l} mod=${t}`);
  let s = mod$1(l, t), h = t, m = _0n$2, d = _1n$2;
  for (; s !== _0n$2; ) {
    const _ = h / s, T = h % s, z = m - d * _;
    h = s, s = T, m = d, d = z;
  }
  if (h !== _1n$2)
    throw new Error("invert: does not exist");
  return mod$1(m, t);
}
function invertBatch$1(l, t = CURVE$1.P) {
  const s = new Array(l.length), h = l.reduce((d, v, _) => v === _0n$2 ? d : (s[_] = d, mod$1(d * v, t)), _1n$2), m = invert$1(h, t);
  return l.reduceRight((d, v, _) => v === _0n$2 ? d : (s[_] = mod$1(d * s[_], t), mod$1(d * v, t)), m), s;
}
function pow2$1(l, t) {
  const { P: s } = CURVE$1;
  let h = l;
  for (; t-- > _0n$2; )
    h *= h, h %= s;
  return h;
}
function pow_2_252_3(l) {
  const { P: t } = CURVE$1, s = BigInt(5), h = BigInt(10), m = BigInt(20), d = BigInt(40), v = BigInt(80), T = l * l % t * l % t, z = pow2$1(T, _2n$2) * T % t, J = pow2$1(z, _1n$2) * l % t, Y = pow2$1(J, s) * J % t, ie = pow2$1(Y, h) * Y % t, ne = pow2$1(ie, m) * ie % t, de = pow2$1(ne, d) * ne % t, ce = pow2$1(de, v) * de % t, re = pow2$1(ce, v) * de % t, oe = pow2$1(re, h) * Y % t;
  return { pow_p_5_8: pow2$1(oe, _2n$2) * l % t, b2: T };
}
function uvRatio(l, t) {
  const s = mod$1(t * t * t), h = mod$1(s * s * t), m = pow_2_252_3(l * h).pow_p_5_8;
  let d = mod$1(l * s * m);
  const v = mod$1(t * d * d), _ = d, T = mod$1(d * SQRT_M1), z = v === l, J = v === mod$1(-l), Y = v === mod$1(-l * SQRT_M1);
  return z && (d = _), (J || Y) && (d = T), edIsNegative(d) && (d = mod$1(-d)), { isValid: z || J, value: d };
}
function invertSqrt(l) {
  return uvRatio(_1n$2, l);
}
function modlLE(l) {
  return mod$1(bytesToNumberLE(l), CURVE$1.l);
}
function equalBytes(l, t) {
  if (l.length !== t.length)
    return !1;
  for (let s = 0; s < l.length; s++)
    if (l[s] !== t[s])
      return !1;
  return !0;
}
function ensureBytes$1(l, t) {
  const s = l instanceof Uint8Array ? Uint8Array.from(l) : hexToBytes$1(l);
  if (typeof t == "number" && s.length !== t)
    throw new Error(`Expected ${t} bytes`);
  return s;
}
function normalizeScalar$1(l, t, s = !0) {
  if (!t)
    throw new TypeError("Specify max value");
  if (typeof l == "number" && Number.isSafeInteger(l) && (l = BigInt(l)), typeof l == "bigint" && l < t) {
    if (s) {
      if (_0n$2 < l)
        return l;
    } else if (_0n$2 <= l)
      return l;
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(l) {
  return l[0] &= 248, l[31] &= 127, l[31] |= 64, l;
}
function checkPrivateKey(l) {
  if (l = typeof l == "bigint" || typeof l == "number" ? numberTo32BytesBE(normalizeScalar$1(l, POW_2_256$1)) : ensureBytes$1(l), l.length !== 32)
    throw new Error("Expected 32 bytes");
  return l;
}
function getKeyFromHash(l) {
  const t = adjustBytes25519(l.slice(0, 32)), s = l.slice(32, 64), h = modlLE(t), m = Point$1.BASE.multiply(h), d = m.toRawBytes();
  return { head: t, prefix: s, scalar: h, point: m, pointBytes: d };
}
let _sha512Sync;
function sha512s(...l) {
  if (typeof _sha512Sync != "function")
    throw new Error("utils.sha512Sync must be set to use sync methods");
  return _sha512Sync(...l);
}
async function getExtendedPublicKey(l) {
  return getKeyFromHash(await utils$2.sha512(checkPrivateKey(l)));
}
function getExtendedPublicKeySync(l) {
  return getKeyFromHash(sha512s(checkPrivateKey(l)));
}
function getPublicKeySync(l) {
  return getExtendedPublicKeySync(l).pointBytes;
}
function signSync$1(l, t) {
  l = ensureBytes$1(l);
  const { prefix: s, scalar: h, pointBytes: m } = getExtendedPublicKeySync(t), d = modlLE(sha512s(s, l)), v = Point$1.BASE.multiply(d), _ = modlLE(sha512s(v.toRawBytes(), m, l)), T = mod$1(d + _ * h, CURVE$1.l);
  return new Signature$1(v, T).toRawBytes();
}
function prepareVerification(l, t, s) {
  t = ensureBytes$1(t), s instanceof Point$1 || (s = Point$1.fromHex(s, !1));
  const { r: h, s: m } = l instanceof Signature$1 ? l.assertValidity() : Signature$1.fromHex(l), d = ExtendedPoint.BASE.multiplyUnsafe(m);
  return { r: h, s: m, SB: d, pub: s, msg: t };
}
function finishVerification(l, t, s, h) {
  const m = modlLE(h), d = ExtendedPoint.fromAffine(l).multiplyUnsafe(m);
  return ExtendedPoint.fromAffine(t).add(d).subtract(s).multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO);
}
function verifySync(l, t, s) {
  const { r: h, SB: m, msg: d, pub: v } = prepareVerification(l, t, s), _ = sha512s(h.toRawBytes(), v.toRawBytes(), d);
  return finishVerification(v, h, m, _);
}
const sync = {
  getExtendedPublicKey: getExtendedPublicKeySync,
  getPublicKey: getPublicKeySync,
  sign: signSync$1,
  verify: verifySync
};
Point$1.BASE._setWindowSize(8);
const crypto$2 = {
  node: nodeCrypto,
  web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
}, utils$2 = {
  bytesToHex: bytesToHex$1,
  hexToBytes: hexToBytes$1,
  concatBytes: concatBytes$1,
  getExtendedPublicKey,
  mod: mod$1,
  invert: invert$1,
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  hashToPrivateScalar: (l) => {
    if (l = ensureBytes$1(l), l.length < 40 || l.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    return mod$1(bytesToNumberLE(l), CURVE$1.l - _1n$2) + _1n$2;
  },
  randomBytes: (l = 32) => {
    if (crypto$2.web)
      return crypto$2.web.getRandomValues(new Uint8Array(l));
    if (crypto$2.node) {
      const { randomBytes: t } = crypto$2.node;
      return new Uint8Array(t(l).buffer);
    } else
      throw new Error("The environment doesn't have randomBytes function");
  },
  randomPrivateKey: () => utils$2.randomBytes(32),
  sha512: async (...l) => {
    const t = concatBytes$1(...l);
    if (crypto$2.web) {
      const s = await crypto$2.web.subtle.digest("SHA-512", t.buffer);
      return new Uint8Array(s);
    } else {
      if (crypto$2.node)
        return Uint8Array.from(crypto$2.node.createHash("sha512").update(t).digest());
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(l = 8, t = Point$1.BASE) {
    const s = t.equals(Point$1.BASE) ? t : new Point$1(t.x, t.y);
    return s._setWindowSize(l), s.multiply(_2n$2), s;
  },
  sha512Sync: void 0
};
Object.defineProperties(utils$2, {
  sha512Sync: {
    configurable: !1,
    get() {
      return _sha512Sync;
    },
    set(l) {
      _sha512Sync || (_sha512Sync = l);
    }
  }
});
var bn = { exports: {} };
(function(l) {
  (function(t, s) {
    function h(k, p) {
      if (!k)
        throw new Error(p || "Assertion failed");
    }
    function m(k, p) {
      k.super_ = p;
      var x = function() {
      };
      x.prototype = p.prototype, k.prototype = new x(), k.prototype.constructor = k;
    }
    function d(k, p, x) {
      if (d.isBN(k))
        return k;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, k !== null && ((p === "le" || p === "be") && (x = p, p = 10), this._init(k || 0, p || 10, x || "be"));
    }
    typeof t == "object" ? t.exports = d : s.BN = d, d.BN = d, d.wordSize = 26;
    var v;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? v = window.Buffer : v = require$$0$5.Buffer;
    } catch {
    }
    d.isBN = function(p) {
      return p instanceof d ? !0 : p !== null && typeof p == "object" && p.constructor.wordSize === d.wordSize && Array.isArray(p.words);
    }, d.max = function(p, x) {
      return p.cmp(x) > 0 ? p : x;
    }, d.min = function(p, x) {
      return p.cmp(x) < 0 ? p : x;
    }, d.prototype._init = function(p, x, S) {
      if (typeof p == "number")
        return this._initNumber(p, x, S);
      if (typeof p == "object")
        return this._initArray(p, x, S);
      x === "hex" && (x = 16), h(x === (x | 0) && x >= 2 && x <= 36), p = p.toString().replace(/\s+/g, "");
      var B = 0;
      p[0] === "-" && (B++, this.negative = 1), B < p.length && (x === 16 ? this._parseHex(p, B, S) : (this._parseBase(p, x, B), S === "le" && this._initArray(this.toArray(), x, S)));
    }, d.prototype._initNumber = function(p, x, S) {
      p < 0 && (this.negative = 1, p = -p), p < 67108864 ? (this.words = [p & 67108863], this.length = 1) : p < 4503599627370496 ? (this.words = [
        p & 67108863,
        p / 67108864 & 67108863
      ], this.length = 2) : (h(p < 9007199254740992), this.words = [
        p & 67108863,
        p / 67108864 & 67108863,
        1
      ], this.length = 3), S === "le" && this._initArray(this.toArray(), x, S);
    }, d.prototype._initArray = function(p, x, S) {
      if (h(typeof p.length == "number"), p.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(p.length / 3), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var L, C, G = 0;
      if (S === "be")
        for (B = p.length - 1, L = 0; B >= 0; B -= 3)
          C = p[B] | p[B - 1] << 8 | p[B - 2] << 16, this.words[L] |= C << G & 67108863, this.words[L + 1] = C >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, L++);
      else if (S === "le")
        for (B = 0, L = 0; B < p.length; B += 3)
          C = p[B] | p[B + 1] << 8 | p[B + 2] << 16, this.words[L] |= C << G & 67108863, this.words[L + 1] = C >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, L++);
      return this._strip();
    };
    function _(k, p) {
      var x = k.charCodeAt(p);
      if (x >= 48 && x <= 57)
        return x - 48;
      if (x >= 65 && x <= 70)
        return x - 55;
      if (x >= 97 && x <= 102)
        return x - 87;
      h(!1, "Invalid character in " + k);
    }
    function T(k, p, x) {
      var S = _(k, x);
      return x - 1 >= p && (S |= _(k, x - 1) << 4), S;
    }
    d.prototype._parseHex = function(p, x, S) {
      this.length = Math.ceil((p.length - x) / 6), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var L = 0, C = 0, G;
      if (S === "be")
        for (B = p.length - 1; B >= x; B -= 2)
          G = T(p, x, B) << L, this.words[C] |= G & 67108863, L >= 18 ? (L -= 18, C += 1, this.words[C] |= G >>> 26) : L += 8;
      else {
        var R = p.length - x;
        for (B = R % 2 === 0 ? x + 1 : x; B < p.length; B += 2)
          G = T(p, x, B) << L, this.words[C] |= G & 67108863, L >= 18 ? (L -= 18, C += 1, this.words[C] |= G >>> 26) : L += 8;
      }
      this._strip();
    };
    function z(k, p, x, S) {
      for (var B = 0, L = 0, C = Math.min(k.length, x), G = p; G < C; G++) {
        var R = k.charCodeAt(G) - 48;
        B *= S, R >= 49 ? L = R - 49 + 10 : R >= 17 ? L = R - 17 + 10 : L = R, h(R >= 0 && L < S, "Invalid character"), B += L;
      }
      return B;
    }
    d.prototype._parseBase = function(p, x, S) {
      this.words = [0], this.length = 1;
      for (var B = 0, L = 1; L <= 67108863; L *= x)
        B++;
      B--, L = L / x | 0;
      for (var C = p.length - S, G = C % B, R = Math.min(C, C - G) + S, y = 0, j = S; j < R; j += B)
        y = z(p, j, j + B, x), this.imuln(L), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      if (G !== 0) {
        var ye = 1;
        for (y = z(p, j, p.length, x), j = 0; j < G; j++)
          ye *= x;
        this.imuln(ye), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      }
      this._strip();
    }, d.prototype.copy = function(p) {
      p.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        p.words[x] = this.words[x];
      p.length = this.length, p.negative = this.negative, p.red = this.red;
    };
    function J(k, p) {
      k.words = p.words, k.length = p.length, k.negative = p.negative, k.red = p.red;
    }
    if (d.prototype._move = function(p) {
      J(p, this);
    }, d.prototype.clone = function() {
      var p = new d(null);
      return this.copy(p), p;
    }, d.prototype._expand = function(p) {
      for (; this.length < p; )
        this.words[this.length++] = 0;
      return this;
    }, d.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, d.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        d.prototype[Symbol.for("nodejs.util.inspect.custom")] = Y;
      } catch {
        d.prototype.inspect = Y;
      }
    else
      d.prototype.inspect = Y;
    function Y() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var ie = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ne = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], de = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    d.prototype.toString = function(p, x) {
      p = p || 10, x = x | 0 || 1;
      var S;
      if (p === 16 || p === "hex") {
        S = "";
        for (var B = 0, L = 0, C = 0; C < this.length; C++) {
          var G = this.words[C], R = ((G << B | L) & 16777215).toString(16);
          L = G >>> 24 - B & 16777215, B += 2, B >= 26 && (B -= 26, C--), L !== 0 || C !== this.length - 1 ? S = ie[6 - R.length] + R + S : S = R + S;
        }
        for (L !== 0 && (S = L.toString(16) + S); S.length % x !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      if (p === (p | 0) && p >= 2 && p <= 36) {
        var y = ne[p], j = de[p];
        S = "";
        var ye = this.clone();
        for (ye.negative = 0; !ye.isZero(); ) {
          var ee = ye.modrn(j).toString(p);
          ye = ye.idivn(j), ye.isZero() ? S = ee + S : S = ie[y - ee.length] + ee + S;
        }
        for (this.isZero() && (S = "0" + S); S.length % x !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      h(!1, "Base should be between 2 and 36");
    }, d.prototype.toNumber = function() {
      var p = this.words[0];
      return this.length === 2 ? p += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? p += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && h(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -p : p;
    }, d.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, v && (d.prototype.toBuffer = function(p, x) {
      return this.toArrayLike(v, p, x);
    }), d.prototype.toArray = function(p, x) {
      return this.toArrayLike(Array, p, x);
    };
    var ce = function(p, x) {
      return p.allocUnsafe ? p.allocUnsafe(x) : new p(x);
    };
    d.prototype.toArrayLike = function(p, x, S) {
      this._strip();
      var B = this.byteLength(), L = S || Math.max(1, B);
      h(B <= L, "byte array longer than desired length"), h(L > 0, "Requested array length <= 0");
      var C = ce(p, L), G = x === "le" ? "LE" : "BE";
      return this["_toArrayLike" + G](C, B), C;
    }, d.prototype._toArrayLikeLE = function(p, x) {
      for (var S = 0, B = 0, L = 0, C = 0; L < this.length; L++) {
        var G = this.words[L] << C | B;
        p[S++] = G & 255, S < p.length && (p[S++] = G >> 8 & 255), S < p.length && (p[S++] = G >> 16 & 255), C === 6 ? (S < p.length && (p[S++] = G >> 24 & 255), B = 0, C = 0) : (B = G >>> 24, C += 2);
      }
      if (S < p.length)
        for (p[S++] = B; S < p.length; )
          p[S++] = 0;
    }, d.prototype._toArrayLikeBE = function(p, x) {
      for (var S = p.length - 1, B = 0, L = 0, C = 0; L < this.length; L++) {
        var G = this.words[L] << C | B;
        p[S--] = G & 255, S >= 0 && (p[S--] = G >> 8 & 255), S >= 0 && (p[S--] = G >> 16 & 255), C === 6 ? (S >= 0 && (p[S--] = G >> 24 & 255), B = 0, C = 0) : (B = G >>> 24, C += 2);
      }
      if (S >= 0)
        for (p[S--] = B; S >= 0; )
          p[S--] = 0;
    }, Math.clz32 ? d.prototype._countBits = function(p) {
      return 32 - Math.clz32(p);
    } : d.prototype._countBits = function(p) {
      var x = p, S = 0;
      return x >= 4096 && (S += 13, x >>>= 13), x >= 64 && (S += 7, x >>>= 7), x >= 8 && (S += 4, x >>>= 4), x >= 2 && (S += 2, x >>>= 2), S + x;
    }, d.prototype._zeroBits = function(p) {
      if (p === 0)
        return 26;
      var x = p, S = 0;
      return (x & 8191) === 0 && (S += 13, x >>>= 13), (x & 127) === 0 && (S += 7, x >>>= 7), (x & 15) === 0 && (S += 4, x >>>= 4), (x & 3) === 0 && (S += 2, x >>>= 2), (x & 1) === 0 && S++, S;
    }, d.prototype.bitLength = function() {
      var p = this.words[this.length - 1], x = this._countBits(p);
      return (this.length - 1) * 26 + x;
    };
    function re(k) {
      for (var p = new Array(k.bitLength()), x = 0; x < p.length; x++) {
        var S = x / 26 | 0, B = x % 26;
        p[x] = k.words[S] >>> B & 1;
      }
      return p;
    }
    d.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var p = 0, x = 0; x < this.length; x++) {
        var S = this._zeroBits(this.words[x]);
        if (p += S, S !== 26)
          break;
      }
      return p;
    }, d.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, d.prototype.toTwos = function(p) {
      return this.negative !== 0 ? this.abs().inotn(p).iaddn(1) : this.clone();
    }, d.prototype.fromTwos = function(p) {
      return this.testn(p - 1) ? this.notn(p).iaddn(1).ineg() : this.clone();
    }, d.prototype.isNeg = function() {
      return this.negative !== 0;
    }, d.prototype.neg = function() {
      return this.clone().ineg();
    }, d.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, d.prototype.iuor = function(p) {
      for (; this.length < p.length; )
        this.words[this.length++] = 0;
      for (var x = 0; x < p.length; x++)
        this.words[x] = this.words[x] | p.words[x];
      return this._strip();
    }, d.prototype.ior = function(p) {
      return h((this.negative | p.negative) === 0), this.iuor(p);
    }, d.prototype.or = function(p) {
      return this.length > p.length ? this.clone().ior(p) : p.clone().ior(this);
    }, d.prototype.uor = function(p) {
      return this.length > p.length ? this.clone().iuor(p) : p.clone().iuor(this);
    }, d.prototype.iuand = function(p) {
      var x;
      this.length > p.length ? x = p : x = this;
      for (var S = 0; S < x.length; S++)
        this.words[S] = this.words[S] & p.words[S];
      return this.length = x.length, this._strip();
    }, d.prototype.iand = function(p) {
      return h((this.negative | p.negative) === 0), this.iuand(p);
    }, d.prototype.and = function(p) {
      return this.length > p.length ? this.clone().iand(p) : p.clone().iand(this);
    }, d.prototype.uand = function(p) {
      return this.length > p.length ? this.clone().iuand(p) : p.clone().iuand(this);
    }, d.prototype.iuxor = function(p) {
      var x, S;
      this.length > p.length ? (x = this, S = p) : (x = p, S = this);
      for (var B = 0; B < S.length; B++)
        this.words[B] = x.words[B] ^ S.words[B];
      if (this !== x)
        for (; B < x.length; B++)
          this.words[B] = x.words[B];
      return this.length = x.length, this._strip();
    }, d.prototype.ixor = function(p) {
      return h((this.negative | p.negative) === 0), this.iuxor(p);
    }, d.prototype.xor = function(p) {
      return this.length > p.length ? this.clone().ixor(p) : p.clone().ixor(this);
    }, d.prototype.uxor = function(p) {
      return this.length > p.length ? this.clone().iuxor(p) : p.clone().iuxor(this);
    }, d.prototype.inotn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = Math.ceil(p / 26) | 0, S = p % 26;
      this._expand(x), S > 0 && x--;
      for (var B = 0; B < x; B++)
        this.words[B] = ~this.words[B] & 67108863;
      return S > 0 && (this.words[B] = ~this.words[B] & 67108863 >> 26 - S), this._strip();
    }, d.prototype.notn = function(p) {
      return this.clone().inotn(p);
    }, d.prototype.setn = function(p, x) {
      h(typeof p == "number" && p >= 0);
      var S = p / 26 | 0, B = p % 26;
      return this._expand(S + 1), x ? this.words[S] = this.words[S] | 1 << B : this.words[S] = this.words[S] & ~(1 << B), this._strip();
    }, d.prototype.iadd = function(p) {
      var x;
      if (this.negative !== 0 && p.negative === 0)
        return this.negative = 0, x = this.isub(p), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && p.negative !== 0)
        return p.negative = 0, x = this.isub(p), p.negative = 1, x._normSign();
      var S, B;
      this.length > p.length ? (S = this, B = p) : (S = p, B = this);
      for (var L = 0, C = 0; C < B.length; C++)
        x = (S.words[C] | 0) + (B.words[C] | 0) + L, this.words[C] = x & 67108863, L = x >>> 26;
      for (; L !== 0 && C < S.length; C++)
        x = (S.words[C] | 0) + L, this.words[C] = x & 67108863, L = x >>> 26;
      if (this.length = S.length, L !== 0)
        this.words[this.length] = L, this.length++;
      else if (S !== this)
        for (; C < S.length; C++)
          this.words[C] = S.words[C];
      return this;
    }, d.prototype.add = function(p) {
      var x;
      return p.negative !== 0 && this.negative === 0 ? (p.negative = 0, x = this.sub(p), p.negative ^= 1, x) : p.negative === 0 && this.negative !== 0 ? (this.negative = 0, x = p.sub(this), this.negative = 1, x) : this.length > p.length ? this.clone().iadd(p) : p.clone().iadd(this);
    }, d.prototype.isub = function(p) {
      if (p.negative !== 0) {
        p.negative = 0;
        var x = this.iadd(p);
        return p.negative = 1, x._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(p), this.negative = 1, this._normSign();
      var S = this.cmp(p);
      if (S === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var B, L;
      S > 0 ? (B = this, L = p) : (B = p, L = this);
      for (var C = 0, G = 0; G < L.length; G++)
        x = (B.words[G] | 0) - (L.words[G] | 0) + C, C = x >> 26, this.words[G] = x & 67108863;
      for (; C !== 0 && G < B.length; G++)
        x = (B.words[G] | 0) + C, C = x >> 26, this.words[G] = x & 67108863;
      if (C === 0 && G < B.length && B !== this)
        for (; G < B.length; G++)
          this.words[G] = B.words[G];
      return this.length = Math.max(this.length, G), B !== this && (this.negative = 1), this._strip();
    }, d.prototype.sub = function(p) {
      return this.clone().isub(p);
    };
    function oe(k, p, x) {
      x.negative = p.negative ^ k.negative;
      var S = k.length + p.length | 0;
      x.length = S, S = S - 1 | 0;
      var B = k.words[0] | 0, L = p.words[0] | 0, C = B * L, G = C & 67108863, R = C / 67108864 | 0;
      x.words[0] = G;
      for (var y = 1; y < S; y++) {
        for (var j = R >>> 26, ye = R & 67108863, ee = Math.min(y, p.length - 1), xe = Math.max(0, y - k.length + 1); xe <= ee; xe++) {
          var $e = y - xe | 0;
          B = k.words[$e] | 0, L = p.words[xe] | 0, C = B * L + ye, j += C / 67108864 | 0, ye = C & 67108863;
        }
        x.words[y] = ye | 0, R = j | 0;
      }
      return R !== 0 ? x.words[y] = R | 0 : x.length--, x._strip();
    }
    var pe = function(p, x, S) {
      var B = p.words, L = x.words, C = S.words, G = 0, R, y, j, ye = B[0] | 0, ee = ye & 8191, xe = ye >>> 13, $e = B[1] | 0, ke = $e & 8191, Ce = $e >>> 13, ht = B[2] | 0, Ue = ht & 8191, De = ht >>> 13, wt = B[3] | 0, He = wt & 8191, Ze = wt >>> 13, Ie = B[4] | 0, ue = Ie & 8191, he = Ie >>> 13, Ne = B[5] | 0, Be = Ne & 8191, Oe = Ne >>> 13, it = B[6] | 0, Ve = it & 8191, Ye = it >>> 13, Pt = B[7] | 0, et = Pt & 8191, Q = Pt >>> 13, W = B[8] | 0, V = W & 8191, se = W >>> 13, Ae = B[9] | 0, _e = Ae & 8191, Re = Ae >>> 13, mt = L[0] | 0, We = mt & 8191, ze = mt >>> 13, kt = L[1] | 0, je = kt & 8191, ot = kt >>> 13, Vt = L[2] | 0, ct = Vt & 8191, ut = Vt >>> 13, Zt = L[3] | 0, rt = Zt & 8191, nt = Zt >>> 13, Gt = L[4] | 0, st = Gt & 8191, at = Gt >>> 13, Jt = L[5] | 0, lt = Jt & 8191, tt = Jt >>> 13, Yt = L[6] | 0, le = Yt & 8191, be = Yt >>> 13, Me = L[7] | 0, te = Me & 8191, ve = Me >>> 13, qe = L[8] | 0, Pe = qe & 8191, Le = qe >>> 13, pt = L[9] | 0, Je = pt & 8191, Ge = pt >>> 13;
      S.negative = p.negative ^ x.negative, S.length = 19, R = Math.imul(ee, We), y = Math.imul(ee, ze), y = y + Math.imul(xe, We) | 0, j = Math.imul(xe, ze);
      var $t = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, R = Math.imul(ke, We), y = Math.imul(ke, ze), y = y + Math.imul(Ce, We) | 0, j = Math.imul(Ce, ze), R = R + Math.imul(ee, je) | 0, y = y + Math.imul(ee, ot) | 0, y = y + Math.imul(xe, je) | 0, j = j + Math.imul(xe, ot) | 0;
      var bt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, R = Math.imul(Ue, We), y = Math.imul(Ue, ze), y = y + Math.imul(De, We) | 0, j = Math.imul(De, ze), R = R + Math.imul(ke, je) | 0, y = y + Math.imul(ke, ot) | 0, y = y + Math.imul(Ce, je) | 0, j = j + Math.imul(Ce, ot) | 0, R = R + Math.imul(ee, ct) | 0, y = y + Math.imul(ee, ut) | 0, y = y + Math.imul(xe, ct) | 0, j = j + Math.imul(xe, ut) | 0;
      var Mt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, R = Math.imul(He, We), y = Math.imul(He, ze), y = y + Math.imul(Ze, We) | 0, j = Math.imul(Ze, ze), R = R + Math.imul(Ue, je) | 0, y = y + Math.imul(Ue, ot) | 0, y = y + Math.imul(De, je) | 0, j = j + Math.imul(De, ot) | 0, R = R + Math.imul(ke, ct) | 0, y = y + Math.imul(ke, ut) | 0, y = y + Math.imul(Ce, ct) | 0, j = j + Math.imul(Ce, ut) | 0, R = R + Math.imul(ee, rt) | 0, y = y + Math.imul(ee, nt) | 0, y = y + Math.imul(xe, rt) | 0, j = j + Math.imul(xe, nt) | 0;
      var Rt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, R = Math.imul(ue, We), y = Math.imul(ue, ze), y = y + Math.imul(he, We) | 0, j = Math.imul(he, ze), R = R + Math.imul(He, je) | 0, y = y + Math.imul(He, ot) | 0, y = y + Math.imul(Ze, je) | 0, j = j + Math.imul(Ze, ot) | 0, R = R + Math.imul(Ue, ct) | 0, y = y + Math.imul(Ue, ut) | 0, y = y + Math.imul(De, ct) | 0, j = j + Math.imul(De, ut) | 0, R = R + Math.imul(ke, rt) | 0, y = y + Math.imul(ke, nt) | 0, y = y + Math.imul(Ce, rt) | 0, j = j + Math.imul(Ce, nt) | 0, R = R + Math.imul(ee, st) | 0, y = y + Math.imul(ee, at) | 0, y = y + Math.imul(xe, st) | 0, j = j + Math.imul(xe, at) | 0;
      var Tt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, R = Math.imul(Be, We), y = Math.imul(Be, ze), y = y + Math.imul(Oe, We) | 0, j = Math.imul(Oe, ze), R = R + Math.imul(ue, je) | 0, y = y + Math.imul(ue, ot) | 0, y = y + Math.imul(he, je) | 0, j = j + Math.imul(he, ot) | 0, R = R + Math.imul(He, ct) | 0, y = y + Math.imul(He, ut) | 0, y = y + Math.imul(Ze, ct) | 0, j = j + Math.imul(Ze, ut) | 0, R = R + Math.imul(Ue, rt) | 0, y = y + Math.imul(Ue, nt) | 0, y = y + Math.imul(De, rt) | 0, j = j + Math.imul(De, nt) | 0, R = R + Math.imul(ke, st) | 0, y = y + Math.imul(ke, at) | 0, y = y + Math.imul(Ce, st) | 0, j = j + Math.imul(Ce, at) | 0, R = R + Math.imul(ee, lt) | 0, y = y + Math.imul(ee, tt) | 0, y = y + Math.imul(xe, lt) | 0, j = j + Math.imul(xe, tt) | 0;
      var Nt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, R = Math.imul(Ve, We), y = Math.imul(Ve, ze), y = y + Math.imul(Ye, We) | 0, j = Math.imul(Ye, ze), R = R + Math.imul(Be, je) | 0, y = y + Math.imul(Be, ot) | 0, y = y + Math.imul(Oe, je) | 0, j = j + Math.imul(Oe, ot) | 0, R = R + Math.imul(ue, ct) | 0, y = y + Math.imul(ue, ut) | 0, y = y + Math.imul(he, ct) | 0, j = j + Math.imul(he, ut) | 0, R = R + Math.imul(He, rt) | 0, y = y + Math.imul(He, nt) | 0, y = y + Math.imul(Ze, rt) | 0, j = j + Math.imul(Ze, nt) | 0, R = R + Math.imul(Ue, st) | 0, y = y + Math.imul(Ue, at) | 0, y = y + Math.imul(De, st) | 0, j = j + Math.imul(De, at) | 0, R = R + Math.imul(ke, lt) | 0, y = y + Math.imul(ke, tt) | 0, y = y + Math.imul(Ce, lt) | 0, j = j + Math.imul(Ce, tt) | 0, R = R + Math.imul(ee, le) | 0, y = y + Math.imul(ee, be) | 0, y = y + Math.imul(xe, le) | 0, j = j + Math.imul(xe, be) | 0;
      var It = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, R = Math.imul(et, We), y = Math.imul(et, ze), y = y + Math.imul(Q, We) | 0, j = Math.imul(Q, ze), R = R + Math.imul(Ve, je) | 0, y = y + Math.imul(Ve, ot) | 0, y = y + Math.imul(Ye, je) | 0, j = j + Math.imul(Ye, ot) | 0, R = R + Math.imul(Be, ct) | 0, y = y + Math.imul(Be, ut) | 0, y = y + Math.imul(Oe, ct) | 0, j = j + Math.imul(Oe, ut) | 0, R = R + Math.imul(ue, rt) | 0, y = y + Math.imul(ue, nt) | 0, y = y + Math.imul(he, rt) | 0, j = j + Math.imul(he, nt) | 0, R = R + Math.imul(He, st) | 0, y = y + Math.imul(He, at) | 0, y = y + Math.imul(Ze, st) | 0, j = j + Math.imul(Ze, at) | 0, R = R + Math.imul(Ue, lt) | 0, y = y + Math.imul(Ue, tt) | 0, y = y + Math.imul(De, lt) | 0, j = j + Math.imul(De, tt) | 0, R = R + Math.imul(ke, le) | 0, y = y + Math.imul(ke, be) | 0, y = y + Math.imul(Ce, le) | 0, j = j + Math.imul(Ce, be) | 0, R = R + Math.imul(ee, te) | 0, y = y + Math.imul(ee, ve) | 0, y = y + Math.imul(xe, te) | 0, j = j + Math.imul(xe, ve) | 0;
      var Ct = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, R = Math.imul(V, We), y = Math.imul(V, ze), y = y + Math.imul(se, We) | 0, j = Math.imul(se, ze), R = R + Math.imul(et, je) | 0, y = y + Math.imul(et, ot) | 0, y = y + Math.imul(Q, je) | 0, j = j + Math.imul(Q, ot) | 0, R = R + Math.imul(Ve, ct) | 0, y = y + Math.imul(Ve, ut) | 0, y = y + Math.imul(Ye, ct) | 0, j = j + Math.imul(Ye, ut) | 0, R = R + Math.imul(Be, rt) | 0, y = y + Math.imul(Be, nt) | 0, y = y + Math.imul(Oe, rt) | 0, j = j + Math.imul(Oe, nt) | 0, R = R + Math.imul(ue, st) | 0, y = y + Math.imul(ue, at) | 0, y = y + Math.imul(he, st) | 0, j = j + Math.imul(he, at) | 0, R = R + Math.imul(He, lt) | 0, y = y + Math.imul(He, tt) | 0, y = y + Math.imul(Ze, lt) | 0, j = j + Math.imul(Ze, tt) | 0, R = R + Math.imul(Ue, le) | 0, y = y + Math.imul(Ue, be) | 0, y = y + Math.imul(De, le) | 0, j = j + Math.imul(De, be) | 0, R = R + Math.imul(ke, te) | 0, y = y + Math.imul(ke, ve) | 0, y = y + Math.imul(Ce, te) | 0, j = j + Math.imul(Ce, ve) | 0, R = R + Math.imul(ee, Pe) | 0, y = y + Math.imul(ee, Le) | 0, y = y + Math.imul(xe, Pe) | 0, j = j + Math.imul(xe, Le) | 0;
      var Bt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, R = Math.imul(_e, We), y = Math.imul(_e, ze), y = y + Math.imul(Re, We) | 0, j = Math.imul(Re, ze), R = R + Math.imul(V, je) | 0, y = y + Math.imul(V, ot) | 0, y = y + Math.imul(se, je) | 0, j = j + Math.imul(se, ot) | 0, R = R + Math.imul(et, ct) | 0, y = y + Math.imul(et, ut) | 0, y = y + Math.imul(Q, ct) | 0, j = j + Math.imul(Q, ut) | 0, R = R + Math.imul(Ve, rt) | 0, y = y + Math.imul(Ve, nt) | 0, y = y + Math.imul(Ye, rt) | 0, j = j + Math.imul(Ye, nt) | 0, R = R + Math.imul(Be, st) | 0, y = y + Math.imul(Be, at) | 0, y = y + Math.imul(Oe, st) | 0, j = j + Math.imul(Oe, at) | 0, R = R + Math.imul(ue, lt) | 0, y = y + Math.imul(ue, tt) | 0, y = y + Math.imul(he, lt) | 0, j = j + Math.imul(he, tt) | 0, R = R + Math.imul(He, le) | 0, y = y + Math.imul(He, be) | 0, y = y + Math.imul(Ze, le) | 0, j = j + Math.imul(Ze, be) | 0, R = R + Math.imul(Ue, te) | 0, y = y + Math.imul(Ue, ve) | 0, y = y + Math.imul(De, te) | 0, j = j + Math.imul(De, ve) | 0, R = R + Math.imul(ke, Pe) | 0, y = y + Math.imul(ke, Le) | 0, y = y + Math.imul(Ce, Pe) | 0, j = j + Math.imul(Ce, Le) | 0, R = R + Math.imul(ee, Je) | 0, y = y + Math.imul(ee, Ge) | 0, y = y + Math.imul(xe, Je) | 0, j = j + Math.imul(xe, Ge) | 0;
      var _t = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, R = Math.imul(_e, je), y = Math.imul(_e, ot), y = y + Math.imul(Re, je) | 0, j = Math.imul(Re, ot), R = R + Math.imul(V, ct) | 0, y = y + Math.imul(V, ut) | 0, y = y + Math.imul(se, ct) | 0, j = j + Math.imul(se, ut) | 0, R = R + Math.imul(et, rt) | 0, y = y + Math.imul(et, nt) | 0, y = y + Math.imul(Q, rt) | 0, j = j + Math.imul(Q, nt) | 0, R = R + Math.imul(Ve, st) | 0, y = y + Math.imul(Ve, at) | 0, y = y + Math.imul(Ye, st) | 0, j = j + Math.imul(Ye, at) | 0, R = R + Math.imul(Be, lt) | 0, y = y + Math.imul(Be, tt) | 0, y = y + Math.imul(Oe, lt) | 0, j = j + Math.imul(Oe, tt) | 0, R = R + Math.imul(ue, le) | 0, y = y + Math.imul(ue, be) | 0, y = y + Math.imul(he, le) | 0, j = j + Math.imul(he, be) | 0, R = R + Math.imul(He, te) | 0, y = y + Math.imul(He, ve) | 0, y = y + Math.imul(Ze, te) | 0, j = j + Math.imul(Ze, ve) | 0, R = R + Math.imul(Ue, Pe) | 0, y = y + Math.imul(Ue, Le) | 0, y = y + Math.imul(De, Pe) | 0, j = j + Math.imul(De, Le) | 0, R = R + Math.imul(ke, Je) | 0, y = y + Math.imul(ke, Ge) | 0, y = y + Math.imul(Ce, Je) | 0, j = j + Math.imul(Ce, Ge) | 0;
      var St = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, R = Math.imul(_e, ct), y = Math.imul(_e, ut), y = y + Math.imul(Re, ct) | 0, j = Math.imul(Re, ut), R = R + Math.imul(V, rt) | 0, y = y + Math.imul(V, nt) | 0, y = y + Math.imul(se, rt) | 0, j = j + Math.imul(se, nt) | 0, R = R + Math.imul(et, st) | 0, y = y + Math.imul(et, at) | 0, y = y + Math.imul(Q, st) | 0, j = j + Math.imul(Q, at) | 0, R = R + Math.imul(Ve, lt) | 0, y = y + Math.imul(Ve, tt) | 0, y = y + Math.imul(Ye, lt) | 0, j = j + Math.imul(Ye, tt) | 0, R = R + Math.imul(Be, le) | 0, y = y + Math.imul(Be, be) | 0, y = y + Math.imul(Oe, le) | 0, j = j + Math.imul(Oe, be) | 0, R = R + Math.imul(ue, te) | 0, y = y + Math.imul(ue, ve) | 0, y = y + Math.imul(he, te) | 0, j = j + Math.imul(he, ve) | 0, R = R + Math.imul(He, Pe) | 0, y = y + Math.imul(He, Le) | 0, y = y + Math.imul(Ze, Pe) | 0, j = j + Math.imul(Ze, Le) | 0, R = R + Math.imul(Ue, Je) | 0, y = y + Math.imul(Ue, Ge) | 0, y = y + Math.imul(De, Je) | 0, j = j + Math.imul(De, Ge) | 0;
      var vt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, R = Math.imul(_e, rt), y = Math.imul(_e, nt), y = y + Math.imul(Re, rt) | 0, j = Math.imul(Re, nt), R = R + Math.imul(V, st) | 0, y = y + Math.imul(V, at) | 0, y = y + Math.imul(se, st) | 0, j = j + Math.imul(se, at) | 0, R = R + Math.imul(et, lt) | 0, y = y + Math.imul(et, tt) | 0, y = y + Math.imul(Q, lt) | 0, j = j + Math.imul(Q, tt) | 0, R = R + Math.imul(Ve, le) | 0, y = y + Math.imul(Ve, be) | 0, y = y + Math.imul(Ye, le) | 0, j = j + Math.imul(Ye, be) | 0, R = R + Math.imul(Be, te) | 0, y = y + Math.imul(Be, ve) | 0, y = y + Math.imul(Oe, te) | 0, j = j + Math.imul(Oe, ve) | 0, R = R + Math.imul(ue, Pe) | 0, y = y + Math.imul(ue, Le) | 0, y = y + Math.imul(he, Pe) | 0, j = j + Math.imul(he, Le) | 0, R = R + Math.imul(He, Je) | 0, y = y + Math.imul(He, Ge) | 0, y = y + Math.imul(Ze, Je) | 0, j = j + Math.imul(Ze, Ge) | 0;
      var At = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, R = Math.imul(_e, st), y = Math.imul(_e, at), y = y + Math.imul(Re, st) | 0, j = Math.imul(Re, at), R = R + Math.imul(V, lt) | 0, y = y + Math.imul(V, tt) | 0, y = y + Math.imul(se, lt) | 0, j = j + Math.imul(se, tt) | 0, R = R + Math.imul(et, le) | 0, y = y + Math.imul(et, be) | 0, y = y + Math.imul(Q, le) | 0, j = j + Math.imul(Q, be) | 0, R = R + Math.imul(Ve, te) | 0, y = y + Math.imul(Ve, ve) | 0, y = y + Math.imul(Ye, te) | 0, j = j + Math.imul(Ye, ve) | 0, R = R + Math.imul(Be, Pe) | 0, y = y + Math.imul(Be, Le) | 0, y = y + Math.imul(Oe, Pe) | 0, j = j + Math.imul(Oe, Le) | 0, R = R + Math.imul(ue, Je) | 0, y = y + Math.imul(ue, Ge) | 0, y = y + Math.imul(he, Je) | 0, j = j + Math.imul(he, Ge) | 0;
      var Et = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, R = Math.imul(_e, lt), y = Math.imul(_e, tt), y = y + Math.imul(Re, lt) | 0, j = Math.imul(Re, tt), R = R + Math.imul(V, le) | 0, y = y + Math.imul(V, be) | 0, y = y + Math.imul(se, le) | 0, j = j + Math.imul(se, be) | 0, R = R + Math.imul(et, te) | 0, y = y + Math.imul(et, ve) | 0, y = y + Math.imul(Q, te) | 0, j = j + Math.imul(Q, ve) | 0, R = R + Math.imul(Ve, Pe) | 0, y = y + Math.imul(Ve, Le) | 0, y = y + Math.imul(Ye, Pe) | 0, j = j + Math.imul(Ye, Le) | 0, R = R + Math.imul(Be, Je) | 0, y = y + Math.imul(Be, Ge) | 0, y = y + Math.imul(Oe, Je) | 0, j = j + Math.imul(Oe, Ge) | 0;
      var yt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, R = Math.imul(_e, le), y = Math.imul(_e, be), y = y + Math.imul(Re, le) | 0, j = Math.imul(Re, be), R = R + Math.imul(V, te) | 0, y = y + Math.imul(V, ve) | 0, y = y + Math.imul(se, te) | 0, j = j + Math.imul(se, ve) | 0, R = R + Math.imul(et, Pe) | 0, y = y + Math.imul(et, Le) | 0, y = y + Math.imul(Q, Pe) | 0, j = j + Math.imul(Q, Le) | 0, R = R + Math.imul(Ve, Je) | 0, y = y + Math.imul(Ve, Ge) | 0, y = y + Math.imul(Ye, Je) | 0, j = j + Math.imul(Ye, Ge) | 0;
      var Xe = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, R = Math.imul(_e, te), y = Math.imul(_e, ve), y = y + Math.imul(Re, te) | 0, j = Math.imul(Re, ve), R = R + Math.imul(V, Pe) | 0, y = y + Math.imul(V, Le) | 0, y = y + Math.imul(se, Pe) | 0, j = j + Math.imul(se, Le) | 0, R = R + Math.imul(et, Je) | 0, y = y + Math.imul(et, Ge) | 0, y = y + Math.imul(Q, Je) | 0, j = j + Math.imul(Q, Ge) | 0;
      var Qe = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, R = Math.imul(_e, Pe), y = Math.imul(_e, Le), y = y + Math.imul(Re, Pe) | 0, j = Math.imul(Re, Le), R = R + Math.imul(V, Je) | 0, y = y + Math.imul(V, Ge) | 0, y = y + Math.imul(se, Je) | 0, j = j + Math.imul(se, Ge) | 0;
      var dt = (G + R | 0) + ((y & 8191) << 13) | 0;
      G = (j + (y >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, R = Math.imul(_e, Je), y = Math.imul(_e, Ge), y = y + Math.imul(Re, Je) | 0, j = Math.imul(Re, Ge);
      var ft = (G + R | 0) + ((y & 8191) << 13) | 0;
      return G = (j + (y >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, C[0] = $t, C[1] = bt, C[2] = Mt, C[3] = Rt, C[4] = Tt, C[5] = Nt, C[6] = It, C[7] = Ct, C[8] = Bt, C[9] = _t, C[10] = St, C[11] = vt, C[12] = At, C[13] = Et, C[14] = yt, C[15] = Xe, C[16] = Qe, C[17] = dt, C[18] = ft, G !== 0 && (C[19] = G, S.length++), S;
    };
    Math.imul || (pe = oe);
    function ae(k, p, x) {
      x.negative = p.negative ^ k.negative, x.length = k.length + p.length;
      for (var S = 0, B = 0, L = 0; L < x.length - 1; L++) {
        var C = B;
        B = 0;
        for (var G = S & 67108863, R = Math.min(L, p.length - 1), y = Math.max(0, L - k.length + 1); y <= R; y++) {
          var j = L - y, ye = k.words[j] | 0, ee = p.words[y] | 0, xe = ye * ee, $e = xe & 67108863;
          C = C + (xe / 67108864 | 0) | 0, $e = $e + G | 0, G = $e & 67108863, C = C + ($e >>> 26) | 0, B += C >>> 26, C &= 67108863;
        }
        x.words[L] = G, S = C, C = B;
      }
      return S !== 0 ? x.words[L] = S : x.length--, x._strip();
    }
    function me(k, p, x) {
      return ae(k, p, x);
    }
    d.prototype.mulTo = function(p, x) {
      var S, B = this.length + p.length;
      return this.length === 10 && p.length === 10 ? S = pe(this, p, x) : B < 63 ? S = oe(this, p, x) : B < 1024 ? S = ae(this, p, x) : S = me(this, p, x), S;
    }, d.prototype.mul = function(p) {
      var x = new d(null);
      return x.words = new Array(this.length + p.length), this.mulTo(p, x);
    }, d.prototype.mulf = function(p) {
      var x = new d(null);
      return x.words = new Array(this.length + p.length), me(this, p, x);
    }, d.prototype.imul = function(p) {
      return this.clone().mulTo(p, this);
    }, d.prototype.imuln = function(p) {
      var x = p < 0;
      x && (p = -p), h(typeof p == "number"), h(p < 67108864);
      for (var S = 0, B = 0; B < this.length; B++) {
        var L = (this.words[B] | 0) * p, C = (L & 67108863) + (S & 67108863);
        S >>= 26, S += L / 67108864 | 0, S += C >>> 26, this.words[B] = C & 67108863;
      }
      return S !== 0 && (this.words[B] = S, this.length++), x ? this.ineg() : this;
    }, d.prototype.muln = function(p) {
      return this.clone().imuln(p);
    }, d.prototype.sqr = function() {
      return this.mul(this);
    }, d.prototype.isqr = function() {
      return this.imul(this.clone());
    }, d.prototype.pow = function(p) {
      var x = re(p);
      if (x.length === 0)
        return new d(1);
      for (var S = this, B = 0; B < x.length && x[B] === 0; B++, S = S.sqr())
        ;
      if (++B < x.length)
        for (var L = S.sqr(); B < x.length; B++, L = L.sqr())
          x[B] !== 0 && (S = S.mul(L));
      return S;
    }, d.prototype.iushln = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26, B = 67108863 >>> 26 - x << 26 - x, L;
      if (x !== 0) {
        var C = 0;
        for (L = 0; L < this.length; L++) {
          var G = this.words[L] & B, R = (this.words[L] | 0) - G << x;
          this.words[L] = R | C, C = G >>> 26 - x;
        }
        C && (this.words[L] = C, this.length++);
      }
      if (S !== 0) {
        for (L = this.length - 1; L >= 0; L--)
          this.words[L + S] = this.words[L];
        for (L = 0; L < S; L++)
          this.words[L] = 0;
        this.length += S;
      }
      return this._strip();
    }, d.prototype.ishln = function(p) {
      return h(this.negative === 0), this.iushln(p);
    }, d.prototype.iushrn = function(p, x, S) {
      h(typeof p == "number" && p >= 0);
      var B;
      x ? B = (x - x % 26) / 26 : B = 0;
      var L = p % 26, C = Math.min((p - L) / 26, this.length), G = 67108863 ^ 67108863 >>> L << L, R = S;
      if (B -= C, B = Math.max(0, B), R) {
        for (var y = 0; y < C; y++)
          R.words[y] = this.words[y];
        R.length = C;
      }
      if (C !== 0)
        if (this.length > C)
          for (this.length -= C, y = 0; y < this.length; y++)
            this.words[y] = this.words[y + C];
        else
          this.words[0] = 0, this.length = 1;
      var j = 0;
      for (y = this.length - 1; y >= 0 && (j !== 0 || y >= B); y--) {
        var ye = this.words[y] | 0;
        this.words[y] = j << 26 - L | ye >>> L, j = ye & G;
      }
      return R && j !== 0 && (R.words[R.length++] = j), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, d.prototype.ishrn = function(p, x, S) {
      return h(this.negative === 0), this.iushrn(p, x, S);
    }, d.prototype.shln = function(p) {
      return this.clone().ishln(p);
    }, d.prototype.ushln = function(p) {
      return this.clone().iushln(p);
    }, d.prototype.shrn = function(p) {
      return this.clone().ishrn(p);
    }, d.prototype.ushrn = function(p) {
      return this.clone().iushrn(p);
    }, d.prototype.testn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26, B = 1 << x;
      if (this.length <= S)
        return !1;
      var L = this.words[S];
      return !!(L & B);
    }, d.prototype.imaskn = function(p) {
      h(typeof p == "number" && p >= 0);
      var x = p % 26, S = (p - x) / 26;
      if (h(this.negative === 0, "imaskn works only with positive numbers"), this.length <= S)
        return this;
      if (x !== 0 && S++, this.length = Math.min(S, this.length), x !== 0) {
        var B = 67108863 ^ 67108863 >>> x << x;
        this.words[this.length - 1] &= B;
      }
      return this._strip();
    }, d.prototype.maskn = function(p) {
      return this.clone().imaskn(p);
    }, d.prototype.iaddn = function(p) {
      return h(typeof p == "number"), h(p < 67108864), p < 0 ? this.isubn(-p) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= p ? (this.words[0] = p - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(p), this.negative = 1, this) : this._iaddn(p);
    }, d.prototype._iaddn = function(p) {
      this.words[0] += p;
      for (var x = 0; x < this.length && this.words[x] >= 67108864; x++)
        this.words[x] -= 67108864, x === this.length - 1 ? this.words[x + 1] = 1 : this.words[x + 1]++;
      return this.length = Math.max(this.length, x + 1), this;
    }, d.prototype.isubn = function(p) {
      if (h(typeof p == "number"), h(p < 67108864), p < 0)
        return this.iaddn(-p);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(p), this.negative = 1, this;
      if (this.words[0] -= p, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var x = 0; x < this.length && this.words[x] < 0; x++)
          this.words[x] += 67108864, this.words[x + 1] -= 1;
      return this._strip();
    }, d.prototype.addn = function(p) {
      return this.clone().iaddn(p);
    }, d.prototype.subn = function(p) {
      return this.clone().isubn(p);
    }, d.prototype.iabs = function() {
      return this.negative = 0, this;
    }, d.prototype.abs = function() {
      return this.clone().iabs();
    }, d.prototype._ishlnsubmul = function(p, x, S) {
      var B = p.length + S, L;
      this._expand(B);
      var C, G = 0;
      for (L = 0; L < p.length; L++) {
        C = (this.words[L + S] | 0) + G;
        var R = (p.words[L] | 0) * x;
        C -= R & 67108863, G = (C >> 26) - (R / 67108864 | 0), this.words[L + S] = C & 67108863;
      }
      for (; L < this.length - S; L++)
        C = (this.words[L + S] | 0) + G, G = C >> 26, this.words[L + S] = C & 67108863;
      if (G === 0)
        return this._strip();
      for (h(G === -1), G = 0, L = 0; L < this.length; L++)
        C = -(this.words[L] | 0) + G, G = C >> 26, this.words[L] = C & 67108863;
      return this.negative = 1, this._strip();
    }, d.prototype._wordDiv = function(p, x) {
      var S = this.length - p.length, B = this.clone(), L = p, C = L.words[L.length - 1] | 0, G = this._countBits(C);
      S = 26 - G, S !== 0 && (L = L.ushln(S), B.iushln(S), C = L.words[L.length - 1] | 0);
      var R = B.length - L.length, y;
      if (x !== "mod") {
        y = new d(null), y.length = R + 1, y.words = new Array(y.length);
        for (var j = 0; j < y.length; j++)
          y.words[j] = 0;
      }
      var ye = B.clone()._ishlnsubmul(L, 1, R);
      ye.negative === 0 && (B = ye, y && (y.words[R] = 1));
      for (var ee = R - 1; ee >= 0; ee--) {
        var xe = (B.words[L.length + ee] | 0) * 67108864 + (B.words[L.length + ee - 1] | 0);
        for (xe = Math.min(xe / C | 0, 67108863), B._ishlnsubmul(L, xe, ee); B.negative !== 0; )
          xe--, B.negative = 0, B._ishlnsubmul(L, 1, ee), B.isZero() || (B.negative ^= 1);
        y && (y.words[ee] = xe);
      }
      return y && y._strip(), B._strip(), x !== "div" && S !== 0 && B.iushrn(S), {
        div: y || null,
        mod: B
      };
    }, d.prototype.divmod = function(p, x, S) {
      if (h(!p.isZero()), this.isZero())
        return {
          div: new d(0),
          mod: new d(0)
        };
      var B, L, C;
      return this.negative !== 0 && p.negative === 0 ? (C = this.neg().divmod(p, x), x !== "mod" && (B = C.div.neg()), x !== "div" && (L = C.mod.neg(), S && L.negative !== 0 && L.iadd(p)), {
        div: B,
        mod: L
      }) : this.negative === 0 && p.negative !== 0 ? (C = this.divmod(p.neg(), x), x !== "mod" && (B = C.div.neg()), {
        div: B,
        mod: C.mod
      }) : (this.negative & p.negative) !== 0 ? (C = this.neg().divmod(p.neg(), x), x !== "div" && (L = C.mod.neg(), S && L.negative !== 0 && L.isub(p)), {
        div: C.div,
        mod: L
      }) : p.length > this.length || this.cmp(p) < 0 ? {
        div: new d(0),
        mod: this
      } : p.length === 1 ? x === "div" ? {
        div: this.divn(p.words[0]),
        mod: null
      } : x === "mod" ? {
        div: null,
        mod: new d(this.modrn(p.words[0]))
      } : {
        div: this.divn(p.words[0]),
        mod: new d(this.modrn(p.words[0]))
      } : this._wordDiv(p, x);
    }, d.prototype.div = function(p) {
      return this.divmod(p, "div", !1).div;
    }, d.prototype.mod = function(p) {
      return this.divmod(p, "mod", !1).mod;
    }, d.prototype.umod = function(p) {
      return this.divmod(p, "mod", !0).mod;
    }, d.prototype.divRound = function(p) {
      var x = this.divmod(p);
      if (x.mod.isZero())
        return x.div;
      var S = x.div.negative !== 0 ? x.mod.isub(p) : x.mod, B = p.ushrn(1), L = p.andln(1), C = S.cmp(B);
      return C < 0 || L === 1 && C === 0 ? x.div : x.div.negative !== 0 ? x.div.isubn(1) : x.div.iaddn(1);
    }, d.prototype.modrn = function(p) {
      var x = p < 0;
      x && (p = -p), h(p <= 67108863);
      for (var S = (1 << 26) % p, B = 0, L = this.length - 1; L >= 0; L--)
        B = (S * B + (this.words[L] | 0)) % p;
      return x ? -B : B;
    }, d.prototype.modn = function(p) {
      return this.modrn(p);
    }, d.prototype.idivn = function(p) {
      var x = p < 0;
      x && (p = -p), h(p <= 67108863);
      for (var S = 0, B = this.length - 1; B >= 0; B--) {
        var L = (this.words[B] | 0) + S * 67108864;
        this.words[B] = L / p | 0, S = L % p;
      }
      return this._strip(), x ? this.ineg() : this;
    }, d.prototype.divn = function(p) {
      return this.clone().idivn(p);
    }, d.prototype.egcd = function(p) {
      h(p.negative === 0), h(!p.isZero());
      var x = this, S = p.clone();
      x.negative !== 0 ? x = x.umod(p) : x = x.clone();
      for (var B = new d(1), L = new d(0), C = new d(0), G = new d(1), R = 0; x.isEven() && S.isEven(); )
        x.iushrn(1), S.iushrn(1), ++R;
      for (var y = S.clone(), j = x.clone(); !x.isZero(); ) {
        for (var ye = 0, ee = 1; (x.words[0] & ee) === 0 && ye < 26; ++ye, ee <<= 1)
          ;
        if (ye > 0)
          for (x.iushrn(ye); ye-- > 0; )
            (B.isOdd() || L.isOdd()) && (B.iadd(y), L.isub(j)), B.iushrn(1), L.iushrn(1);
        for (var xe = 0, $e = 1; (S.words[0] & $e) === 0 && xe < 26; ++xe, $e <<= 1)
          ;
        if (xe > 0)
          for (S.iushrn(xe); xe-- > 0; )
            (C.isOdd() || G.isOdd()) && (C.iadd(y), G.isub(j)), C.iushrn(1), G.iushrn(1);
        x.cmp(S) >= 0 ? (x.isub(S), B.isub(C), L.isub(G)) : (S.isub(x), C.isub(B), G.isub(L));
      }
      return {
        a: C,
        b: G,
        gcd: S.iushln(R)
      };
    }, d.prototype._invmp = function(p) {
      h(p.negative === 0), h(!p.isZero());
      var x = this, S = p.clone();
      x.negative !== 0 ? x = x.umod(p) : x = x.clone();
      for (var B = new d(1), L = new d(0), C = S.clone(); x.cmpn(1) > 0 && S.cmpn(1) > 0; ) {
        for (var G = 0, R = 1; (x.words[0] & R) === 0 && G < 26; ++G, R <<= 1)
          ;
        if (G > 0)
          for (x.iushrn(G); G-- > 0; )
            B.isOdd() && B.iadd(C), B.iushrn(1);
        for (var y = 0, j = 1; (S.words[0] & j) === 0 && y < 26; ++y, j <<= 1)
          ;
        if (y > 0)
          for (S.iushrn(y); y-- > 0; )
            L.isOdd() && L.iadd(C), L.iushrn(1);
        x.cmp(S) >= 0 ? (x.isub(S), B.isub(L)) : (S.isub(x), L.isub(B));
      }
      var ye;
      return x.cmpn(1) === 0 ? ye = B : ye = L, ye.cmpn(0) < 0 && ye.iadd(p), ye;
    }, d.prototype.gcd = function(p) {
      if (this.isZero())
        return p.abs();
      if (p.isZero())
        return this.abs();
      var x = this.clone(), S = p.clone();
      x.negative = 0, S.negative = 0;
      for (var B = 0; x.isEven() && S.isEven(); B++)
        x.iushrn(1), S.iushrn(1);
      do {
        for (; x.isEven(); )
          x.iushrn(1);
        for (; S.isEven(); )
          S.iushrn(1);
        var L = x.cmp(S);
        if (L < 0) {
          var C = x;
          x = S, S = C;
        } else if (L === 0 || S.cmpn(1) === 0)
          break;
        x.isub(S);
      } while (!0);
      return S.iushln(B);
    }, d.prototype.invm = function(p) {
      return this.egcd(p).a.umod(p);
    }, d.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, d.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, d.prototype.andln = function(p) {
      return this.words[0] & p;
    }, d.prototype.bincn = function(p) {
      h(typeof p == "number");
      var x = p % 26, S = (p - x) / 26, B = 1 << x;
      if (this.length <= S)
        return this._expand(S + 1), this.words[S] |= B, this;
      for (var L = B, C = S; L !== 0 && C < this.length; C++) {
        var G = this.words[C] | 0;
        G += L, L = G >>> 26, G &= 67108863, this.words[C] = G;
      }
      return L !== 0 && (this.words[C] = L, this.length++), this;
    }, d.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, d.prototype.cmpn = function(p) {
      var x = p < 0;
      if (this.negative !== 0 && !x)
        return -1;
      if (this.negative === 0 && x)
        return 1;
      this._strip();
      var S;
      if (this.length > 1)
        S = 1;
      else {
        x && (p = -p), h(p <= 67108863, "Number is too big");
        var B = this.words[0] | 0;
        S = B === p ? 0 : B < p ? -1 : 1;
      }
      return this.negative !== 0 ? -S | 0 : S;
    }, d.prototype.cmp = function(p) {
      if (this.negative !== 0 && p.negative === 0)
        return -1;
      if (this.negative === 0 && p.negative !== 0)
        return 1;
      var x = this.ucmp(p);
      return this.negative !== 0 ? -x | 0 : x;
    }, d.prototype.ucmp = function(p) {
      if (this.length > p.length)
        return 1;
      if (this.length < p.length)
        return -1;
      for (var x = 0, S = this.length - 1; S >= 0; S--) {
        var B = this.words[S] | 0, L = p.words[S] | 0;
        if (B !== L) {
          B < L ? x = -1 : B > L && (x = 1);
          break;
        }
      }
      return x;
    }, d.prototype.gtn = function(p) {
      return this.cmpn(p) === 1;
    }, d.prototype.gt = function(p) {
      return this.cmp(p) === 1;
    }, d.prototype.gten = function(p) {
      return this.cmpn(p) >= 0;
    }, d.prototype.gte = function(p) {
      return this.cmp(p) >= 0;
    }, d.prototype.ltn = function(p) {
      return this.cmpn(p) === -1;
    }, d.prototype.lt = function(p) {
      return this.cmp(p) === -1;
    }, d.prototype.lten = function(p) {
      return this.cmpn(p) <= 0;
    }, d.prototype.lte = function(p) {
      return this.cmp(p) <= 0;
    }, d.prototype.eqn = function(p) {
      return this.cmpn(p) === 0;
    }, d.prototype.eq = function(p) {
      return this.cmp(p) === 0;
    }, d.red = function(p) {
      return new X(p);
    }, d.prototype.toRed = function(p) {
      return h(!this.red, "Already a number in reduction context"), h(this.negative === 0, "red works only with positives"), p.convertTo(this)._forceRed(p);
    }, d.prototype.fromRed = function() {
      return h(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, d.prototype._forceRed = function(p) {
      return this.red = p, this;
    }, d.prototype.forceRed = function(p) {
      return h(!this.red, "Already a number in reduction context"), this._forceRed(p);
    }, d.prototype.redAdd = function(p) {
      return h(this.red, "redAdd works only with red numbers"), this.red.add(this, p);
    }, d.prototype.redIAdd = function(p) {
      return h(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, p);
    }, d.prototype.redSub = function(p) {
      return h(this.red, "redSub works only with red numbers"), this.red.sub(this, p);
    }, d.prototype.redISub = function(p) {
      return h(this.red, "redISub works only with red numbers"), this.red.isub(this, p);
    }, d.prototype.redShl = function(p) {
      return h(this.red, "redShl works only with red numbers"), this.red.shl(this, p);
    }, d.prototype.redMul = function(p) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.mul(this, p);
    }, d.prototype.redIMul = function(p) {
      return h(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.imul(this, p);
    }, d.prototype.redSqr = function() {
      return h(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, d.prototype.redISqr = function() {
      return h(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, d.prototype.redSqrt = function() {
      return h(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, d.prototype.redInvm = function() {
      return h(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, d.prototype.redNeg = function() {
      return h(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, d.prototype.redPow = function(p) {
      return h(this.red && !p.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, p);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function we(k, p) {
      this.name = k, this.p = new d(p, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    we.prototype._tmp = function() {
      var p = new d(null);
      return p.words = new Array(Math.ceil(this.n / 13)), p;
    }, we.prototype.ireduce = function(p) {
      var x = p, S;
      do
        this.split(x, this.tmp), x = this.imulK(x), x = x.iadd(this.tmp), S = x.bitLength();
      while (S > this.n);
      var B = S < this.n ? -1 : x.ucmp(this.p);
      return B === 0 ? (x.words[0] = 0, x.length = 1) : B > 0 ? x.isub(this.p) : x.strip !== void 0 ? x.strip() : x._strip(), x;
    }, we.prototype.split = function(p, x) {
      p.iushrn(this.n, 0, x);
    }, we.prototype.imulK = function(p) {
      return p.imul(this.k);
    };
    function Ee() {
      we.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    m(Ee, we), Ee.prototype.split = function(p, x) {
      for (var S = 4194303, B = Math.min(p.length, 9), L = 0; L < B; L++)
        x.words[L] = p.words[L];
      if (x.length = B, p.length <= 9) {
        p.words[0] = 0, p.length = 1;
        return;
      }
      var C = p.words[9];
      for (x.words[x.length++] = C & S, L = 10; L < p.length; L++) {
        var G = p.words[L] | 0;
        p.words[L - 10] = (G & S) << 4 | C >>> 22, C = G;
      }
      C >>>= 22, p.words[L - 10] = C, C === 0 && p.length > 10 ? p.length -= 10 : p.length -= 9;
    }, Ee.prototype.imulK = function(p) {
      p.words[p.length] = 0, p.words[p.length + 1] = 0, p.length += 2;
      for (var x = 0, S = 0; S < p.length; S++) {
        var B = p.words[S] | 0;
        x += B * 977, p.words[S] = x & 67108863, x = B * 64 + (x / 67108864 | 0);
      }
      return p.words[p.length - 1] === 0 && (p.length--, p.words[p.length - 1] === 0 && p.length--), p;
    };
    function Te() {
      we.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    m(Te, we);
    function Ke() {
      we.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    m(Ke, we);
    function Se() {
      we.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    m(Se, we), Se.prototype.imulK = function(p) {
      for (var x = 0, S = 0; S < p.length; S++) {
        var B = (p.words[S] | 0) * 19 + x, L = B & 67108863;
        B >>>= 26, p.words[S] = L, x = B;
      }
      return x !== 0 && (p.words[p.length++] = x), p;
    }, d._prime = function(p) {
      if (ge[p])
        return ge[p];
      var x;
      if (p === "k256")
        x = new Ee();
      else if (p === "p224")
        x = new Te();
      else if (p === "p192")
        x = new Ke();
      else if (p === "p25519")
        x = new Se();
      else
        throw new Error("Unknown prime " + p);
      return ge[p] = x, x;
    };
    function X(k) {
      if (typeof k == "string") {
        var p = d._prime(k);
        this.m = p.p, this.prime = p;
      } else
        h(k.gtn(1), "modulus must be greater than 1"), this.m = k, this.prime = null;
    }
    X.prototype._verify1 = function(p) {
      h(p.negative === 0, "red works only with positives"), h(p.red, "red works only with red numbers");
    }, X.prototype._verify2 = function(p, x) {
      h((p.negative | x.negative) === 0, "red works only with positives"), h(
        p.red && p.red === x.red,
        "red works only with red numbers"
      );
    }, X.prototype.imod = function(p) {
      return this.prime ? this.prime.ireduce(p)._forceRed(this) : (J(p, p.umod(this.m)._forceRed(this)), p);
    }, X.prototype.neg = function(p) {
      return p.isZero() ? p.clone() : this.m.sub(p)._forceRed(this);
    }, X.prototype.add = function(p, x) {
      this._verify2(p, x);
      var S = p.add(x);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S._forceRed(this);
    }, X.prototype.iadd = function(p, x) {
      this._verify2(p, x);
      var S = p.iadd(x);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S;
    }, X.prototype.sub = function(p, x) {
      this._verify2(p, x);
      var S = p.sub(x);
      return S.cmpn(0) < 0 && S.iadd(this.m), S._forceRed(this);
    }, X.prototype.isub = function(p, x) {
      this._verify2(p, x);
      var S = p.isub(x);
      return S.cmpn(0) < 0 && S.iadd(this.m), S;
    }, X.prototype.shl = function(p, x) {
      return this._verify1(p), this.imod(p.ushln(x));
    }, X.prototype.imul = function(p, x) {
      return this._verify2(p, x), this.imod(p.imul(x));
    }, X.prototype.mul = function(p, x) {
      return this._verify2(p, x), this.imod(p.mul(x));
    }, X.prototype.isqr = function(p) {
      return this.imul(p, p.clone());
    }, X.prototype.sqr = function(p) {
      return this.mul(p, p);
    }, X.prototype.sqrt = function(p) {
      if (p.isZero())
        return p.clone();
      var x = this.m.andln(3);
      if (h(x % 2 === 1), x === 3) {
        var S = this.m.add(new d(1)).iushrn(2);
        return this.pow(p, S);
      }
      for (var B = this.m.subn(1), L = 0; !B.isZero() && B.andln(1) === 0; )
        L++, B.iushrn(1);
      h(!B.isZero());
      var C = new d(1).toRed(this), G = C.redNeg(), R = this.m.subn(1).iushrn(1), y = this.m.bitLength();
      for (y = new d(2 * y * y).toRed(this); this.pow(y, R).cmp(G) !== 0; )
        y.redIAdd(G);
      for (var j = this.pow(y, B), ye = this.pow(p, B.addn(1).iushrn(1)), ee = this.pow(p, B), xe = L; ee.cmp(C) !== 0; ) {
        for (var $e = ee, ke = 0; $e.cmp(C) !== 0; ke++)
          $e = $e.redSqr();
        h(ke < xe);
        var Ce = this.pow(j, new d(1).iushln(xe - ke - 1));
        ye = ye.redMul(Ce), j = Ce.redSqr(), ee = ee.redMul(j), xe = ke;
      }
      return ye;
    }, X.prototype.invm = function(p) {
      var x = p._invmp(this.m);
      return x.negative !== 0 ? (x.negative = 0, this.imod(x).redNeg()) : this.imod(x);
    }, X.prototype.pow = function(p, x) {
      if (x.isZero())
        return new d(1).toRed(this);
      if (x.cmpn(1) === 0)
        return p.clone();
      var S = 4, B = new Array(1 << S);
      B[0] = new d(1).toRed(this), B[1] = p;
      for (var L = 2; L < B.length; L++)
        B[L] = this.mul(B[L - 1], p);
      var C = B[0], G = 0, R = 0, y = x.bitLength() % 26;
      for (y === 0 && (y = 26), L = x.length - 1; L >= 0; L--) {
        for (var j = x.words[L], ye = y - 1; ye >= 0; ye--) {
          var ee = j >> ye & 1;
          if (C !== B[0] && (C = this.sqr(C)), ee === 0 && G === 0) {
            R = 0;
            continue;
          }
          G <<= 1, G |= ee, R++, !(R !== S && (L !== 0 || ye !== 0)) && (C = this.mul(C, B[G]), R = 0, G = 0);
        }
        y = 26;
      }
      return C;
    }, X.prototype.convertTo = function(p) {
      var x = p.umod(this.m);
      return x === p ? x.clone() : x;
    }, X.prototype.convertFrom = function(p) {
      var x = p.clone();
      return x.red = null, x;
    }, d.mont = function(p) {
      return new fe(p);
    };
    function fe(k) {
      X.call(this, k), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    m(fe, X), fe.prototype.convertTo = function(p) {
      return this.imod(p.ushln(this.shift));
    }, fe.prototype.convertFrom = function(p) {
      var x = this.imod(p.mul(this.rinv));
      return x.red = null, x;
    }, fe.prototype.imul = function(p, x) {
      if (p.isZero() || x.isZero())
        return p.words[0] = 0, p.length = 1, p;
      var S = p.imul(x), B = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = S.isub(B).iushrn(this.shift), C = L;
      return L.cmp(this.m) >= 0 ? C = L.isub(this.m) : L.cmpn(0) < 0 && (C = L.iadd(this.m)), C._forceRed(this);
    }, fe.prototype.mul = function(p, x) {
      if (p.isZero() || x.isZero())
        return new d(0)._forceRed(this);
      var S = p.mul(x), B = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = S.isub(B).iushrn(this.shift), C = L;
      return L.cmp(this.m) >= 0 ? C = L.isub(this.m) : L.cmpn(0) < 0 && (C = L.iadd(this.m)), C._forceRed(this);
    }, fe.prototype.invm = function(p) {
      var x = this.imod(p._invmp(this.m).mul(this.r2));
      return x._forceRed(this);
    };
  })(l, commonjsGlobal);
})(bn);
var BN = bn.exports;
const Chi = (l, t, s) => l & t ^ ~l & s, Maj = (l, t, s) => l & t ^ l & s ^ t & s, SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: t, B: s, C: h, D: m, E: d, F: v, G: _, H: T } = this;
    return [t, s, h, m, d, v, _, T];
  }
  set(t, s, h, m, d, v, _, T) {
    this.A = t | 0, this.B = s | 0, this.C = h | 0, this.D = m | 0, this.E = d | 0, this.F = v | 0, this.G = _ | 0, this.H = T | 0;
  }
  process(t, s) {
    for (let Y = 0; Y < 16; Y++, s += 4)
      SHA256_W[Y] = t.getUint32(s, !1);
    for (let Y = 16; Y < 64; Y++) {
      const ie = SHA256_W[Y - 15], ne = SHA256_W[Y - 2], de = rotr(ie, 7) ^ rotr(ie, 18) ^ ie >>> 3, ce = rotr(ne, 17) ^ rotr(ne, 19) ^ ne >>> 10;
      SHA256_W[Y] = ce + SHA256_W[Y - 7] + de + SHA256_W[Y - 16] | 0;
    }
    let { A: h, B: m, C: d, D: v, E: _, F: T, G: z, H: J } = this;
    for (let Y = 0; Y < 64; Y++) {
      const ie = rotr(_, 6) ^ rotr(_, 11) ^ rotr(_, 25), ne = J + ie + Chi(_, T, z) + SHA256_K[Y] + SHA256_W[Y] | 0, ce = (rotr(h, 2) ^ rotr(h, 13) ^ rotr(h, 22)) + Maj(h, m, d) | 0;
      J = z, z = T, T = _, _ = v + ne | 0, v = d, d = m, m = h, h = ne + ce | 0;
    }
    h = h + this.A | 0, m = m + this.B | 0, d = d + this.C | 0, v = v + this.D | 0, _ = _ + this.E | 0, T = T + this.F | 0, z = z + this.G | 0, J = J + this.H | 0, this.set(h, m, d, v, _, T, z, J);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
const sha256 = wrapConstructor(() => new SHA256());
wrapConstructor(() => new SHA224());
var Layout$1 = {};
Object.defineProperty(Layout$1, "__esModule", { value: !0 });
Layout$1.s16 = Layout$1.s8 = Layout$1.nu64be = Layout$1.u48be = Layout$1.u40be = Layout$1.u32be = Layout$1.u24be = Layout$1.u16be = nu64 = Layout$1.nu64 = Layout$1.u48 = Layout$1.u40 = u32 = Layout$1.u32 = Layout$1.u24 = u16 = Layout$1.u16 = u8 = Layout$1.u8 = offset = Layout$1.offset = Layout$1.greedy = Layout$1.Constant = Layout$1.UTF8 = Layout$1.CString = Layout$1.Blob = Layout$1.Boolean = Layout$1.BitField = Layout$1.BitStructure = Layout$1.VariantLayout = Layout$1.Union = Layout$1.UnionLayoutDiscriminator = Layout$1.UnionDiscriminator = Layout$1.Structure = Layout$1.Sequence = Layout$1.DoubleBE = Layout$1.Double = Layout$1.FloatBE = Layout$1.Float = Layout$1.NearInt64BE = Layout$1.NearInt64 = Layout$1.NearUInt64BE = Layout$1.NearUInt64 = Layout$1.IntBE = Layout$1.Int = Layout$1.UIntBE = Layout$1.UInt = Layout$1.OffsetLayout = Layout$1.GreedyCount = Layout$1.ExternalLayout = Layout$1.bindConstructorLayout = Layout$1.nameWithProperty = Layout$1.Layout = Layout$1.uint8ArrayToBuffer = Layout$1.checkUint8Array = void 0;
Layout$1.constant = Layout$1.utf8 = Layout$1.cstr = blob = Layout$1.blob = Layout$1.unionLayoutDiscriminator = Layout$1.union = seq = Layout$1.seq = Layout$1.bits = struct = Layout$1.struct = Layout$1.f64be = Layout$1.f64 = Layout$1.f32be = Layout$1.f32 = Layout$1.ns64be = Layout$1.s48be = Layout$1.s40be = Layout$1.s32be = Layout$1.s24be = Layout$1.s16be = ns64 = Layout$1.ns64 = Layout$1.s48 = Layout$1.s40 = Layout$1.s32 = Layout$1.s24 = void 0;
const buffer_1 = buffer$1;
function checkUint8Array(l) {
  if (!(l instanceof Uint8Array))
    throw new TypeError("b must be a Uint8Array");
}
Layout$1.checkUint8Array = checkUint8Array;
function uint8ArrayToBuffer(l) {
  return checkUint8Array(l), buffer_1.Buffer.from(l.buffer, l.byteOffset, l.length);
}
Layout$1.uint8ArrayToBuffer = uint8ArrayToBuffer;
class Layout {
  constructor(t, s) {
    if (!Number.isInteger(t))
      throw new TypeError("span must be an integer");
    this.span = t, this.property = s;
  }
  makeDestinationObject() {
    return {};
  }
  getSpan(t, s) {
    if (0 > this.span)
      throw new RangeError("indeterminate span");
    return this.span;
  }
  replicate(t) {
    const s = Object.create(this.constructor.prototype);
    return Object.assign(s, this), s.property = t, s;
  }
  fromArray(t) {
  }
}
Layout$1.Layout = Layout;
function nameWithProperty(l, t) {
  return t.property ? l + "[" + t.property + "]" : l;
}
Layout$1.nameWithProperty = nameWithProperty;
function bindConstructorLayout(l, t) {
  if (typeof l != "function")
    throw new TypeError("Class must be constructor");
  if (Object.prototype.hasOwnProperty.call(l, "layout_"))
    throw new Error("Class is already bound to a layout");
  if (!(t && t instanceof Layout))
    throw new TypeError("layout must be a Layout");
  if (Object.prototype.hasOwnProperty.call(t, "boundConstructor_"))
    throw new Error("layout is already bound to a constructor");
  l.layout_ = t, t.boundConstructor_ = l, t.makeDestinationObject = () => new l(), Object.defineProperty(l.prototype, "encode", {
    value(s, h) {
      return t.encode(this, s, h);
    },
    writable: !0
  }), Object.defineProperty(l, "decode", {
    value(s, h) {
      return t.decode(s, h);
    },
    writable: !0
  });
}
Layout$1.bindConstructorLayout = bindConstructorLayout;
class ExternalLayout extends Layout {
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
}
Layout$1.ExternalLayout = ExternalLayout;
class GreedyCount extends ExternalLayout {
  constructor(t = 1, s) {
    if (!Number.isInteger(t) || 0 >= t)
      throw new TypeError("elementSpan must be a (positive) integer");
    super(-1, s), this.elementSpan = t;
  }
  isCount() {
    return !0;
  }
  decode(t, s = 0) {
    checkUint8Array(t);
    const h = t.length - s;
    return Math.floor(h / this.elementSpan);
  }
  encode(t, s, h) {
    return 0;
  }
}
Layout$1.GreedyCount = GreedyCount;
class OffsetLayout extends ExternalLayout {
  constructor(t, s = 0, h) {
    if (!(t instanceof Layout))
      throw new TypeError("layout must be a Layout");
    if (!Number.isInteger(s))
      throw new TypeError("offset must be integer or undefined");
    super(t.span, h || t.property), this.layout = t, this.offset = s;
  }
  isCount() {
    return this.layout instanceof UInt || this.layout instanceof UIntBE;
  }
  decode(t, s = 0) {
    return this.layout.decode(t, s + this.offset);
  }
  encode(t, s, h = 0) {
    return this.layout.encode(t, s, h + this.offset);
  }
}
Layout$1.OffsetLayout = OffsetLayout;
class UInt extends Layout {
  constructor(t, s) {
    if (super(t, s), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(t, s = 0) {
    return uint8ArrayToBuffer(t).readUIntLE(s, this.span);
  }
  encode(t, s, h = 0) {
    return uint8ArrayToBuffer(s).writeUIntLE(t, h, this.span), this.span;
  }
}
Layout$1.UInt = UInt;
class UIntBE extends Layout {
  constructor(t, s) {
    if (super(t, s), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(t, s = 0) {
    return uint8ArrayToBuffer(t).readUIntBE(s, this.span);
  }
  encode(t, s, h = 0) {
    return uint8ArrayToBuffer(s).writeUIntBE(t, h, this.span), this.span;
  }
}
Layout$1.UIntBE = UIntBE;
class Int extends Layout {
  constructor(t, s) {
    if (super(t, s), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(t, s = 0) {
    return uint8ArrayToBuffer(t).readIntLE(s, this.span);
  }
  encode(t, s, h = 0) {
    return uint8ArrayToBuffer(s).writeIntLE(t, h, this.span), this.span;
  }
}
Layout$1.Int = Int;
class IntBE extends Layout {
  constructor(t, s) {
    if (super(t, s), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(t, s = 0) {
    return uint8ArrayToBuffer(t).readIntBE(s, this.span);
  }
  encode(t, s, h = 0) {
    return uint8ArrayToBuffer(s).writeIntBE(t, h, this.span), this.span;
  }
}
Layout$1.IntBE = IntBE;
const V2E32 = Math.pow(2, 32);
function divmodInt64(l) {
  const t = Math.floor(l / V2E32), s = l - t * V2E32;
  return { hi32: t, lo32: s };
}
function roundedInt64(l, t) {
  return l * V2E32 + t;
}
class NearUInt64 extends Layout {
  constructor(t) {
    super(8, t);
  }
  decode(t, s = 0) {
    const h = uint8ArrayToBuffer(t), m = h.readUInt32LE(s), d = h.readUInt32LE(s + 4);
    return roundedInt64(d, m);
  }
  encode(t, s, h = 0) {
    const m = divmodInt64(t), d = uint8ArrayToBuffer(s);
    return d.writeUInt32LE(m.lo32, h), d.writeUInt32LE(m.hi32, h + 4), 8;
  }
}
Layout$1.NearUInt64 = NearUInt64;
class NearUInt64BE extends Layout {
  constructor(t) {
    super(8, t);
  }
  decode(t, s = 0) {
    const h = uint8ArrayToBuffer(t), m = h.readUInt32BE(s), d = h.readUInt32BE(s + 4);
    return roundedInt64(m, d);
  }
  encode(t, s, h = 0) {
    const m = divmodInt64(t), d = uint8ArrayToBuffer(s);
    return d.writeUInt32BE(m.hi32, h), d.writeUInt32BE(m.lo32, h + 4), 8;
  }
}
Layout$1.NearUInt64BE = NearUInt64BE;
class NearInt64 extends Layout {
  constructor(t) {
    super(8, t);
  }
  decode(t, s = 0) {
    const h = uint8ArrayToBuffer(t), m = h.readUInt32LE(s), d = h.readInt32LE(s + 4);
    return roundedInt64(d, m);
  }
  encode(t, s, h = 0) {
    const m = divmodInt64(t), d = uint8ArrayToBuffer(s);
    return d.writeUInt32LE(m.lo32, h), d.writeInt32LE(m.hi32, h + 4), 8;
  }
}
Layout$1.NearInt64 = NearInt64;
class NearInt64BE extends Layout {
  constructor(t) {
    super(8, t);
  }
  decode(t, s = 0) {
    const h = uint8ArrayToBuffer(t), m = h.readInt32BE(s), d = h.readUInt32BE(s + 4);
    return roundedInt64(m, d);
  }
  encode(t, s, h = 0) {
    const m = divmodInt64(t), d = uint8ArrayToBuffer(s);
    return d.writeInt32BE(m.hi32, h), d.writeUInt32BE(m.lo32, h + 4), 8;
  }
}
Layout$1.NearInt64BE = NearInt64BE;
class Float extends Layout {
  constructor(t) {
    super(4, t);
  }
  decode(t, s = 0) {
    return uint8ArrayToBuffer(t).readFloatLE(s);
  }
  encode(t, s, h = 0) {
    return uint8ArrayToBuffer(s).writeFloatLE(t, h), 4;
  }
}
Layout$1.Float = Float;
class FloatBE extends Layout {
  constructor(t) {
    super(4, t);
  }
  decode(t, s = 0) {
    return uint8ArrayToBuffer(t).readFloatBE(s);
  }
  encode(t, s, h = 0) {
    return uint8ArrayToBuffer(s).writeFloatBE(t, h), 4;
  }
}
Layout$1.FloatBE = FloatBE;
class Double extends Layout {
  constructor(t) {
    super(8, t);
  }
  decode(t, s = 0) {
    return uint8ArrayToBuffer(t).readDoubleLE(s);
  }
  encode(t, s, h = 0) {
    return uint8ArrayToBuffer(s).writeDoubleLE(t, h), 8;
  }
}
Layout$1.Double = Double;
class DoubleBE extends Layout {
  constructor(t) {
    super(8, t);
  }
  decode(t, s = 0) {
    return uint8ArrayToBuffer(t).readDoubleBE(s);
  }
  encode(t, s, h = 0) {
    return uint8ArrayToBuffer(s).writeDoubleBE(t, h), 8;
  }
}
Layout$1.DoubleBE = DoubleBE;
class Sequence extends Layout {
  constructor(t, s, h) {
    if (!(t instanceof Layout))
      throw new TypeError("elementLayout must be a Layout");
    if (!(s instanceof ExternalLayout && s.isCount() || Number.isInteger(s) && 0 <= s))
      throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
    let m = -1;
    !(s instanceof ExternalLayout) && 0 < t.span && (m = s * t.span), super(m, h), this.elementLayout = t, this.count = s;
  }
  getSpan(t, s = 0) {
    if (0 <= this.span)
      return this.span;
    let h = 0, m = this.count;
    if (m instanceof ExternalLayout && (m = m.decode(t, s)), 0 < this.elementLayout.span)
      h = m * this.elementLayout.span;
    else {
      let d = 0;
      for (; d < m; )
        h += this.elementLayout.getSpan(t, s + h), ++d;
    }
    return h;
  }
  decode(t, s = 0) {
    const h = [];
    let m = 0, d = this.count;
    for (d instanceof ExternalLayout && (d = d.decode(t, s)); m < d; )
      h.push(this.elementLayout.decode(t, s)), s += this.elementLayout.getSpan(t, s), m += 1;
    return h;
  }
  encode(t, s, h = 0) {
    const m = this.elementLayout, d = t.reduce((v, _) => v + m.encode(_, s, h + v), 0);
    return this.count instanceof ExternalLayout && this.count.encode(t.length, s, h), d;
  }
}
Layout$1.Sequence = Sequence;
class Structure extends Layout {
  constructor(t, s, h) {
    if (!(Array.isArray(t) && t.reduce((d, v) => d && v instanceof Layout, !0)))
      throw new TypeError("fields must be array of Layout instances");
    typeof s == "boolean" && h === void 0 && (h = s, s = void 0);
    for (const d of t)
      if (0 > d.span && d.property === void 0)
        throw new Error("fields cannot contain unnamed variable-length layout");
    let m = -1;
    try {
      m = t.reduce((d, v) => d + v.getSpan(), 0);
    } catch {
    }
    super(m, s), this.fields = t, this.decodePrefixes = !!h;
  }
  getSpan(t, s = 0) {
    if (0 <= this.span)
      return this.span;
    let h = 0;
    try {
      h = this.fields.reduce((m, d) => {
        const v = d.getSpan(t, s);
        return s += v, m + v;
      }, 0);
    } catch {
      throw new RangeError("indeterminate span");
    }
    return h;
  }
  decode(t, s = 0) {
    checkUint8Array(t);
    const h = this.makeDestinationObject();
    for (const m of this.fields)
      if (m.property !== void 0 && (h[m.property] = m.decode(t, s)), s += m.getSpan(t, s), this.decodePrefixes && t.length === s)
        break;
    return h;
  }
  encode(t, s, h = 0) {
    const m = h;
    let d = 0, v = 0;
    for (const _ of this.fields) {
      let T = _.span;
      if (v = 0 < T ? T : 0, _.property !== void 0) {
        const z = t[_.property];
        z !== void 0 && (v = _.encode(z, s, h), 0 > T && (T = _.getSpan(s, h)));
      }
      d = h, h += T;
    }
    return d + v - m;
  }
  fromArray(t) {
    const s = this.makeDestinationObject();
    for (const h of this.fields)
      h.property !== void 0 && 0 < t.length && (s[h.property] = t.shift());
    return s;
  }
  layoutFor(t) {
    if (typeof t != "string")
      throw new TypeError("property must be string");
    for (const s of this.fields)
      if (s.property === t)
        return s;
  }
  offsetOf(t) {
    if (typeof t != "string")
      throw new TypeError("property must be string");
    let s = 0;
    for (const h of this.fields) {
      if (h.property === t)
        return s;
      0 > h.span ? s = -1 : 0 <= s && (s += h.span);
    }
  }
}
Layout$1.Structure = Structure;
class UnionDiscriminator {
  constructor(t) {
    this.property = t;
  }
  decode(t, s) {
    throw new Error("UnionDiscriminator is abstract");
  }
  encode(t, s, h) {
    throw new Error("UnionDiscriminator is abstract");
  }
}
Layout$1.UnionDiscriminator = UnionDiscriminator;
class UnionLayoutDiscriminator extends UnionDiscriminator {
  constructor(t, s) {
    if (!(t instanceof ExternalLayout && t.isCount()))
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    super(s || t.property || "variant"), this.layout = t;
  }
  decode(t, s) {
    return this.layout.decode(t, s);
  }
  encode(t, s, h) {
    return this.layout.encode(t, s, h);
  }
}
Layout$1.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
class Union extends Layout {
  constructor(t, s, h) {
    let m;
    if (t instanceof UInt || t instanceof UIntBE)
      m = new UnionLayoutDiscriminator(new OffsetLayout(t));
    else if (t instanceof ExternalLayout && t.isCount())
      m = new UnionLayoutDiscriminator(t);
    else if (t instanceof UnionDiscriminator)
      m = t;
    else
      throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
    if (s === void 0 && (s = null), !(s === null || s instanceof Layout))
      throw new TypeError("defaultLayout must be null or a Layout");
    if (s !== null) {
      if (0 > s.span)
        throw new Error("defaultLayout must have constant span");
      s.property === void 0 && (s = s.replicate("content"));
    }
    let d = -1;
    s && (d = s.span, 0 <= d && (t instanceof UInt || t instanceof UIntBE) && (d += m.layout.span)), super(d, h), this.discriminator = m, this.usesPrefixDiscriminator = t instanceof UInt || t instanceof UIntBE, this.defaultLayout = s, this.registry = {};
    let v = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(_) {
      return v(_);
    }, this.configGetSourceVariant = function(_) {
      v = _.bind(this);
    };
  }
  getSpan(t, s = 0) {
    if (0 <= this.span)
      return this.span;
    const h = this.getVariant(t, s);
    if (!h)
      throw new Error("unable to determine span for unrecognized variant");
    return h.getSpan(t, s);
  }
  defaultGetSourceVariant(t) {
    if (Object.prototype.hasOwnProperty.call(t, this.discriminator.property)) {
      if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(t, this.defaultLayout.property))
        return;
      const s = this.registry[t[this.discriminator.property]];
      if (s && (!s.layout || s.property && Object.prototype.hasOwnProperty.call(t, s.property)))
        return s;
    } else
      for (const s in this.registry) {
        const h = this.registry[s];
        if (h.property && Object.prototype.hasOwnProperty.call(t, h.property))
          return h;
      }
    throw new Error("unable to infer src variant");
  }
  decode(t, s = 0) {
    let h;
    const m = this.discriminator, d = m.decode(t, s), v = this.registry[d];
    if (v === void 0) {
      const _ = this.defaultLayout;
      let T = 0;
      this.usesPrefixDiscriminator && (T = m.layout.span), h = this.makeDestinationObject(), h[m.property] = d, h[_.property] = _.decode(t, s + T);
    } else
      h = v.decode(t, s);
    return h;
  }
  encode(t, s, h = 0) {
    const m = this.getSourceVariant(t);
    if (m === void 0) {
      const d = this.discriminator, v = this.defaultLayout;
      let _ = 0;
      return this.usesPrefixDiscriminator && (_ = d.layout.span), d.encode(t[d.property], s, h), _ + v.encode(t[v.property], s, h + _);
    }
    return m.encode(t, s, h);
  }
  addVariant(t, s, h) {
    const m = new VariantLayout(this, t, s, h);
    return this.registry[t] = m, m;
  }
  getVariant(t, s = 0) {
    let h;
    return t instanceof Uint8Array ? h = this.discriminator.decode(t, s) : h = t, this.registry[h];
  }
}
Layout$1.Union = Union;
class VariantLayout extends Layout {
  constructor(t, s, h, m) {
    if (!(t instanceof Union))
      throw new TypeError("union must be a Union");
    if (!Number.isInteger(s) || 0 > s)
      throw new TypeError("variant must be a (non-negative) integer");
    if (typeof h == "string" && m === void 0 && (m = h, h = null), h) {
      if (!(h instanceof Layout))
        throw new TypeError("layout must be a Layout");
      if (t.defaultLayout !== null && 0 <= h.span && h.span > t.defaultLayout.span)
        throw new Error("variant span exceeds span of containing union");
      if (typeof m != "string")
        throw new TypeError("variant must have a String property");
    }
    let d = t.span;
    0 > t.span && (d = h ? h.span : 0, 0 <= d && t.usesPrefixDiscriminator && (d += t.discriminator.layout.span)), super(d, m), this.union = t, this.variant = s, this.layout = h || null;
  }
  getSpan(t, s = 0) {
    if (0 <= this.span)
      return this.span;
    let h = 0;
    this.union.usesPrefixDiscriminator && (h = this.union.discriminator.layout.span);
    let m = 0;
    return this.layout && (m = this.layout.getSpan(t, s + h)), h + m;
  }
  decode(t, s = 0) {
    const h = this.makeDestinationObject();
    if (this !== this.union.getVariant(t, s))
      throw new Error("variant mismatch");
    let m = 0;
    return this.union.usesPrefixDiscriminator && (m = this.union.discriminator.layout.span), this.layout ? h[this.property] = this.layout.decode(t, s + m) : this.property ? h[this.property] = !0 : this.union.usesPrefixDiscriminator && (h[this.union.discriminator.property] = this.variant), h;
  }
  encode(t, s, h = 0) {
    let m = 0;
    if (this.union.usesPrefixDiscriminator && (m = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(t, this.property))
      throw new TypeError("variant lacks property " + this.property);
    this.union.discriminator.encode(this.variant, s, h);
    let d = m;
    if (this.layout && (this.layout.encode(t[this.property], s, h + m), d += this.layout.getSpan(s, h + m), 0 <= this.union.span && d > this.union.span))
      throw new Error("encoded variant overruns containing union");
    return d;
  }
  fromArray(t) {
    if (this.layout)
      return this.layout.fromArray(t);
  }
}
Layout$1.VariantLayout = VariantLayout;
function fixBitwiseResult(l) {
  return 0 > l && (l += 4294967296), l;
}
class BitStructure extends Layout {
  constructor(t, s, h) {
    if (!(t instanceof UInt || t instanceof UIntBE))
      throw new TypeError("word must be a UInt or UIntBE layout");
    if (typeof s == "string" && h === void 0 && (h = s, s = !1), 4 < t.span)
      throw new RangeError("word cannot exceed 32 bits");
    super(t.span, h), this.word = t, this.msb = !!s, this.fields = [];
    let m = 0;
    this._packedSetValue = function(d) {
      return m = fixBitwiseResult(d), this;
    }, this._packedGetValue = function() {
      return m;
    };
  }
  decode(t, s = 0) {
    const h = this.makeDestinationObject(), m = this.word.decode(t, s);
    this._packedSetValue(m);
    for (const d of this.fields)
      d.property !== void 0 && (h[d.property] = d.decode(t));
    return h;
  }
  encode(t, s, h = 0) {
    const m = this.word.decode(s, h);
    this._packedSetValue(m);
    for (const d of this.fields)
      if (d.property !== void 0) {
        const v = t[d.property];
        v !== void 0 && d.encode(v);
      }
    return this.word.encode(this._packedGetValue(), s, h);
  }
  addField(t, s) {
    const h = new BitField(this, t, s);
    return this.fields.push(h), h;
  }
  addBoolean(t) {
    const s = new Boolean$1(this, t);
    return this.fields.push(s), s;
  }
  fieldFor(t) {
    if (typeof t != "string")
      throw new TypeError("property must be string");
    for (const s of this.fields)
      if (s.property === t)
        return s;
  }
}
Layout$1.BitStructure = BitStructure;
class BitField {
  constructor(t, s, h) {
    if (!(t instanceof BitStructure))
      throw new TypeError("container must be a BitStructure");
    if (!Number.isInteger(s) || 0 >= s)
      throw new TypeError("bits must be positive integer");
    const m = 8 * t.span, d = t.fields.reduce((v, _) => v + _.bits, 0);
    if (s + d > m)
      throw new Error("bits too long for span remainder (" + (m - d) + " of " + m + " remain)");
    this.container = t, this.bits = s, this.valueMask = (1 << s) - 1, s === 32 && (this.valueMask = 4294967295), this.start = d, this.container.msb && (this.start = m - d - s), this.wordMask = fixBitwiseResult(this.valueMask << this.start), this.property = h;
  }
  decode(t, s) {
    const h = this.container._packedGetValue();
    return fixBitwiseResult(h & this.wordMask) >>> this.start;
  }
  encode(t) {
    if (typeof t != "number" || !Number.isInteger(t) || t !== fixBitwiseResult(t & this.valueMask))
      throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
    const s = this.container._packedGetValue(), h = fixBitwiseResult(t << this.start);
    this.container._packedSetValue(fixBitwiseResult(s & ~this.wordMask) | h);
  }
}
Layout$1.BitField = BitField;
let Boolean$1 = class extends BitField {
  constructor(t, s) {
    super(t, 1, s);
  }
  decode(t, s) {
    return !!super.decode(t, s);
  }
  encode(t) {
    typeof t == "boolean" && (t = +t), super.encode(t);
  }
};
Layout$1.Boolean = Boolean$1;
class Blob extends Layout {
  constructor(t, s) {
    if (!(t instanceof ExternalLayout && t.isCount() || Number.isInteger(t) && 0 <= t))
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    let h = -1;
    t instanceof ExternalLayout || (h = t), super(h, s), this.length = t;
  }
  getSpan(t, s) {
    let h = this.span;
    return 0 > h && (h = this.length.decode(t, s)), h;
  }
  decode(t, s = 0) {
    let h = this.span;
    return 0 > h && (h = this.length.decode(t, s)), uint8ArrayToBuffer(t).slice(s, s + h);
  }
  encode(t, s, h) {
    let m = this.length;
    if (this.length instanceof ExternalLayout && (m = t.length), !(t instanceof Uint8Array && m === t.length))
      throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + m + ") Uint8Array as src");
    if (h + m > s.length)
      throw new RangeError("encoding overruns Uint8Array");
    const d = uint8ArrayToBuffer(t);
    return uint8ArrayToBuffer(s).write(d.toString("hex"), h, m, "hex"), this.length instanceof ExternalLayout && this.length.encode(m, s, h), m;
  }
}
Layout$1.Blob = Blob;
class CString extends Layout {
  constructor(t) {
    super(-1, t);
  }
  getSpan(t, s = 0) {
    checkUint8Array(t);
    let h = s;
    for (; h < t.length && t[h] !== 0; )
      h += 1;
    return 1 + h - s;
  }
  decode(t, s = 0) {
    const h = this.getSpan(t, s);
    return uint8ArrayToBuffer(t).slice(s, s + h - 1).toString("utf-8");
  }
  encode(t, s, h = 0) {
    typeof t != "string" && (t = String(t));
    const m = buffer_1.Buffer.from(t, "utf8"), d = m.length;
    if (h + d > s.length)
      throw new RangeError("encoding overruns Buffer");
    const v = uint8ArrayToBuffer(s);
    return m.copy(v, h), v[h + d] = 0, d + 1;
  }
}
Layout$1.CString = CString;
class UTF8 extends Layout {
  constructor(t, s) {
    if (typeof t == "string" && s === void 0 && (s = t, t = void 0), t === void 0)
      t = -1;
    else if (!Number.isInteger(t))
      throw new TypeError("maxSpan must be an integer");
    super(-1, s), this.maxSpan = t;
  }
  getSpan(t, s = 0) {
    return checkUint8Array(t), t.length - s;
  }
  decode(t, s = 0) {
    const h = this.getSpan(t, s);
    if (0 <= this.maxSpan && this.maxSpan < h)
      throw new RangeError("text length exceeds maxSpan");
    return uint8ArrayToBuffer(t).slice(s, s + h).toString("utf-8");
  }
  encode(t, s, h = 0) {
    typeof t != "string" && (t = String(t));
    const m = buffer_1.Buffer.from(t, "utf8"), d = m.length;
    if (0 <= this.maxSpan && this.maxSpan < d)
      throw new RangeError("text length exceeds maxSpan");
    if (h + d > s.length)
      throw new RangeError("encoding overruns Buffer");
    return m.copy(uint8ArrayToBuffer(s), h), d;
  }
}
Layout$1.UTF8 = UTF8;
class Constant extends Layout {
  constructor(t, s) {
    super(0, s), this.value = t;
  }
  decode(t, s) {
    return this.value;
  }
  encode(t, s, h) {
    return 0;
  }
}
Layout$1.Constant = Constant;
Layout$1.greedy = (l, t) => new GreedyCount(l, t);
var offset = Layout$1.offset = (l, t, s) => new OffsetLayout(l, t, s), u8 = Layout$1.u8 = (l) => new UInt(1, l), u16 = Layout$1.u16 = (l) => new UInt(2, l);
Layout$1.u24 = (l) => new UInt(3, l);
var u32 = Layout$1.u32 = (l) => new UInt(4, l);
Layout$1.u40 = (l) => new UInt(5, l);
Layout$1.u48 = (l) => new UInt(6, l);
var nu64 = Layout$1.nu64 = (l) => new NearUInt64(l);
Layout$1.u16be = (l) => new UIntBE(2, l);
Layout$1.u24be = (l) => new UIntBE(3, l);
Layout$1.u32be = (l) => new UIntBE(4, l);
Layout$1.u40be = (l) => new UIntBE(5, l);
Layout$1.u48be = (l) => new UIntBE(6, l);
Layout$1.nu64be = (l) => new NearUInt64BE(l);
Layout$1.s8 = (l) => new Int(1, l);
Layout$1.s16 = (l) => new Int(2, l);
Layout$1.s24 = (l) => new Int(3, l);
Layout$1.s32 = (l) => new Int(4, l);
Layout$1.s40 = (l) => new Int(5, l);
Layout$1.s48 = (l) => new Int(6, l);
var ns64 = Layout$1.ns64 = (l) => new NearInt64(l);
Layout$1.s16be = (l) => new IntBE(2, l);
Layout$1.s24be = (l) => new IntBE(3, l);
Layout$1.s32be = (l) => new IntBE(4, l);
Layout$1.s40be = (l) => new IntBE(5, l);
Layout$1.s48be = (l) => new IntBE(6, l);
Layout$1.ns64be = (l) => new NearInt64BE(l);
Layout$1.f32 = (l) => new Float(l);
Layout$1.f32be = (l) => new FloatBE(l);
Layout$1.f64 = (l) => new Double(l);
Layout$1.f64be = (l) => new DoubleBE(l);
var struct = Layout$1.struct = (l, t, s) => new Structure(l, t, s);
Layout$1.bits = (l, t, s) => new BitStructure(l, t, s);
var seq = Layout$1.seq = (l, t, s) => new Sequence(l, t, s);
Layout$1.union = (l, t, s) => new Union(l, t, s);
Layout$1.unionLayoutDiscriminator = (l, t) => new UnionLayoutDiscriminator(l, t);
var blob = Layout$1.blob = (l, t) => new Blob(l, t);
Layout$1.cstr = (l) => new CString(l);
Layout$1.utf8 = (l, t) => new UTF8(l, t);
Layout$1.constant = (l, t) => new Constant(l, t);
var browser$1 = {};
Object.defineProperty(browser$1, "__esModule", { value: !0 });
function toBigIntLE(l) {
  {
    const t = Buffer.from(l);
    t.reverse();
    const s = t.toString("hex");
    return s.length === 0 ? BigInt(0) : BigInt(`0x${s}`);
  }
}
var toBigIntLE_1 = browser$1.toBigIntLE = toBigIntLE;
function toBigIntBE(l) {
  {
    const t = l.toString("hex");
    return t.length === 0 ? BigInt(0) : BigInt(`0x${t}`);
  }
}
browser$1.toBigIntBE = toBigIntBE;
function toBufferLE(l, t) {
  {
    const s = l.toString(16), h = Buffer.from(s.padStart(t * 2, "0").slice(0, t * 2), "hex");
    return h.reverse(), h;
  }
}
var toBufferLE_1 = browser$1.toBufferLE = toBufferLE;
function toBufferBE(l, t) {
  {
    const s = l.toString(16);
    return Buffer.from(s.padStart(t * 2, "0").slice(0, t * 2), "hex");
  }
}
browser$1.toBufferBE = toBufferBE;
class StructError extends TypeError {
  constructor(t, s) {
    let h;
    const {
      message: m,
      ...d
    } = t, {
      path: v
    } = t, _ = v.length === 0 ? m : "At path: " + v.join(".") + " -- " + m;
    super(_), Object.assign(this, d), this.name = this.constructor.name, this.failures = () => {
      var T;
      return (T = h) != null ? T : h = [t, ...s()];
    };
  }
}
function isIterable(l) {
  return isObject(l) && typeof l[Symbol.iterator] == "function";
}
function isObject(l) {
  return typeof l == "object" && l != null;
}
function print(l) {
  return typeof l == "string" ? JSON.stringify(l) : "" + l;
}
function shiftIterator(l) {
  const {
    done: t,
    value: s
  } = l.next();
  return t ? void 0 : s;
}
function toFailure(l, t, s, h) {
  if (l === !0)
    return;
  l === !1 ? l = {} : typeof l == "string" && (l = {
    message: l
  });
  const {
    path: m,
    branch: d
  } = t, {
    type: v
  } = s, {
    refinement: _,
    message: T = "Expected a value of type `" + v + "`" + (_ ? " with refinement `" + _ + "`" : "") + ", but received: `" + print(h) + "`"
  } = l;
  return {
    value: h,
    type: v,
    refinement: _,
    key: m[m.length - 1],
    path: m,
    branch: d,
    ...l,
    message: T
  };
}
function* toFailures(l, t, s, h) {
  isIterable(l) || (l = [l]);
  for (const m of l) {
    const d = toFailure(m, t, s, h);
    d && (yield d);
  }
}
function* run(l, t, s = {}) {
  const {
    path: h = [],
    branch: m = [l],
    coerce: d = !1,
    mask: v = !1
  } = s, _ = {
    path: h,
    branch: m
  };
  if (d && (l = t.coercer(l, _), v && t.type !== "type" && isObject(t.schema) && isObject(l) && !Array.isArray(l)))
    for (const z in l)
      t.schema[z] === void 0 && delete l[z];
  let T = !0;
  for (const z of t.validator(l, _))
    T = !1, yield [z, void 0];
  for (let [z, J, Y] of t.entries(l, _)) {
    const ie = run(J, Y, {
      path: z === void 0 ? h : [...h, z],
      branch: z === void 0 ? m : [...m, J],
      coerce: d,
      mask: v
    });
    for (const ne of ie)
      ne[0] ? (T = !1, yield [ne[0], void 0]) : d && (J = ne[1], z === void 0 ? l = J : l instanceof Map ? l.set(z, J) : l instanceof Set ? l.add(J) : isObject(l) && (l[z] = J));
  }
  if (T)
    for (const z of t.refiner(l, _))
      T = !1, yield [z, void 0];
  T && (yield [void 0, l]);
}
let Struct$1 = class {
  constructor(t) {
    const {
      type: s,
      schema: h,
      validator: m,
      refiner: d,
      coercer: v = (T) => T,
      entries: _ = function* () {
      }
    } = t;
    this.type = s, this.schema = h, this.entries = _, this.coercer = v, m ? this.validator = (T, z) => {
      const J = m(T, z);
      return toFailures(J, z, this, T);
    } : this.validator = () => [], d ? this.refiner = (T, z) => {
      const J = d(T, z);
      return toFailures(J, z, this, T);
    } : this.refiner = () => [];
  }
  assert(t) {
    return assert$1(t, this);
  }
  create(t) {
    return create(t, this);
  }
  is(t) {
    return is(t, this);
  }
  mask(t) {
    return mask(t, this);
  }
  validate(t, s = {}) {
    return validate$1(t, this, s);
  }
};
function assert$1(l, t) {
  const s = validate$1(l, t);
  if (s[0])
    throw s[0];
}
function create(l, t) {
  const s = validate$1(l, t, {
    coerce: !0
  });
  if (s[0])
    throw s[0];
  return s[1];
}
function mask(l, t) {
  const s = validate$1(l, t, {
    coerce: !0,
    mask: !0
  });
  if (s[0])
    throw s[0];
  return s[1];
}
function is(l, t) {
  return !validate$1(l, t)[0];
}
function validate$1(l, t, s = {}) {
  const h = run(l, t, s), m = shiftIterator(h);
  return m[0] ? [new StructError(m[0], function* () {
    for (const v of h)
      v[0] && (yield v[0]);
  }), void 0] : [void 0, m[1]];
}
function define(l, t) {
  return new Struct$1({
    type: l,
    schema: null,
    validator: t
  });
}
function any() {
  return define("any", () => !0);
}
function array(l) {
  return new Struct$1({
    type: "array",
    schema: l,
    *entries(t) {
      if (l && Array.isArray(t))
        for (const [s, h] of t.entries())
          yield [s, h, l];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return Array.isArray(t) || "Expected an array value, but received: " + print(t);
    }
  });
}
function boolean() {
  return define("boolean", (l) => typeof l == "boolean");
}
function instance(l) {
  return define("instance", (t) => t instanceof l || "Expected a `" + l.name + "` instance, but received: " + print(t));
}
function literal(l) {
  const t = print(l), s = typeof l;
  return new Struct$1({
    type: "literal",
    schema: s === "string" || s === "number" || s === "boolean" ? l : null,
    validator(h) {
      return h === l || "Expected the literal `" + t + "`, but received: " + print(h);
    }
  });
}
function never() {
  return define("never", () => !1);
}
function nullable(l) {
  return new Struct$1({
    ...l,
    validator: (t, s) => t === null || l.validator(t, s),
    refiner: (t, s) => t === null || l.refiner(t, s)
  });
}
function number() {
  return define("number", (l) => typeof l == "number" && !isNaN(l) || "Expected a number, but received: " + print(l));
}
function optional(l) {
  return new Struct$1({
    ...l,
    validator: (t, s) => t === void 0 || l.validator(t, s),
    refiner: (t, s) => t === void 0 || l.refiner(t, s)
  });
}
function record(l, t) {
  return new Struct$1({
    type: "record",
    schema: null,
    *entries(s) {
      if (isObject(s))
        for (const h in s) {
          const m = s[h];
          yield [h, h, l], yield [h, m, t];
        }
    },
    validator(s) {
      return isObject(s) || "Expected an object, but received: " + print(s);
    }
  });
}
function string() {
  return define("string", (l) => typeof l == "string" || "Expected a string, but received: " + print(l));
}
function tuple(l) {
  const t = never();
  return new Struct$1({
    type: "tuple",
    schema: null,
    *entries(s) {
      if (Array.isArray(s)) {
        const h = Math.max(l.length, s.length);
        for (let m = 0; m < h; m++)
          yield [m, s[m], l[m] || t];
      }
    },
    validator(s) {
      return Array.isArray(s) || "Expected an array, but received: " + print(s);
    }
  });
}
function type(l) {
  const t = Object.keys(l);
  return new Struct$1({
    type: "type",
    schema: l,
    *entries(s) {
      if (isObject(s))
        for (const h of t)
          yield [h, s[h], l[h]];
    },
    validator(s) {
      return isObject(s) || "Expected an object, but received: " + print(s);
    }
  });
}
function union(l) {
  const t = l.map((s) => s.type).join(" | ");
  return new Struct$1({
    type: "union",
    schema: null,
    validator(s, h) {
      const m = [];
      for (const d of l) {
        const [...v] = run(s, d, h), [_] = v;
        if (_[0])
          for (const [T] of v)
            T && m.push(T);
        else
          return [];
      }
      return ["Expected the value to satisfy a union of `" + t + "`, but received: " + print(s), ...m];
    }
  });
}
function unknown() {
  return define("unknown", () => !0);
}
function coerce(l, t, s) {
  return new Struct$1({
    ...l,
    coercer: (h, m) => is(h, t) ? l.coercer(s(h, m), m) : l.coercer(h, m)
  });
}
var index_browser = {}, interopRequireDefault = { exports: {} };
(function(l) {
  function t(s) {
    return s && s.__esModule ? s : {
      default: s
    };
  }
  l.exports = t, l.exports.__esModule = !0, l.exports.default = l.exports;
})(interopRequireDefault);
var createClass = { exports: {} }, toPropertyKey = { exports: {} }, _typeof = { exports: {} }, hasRequired_typeof;
function require_typeof() {
  return hasRequired_typeof || (hasRequired_typeof = 1, function(l) {
    function t(s) {
      return l.exports = t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
        return typeof h;
      } : function(h) {
        return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
      }, l.exports.__esModule = !0, l.exports.default = l.exports, t(s);
    }
    l.exports = t, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(_typeof)), _typeof.exports;
}
var toPrimitive = { exports: {} }, hasRequiredToPrimitive;
function requireToPrimitive() {
  return hasRequiredToPrimitive || (hasRequiredToPrimitive = 1, function(l) {
    var t = require_typeof().default;
    function s(h, m) {
      if (t(h) !== "object" || h === null)
        return h;
      var d = h[Symbol.toPrimitive];
      if (d !== void 0) {
        var v = d.call(h, m || "default");
        if (t(v) !== "object")
          return v;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (m === "string" ? String : Number)(h);
    }
    l.exports = s, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(toPrimitive)), toPrimitive.exports;
}
var hasRequiredToPropertyKey;
function requireToPropertyKey() {
  return hasRequiredToPropertyKey || (hasRequiredToPropertyKey = 1, function(l) {
    var t = require_typeof().default, s = requireToPrimitive();
    function h(m) {
      var d = s(m, "string");
      return t(d) === "symbol" ? d : String(d);
    }
    l.exports = h, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(toPropertyKey)), toPropertyKey.exports;
}
var hasRequiredCreateClass;
function requireCreateClass() {
  return hasRequiredCreateClass || (hasRequiredCreateClass = 1, function(l) {
    var t = requireToPropertyKey();
    function s(m, d) {
      for (var v = 0; v < d.length; v++) {
        var _ = d[v];
        _.enumerable = _.enumerable || !1, _.configurable = !0, "value" in _ && (_.writable = !0), Object.defineProperty(m, t(_.key), _);
      }
    }
    function h(m, d, v) {
      return d && s(m.prototype, d), v && s(m, v), Object.defineProperty(m, "prototype", {
        writable: !1
      }), m;
    }
    l.exports = h, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(createClass)), createClass.exports;
}
var classCallCheck = { exports: {} }, hasRequiredClassCallCheck;
function requireClassCallCheck() {
  return hasRequiredClassCallCheck || (hasRequiredClassCallCheck = 1, function(l) {
    function t(s, h) {
      if (!(s instanceof h))
        throw new TypeError("Cannot call a class as a function");
    }
    l.exports = t, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(classCallCheck)), classCallCheck.exports;
}
var inherits = { exports: {} }, setPrototypeOf = { exports: {} }, hasRequiredSetPrototypeOf;
function requireSetPrototypeOf() {
  return hasRequiredSetPrototypeOf || (hasRequiredSetPrototypeOf = 1, function(l) {
    function t(s, h) {
      return l.exports = t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
        return d.__proto__ = v, d;
      }, l.exports.__esModule = !0, l.exports.default = l.exports, t(s, h);
    }
    l.exports = t, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(setPrototypeOf)), setPrototypeOf.exports;
}
var hasRequiredInherits;
function requireInherits() {
  return hasRequiredInherits || (hasRequiredInherits = 1, function(l) {
    var t = requireSetPrototypeOf();
    function s(h, m) {
      if (typeof m != "function" && m !== null)
        throw new TypeError("Super expression must either be null or a function");
      h.prototype = Object.create(m && m.prototype, {
        constructor: {
          value: h,
          writable: !0,
          configurable: !0
        }
      }), Object.defineProperty(h, "prototype", {
        writable: !1
      }), m && t(h, m);
    }
    l.exports = s, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(inherits)), inherits.exports;
}
var possibleConstructorReturn = { exports: {} }, assertThisInitialized = { exports: {} }, hasRequiredAssertThisInitialized;
function requireAssertThisInitialized() {
  return hasRequiredAssertThisInitialized || (hasRequiredAssertThisInitialized = 1, function(l) {
    function t(s) {
      if (s === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return s;
    }
    l.exports = t, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(assertThisInitialized)), assertThisInitialized.exports;
}
var hasRequiredPossibleConstructorReturn;
function requirePossibleConstructorReturn() {
  return hasRequiredPossibleConstructorReturn || (hasRequiredPossibleConstructorReturn = 1, function(l) {
    var t = require_typeof().default, s = requireAssertThisInitialized();
    function h(m, d) {
      if (d && (t(d) === "object" || typeof d == "function"))
        return d;
      if (d !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
      return s(m);
    }
    l.exports = h, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(possibleConstructorReturn)), possibleConstructorReturn.exports;
}
var getPrototypeOf = { exports: {} }, hasRequiredGetPrototypeOf;
function requireGetPrototypeOf() {
  return hasRequiredGetPrototypeOf || (hasRequiredGetPrototypeOf = 1, function(l) {
    function t(s) {
      return l.exports = t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(m) {
        return m.__proto__ || Object.getPrototypeOf(m);
      }, l.exports.__esModule = !0, l.exports.default = l.exports, t(s);
    }
    l.exports = t, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(getPrototypeOf)), getPrototypeOf.exports;
}
var websocket_browser = {}, hasRequiredWebsocket_browser;
function requireWebsocket_browser() {
  return hasRequiredWebsocket_browser || (hasRequiredWebsocket_browser = 1, function(l) {
    var t = interopRequireDefault.exports;
    Object.defineProperty(l, "__esModule", {
      value: !0
    }), l.default = Y;
    var s = t(requireClassCallCheck()), h = t(requireCreateClass()), m = t(requireInherits()), d = t(requirePossibleConstructorReturn()), v = t(requireGetPrototypeOf()), _ = eventemitter3.exports;
    function T(ie) {
      var ne = z();
      return function() {
        var ce = (0, v.default)(ie), re;
        if (ne) {
          var oe = (0, v.default)(this).constructor;
          re = Reflect.construct(ce, arguments, oe);
        } else
          re = ce.apply(this, arguments);
        return (0, d.default)(this, re);
      };
    }
    function z() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var J = /* @__PURE__ */ function(ie) {
      (0, m.default)(de, ie);
      var ne = T(de);
      function de(ce, re, oe) {
        var pe;
        return (0, s.default)(this, de), pe = ne.call(this), pe.socket = new window.WebSocket(ce, oe), pe.socket.onopen = function() {
          return pe.emit("open");
        }, pe.socket.onmessage = function(ae) {
          return pe.emit("message", ae.data);
        }, pe.socket.onerror = function(ae) {
          return pe.emit("error", ae);
        }, pe.socket.onclose = function(ae) {
          pe.emit("close", ae.code, ae.reason);
        }, pe;
      }
      return (0, h.default)(de, [{
        key: "send",
        value: function(re, oe, pe) {
          var ae = pe || oe;
          try {
            this.socket.send(re), ae();
          } catch (me) {
            ae(me);
          }
        }
      }, {
        key: "close",
        value: function(re, oe) {
          this.socket.close(re, oe);
        }
      }, {
        key: "addEventListener",
        value: function(re, oe, pe) {
          this.socket.addEventListener(re, oe, pe);
        }
      }]), de;
    }(_.EventEmitter);
    function Y(ie, ne) {
      return new J(ie, ne);
    }
  }(websocket_browser)), websocket_browser;
}
var client = {}, regeneratorRuntime$1 = { exports: {} }, hasRequiredRegeneratorRuntime;
function requireRegeneratorRuntime() {
  return hasRequiredRegeneratorRuntime || (hasRequiredRegeneratorRuntime = 1, function(l) {
    var t = require_typeof().default;
    function s() {
      l.exports = s = function() {
        return h;
      }, l.exports.__esModule = !0, l.exports.default = l.exports;
      var h = {}, m = Object.prototype, d = m.hasOwnProperty, v = Object.defineProperty || function(x, S, B) {
        x[S] = B.value;
      }, _ = typeof Symbol == "function" ? Symbol : {}, T = _.iterator || "@@iterator", z = _.asyncIterator || "@@asyncIterator", J = _.toStringTag || "@@toStringTag";
      function Y(x, S, B) {
        return Object.defineProperty(x, S, {
          value: B,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), x[S];
      }
      try {
        Y({}, "");
      } catch {
        Y = function(B, L, C) {
          return B[L] = C;
        };
      }
      function ie(x, S, B, L) {
        var C = S && S.prototype instanceof ce ? S : ce, G = Object.create(C.prototype), R = new fe(L || []);
        return v(G, "_invoke", {
          value: Te(x, B, R)
        }), G;
      }
      function ne(x, S, B) {
        try {
          return {
            type: "normal",
            arg: x.call(S, B)
          };
        } catch (L) {
          return {
            type: "throw",
            arg: L
          };
        }
      }
      h.wrap = ie;
      var de = {};
      function ce() {
      }
      function re() {
      }
      function oe() {
      }
      var pe = {};
      Y(pe, T, function() {
        return this;
      });
      var ae = Object.getPrototypeOf, me = ae && ae(ae(k([])));
      me && me !== m && d.call(me, T) && (pe = me);
      var ge = oe.prototype = ce.prototype = Object.create(pe);
      function we(x) {
        ["next", "throw", "return"].forEach(function(S) {
          Y(x, S, function(B) {
            return this._invoke(S, B);
          });
        });
      }
      function Ee(x, S) {
        function B(C, G, R, y) {
          var j = ne(x[C], x, G);
          if (j.type !== "throw") {
            var ye = j.arg, ee = ye.value;
            return ee && t(ee) == "object" && d.call(ee, "__await") ? S.resolve(ee.__await).then(function(xe) {
              B("next", xe, R, y);
            }, function(xe) {
              B("throw", xe, R, y);
            }) : S.resolve(ee).then(function(xe) {
              ye.value = xe, R(ye);
            }, function(xe) {
              return B("throw", xe, R, y);
            });
          }
          y(j.arg);
        }
        var L;
        v(this, "_invoke", {
          value: function(G, R) {
            function y() {
              return new S(function(j, ye) {
                B(G, R, j, ye);
              });
            }
            return L = L ? L.then(y, y) : y();
          }
        });
      }
      function Te(x, S, B) {
        var L = "suspendedStart";
        return function(C, G) {
          if (L === "executing")
            throw new Error("Generator is already running");
          if (L === "completed") {
            if (C === "throw")
              throw G;
            return p();
          }
          for (B.method = C, B.arg = G; ; ) {
            var R = B.delegate;
            if (R) {
              var y = Ke(R, B);
              if (y) {
                if (y === de)
                  continue;
                return y;
              }
            }
            if (B.method === "next")
              B.sent = B._sent = B.arg;
            else if (B.method === "throw") {
              if (L === "suspendedStart")
                throw L = "completed", B.arg;
              B.dispatchException(B.arg);
            } else
              B.method === "return" && B.abrupt("return", B.arg);
            L = "executing";
            var j = ne(x, S, B);
            if (j.type === "normal") {
              if (L = B.done ? "completed" : "suspendedYield", j.arg === de)
                continue;
              return {
                value: j.arg,
                done: B.done
              };
            }
            j.type === "throw" && (L = "completed", B.method = "throw", B.arg = j.arg);
          }
        };
      }
      function Ke(x, S) {
        var B = S.method, L = x.iterator[B];
        if (L === void 0)
          return S.delegate = null, B === "throw" && x.iterator.return && (S.method = "return", S.arg = void 0, Ke(x, S), S.method === "throw") || B !== "return" && (S.method = "throw", S.arg = new TypeError("The iterator does not provide a '" + B + "' method")), de;
        var C = ne(L, x.iterator, S.arg);
        if (C.type === "throw")
          return S.method = "throw", S.arg = C.arg, S.delegate = null, de;
        var G = C.arg;
        return G ? G.done ? (S[x.resultName] = G.value, S.next = x.nextLoc, S.method !== "return" && (S.method = "next", S.arg = void 0), S.delegate = null, de) : G : (S.method = "throw", S.arg = new TypeError("iterator result is not an object"), S.delegate = null, de);
      }
      function Se(x) {
        var S = {
          tryLoc: x[0]
        };
        1 in x && (S.catchLoc = x[1]), 2 in x && (S.finallyLoc = x[2], S.afterLoc = x[3]), this.tryEntries.push(S);
      }
      function X(x) {
        var S = x.completion || {};
        S.type = "normal", delete S.arg, x.completion = S;
      }
      function fe(x) {
        this.tryEntries = [{
          tryLoc: "root"
        }], x.forEach(Se, this), this.reset(!0);
      }
      function k(x) {
        if (x) {
          var S = x[T];
          if (S)
            return S.call(x);
          if (typeof x.next == "function")
            return x;
          if (!isNaN(x.length)) {
            var B = -1, L = function C() {
              for (; ++B < x.length; )
                if (d.call(x, B))
                  return C.value = x[B], C.done = !1, C;
              return C.value = void 0, C.done = !0, C;
            };
            return L.next = L;
          }
        }
        return {
          next: p
        };
      }
      function p() {
        return {
          value: void 0,
          done: !0
        };
      }
      return re.prototype = oe, v(ge, "constructor", {
        value: oe,
        configurable: !0
      }), v(oe, "constructor", {
        value: re,
        configurable: !0
      }), re.displayName = Y(oe, J, "GeneratorFunction"), h.isGeneratorFunction = function(x) {
        var S = typeof x == "function" && x.constructor;
        return !!S && (S === re || (S.displayName || S.name) === "GeneratorFunction");
      }, h.mark = function(x) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(x, oe) : (x.__proto__ = oe, Y(x, J, "GeneratorFunction")), x.prototype = Object.create(ge), x;
      }, h.awrap = function(x) {
        return {
          __await: x
        };
      }, we(Ee.prototype), Y(Ee.prototype, z, function() {
        return this;
      }), h.AsyncIterator = Ee, h.async = function(x, S, B, L, C) {
        C === void 0 && (C = Promise);
        var G = new Ee(ie(x, S, B, L), C);
        return h.isGeneratorFunction(S) ? G : G.next().then(function(R) {
          return R.done ? R.value : G.next();
        });
      }, we(ge), Y(ge, J, "Generator"), Y(ge, T, function() {
        return this;
      }), Y(ge, "toString", function() {
        return "[object Generator]";
      }), h.keys = function(x) {
        var S = Object(x), B = [];
        for (var L in S)
          B.push(L);
        return B.reverse(), function C() {
          for (; B.length; ) {
            var G = B.pop();
            if (G in S)
              return C.value = G, C.done = !1, C;
          }
          return C.done = !0, C;
        };
      }, h.values = k, fe.prototype = {
        constructor: fe,
        reset: function(S) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(X), !S)
            for (var B in this)
              B.charAt(0) === "t" && d.call(this, B) && !isNaN(+B.slice(1)) && (this[B] = void 0);
        },
        stop: function() {
          this.done = !0;
          var S = this.tryEntries[0].completion;
          if (S.type === "throw")
            throw S.arg;
          return this.rval;
        },
        dispatchException: function(S) {
          if (this.done)
            throw S;
          var B = this;
          function L(ye, ee) {
            return R.type = "throw", R.arg = S, B.next = ye, ee && (B.method = "next", B.arg = void 0), !!ee;
          }
          for (var C = this.tryEntries.length - 1; C >= 0; --C) {
            var G = this.tryEntries[C], R = G.completion;
            if (G.tryLoc === "root")
              return L("end");
            if (G.tryLoc <= this.prev) {
              var y = d.call(G, "catchLoc"), j = d.call(G, "finallyLoc");
              if (y && j) {
                if (this.prev < G.catchLoc)
                  return L(G.catchLoc, !0);
                if (this.prev < G.finallyLoc)
                  return L(G.finallyLoc);
              } else if (y) {
                if (this.prev < G.catchLoc)
                  return L(G.catchLoc, !0);
              } else {
                if (!j)
                  throw new Error("try statement without catch or finally");
                if (this.prev < G.finallyLoc)
                  return L(G.finallyLoc);
              }
            }
          }
        },
        abrupt: function(S, B) {
          for (var L = this.tryEntries.length - 1; L >= 0; --L) {
            var C = this.tryEntries[L];
            if (C.tryLoc <= this.prev && d.call(C, "finallyLoc") && this.prev < C.finallyLoc) {
              var G = C;
              break;
            }
          }
          G && (S === "break" || S === "continue") && G.tryLoc <= B && B <= G.finallyLoc && (G = null);
          var R = G ? G.completion : {};
          return R.type = S, R.arg = B, G ? (this.method = "next", this.next = G.finallyLoc, de) : this.complete(R);
        },
        complete: function(S, B) {
          if (S.type === "throw")
            throw S.arg;
          return S.type === "break" || S.type === "continue" ? this.next = S.arg : S.type === "return" ? (this.rval = this.arg = S.arg, this.method = "return", this.next = "end") : S.type === "normal" && B && (this.next = B), de;
        },
        finish: function(S) {
          for (var B = this.tryEntries.length - 1; B >= 0; --B) {
            var L = this.tryEntries[B];
            if (L.finallyLoc === S)
              return this.complete(L.completion, L.afterLoc), X(L), de;
          }
        },
        catch: function(S) {
          for (var B = this.tryEntries.length - 1; B >= 0; --B) {
            var L = this.tryEntries[B];
            if (L.tryLoc === S) {
              var C = L.completion;
              if (C.type === "throw") {
                var G = C.arg;
                X(L);
              }
              return G;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(S, B, L) {
          return this.delegate = {
            iterator: k(S),
            resultName: B,
            nextLoc: L
          }, this.method === "next" && (this.arg = void 0), de;
        }
      }, h;
    }
    l.exports = s, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(regeneratorRuntime$1)), regeneratorRuntime$1.exports;
}
var regenerator, hasRequiredRegenerator;
function requireRegenerator() {
  if (hasRequiredRegenerator)
    return regenerator;
  hasRequiredRegenerator = 1;
  var l = requireRegeneratorRuntime()();
  regenerator = l;
  try {
    regeneratorRuntime = l;
  } catch {
    typeof globalThis == "object" ? globalThis.regeneratorRuntime = l : Function("r", "regeneratorRuntime = r")(l);
  }
  return regenerator;
}
var asyncToGenerator = { exports: {} }, hasRequiredAsyncToGenerator;
function requireAsyncToGenerator() {
  return hasRequiredAsyncToGenerator || (hasRequiredAsyncToGenerator = 1, function(l) {
    function t(h, m, d, v, _, T, z) {
      try {
        var J = h[T](z), Y = J.value;
      } catch (ie) {
        d(ie);
        return;
      }
      J.done ? m(Y) : Promise.resolve(Y).then(v, _);
    }
    function s(h) {
      return function() {
        var m = this, d = arguments;
        return new Promise(function(v, _) {
          var T = h.apply(m, d);
          function z(Y) {
            t(T, v, _, z, J, "next", Y);
          }
          function J(Y) {
            t(T, v, _, z, J, "throw", Y);
          }
          z(void 0);
        });
      };
    }
    l.exports = s, l.exports.__esModule = !0, l.exports.default = l.exports;
  }(asyncToGenerator)), asyncToGenerator.exports;
}
var hasRequiredClient;
function requireClient() {
  return hasRequiredClient || (hasRequiredClient = 1, function(l) {
    var t = interopRequireDefault.exports;
    Object.defineProperty(l, "__esModule", {
      value: !0
    }), l.default = void 0;
    var s = t(requireRegenerator()), h = t(requireAsyncToGenerator()), m = t(require_typeof()), d = t(requireClassCallCheck()), v = t(requireCreateClass()), _ = t(requireInherits()), T = t(requirePossibleConstructorReturn()), z = t(requireGetPrototypeOf()), J = eventemitter3.exports;
    function Y(ce) {
      var re = ie();
      return function() {
        var pe = (0, z.default)(ce), ae;
        if (re) {
          var me = (0, z.default)(this).constructor;
          ae = Reflect.construct(pe, arguments, me);
        } else
          ae = pe.apply(this, arguments);
        return (0, T.default)(this, ae);
      };
    }
    function ie() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var ne = function(ce, re) {
      var oe = {};
      for (var pe in ce)
        Object.prototype.hasOwnProperty.call(ce, pe) && re.indexOf(pe) < 0 && (oe[pe] = ce[pe]);
      if (ce != null && typeof Object.getOwnPropertySymbols == "function")
        for (var ae = 0, pe = Object.getOwnPropertySymbols(ce); ae < pe.length; ae++)
          re.indexOf(pe[ae]) < 0 && Object.prototype.propertyIsEnumerable.call(ce, pe[ae]) && (oe[pe[ae]] = ce[pe[ae]]);
      return oe;
    }, de = /* @__PURE__ */ function(ce) {
      (0, _.default)(oe, ce);
      var re = Y(oe);
      function oe(pe) {
        var ae, me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080", ge = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, we = arguments.length > 3 ? arguments[3] : void 0;
        (0, d.default)(this, oe);
        var Ee = ge.autoconnect, Te = Ee === void 0 ? !0 : Ee, Ke = ge.reconnect, Se = Ke === void 0 ? !0 : Ke, X = ge.reconnect_interval, fe = X === void 0 ? 1e3 : X, k = ge.max_reconnects, p = k === void 0 ? 5 : k, x = ne(ge, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
        return ae = re.call(this), ae.webSocketFactory = pe, ae.queue = {}, ae.rpc_id = 0, ae.address = me, ae.autoconnect = Te, ae.ready = !1, ae.reconnect = Se, ae.reconnect_interval = fe, ae.max_reconnects = p, ae.rest_options = x, ae.current_reconnects = 0, ae.generate_request_id = we || function() {
          return ++ae.rpc_id;
        }, ae.autoconnect && ae._connect(ae.address, Object.assign({
          autoconnect: ae.autoconnect,
          reconnect: ae.reconnect,
          reconnect_interval: ae.reconnect_interval,
          max_reconnects: ae.max_reconnects
        }, ae.rest_options)), ae;
      }
      return (0, v.default)(oe, [{
        key: "connect",
        value: function() {
          this.socket || this._connect(this.address, Object.assign({
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects
          }, this.rest_options));
        }
      }, {
        key: "call",
        value: function(ae, me, ge, we) {
          var Ee = this;
          return !we && (0, m.default)(ge) === "object" && (we = ge, ge = null), new Promise(function(Te, Ke) {
            if (!Ee.ready)
              return Ke(new Error("socket not ready"));
            var Se = Ee.generate_request_id(ae, me), X = {
              jsonrpc: "2.0",
              method: ae,
              params: me || null,
              id: Se
            };
            Ee.socket.send(JSON.stringify(X), we, function(fe) {
              if (fe)
                return Ke(fe);
              Ee.queue[Se] = {
                promise: [Te, Ke]
              }, ge && (Ee.queue[Se].timeout = setTimeout(function() {
                delete Ee.queue[Se], Ke(new Error("reply timeout"));
              }, ge));
            });
          });
        }
      }, {
        key: "login",
        value: function() {
          var pe = (0, h.default)(/* @__PURE__ */ s.default.mark(function me(ge) {
            var we;
            return s.default.wrap(function(Te) {
              for (; ; )
                switch (Te.prev = Te.next) {
                  case 0:
                    return Te.next = 2, this.call("rpc.login", ge);
                  case 2:
                    if (we = Te.sent, we) {
                      Te.next = 5;
                      break;
                    }
                    throw new Error("authentication failed");
                  case 5:
                    return Te.abrupt("return", we);
                  case 6:
                  case "end":
                    return Te.stop();
                }
            }, me, this);
          }));
          function ae(me) {
            return pe.apply(this, arguments);
          }
          return ae;
        }()
      }, {
        key: "listMethods",
        value: function() {
          var pe = (0, h.default)(/* @__PURE__ */ s.default.mark(function me() {
            return s.default.wrap(function(we) {
              for (; ; )
                switch (we.prev = we.next) {
                  case 0:
                    return we.next = 2, this.call("__listMethods");
                  case 2:
                    return we.abrupt("return", we.sent);
                  case 3:
                  case "end":
                    return we.stop();
                }
            }, me, this);
          }));
          function ae() {
            return pe.apply(this, arguments);
          }
          return ae;
        }()
      }, {
        key: "notify",
        value: function(ae, me) {
          var ge = this;
          return new Promise(function(we, Ee) {
            if (!ge.ready)
              return Ee(new Error("socket not ready"));
            var Te = {
              jsonrpc: "2.0",
              method: ae,
              params: me || null
            };
            ge.socket.send(JSON.stringify(Te), function(Ke) {
              if (Ke)
                return Ee(Ke);
              we();
            });
          });
        }
      }, {
        key: "subscribe",
        value: function() {
          var pe = (0, h.default)(/* @__PURE__ */ s.default.mark(function me(ge) {
            var we;
            return s.default.wrap(function(Te) {
              for (; ; )
                switch (Te.prev = Te.next) {
                  case 0:
                    return typeof ge == "string" && (ge = [ge]), Te.next = 3, this.call("rpc.on", ge);
                  case 3:
                    if (we = Te.sent, !(typeof ge == "string" && we[ge] !== "ok")) {
                      Te.next = 6;
                      break;
                    }
                    throw new Error("Failed subscribing to an event '" + ge + "' with: " + we[ge]);
                  case 6:
                    return Te.abrupt("return", we);
                  case 7:
                  case "end":
                    return Te.stop();
                }
            }, me, this);
          }));
          function ae(me) {
            return pe.apply(this, arguments);
          }
          return ae;
        }()
      }, {
        key: "unsubscribe",
        value: function() {
          var pe = (0, h.default)(/* @__PURE__ */ s.default.mark(function me(ge) {
            var we;
            return s.default.wrap(function(Te) {
              for (; ; )
                switch (Te.prev = Te.next) {
                  case 0:
                    return typeof ge == "string" && (ge = [ge]), Te.next = 3, this.call("rpc.off", ge);
                  case 3:
                    if (we = Te.sent, !(typeof ge == "string" && we[ge] !== "ok")) {
                      Te.next = 6;
                      break;
                    }
                    throw new Error("Failed unsubscribing from an event with: " + we);
                  case 6:
                    return Te.abrupt("return", we);
                  case 7:
                  case "end":
                    return Te.stop();
                }
            }, me, this);
          }));
          function ae(me) {
            return pe.apply(this, arguments);
          }
          return ae;
        }()
      }, {
        key: "close",
        value: function(ae, me) {
          this.socket.close(ae || 1e3, me);
        }
      }, {
        key: "_connect",
        value: function(ae, me) {
          var ge = this;
          this.socket = this.webSocketFactory(ae, me), this.socket.addEventListener("open", function() {
            ge.ready = !0, ge.emit("open"), ge.current_reconnects = 0;
          }), this.socket.addEventListener("message", function(we) {
            var Ee = we.data;
            Ee instanceof ArrayBuffer && (Ee = Buffer.from(Ee).toString());
            try {
              Ee = JSON.parse(Ee);
            } catch {
              return;
            }
            if (Ee.notification && ge.listeners(Ee.notification).length) {
              if (!Object.keys(Ee.params).length)
                return ge.emit(Ee.notification);
              var Te = [Ee.notification];
              if (Ee.params.constructor === Object)
                Te.push(Ee.params);
              else
                for (var Ke = 0; Ke < Ee.params.length; Ke++)
                  Te.push(Ee.params[Ke]);
              return Promise.resolve().then(function() {
                ge.emit.apply(ge, Te);
              });
            }
            if (!ge.queue[Ee.id])
              return Ee.method && Ee.params ? Promise.resolve().then(function() {
                ge.emit(Ee.method, Ee.params);
              }) : void 0;
            "error" in Ee == "result" in Ee && ge.queue[Ee.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), ge.queue[Ee.id].timeout && clearTimeout(ge.queue[Ee.id].timeout), Ee.error ? ge.queue[Ee.id].promise[1](Ee.error) : ge.queue[Ee.id].promise[0](Ee.result), delete ge.queue[Ee.id];
          }), this.socket.addEventListener("error", function(we) {
            return ge.emit("error", we);
          }), this.socket.addEventListener("close", function(we) {
            var Ee = we.code, Te = we.reason;
            ge.ready && setTimeout(function() {
              return ge.emit("close", Ee, Te);
            }, 0), ge.ready = !1, ge.socket = void 0, Ee !== 1e3 && (ge.current_reconnects++, ge.reconnect && (ge.max_reconnects > ge.current_reconnects || ge.max_reconnects === 0) && setTimeout(function() {
              return ge._connect(ae, me);
            }, ge.reconnect_interval));
          });
        }
      }]), oe;
    }(J.EventEmitter);
    l.default = de;
  }(client)), client;
}
var _interopRequireDefault = interopRequireDefault.exports;
Object.defineProperty(index_browser, "__esModule", {
  value: !0
});
var Client_1 = index_browser.Client = void 0, _createClass2 = _interopRequireDefault(requireCreateClass()), _classCallCheck2 = _interopRequireDefault(requireClassCallCheck()), _inherits2 = _interopRequireDefault(requireInherits()), _possibleConstructorReturn2 = _interopRequireDefault(requirePossibleConstructorReturn()), _getPrototypeOf2 = _interopRequireDefault(requireGetPrototypeOf()), _websocket = _interopRequireDefault(requireWebsocket_browser()), _client = _interopRequireDefault(requireClient());
function _createSuper(l) {
  var t = _isNativeReflectConstruct();
  return function() {
    var h = (0, _getPrototypeOf2.default)(l), m;
    if (t) {
      var d = (0, _getPrototypeOf2.default)(this).constructor;
      m = Reflect.construct(h, arguments, d);
    } else
      m = h.apply(this, arguments);
    return (0, _possibleConstructorReturn2.default)(this, m);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var Client = /* @__PURE__ */ function(l) {
  (0, _inherits2.default)(s, l);
  var t = _createSuper(s);
  function s() {
    var h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ws://localhost:8080", m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, d = m.autoconnect, v = d === void 0 ? !0 : d, _ = m.reconnect, T = _ === void 0 ? !0 : _, z = m.reconnect_interval, J = z === void 0 ? 1e3 : z, Y = m.max_reconnects, ie = Y === void 0 ? 5 : Y, ne = arguments.length > 2 ? arguments[2] : void 0;
    return (0, _classCallCheck2.default)(this, s), t.call(this, _websocket.default, h, {
      autoconnect: v,
      reconnect: T,
      reconnect_interval: J,
      max_reconnects: ie
    }, ne);
  }
  return (0, _createClass2.default)(s);
}(_client.default);
Client_1 = index_browser.Client = Client;
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(l) {
  return typeof l == "string" && REGEX.test(l);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i)
  byteToHex.push((i + 256).toString(16).substr(1));
function stringify$1(l) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, s = (byteToHex[l[t + 0]] + byteToHex[l[t + 1]] + byteToHex[l[t + 2]] + byteToHex[l[t + 3]] + "-" + byteToHex[l[t + 4]] + byteToHex[l[t + 5]] + "-" + byteToHex[l[t + 6]] + byteToHex[l[t + 7]] + "-" + byteToHex[l[t + 8]] + byteToHex[l[t + 9]] + "-" + byteToHex[l[t + 10]] + byteToHex[l[t + 11]] + byteToHex[l[t + 12]] + byteToHex[l[t + 13]] + byteToHex[l[t + 14]] + byteToHex[l[t + 15]]).toLowerCase();
  if (!validate(s))
    throw TypeError("Stringified UUID is invalid");
  return s;
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
function v1(l, t, s) {
  var h = t && s || 0, m = t || new Array(16);
  l = l || {};
  var d = l.node || _nodeId, v = l.clockseq !== void 0 ? l.clockseq : _clockseq;
  if (d == null || v == null) {
    var _ = l.random || (l.rng || rng)();
    d == null && (d = _nodeId = [_[0] | 1, _[1], _[2], _[3], _[4], _[5]]), v == null && (v = _clockseq = (_[6] << 8 | _[7]) & 16383);
  }
  var T = l.msecs !== void 0 ? l.msecs : Date.now(), z = l.nsecs !== void 0 ? l.nsecs : _lastNSecs + 1, J = T - _lastMSecs + (z - _lastNSecs) / 1e4;
  if (J < 0 && l.clockseq === void 0 && (v = v + 1 & 16383), (J < 0 || T > _lastMSecs) && l.nsecs === void 0 && (z = 0), z >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = T, _lastNSecs = z, _clockseq = v, T += 122192928e5;
  var Y = ((T & 268435455) * 1e4 + z) % 4294967296;
  m[h++] = Y >>> 24 & 255, m[h++] = Y >>> 16 & 255, m[h++] = Y >>> 8 & 255, m[h++] = Y & 255;
  var ie = T / 4294967296 * 1e4 & 268435455;
  m[h++] = ie >>> 8 & 255, m[h++] = ie & 255, m[h++] = ie >>> 24 & 15 | 16, m[h++] = ie >>> 16 & 255, m[h++] = v >>> 8 | 128, m[h++] = v & 255;
  for (var ne = 0; ne < 6; ++ne)
    m[h + ne] = d[ne];
  return t || stringify$1(m);
}
function parse(l) {
  if (!validate(l))
    throw TypeError("Invalid UUID");
  var t, s = new Uint8Array(16);
  return s[0] = (t = parseInt(l.slice(0, 8), 16)) >>> 24, s[1] = t >>> 16 & 255, s[2] = t >>> 8 & 255, s[3] = t & 255, s[4] = (t = parseInt(l.slice(9, 13), 16)) >>> 8, s[5] = t & 255, s[6] = (t = parseInt(l.slice(14, 18), 16)) >>> 8, s[7] = t & 255, s[8] = (t = parseInt(l.slice(19, 23), 16)) >>> 8, s[9] = t & 255, s[10] = (t = parseInt(l.slice(24, 36), 16)) / 1099511627776 & 255, s[11] = t / 4294967296 & 255, s[12] = t >>> 24 & 255, s[13] = t >>> 16 & 255, s[14] = t >>> 8 & 255, s[15] = t & 255, s;
}
function stringToBytes(l) {
  l = unescape(encodeURIComponent(l));
  for (var t = [], s = 0; s < l.length; ++s)
    t.push(l.charCodeAt(s));
  return t;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(l, t, s) {
  function h(m, d, v, _) {
    if (typeof m == "string" && (m = stringToBytes(m)), typeof d == "string" && (d = parse(d)), d.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var T = new Uint8Array(16 + m.length);
    if (T.set(d), T.set(m, d.length), T = s(T), T[6] = T[6] & 15 | t, T[8] = T[8] & 63 | 128, v) {
      _ = _ || 0;
      for (var z = 0; z < 16; ++z)
        v[_ + z] = T[z];
      return v;
    }
    return stringify$1(T);
  }
  try {
    h.name = l;
  } catch {
  }
  return h.DNS = DNS, h.URL = URL$1, h;
}
function md5(l) {
  if (typeof l == "string") {
    var t = unescape(encodeURIComponent(l));
    l = new Uint8Array(t.length);
    for (var s = 0; s < t.length; ++s)
      l[s] = t.charCodeAt(s);
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(l), l.length * 8));
}
function md5ToHexEncodedArray(l) {
  for (var t = [], s = l.length * 32, h = "0123456789abcdef", m = 0; m < s; m += 8) {
    var d = l[m >> 5] >>> m % 32 & 255, v = parseInt(h.charAt(d >>> 4 & 15) + h.charAt(d & 15), 16);
    t.push(v);
  }
  return t;
}
function getOutputLength(l) {
  return (l + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(l, t) {
  l[t >> 5] |= 128 << t % 32, l[getOutputLength(t) - 1] = t;
  for (var s = 1732584193, h = -271733879, m = -1732584194, d = 271733878, v = 0; v < l.length; v += 16) {
    var _ = s, T = h, z = m, J = d;
    s = md5ff(s, h, m, d, l[v], 7, -680876936), d = md5ff(d, s, h, m, l[v + 1], 12, -389564586), m = md5ff(m, d, s, h, l[v + 2], 17, 606105819), h = md5ff(h, m, d, s, l[v + 3], 22, -1044525330), s = md5ff(s, h, m, d, l[v + 4], 7, -176418897), d = md5ff(d, s, h, m, l[v + 5], 12, 1200080426), m = md5ff(m, d, s, h, l[v + 6], 17, -1473231341), h = md5ff(h, m, d, s, l[v + 7], 22, -45705983), s = md5ff(s, h, m, d, l[v + 8], 7, 1770035416), d = md5ff(d, s, h, m, l[v + 9], 12, -1958414417), m = md5ff(m, d, s, h, l[v + 10], 17, -42063), h = md5ff(h, m, d, s, l[v + 11], 22, -1990404162), s = md5ff(s, h, m, d, l[v + 12], 7, 1804603682), d = md5ff(d, s, h, m, l[v + 13], 12, -40341101), m = md5ff(m, d, s, h, l[v + 14], 17, -1502002290), h = md5ff(h, m, d, s, l[v + 15], 22, 1236535329), s = md5gg(s, h, m, d, l[v + 1], 5, -165796510), d = md5gg(d, s, h, m, l[v + 6], 9, -1069501632), m = md5gg(m, d, s, h, l[v + 11], 14, 643717713), h = md5gg(h, m, d, s, l[v], 20, -373897302), s = md5gg(s, h, m, d, l[v + 5], 5, -701558691), d = md5gg(d, s, h, m, l[v + 10], 9, 38016083), m = md5gg(m, d, s, h, l[v + 15], 14, -660478335), h = md5gg(h, m, d, s, l[v + 4], 20, -405537848), s = md5gg(s, h, m, d, l[v + 9], 5, 568446438), d = md5gg(d, s, h, m, l[v + 14], 9, -1019803690), m = md5gg(m, d, s, h, l[v + 3], 14, -187363961), h = md5gg(h, m, d, s, l[v + 8], 20, 1163531501), s = md5gg(s, h, m, d, l[v + 13], 5, -1444681467), d = md5gg(d, s, h, m, l[v + 2], 9, -51403784), m = md5gg(m, d, s, h, l[v + 7], 14, 1735328473), h = md5gg(h, m, d, s, l[v + 12], 20, -1926607734), s = md5hh(s, h, m, d, l[v + 5], 4, -378558), d = md5hh(d, s, h, m, l[v + 8], 11, -2022574463), m = md5hh(m, d, s, h, l[v + 11], 16, 1839030562), h = md5hh(h, m, d, s, l[v + 14], 23, -35309556), s = md5hh(s, h, m, d, l[v + 1], 4, -1530992060), d = md5hh(d, s, h, m, l[v + 4], 11, 1272893353), m = md5hh(m, d, s, h, l[v + 7], 16, -155497632), h = md5hh(h, m, d, s, l[v + 10], 23, -1094730640), s = md5hh(s, h, m, d, l[v + 13], 4, 681279174), d = md5hh(d, s, h, m, l[v], 11, -358537222), m = md5hh(m, d, s, h, l[v + 3], 16, -722521979), h = md5hh(h, m, d, s, l[v + 6], 23, 76029189), s = md5hh(s, h, m, d, l[v + 9], 4, -640364487), d = md5hh(d, s, h, m, l[v + 12], 11, -421815835), m = md5hh(m, d, s, h, l[v + 15], 16, 530742520), h = md5hh(h, m, d, s, l[v + 2], 23, -995338651), s = md5ii(s, h, m, d, l[v], 6, -198630844), d = md5ii(d, s, h, m, l[v + 7], 10, 1126891415), m = md5ii(m, d, s, h, l[v + 14], 15, -1416354905), h = md5ii(h, m, d, s, l[v + 5], 21, -57434055), s = md5ii(s, h, m, d, l[v + 12], 6, 1700485571), d = md5ii(d, s, h, m, l[v + 3], 10, -1894986606), m = md5ii(m, d, s, h, l[v + 10], 15, -1051523), h = md5ii(h, m, d, s, l[v + 1], 21, -2054922799), s = md5ii(s, h, m, d, l[v + 8], 6, 1873313359), d = md5ii(d, s, h, m, l[v + 15], 10, -30611744), m = md5ii(m, d, s, h, l[v + 6], 15, -1560198380), h = md5ii(h, m, d, s, l[v + 13], 21, 1309151649), s = md5ii(s, h, m, d, l[v + 4], 6, -145523070), d = md5ii(d, s, h, m, l[v + 11], 10, -1120210379), m = md5ii(m, d, s, h, l[v + 2], 15, 718787259), h = md5ii(h, m, d, s, l[v + 9], 21, -343485551), s = safeAdd(s, _), h = safeAdd(h, T), m = safeAdd(m, z), d = safeAdd(d, J);
  }
  return [s, h, m, d];
}
function bytesToWords(l) {
  if (l.length === 0)
    return [];
  for (var t = l.length * 8, s = new Uint32Array(getOutputLength(t)), h = 0; h < t; h += 8)
    s[h >> 5] |= (l[h / 8] & 255) << h % 32;
  return s;
}
function safeAdd(l, t) {
  var s = (l & 65535) + (t & 65535), h = (l >> 16) + (t >> 16) + (s >> 16);
  return h << 16 | s & 65535;
}
function bitRotateLeft(l, t) {
  return l << t | l >>> 32 - t;
}
function md5cmn(l, t, s, h, m, d) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(t, l), safeAdd(h, d)), m), s);
}
function md5ff(l, t, s, h, m, d, v) {
  return md5cmn(t & s | ~t & h, l, t, m, d, v);
}
function md5gg(l, t, s, h, m, d, v) {
  return md5cmn(t & h | s & ~h, l, t, m, d, v);
}
function md5hh(l, t, s, h, m, d, v) {
  return md5cmn(t ^ s ^ h, l, t, m, d, v);
}
function md5ii(l, t, s, h, m, d, v) {
  return md5cmn(s ^ (t | ~h), l, t, m, d, v);
}
var v3 = v35("v3", 48, md5), v3$1 = v3;
function v4(l, t, s) {
  l = l || {};
  var h = l.random || (l.rng || rng)();
  if (h[6] = h[6] & 15 | 64, h[8] = h[8] & 63 | 128, t) {
    s = s || 0;
    for (var m = 0; m < 16; ++m)
      t[s + m] = h[m];
    return t;
  }
  return stringify$1(h);
}
function f(l, t, s, h) {
  switch (l) {
    case 0:
      return t & s ^ ~t & h;
    case 1:
      return t ^ s ^ h;
    case 2:
      return t & s ^ t & h ^ s & h;
    case 3:
      return t ^ s ^ h;
  }
}
function ROTL(l, t) {
  return l << t | l >>> 32 - t;
}
function sha1(l) {
  var t = [1518500249, 1859775393, 2400959708, 3395469782], s = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof l == "string") {
    var h = unescape(encodeURIComponent(l));
    l = [];
    for (var m = 0; m < h.length; ++m)
      l.push(h.charCodeAt(m));
  } else
    Array.isArray(l) || (l = Array.prototype.slice.call(l));
  l.push(128);
  for (var d = l.length / 4 + 2, v = Math.ceil(d / 16), _ = new Array(v), T = 0; T < v; ++T) {
    for (var z = new Uint32Array(16), J = 0; J < 16; ++J)
      z[J] = l[T * 64 + J * 4] << 24 | l[T * 64 + J * 4 + 1] << 16 | l[T * 64 + J * 4 + 2] << 8 | l[T * 64 + J * 4 + 3];
    _[T] = z;
  }
  _[v - 1][14] = (l.length - 1) * 8 / Math.pow(2, 32), _[v - 1][14] = Math.floor(_[v - 1][14]), _[v - 1][15] = (l.length - 1) * 8 & 4294967295;
  for (var Y = 0; Y < v; ++Y) {
    for (var ie = new Uint32Array(80), ne = 0; ne < 16; ++ne)
      ie[ne] = _[Y][ne];
    for (var de = 16; de < 80; ++de)
      ie[de] = ROTL(ie[de - 3] ^ ie[de - 8] ^ ie[de - 14] ^ ie[de - 16], 1);
    for (var ce = s[0], re = s[1], oe = s[2], pe = s[3], ae = s[4], me = 0; me < 80; ++me) {
      var ge = Math.floor(me / 20), we = ROTL(ce, 5) + f(ge, re, oe, pe) + ae + t[ge] + ie[me] >>> 0;
      ae = pe, pe = oe, oe = ROTL(re, 30) >>> 0, re = ce, ce = we;
    }
    s[0] = s[0] + ce >>> 0, s[1] = s[1] + re >>> 0, s[2] = s[2] + oe >>> 0, s[3] = s[3] + pe >>> 0, s[4] = s[4] + ae >>> 0;
  }
  return [s[0] >> 24 & 255, s[0] >> 16 & 255, s[0] >> 8 & 255, s[0] & 255, s[1] >> 24 & 255, s[1] >> 16 & 255, s[1] >> 8 & 255, s[1] & 255, s[2] >> 24 & 255, s[2] >> 16 & 255, s[2] >> 8 & 255, s[2] & 255, s[3] >> 24 & 255, s[3] >> 16 & 255, s[3] >> 8 & 255, s[3] & 255, s[4] >> 24 & 255, s[4] >> 16 & 255, s[4] >> 8 & 255, s[4] & 255];
}
var v5 = v35("v5", 80, sha1), v5$1 = v5, nil = "00000000-0000-0000-0000-000000000000";
function version(l) {
  if (!validate(l))
    throw TypeError("Invalid UUID");
  return parseInt(l.substr(14, 1), 16);
}
var esmBrowser = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  NIL: nil,
  parse,
  stringify: stringify$1,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  validate,
  version
}), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
const uuid$1 = require$$0$1.v4, generateRequest$1 = function(l, t, s, h) {
  if (typeof l != "string")
    throw new TypeError(l + " must be a string");
  h = h || {};
  const m = typeof h.version == "number" ? h.version : 2;
  if (m !== 1 && m !== 2)
    throw new TypeError(m + " must be 1 or 2");
  const d = {
    method: l
  };
  if (m === 2 && (d.jsonrpc = "2.0"), t) {
    if (typeof t != "object" && !Array.isArray(t))
      throw new TypeError(t + " must be an object, array or omitted");
    d.params = t;
  }
  if (typeof s > "u") {
    const v = typeof h.generator == "function" ? h.generator : function() {
      return uuid$1();
    };
    d.id = v(d, h);
  } else
    m === 2 && s === null ? h.notificationIdNull && (d.id = null) : d.id = s;
  return d;
};
var generateRequest_1 = generateRequest$1;
const uuid = require$$0$1.v4, generateRequest = generateRequest_1, ClientBrowser = function(l, t) {
  if (!(this instanceof ClientBrowser))
    return new ClientBrowser(l, t);
  t || (t = {}), this.options = {
    reviver: typeof t.reviver < "u" ? t.reviver : null,
    replacer: typeof t.replacer < "u" ? t.replacer : null,
    generator: typeof t.generator < "u" ? t.generator : function() {
      return uuid();
    },
    version: typeof t.version < "u" ? t.version : 2,
    notificationIdNull: typeof t.notificationIdNull == "boolean" ? t.notificationIdNull : !1
  }, this.callServer = l;
};
var browser = ClientBrowser;
ClientBrowser.prototype.request = function(l, t, s, h) {
  const m = this;
  let d = null;
  const v = Array.isArray(l) && typeof t == "function";
  if (this.options.version === 1 && v)
    throw new TypeError("JSON-RPC 1.0 does not support batching");
  if (v || !v && l && typeof l == "object" && typeof t == "function")
    h = t, d = l;
  else {
    typeof s == "function" && (h = s, s = void 0);
    const z = typeof h == "function";
    try {
      d = generateRequest(l, t, s, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull
      });
    } catch (J) {
      if (z)
        return h(J);
      throw J;
    }
    if (!z)
      return d;
  }
  let T;
  try {
    T = JSON.stringify(d, this.options.replacer);
  } catch (z) {
    return h(z);
  }
  return this.callServer(T, function(z, J) {
    m._parseResponse(z, J, h);
  }), d;
};
ClientBrowser.prototype._parseResponse = function(l, t, s) {
  if (l) {
    s(l);
    return;
  }
  if (!t)
    return s();
  let h;
  try {
    h = JSON.parse(t, this.options.reviver);
  } catch (m) {
    return s(m);
  }
  if (s.length === 3)
    if (Array.isArray(h)) {
      const m = function(v) {
        return typeof v.error < "u";
      }, d = function(v) {
        return !m(v);
      };
      return s(null, h.filter(m), h.filter(d));
    } else
      return s(null, h.error, h.result);
  s(null, h);
};
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []], _0n$1 = BigInt(0), _1n$1 = BigInt(1), _2n$1 = BigInt(2), _7n = BigInt(7), _256n = BigInt(256), _0x71n = BigInt(113);
for (let l = 0, t = _1n$1, s = 1, h = 0; l < 24; l++) {
  [s, h] = [h, (2 * s + 3 * h) % 5], SHA3_PI.push(2 * (5 * h + s)), SHA3_ROTL.push((l + 1) * (l + 2) / 2 % 64);
  let m = _0n$1;
  for (let d = 0; d < 7; d++)
    t = (t << _1n$1 ^ (t >> _7n) * _0x71n) % _256n, t & _2n$1 && (m ^= _1n$1 << (_1n$1 << BigInt(d)) - _1n$1);
  _SHA3_IOTA.push(m);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = u64$1.split(_SHA3_IOTA, !0), rotlH = (l, t, s) => s > 32 ? u64$1.rotlBH(l, t, s) : u64$1.rotlSH(l, t, s), rotlL = (l, t, s) => s > 32 ? u64$1.rotlBL(l, t, s) : u64$1.rotlSL(l, t, s);
function keccakP(l, t = 24) {
  const s = new Uint32Array(10);
  for (let h = 24 - t; h < 24; h++) {
    for (let v = 0; v < 10; v++)
      s[v] = l[v] ^ l[v + 10] ^ l[v + 20] ^ l[v + 30] ^ l[v + 40];
    for (let v = 0; v < 10; v += 2) {
      const _ = (v + 8) % 10, T = (v + 2) % 10, z = s[T], J = s[T + 1], Y = rotlH(z, J, 1) ^ s[_], ie = rotlL(z, J, 1) ^ s[_ + 1];
      for (let ne = 0; ne < 50; ne += 10)
        l[v + ne] ^= Y, l[v + ne + 1] ^= ie;
    }
    let m = l[2], d = l[3];
    for (let v = 0; v < 24; v++) {
      const _ = SHA3_ROTL[v], T = rotlH(m, d, _), z = rotlL(m, d, _), J = SHA3_PI[v];
      m = l[J], d = l[J + 1], l[J] = T, l[J + 1] = z;
    }
    for (let v = 0; v < 50; v += 10) {
      for (let _ = 0; _ < 10; _++)
        s[_] = l[v + _];
      for (let _ = 0; _ < 10; _++)
        l[v + _] ^= ~s[(_ + 2) % 10] & s[(_ + 4) % 10];
    }
    l[0] ^= SHA3_IOTA_H[h], l[1] ^= SHA3_IOTA_L[h];
  }
  s.fill(0);
}
class Keccak extends Hash {
  constructor(t, s, h, m = !1, d = 24) {
    if (super(), this.blockLen = t, this.suffix = s, this.outputLen = h, this.enableXOF = m, this.rounds = d, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, assert$2.number(h), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = u32$1(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    assert$2.exists(this);
    const { blockLen: s, state: h } = this;
    t = toBytes(t);
    const m = t.length;
    for (let d = 0; d < m; ) {
      const v = Math.min(s - this.pos, m - d);
      for (let _ = 0; _ < v; _++)
        h[this.pos++] ^= t[d++];
      this.pos === s && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: s, pos: h, blockLen: m } = this;
    t[h] ^= s, (s & 128) !== 0 && h === m - 1 && this.keccak(), t[m - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    assert$2.exists(this, !1), assert$2.bytes(t), this.finish();
    const s = this.state, { blockLen: h } = this;
    for (let m = 0, d = t.length; m < d; ) {
      this.posOut >= h && this.keccak();
      const v = Math.min(h - this.posOut, d - m);
      t.set(s.subarray(this.posOut, this.posOut + v), m), this.posOut += v, m += v;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return assert$2.number(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (assert$2.output(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: s, suffix: h, outputLen: m, rounds: d, enableXOF: v } = this;
    return t || (t = new Keccak(s, h, m, v, d)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = d, t.suffix = h, t.outputLen = m, t.enableXOF = v, t.destroyed = this.destroyed, t;
  }
}
const gen = (l, t, s) => wrapConstructor(() => new Keccak(t, l, s));
gen(6, 144, 224 / 8);
gen(6, 136, 256 / 8);
gen(6, 104, 384 / 8);
gen(6, 72, 512 / 8);
gen(1, 144, 224 / 8);
const keccak_256 = gen(1, 136, 256 / 8);
gen(1, 104, 384 / 8);
gen(1, 72, 512 / 8);
const genShake = (l, t, s) => wrapConstructorWithOpts((h = {}) => new Keccak(t, l, h.dkLen === void 0 ? s : h.dkLen, !0));
genShake(31, 168, 128 / 8);
genShake(31, 136, 256 / 8);
class HMAC extends Hash {
  constructor(t, s) {
    super(), this.finished = !1, this.destroyed = !1, assert$2.hash(t);
    const h = toBytes(s);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const m = this.blockLen, d = new Uint8Array(m);
    d.set(h.length > m ? t.create().update(h).digest() : h);
    for (let v = 0; v < d.length; v++)
      d[v] ^= 54;
    this.iHash.update(d), this.oHash = t.create();
    for (let v = 0; v < d.length; v++)
      d[v] ^= 106;
    this.oHash.update(d), d.fill(0);
  }
  update(t) {
    return assert$2.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    assert$2.exists(this), assert$2.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: s, iHash: h, finished: m, destroyed: d, blockLen: v, outputLen: _ } = this;
    return t = t, t.finished = m, t.destroyed = d, t.blockLen = v, t.outputLen = _, t.oHash = s._cloneInto(t.oHash), t.iHash = h._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac = (l, t, s) => new HMAC(l, t).update(s).digest();
hmac.create = (l, t) => new HMAC(l, t);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _8n = BigInt(8), CURVE = Object.freeze({
  a: _0n,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
}), divNearest = (l, t) => (l + t / _2n) / t, endo = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  splitScalar(l) {
    const { n: t } = CURVE, s = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), h = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), m = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), d = s, v = BigInt("0x100000000000000000000000000000000"), _ = divNearest(d * l, t), T = divNearest(-h * l, t);
    let z = mod(l - _ * s - T * m, t), J = mod(-_ * h - T * d, t);
    const Y = z > v, ie = J > v;
    if (Y && (z = t - z), ie && (J = t - J), z > v || J > v)
      throw new Error("splitScalarEndo: Endomorphism failed, k=" + l);
    return { k1neg: Y, k1: z, k2neg: ie, k2: J };
  }
}, fieldLen = 32, groupLen = 32, hashLen = 32, compressedLen = fieldLen + 1, uncompressedLen = 2 * fieldLen + 1;
function weierstrass(l) {
  const { a: t, b: s } = CURVE, h = mod(l * l), m = mod(h * l);
  return mod(m + t * l + s);
}
const USE_ENDOMORPHISM = CURVE.a === _0n;
class ShaError extends Error {
  constructor(t) {
    super(t);
  }
}
function assertJacPoint(l) {
  if (!(l instanceof JacobianPoint))
    throw new TypeError("JacobianPoint expected");
}
class JacobianPoint {
  constructor(t, s, h) {
    this.x = t, this.y = s, this.z = h;
  }
  static fromAffine(t) {
    if (!(t instanceof Point))
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    return t.equals(Point.ZERO) ? JacobianPoint.ZERO : new JacobianPoint(t.x, t.y, _1n);
  }
  static toAffineBatch(t) {
    const s = invertBatch(t.map((h) => h.z));
    return t.map((h, m) => h.toAffine(s[m]));
  }
  static normalizeZ(t) {
    return JacobianPoint.toAffineBatch(t).map(JacobianPoint.fromAffine);
  }
  equals(t) {
    assertJacPoint(t);
    const { x: s, y: h, z: m } = this, { x: d, y: v, z: _ } = t, T = mod(m * m), z = mod(_ * _), J = mod(s * z), Y = mod(d * T), ie = mod(mod(h * _) * z), ne = mod(mod(v * m) * T);
    return J === Y && ie === ne;
  }
  negate() {
    return new JacobianPoint(this.x, mod(-this.y), this.z);
  }
  double() {
    const { x: t, y: s, z: h } = this, m = mod(t * t), d = mod(s * s), v = mod(d * d), _ = t + d, T = mod(_2n * (mod(_ * _) - m - v)), z = mod(_3n * m), J = mod(z * z), Y = mod(J - _2n * T), ie = mod(z * (T - Y) - _8n * v), ne = mod(_2n * s * h);
    return new JacobianPoint(Y, ie, ne);
  }
  add(t) {
    assertJacPoint(t);
    const { x: s, y: h, z: m } = this, { x: d, y: v, z: _ } = t;
    if (d === _0n || v === _0n)
      return this;
    if (s === _0n || h === _0n)
      return t;
    const T = mod(m * m), z = mod(_ * _), J = mod(s * z), Y = mod(d * T), ie = mod(mod(h * _) * z), ne = mod(mod(v * m) * T), de = mod(Y - J), ce = mod(ne - ie);
    if (de === _0n)
      return ce === _0n ? this.double() : JacobianPoint.ZERO;
    const re = mod(de * de), oe = mod(de * re), pe = mod(J * re), ae = mod(ce * ce - oe - _2n * pe), me = mod(ce * (pe - ae) - ie * oe), ge = mod(m * _ * de);
    return new JacobianPoint(ae, me, ge);
  }
  subtract(t) {
    return this.add(t.negate());
  }
  multiplyUnsafe(t) {
    const s = JacobianPoint.ZERO;
    if (typeof t == "bigint" && t === _0n)
      return s;
    let h = normalizeScalar(t);
    if (h === _1n)
      return this;
    if (!USE_ENDOMORPHISM) {
      let Y = s, ie = this;
      for (; h > _0n; )
        h & _1n && (Y = Y.add(ie)), ie = ie.double(), h >>= _1n;
      return Y;
    }
    let { k1neg: m, k1: d, k2neg: v, k2: _ } = endo.splitScalar(h), T = s, z = s, J = this;
    for (; d > _0n || _ > _0n; )
      d & _1n && (T = T.add(J)), _ & _1n && (z = z.add(J)), J = J.double(), d >>= _1n, _ >>= _1n;
    return m && (T = T.negate()), v && (z = z.negate()), z = new JacobianPoint(mod(z.x * endo.beta), z.y, z.z), T.add(z);
  }
  precomputeWindow(t) {
    const s = USE_ENDOMORPHISM ? 128 / t + 1 : 256 / t + 1, h = [];
    let m = this, d = m;
    for (let v = 0; v < s; v++) {
      d = m, h.push(d);
      for (let _ = 1; _ < 2 ** (t - 1); _++)
        d = d.add(m), h.push(d);
      m = d.double();
    }
    return h;
  }
  wNAF(t, s) {
    !s && this.equals(JacobianPoint.BASE) && (s = Point.BASE);
    const h = s && s._WINDOW_SIZE || 1;
    if (256 % h)
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    let m = s && pointPrecomputes.get(s);
    m || (m = this.precomputeWindow(h), s && h !== 1 && (m = JacobianPoint.normalizeZ(m), pointPrecomputes.set(s, m)));
    let d = JacobianPoint.ZERO, v = JacobianPoint.BASE;
    const _ = 1 + (USE_ENDOMORPHISM ? 128 / h : 256 / h), T = 2 ** (h - 1), z = BigInt(2 ** h - 1), J = 2 ** h, Y = BigInt(h);
    for (let ie = 0; ie < _; ie++) {
      const ne = ie * T;
      let de = Number(t & z);
      t >>= Y, de > T && (de -= J, t += _1n);
      const ce = ne, re = ne + Math.abs(de) - 1, oe = ie % 2 !== 0, pe = de < 0;
      de === 0 ? v = v.add(constTimeNegate(oe, m[ce])) : d = d.add(constTimeNegate(pe, m[re]));
    }
    return { p: d, f: v };
  }
  multiply(t, s) {
    let h = normalizeScalar(t), m, d;
    if (USE_ENDOMORPHISM) {
      const { k1neg: v, k1: _, k2neg: T, k2: z } = endo.splitScalar(h);
      let { p: J, f: Y } = this.wNAF(_, s), { p: ie, f: ne } = this.wNAF(z, s);
      J = constTimeNegate(v, J), ie = constTimeNegate(T, ie), ie = new JacobianPoint(mod(ie.x * endo.beta), ie.y, ie.z), m = J.add(ie), d = Y.add(ne);
    } else {
      const { p: v, f: _ } = this.wNAF(h, s);
      m = v, d = _;
    }
    return JacobianPoint.normalizeZ([m, d])[0];
  }
  toAffine(t) {
    const { x: s, y: h, z: m } = this, d = this.equals(JacobianPoint.ZERO);
    t == null && (t = d ? _8n : invert(m));
    const v = t, _ = mod(v * v), T = mod(_ * v), z = mod(s * _), J = mod(h * T), Y = mod(m * v);
    if (d)
      return Point.ZERO;
    if (Y !== _1n)
      throw new Error("invZ was invalid");
    return new Point(z, J);
  }
}
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
function constTimeNegate(l, t) {
  const s = t.negate();
  return l ? s : t;
}
const pointPrecomputes = /* @__PURE__ */ new WeakMap();
class Point {
  constructor(t, s) {
    this.x = t, this.y = s;
  }
  _setWindowSize(t) {
    this._WINDOW_SIZE = t, pointPrecomputes.delete(this);
  }
  hasEvenY() {
    return this.y % _2n === _0n;
  }
  static fromCompressedHex(t) {
    const s = t.length === 32, h = bytesToNumber(s ? t : t.subarray(1));
    if (!isValidFieldElement(h))
      throw new Error("Point is not on curve");
    const m = weierstrass(h);
    let d = sqrtMod(m);
    const v = (d & _1n) === _1n;
    s ? v && (d = mod(-d)) : (t[0] & 1) === 1 !== v && (d = mod(-d));
    const _ = new Point(h, d);
    return _.assertValidity(), _;
  }
  static fromUncompressedHex(t) {
    const s = bytesToNumber(t.subarray(1, fieldLen + 1)), h = bytesToNumber(t.subarray(fieldLen + 1, fieldLen * 2 + 1)), m = new Point(s, h);
    return m.assertValidity(), m;
  }
  static fromHex(t) {
    const s = ensureBytes(t), h = s.length, m = s[0];
    if (h === fieldLen)
      return this.fromCompressedHex(s);
    if (h === compressedLen && (m === 2 || m === 3))
      return this.fromCompressedHex(s);
    if (h === uncompressedLen && m === 4)
      return this.fromUncompressedHex(s);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${h}`);
  }
  static fromPrivateKey(t) {
    return Point.BASE.multiply(normalizePrivateKey(t));
  }
  static fromSignature(t, s, h) {
    const { r: m, s: d } = normalizeSignature(s);
    if (![0, 1, 2, 3].includes(h))
      throw new Error("Cannot recover: invalid recovery bit");
    const v = truncateHash(ensureBytes(t)), { n: _ } = CURVE, T = h === 2 || h === 3 ? m + _ : m, z = invert(T, _), J = mod(-v * z, _), Y = mod(d * z, _), ie = h & 1 ? "03" : "02", ne = Point.fromHex(ie + numTo32bStr(T)), de = Point.BASE.multiplyAndAddUnsafe(ne, J, Y);
    if (!de)
      throw new Error("Cannot recover signature: point at infinify");
    return de.assertValidity(), de;
  }
  toRawBytes(t = !1) {
    return hexToBytes(this.toHex(t));
  }
  toHex(t = !1) {
    const s = numTo32bStr(this.x);
    return t ? `${this.hasEvenY() ? "02" : "03"}${s}` : `04${s}${numTo32bStr(this.y)}`;
  }
  toHexX() {
    return this.toHex(!0).slice(2);
  }
  toRawX() {
    return this.toRawBytes(!0).slice(1);
  }
  assertValidity() {
    const t = "Point is not on elliptic curve", { x: s, y: h } = this;
    if (!isValidFieldElement(s) || !isValidFieldElement(h))
      throw new Error(t);
    const m = mod(h * h), d = weierstrass(s);
    if (mod(m - d) !== _0n)
      throw new Error(t);
  }
  equals(t) {
    return this.x === t.x && this.y === t.y;
  }
  negate() {
    return new Point(this.x, mod(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(t) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(t)).toAffine();
  }
  subtract(t) {
    return this.add(t.negate());
  }
  multiply(t) {
    return JacobianPoint.fromAffine(this).multiply(t, this).toAffine();
  }
  multiplyAndAddUnsafe(t, s, h) {
    const m = JacobianPoint.fromAffine(this), d = s === _0n || s === _1n || this !== Point.BASE ? m.multiplyUnsafe(s) : m.multiply(s), v = JacobianPoint.fromAffine(t).multiplyUnsafe(h), _ = d.add(v);
    return _.equals(JacobianPoint.ZERO) ? void 0 : _.toAffine();
  }
}
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(l) {
  return Number.parseInt(l[0], 16) >= 8 ? "00" + l : l;
}
function parseDERInt(l) {
  if (l.length < 2 || l[0] !== 2)
    throw new Error(`Invalid signature integer tag: ${bytesToHex(l)}`);
  const t = l[1], s = l.subarray(2, t + 2);
  if (!t || s.length !== t)
    throw new Error("Invalid signature integer: wrong length");
  if (s[0] === 0 && s[1] <= 127)
    throw new Error("Invalid signature integer: trailing length");
  return { data: bytesToNumber(s), left: l.subarray(t + 2) };
}
function parseDERSignature(l) {
  if (l.length < 2 || l[0] != 48)
    throw new Error(`Invalid signature tag: ${bytesToHex(l)}`);
  if (l[1] !== l.length - 2)
    throw new Error("Invalid signature: incorrect length");
  const { data: t, left: s } = parseDERInt(l.subarray(2)), { data: h, left: m } = parseDERInt(s);
  if (m.length)
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(m)}`);
  return { r: t, s: h };
}
class Signature {
  constructor(t, s) {
    this.r = t, this.s = s, this.assertValidity();
  }
  static fromCompact(t) {
    const s = t instanceof Uint8Array, h = "Signature.fromCompact";
    if (typeof t != "string" && !s)
      throw new TypeError(`${h}: Expected string or Uint8Array`);
    const m = s ? bytesToHex(t) : t;
    if (m.length !== 128)
      throw new Error(`${h}: Expected 64-byte hex`);
    return new Signature(hexToNumber(m.slice(0, 64)), hexToNumber(m.slice(64, 128)));
  }
  static fromDER(t) {
    const s = t instanceof Uint8Array;
    if (typeof t != "string" && !s)
      throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
    const { r: h, s: m } = parseDERSignature(s ? t : hexToBytes(t));
    return new Signature(h, m);
  }
  static fromHex(t) {
    return this.fromDER(t);
  }
  assertValidity() {
    const { r: t, s } = this;
    if (!isWithinCurveOrder(t))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const t = CURVE.n >> _1n;
    return this.s > t;
  }
  normalizeS() {
    return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;
  }
  toDERRawBytes() {
    return hexToBytes(this.toDERHex());
  }
  toDERHex() {
    const t = sliceDER(numberToHexUnpadded(this.s)), s = sliceDER(numberToHexUnpadded(this.r)), h = t.length / 2, m = s.length / 2, d = numberToHexUnpadded(h), v = numberToHexUnpadded(m);
    return `30${numberToHexUnpadded(m + h + 4)}02${v}${s}02${d}${t}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
}
function concatBytes(...l) {
  if (!l.every((h) => h instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (l.length === 1)
    return l[0];
  const t = l.reduce((h, m) => h + m.length, 0), s = new Uint8Array(t);
  for (let h = 0, m = 0; h < l.length; h++) {
    const d = l[h];
    s.set(d, m), m += d.length;
  }
  return s;
}
const hexes = Array.from({ length: 256 }, (l, t) => t.toString(16).padStart(2, "0"));
function bytesToHex(l) {
  if (!(l instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let t = "";
  for (let s = 0; s < l.length; s++)
    t += hexes[l[s]];
  return t;
}
const POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(l) {
  if (typeof l != "bigint")
    throw new Error("Expected bigint");
  if (!(_0n <= l && l < POW_2_256))
    throw new Error("Expected number 0 <= n < 2^256");
  return l.toString(16).padStart(64, "0");
}
function numTo32b(l) {
  const t = hexToBytes(numTo32bStr(l));
  if (t.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return t;
}
function numberToHexUnpadded(l) {
  const t = l.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function hexToNumber(l) {
  if (typeof l != "string")
    throw new TypeError("hexToNumber: expected string, got " + typeof l);
  return BigInt(`0x${l}`);
}
function hexToBytes(l) {
  if (typeof l != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof l);
  if (l.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + l.length);
  const t = new Uint8Array(l.length / 2);
  for (let s = 0; s < t.length; s++) {
    const h = s * 2, m = l.slice(h, h + 2), d = Number.parseInt(m, 16);
    if (Number.isNaN(d) || d < 0)
      throw new Error("Invalid byte sequence");
    t[s] = d;
  }
  return t;
}
function bytesToNumber(l) {
  return hexToNumber(bytesToHex(l));
}
function ensureBytes(l) {
  return l instanceof Uint8Array ? Uint8Array.from(l) : hexToBytes(l);
}
function normalizeScalar(l) {
  if (typeof l == "number" && Number.isSafeInteger(l) && l > 0)
    return BigInt(l);
  if (typeof l == "bigint" && isWithinCurveOrder(l))
    return l;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod(l, t = CURVE.P) {
  const s = l % t;
  return s >= _0n ? s : t + s;
}
function pow2(l, t) {
  const { P: s } = CURVE;
  let h = l;
  for (; t-- > _0n; )
    h *= h, h %= s;
  return h;
}
function sqrtMod(l) {
  const { P: t } = CURVE, s = BigInt(6), h = BigInt(11), m = BigInt(22), d = BigInt(23), v = BigInt(44), _ = BigInt(88), T = l * l * l % t, z = T * T * l % t, J = pow2(z, _3n) * z % t, Y = pow2(J, _3n) * z % t, ie = pow2(Y, _2n) * T % t, ne = pow2(ie, h) * ie % t, de = pow2(ne, m) * ne % t, ce = pow2(de, v) * de % t, re = pow2(ce, _) * ce % t, oe = pow2(re, v) * de % t, pe = pow2(oe, _3n) * z % t, ae = pow2(pe, d) * ne % t, me = pow2(ae, s) * T % t, ge = pow2(me, _2n);
  if (ge * ge % t !== l)
    throw new Error("Cannot find square root");
  return ge;
}
function invert(l, t = CURVE.P) {
  if (l === _0n || t <= _0n)
    throw new Error(`invert: expected positive integers, got n=${l} mod=${t}`);
  let s = mod(l, t), h = t, m = _0n, d = _1n;
  for (; s !== _0n; ) {
    const _ = h / s, T = h % s, z = m - d * _;
    h = s, s = T, m = d, d = z;
  }
  if (h !== _1n)
    throw new Error("invert: does not exist");
  return mod(m, t);
}
function invertBatch(l, t = CURVE.P) {
  const s = new Array(l.length), h = l.reduce((d, v, _) => v === _0n ? d : (s[_] = d, mod(d * v, t)), _1n), m = invert(h, t);
  return l.reduceRight((d, v, _) => v === _0n ? d : (s[_] = mod(d * s[_], t), mod(d * v, t)), m), s;
}
function bits2int_2(l) {
  const t = l.length * 8 - groupLen * 8, s = bytesToNumber(l);
  return t > 0 ? s >> BigInt(t) : s;
}
function truncateHash(l, t = !1) {
  const s = bits2int_2(l);
  if (t)
    return s;
  const { n: h } = CURVE;
  return s >= h ? s - h : s;
}
let _sha256Sync, _hmacSha256Sync;
class HmacDrbg {
  constructor(t, s) {
    if (this.hashLen = t, this.qByteLen = s, typeof t != "number" || t < 2)
      throw new Error("hashLen must be a number");
    if (typeof s != "number" || s < 2)
      throw new Error("qByteLen must be a number");
    this.v = new Uint8Array(t).fill(1), this.k = new Uint8Array(t).fill(0), this.counter = 0;
  }
  hmac(...t) {
    return utils$1.hmacSha256(this.k, ...t);
  }
  hmacSync(...t) {
    return _hmacSha256Sync(this.k, ...t);
  }
  checkSync() {
    if (typeof _hmacSha256Sync != "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(t = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), t), this.v = await this.hmac(this.v), t.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), t), this.v = await this.hmac(this.v));
  }
  reseedSync(t = new Uint8Array()) {
    this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), t), this.v = this.hmacSync(this.v), t.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), t), this.v = this.hmacSync(this.v));
  }
  async generate() {
    this.incr();
    let t = 0;
    const s = [];
    for (; t < this.qByteLen; ) {
      this.v = await this.hmac(this.v);
      const h = this.v.slice();
      s.push(h), t += this.v.length;
    }
    return concatBytes(...s);
  }
  generateSync() {
    this.checkSync(), this.incr();
    let t = 0;
    const s = [];
    for (; t < this.qByteLen; ) {
      this.v = this.hmacSync(this.v);
      const h = this.v.slice();
      s.push(h), t += this.v.length;
    }
    return concatBytes(...s);
  }
}
function isWithinCurveOrder(l) {
  return _0n < l && l < CURVE.n;
}
function isValidFieldElement(l) {
  return _0n < l && l < CURVE.P;
}
function kmdToSig(l, t, s, h = !0) {
  const { n: m } = CURVE, d = truncateHash(l, !0);
  if (!isWithinCurveOrder(d))
    return;
  const v = invert(d, m), _ = Point.BASE.multiply(d), T = mod(_.x, m);
  if (T === _0n)
    return;
  const z = mod(v * mod(t + s * T, m), m);
  if (z === _0n)
    return;
  let J = new Signature(T, z), Y = (_.x === J.r ? 0 : 2) | Number(_.y & _1n);
  return h && J.hasHighS() && (J = J.normalizeS(), Y ^= 1), { sig: J, recovery: Y };
}
function normalizePrivateKey(l) {
  let t;
  if (typeof l == "bigint")
    t = l;
  else if (typeof l == "number" && Number.isSafeInteger(l) && l > 0)
    t = BigInt(l);
  else if (typeof l == "string") {
    if (l.length !== 2 * groupLen)
      throw new Error("Expected 32 bytes of private key");
    t = hexToNumber(l);
  } else if (l instanceof Uint8Array) {
    if (l.length !== groupLen)
      throw new Error("Expected 32 bytes of private key");
    t = bytesToNumber(l);
  } else
    throw new TypeError("Expected valid private key");
  if (!isWithinCurveOrder(t))
    throw new Error("Expected private key: 0 < key < n");
  return t;
}
function normalizeSignature(l) {
  if (l instanceof Signature)
    return l.assertValidity(), l;
  try {
    return Signature.fromDER(l);
  } catch {
    return Signature.fromCompact(l);
  }
}
function getPublicKey$1(l, t = !1) {
  return Point.fromPrivateKey(l).toRawBytes(t);
}
function bits2int(l) {
  const t = l.length > fieldLen ? l.slice(0, fieldLen) : l;
  return bytesToNumber(t);
}
function bits2octets(l) {
  const t = bits2int(l), s = mod(t, CURVE.n);
  return int2octets(s < _0n ? t : s);
}
function int2octets(l) {
  return numTo32b(l);
}
function initSigArgs(l, t, s) {
  if (l == null)
    throw new Error(`sign: expected valid message hash, not "${l}"`);
  const h = ensureBytes(l), m = normalizePrivateKey(t), d = [int2octets(m), bits2octets(h)];
  if (s != null) {
    s === !0 && (s = utils$1.randomBytes(fieldLen));
    const T = ensureBytes(s);
    if (T.length !== fieldLen)
      throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
    d.push(T);
  }
  const v = concatBytes(...d), _ = bits2int(h);
  return { seed: v, m: _, d: m };
}
function finalizeSig(l, t) {
  const { sig: s, recovery: h } = l, { der: m, recovered: d } = Object.assign({ canonical: !0, der: !0 }, t), v = m ? s.toDERRawBytes() : s.toCompactRawBytes();
  return d ? [v, h] : v;
}
function signSync(l, t, s = {}) {
  const { seed: h, m, d } = initSigArgs(l, t, s.extraEntropy), v = new HmacDrbg(hashLen, groupLen);
  v.reseedSync(h);
  let _;
  for (; !(_ = kmdToSig(v.generateSync(), m, d, s.canonical)); )
    v.reseedSync();
  return finalizeSig(_, s);
}
Point.BASE._setWindowSize(8);
const crypto$1 = {
  node: nodeCrypto,
  web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
}, TAGGED_HASH_PREFIXES = {}, utils$1 = {
  bytesToHex,
  hexToBytes,
  concatBytes,
  mod,
  invert,
  isValidPrivateKey(l) {
    try {
      return normalizePrivateKey(l), !0;
    } catch {
      return !1;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (l) => {
    l = ensureBytes(l);
    const t = groupLen + 8;
    if (l.length < t || l.length > 1024)
      throw new Error("Expected valid bytes of private key as per FIPS 186");
    const s = mod(bytesToNumber(l), CURVE.n - _1n) + _1n;
    return numTo32b(s);
  },
  randomBytes: (l = 32) => {
    if (crypto$1.web)
      return crypto$1.web.getRandomValues(new Uint8Array(l));
    if (crypto$1.node) {
      const { randomBytes: t } = crypto$1.node;
      return Uint8Array.from(t(l));
    } else
      throw new Error("The environment doesn't have randomBytes function");
  },
  randomPrivateKey: () => utils$1.hashToPrivateKey(utils$1.randomBytes(groupLen + 8)),
  precompute(l = 8, t = Point.BASE) {
    const s = t === Point.BASE ? t : new Point(t.x, t.y);
    return s._setWindowSize(l), s.multiply(_3n), s;
  },
  sha256: async (...l) => {
    if (crypto$1.web) {
      const t = await crypto$1.web.subtle.digest("SHA-256", concatBytes(...l));
      return new Uint8Array(t);
    } else if (crypto$1.node) {
      const { createHash: t } = crypto$1.node, s = t("sha256");
      return l.forEach((h) => s.update(h)), Uint8Array.from(s.digest());
    } else
      throw new Error("The environment doesn't have sha256 function");
  },
  hmacSha256: async (l, ...t) => {
    if (crypto$1.web) {
      const s = await crypto$1.web.subtle.importKey("raw", l, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), h = concatBytes(...t), m = await crypto$1.web.subtle.sign("HMAC", s, h);
      return new Uint8Array(m);
    } else if (crypto$1.node) {
      const { createHmac: s } = crypto$1.node, h = s("sha256", l);
      return t.forEach((m) => h.update(m)), Uint8Array.from(h.digest());
    } else
      throw new Error("The environment doesn't have hmac-sha256 function");
  },
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: async (l, ...t) => {
    let s = TAGGED_HASH_PREFIXES[l];
    if (s === void 0) {
      const h = await utils$1.sha256(Uint8Array.from(l, (m) => m.charCodeAt(0)));
      s = concatBytes(h, h), TAGGED_HASH_PREFIXES[l] = s;
    }
    return utils$1.sha256(s, ...t);
  },
  taggedHashSync: (l, ...t) => {
    if (typeof _sha256Sync != "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let s = TAGGED_HASH_PREFIXES[l];
    if (s === void 0) {
      const h = _sha256Sync(Uint8Array.from(l, (m) => m.charCodeAt(0)));
      s = concatBytes(h, h), TAGGED_HASH_PREFIXES[l] = s;
    }
    return _sha256Sync(s, ...t);
  },
  _JacobianPoint: JacobianPoint
};
Object.defineProperties(utils$1, {
  sha256Sync: {
    configurable: !1,
    get() {
      return _sha256Sync;
    },
    set(l) {
      _sha256Sync || (_sha256Sync = l);
    }
  },
  hmacSha256Sync: {
    configurable: !1,
    get() {
      return _hmacSha256Sync;
    },
    set(l) {
      _hmacSha256Sync || (_hmacSha256Sync = l);
    }
  }
});
utils$2.sha512Sync = (...l) => sha512(utils$2.concatBytes(...l));
const generatePrivateKey = utils$2.randomPrivateKey, generateKeypair = () => {
  const l = utils$2.randomPrivateKey(), t = getPublicKey(l), s = new Uint8Array(64);
  return s.set(l), s.set(t, 32), {
    publicKey: t,
    secretKey: s
  };
}, getPublicKey = sync.getPublicKey;
function isOnCurve(l) {
  try {
    return Point$1.fromHex(
      l,
      !0
    ), !0;
  } catch {
    return !1;
  }
}
const sign = (l, t) => sync.sign(l, t.slice(0, 32)), verify = sync.verify, toBuffer = (l) => buffer.Buffer.isBuffer(l) ? l : l instanceof Uint8Array ? buffer.Buffer.from(l.buffer, l.byteOffset, l.byteLength) : buffer.Buffer.from(l);
class Struct {
  constructor(t) {
    Object.assign(this, t);
  }
  encode() {
    return buffer.Buffer.from(serialize_1(SOLANA_SCHEMA, this));
  }
  static decode(t) {
    return deserialize_1(SOLANA_SCHEMA, this, t);
  }
  static decodeUnchecked(t) {
    return deserializeUnchecked_1(SOLANA_SCHEMA, this, t);
  }
}
class Enum extends Struct {
  constructor(t) {
    if (super(t), this.enum = "", Object.keys(t).length !== 1)
      throw new Error("Enum can only take single value");
    Object.keys(t).map((s) => {
      this.enum = s;
    });
  }
}
const SOLANA_SCHEMA = /* @__PURE__ */ new Map();
let _Symbol$toStringTag;
const MAX_SEED_LENGTH = 32, PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(l) {
  return l._bn !== void 0;
}
let uniquePublicKeyCounter = 1;
_Symbol$toStringTag = Symbol.toStringTag;
class PublicKey extends Struct {
  constructor(t) {
    if (super({}), this._bn = void 0, isPublicKeyData(t))
      this._bn = t._bn;
    else {
      if (typeof t == "string") {
        const s = bs58.decode(t);
        if (s.length != PUBLIC_KEY_LENGTH)
          throw new Error("Invalid public key input");
        this._bn = new BN(s);
      } else
        this._bn = new BN(t);
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH)
        throw new Error("Invalid public key input");
    }
  }
  static unique() {
    const t = new PublicKey(uniquePublicKeyCounter);
    return uniquePublicKeyCounter += 1, new PublicKey(t.toBuffer());
  }
  equals(t) {
    return this._bn.eq(t._bn);
  }
  toBase58() {
    return bs58.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const t = this.toBuffer();
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  }
  toBuffer() {
    const t = this._bn.toArrayLike(buffer.Buffer);
    if (t.length === PUBLIC_KEY_LENGTH)
      return t;
    const s = buffer.Buffer.alloc(32);
    return t.copy(s, 32 - t.length), s;
  }
  get [_Symbol$toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(t, s, h) {
    const m = buffer.Buffer.concat([t.toBuffer(), buffer.Buffer.from(s), h.toBuffer()]), d = sha256(m);
    return new PublicKey(d);
  }
  static createProgramAddressSync(t, s) {
    let h = buffer.Buffer.alloc(0);
    t.forEach(function(d) {
      if (d.length > MAX_SEED_LENGTH)
        throw new TypeError("Max seed length exceeded");
      h = buffer.Buffer.concat([h, toBuffer(d)]);
    }), h = buffer.Buffer.concat([h, s.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
    const m = sha256(h);
    if (isOnCurve(m))
      throw new Error("Invalid seeds, address must fall off the curve");
    return new PublicKey(m);
  }
  static async createProgramAddress(t, s) {
    return this.createProgramAddressSync(t, s);
  }
  static findProgramAddressSync(t, s) {
    let h = 255, m;
    for (; h != 0; ) {
      try {
        const d = t.concat(buffer.Buffer.from([h]));
        m = this.createProgramAddressSync(d, s);
      } catch (d) {
        if (d instanceof TypeError)
          throw d;
        h--;
        continue;
      }
      return [m, h];
    }
    throw new Error("Unable to find a viable program address nonce");
  }
  static async findProgramAddress(t, s) {
    return this.findProgramAddressSync(t, s);
  }
  static isOnCurve(t) {
    const s = new PublicKey(t);
    return isOnCurve(s.toBytes());
  }
}
PublicKey.default = new PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
class Account {
  constructor(t) {
    if (this._publicKey = void 0, this._secretKey = void 0, t) {
      const s = toBuffer(t);
      if (t.length !== 64)
        throw new Error("bad secret key size");
      this._publicKey = s.slice(32, 64), this._secretKey = s.slice(0, 32);
    } else
      this._secretKey = toBuffer(generatePrivateKey()), this._publicKey = toBuffer(getPublicKey(this._secretKey));
  }
  get publicKey() {
    return new PublicKey(this._publicKey);
  }
  get secretKey() {
    return buffer.Buffer.concat([this._secretKey, this._publicKey], 64);
  }
}
const BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111"), PACKET_DATA_SIZE = 1280 - 40 - 8, VERSION_PREFIX_MASK = 127, SIGNATURE_LENGTH_IN_BYTES = 64;
class TransactionExpiredBlockheightExceededError extends Error {
  constructor(t) {
    super(`Signature ${t} has expired: block height exceeded.`), this.signature = void 0, this.signature = t;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
class TransactionExpiredTimeoutError extends Error {
  constructor(t, s) {
    super(`Transaction was not confirmed in ${s.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`), this.signature = void 0, this.signature = t;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
class TransactionExpiredNonceInvalidError extends Error {
  constructor(t) {
    super(`Signature ${t} has expired: the nonce is no longer valid.`), this.signature = void 0, this.signature = t;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
class MessageAccountKeys {
  constructor(t, s) {
    this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = t, this.accountKeysFromLookups = s;
  }
  keySegments() {
    const t = [this.staticAccountKeys];
    return this.accountKeysFromLookups && (t.push(this.accountKeysFromLookups.writable), t.push(this.accountKeysFromLookups.readonly)), t;
  }
  get(t) {
    for (const s of this.keySegments()) {
      if (t < s.length)
        return s[t];
      t -= s.length;
    }
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(t) {
    if (this.length > 255 + 1)
      throw new Error("Account index overflow encountered during compilation");
    const h = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((d, v) => {
      h.set(d.toBase58(), v);
    });
    const m = (d) => {
      const v = h.get(d.toBase58());
      if (v === void 0)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return v;
    };
    return t.map((d) => ({
      programIdIndex: m(d.programId),
      accountKeyIndexes: d.keys.map((v) => m(v.pubkey)),
      data: d.data
    }));
  }
}
const publicKey = (l = "publicKey") => blob(32, l), signature = (l = "signature") => blob(64, l), rustString = (l = "string") => {
  const t = struct([u32("length"), u32("lengthPadding"), blob(offset(u32(), -8), "chars")], l), s = t.decode.bind(t), h = t.encode.bind(t), m = t;
  return m.decode = (d, v) => s(d, v).chars.toString(), m.encode = (d, v, _) => {
    const T = {
      chars: buffer.Buffer.from(d, "utf8")
    };
    return h(T, v, _);
  }, m.alloc = (d) => u32().span + u32().span + buffer.Buffer.from(d, "utf8").length, m;
}, authorized = (l = "authorized") => struct([publicKey("staker"), publicKey("withdrawer")], l), lockup = (l = "lockup") => struct([ns64("unixTimestamp"), ns64("epoch"), publicKey("custodian")], l), voteInit = (l = "voteInit") => struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), u8("commission")], l), voteAuthorizeWithSeedArgs = (l = "voteAuthorizeWithSeedArgs") => struct([u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], l);
function getAlloc(l, t) {
  const s = (m) => {
    if (m.span >= 0)
      return m.span;
    if (typeof m.alloc == "function")
      return m.alloc(t[m.property]);
    if ("count" in m && "elementLayout" in m) {
      const d = t[m.property];
      if (Array.isArray(d))
        return d.length * s(m.elementLayout);
    } else if ("fields" in m)
      return getAlloc({
        layout: m
      }, t[m.property]);
    return 0;
  };
  let h = 0;
  return l.layout.fields.forEach((m) => {
    h += s(m);
  }), h;
}
function decodeLength(l) {
  let t = 0, s = 0;
  for (; ; ) {
    let h = l.shift();
    if (t |= (h & 127) << s * 7, s += 1, (h & 128) === 0)
      break;
  }
  return t;
}
function encodeLength(l, t) {
  let s = t;
  for (; ; ) {
    let h = s & 127;
    if (s >>= 7, s == 0) {
      l.push(h);
      break;
    } else
      h |= 128, l.push(h);
  }
}
function assert(l, t) {
  if (!l)
    throw new Error(t || "Assertion failed");
}
class CompiledKeys {
  constructor(t, s) {
    this.payer = void 0, this.keyMetaMap = void 0, this.payer = t, this.keyMetaMap = s;
  }
  static compile(t, s) {
    const h = /* @__PURE__ */ new Map(), m = (v) => {
      const _ = v.toBase58();
      let T = h.get(_);
      return T === void 0 && (T = {
        isSigner: !1,
        isWritable: !1,
        isInvoked: !1
      }, h.set(_, T)), T;
    }, d = m(s);
    d.isSigner = !0, d.isWritable = !0;
    for (const v of t) {
      m(v.programId).isInvoked = !0;
      for (const _ of v.keys) {
        const T = m(_.pubkey);
        T.isSigner || (T.isSigner = _.isSigner), T.isWritable || (T.isWritable = _.isWritable);
      }
    }
    return new CompiledKeys(s, h);
  }
  getMessageComponents() {
    const t = [...this.keyMetaMap.entries()];
    assert(t.length <= 256, "Max static account keys length exceeded");
    const s = t.filter(([, T]) => T.isSigner && T.isWritable), h = t.filter(([, T]) => T.isSigner && !T.isWritable), m = t.filter(([, T]) => !T.isSigner && T.isWritable), d = t.filter(([, T]) => !T.isSigner && !T.isWritable), v = {
      numRequiredSignatures: s.length + h.length,
      numReadonlySignedAccounts: h.length,
      numReadonlyUnsignedAccounts: d.length
    };
    {
      assert(s.length > 0, "Expected at least one writable signer key");
      const [T] = s[0];
      assert(T === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const _ = [...s.map(([T]) => new PublicKey(T)), ...h.map(([T]) => new PublicKey(T)), ...m.map(([T]) => new PublicKey(T)), ...d.map(([T]) => new PublicKey(T))];
    return [v, _];
  }
  extractTableLookup(t) {
    const [s, h] = this.drainKeysFoundInLookupTable(t.state.addresses, (v) => !v.isSigner && !v.isInvoked && v.isWritable), [m, d] = this.drainKeysFoundInLookupTable(t.state.addresses, (v) => !v.isSigner && !v.isInvoked && !v.isWritable);
    if (!(s.length === 0 && m.length === 0))
      return [{
        accountKey: t.key,
        writableIndexes: s,
        readonlyIndexes: m
      }, {
        writable: h,
        readonly: d
      }];
  }
  drainKeysFoundInLookupTable(t, s) {
    const h = new Array(), m = new Array();
    for (const [d, v] of this.keyMetaMap.entries())
      if (s(v)) {
        const _ = new PublicKey(d), T = t.findIndex((z) => z.equals(_));
        T >= 0 && (assert(T < 256, "Max lookup table index exceeded"), h.push(T), m.push(_), this.keyMetaMap.delete(d));
      }
    return [h, m];
  }
}
class Message {
  constructor(t) {
    this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = /* @__PURE__ */ new Map(), this.header = t.header, this.accountKeys = t.accountKeys.map((s) => new PublicKey(s)), this.recentBlockhash = t.recentBlockhash, this.instructions = t.instructions, this.instructions.forEach((s) => this.indexToProgramIds.set(s.programIdIndex, this.accountKeys[s.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((t) => ({
      programIdIndex: t.programIdIndex,
      accountKeyIndexes: t.accounts,
      data: bs58.decode(t.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(t) {
    const s = CompiledKeys.compile(t.instructions, t.payerKey), [h, m] = s.getMessageComponents(), v = new MessageAccountKeys(m).compileInstructions(t.instructions).map((_) => ({
      programIdIndex: _.programIdIndex,
      accounts: _.accountKeyIndexes,
      data: bs58.encode(_.data)
    }));
    return new Message({
      header: h,
      accountKeys: m,
      recentBlockhash: t.recentBlockhash,
      instructions: v
    });
  }
  isAccountSigner(t) {
    return t < this.header.numRequiredSignatures;
  }
  isAccountWritable(t) {
    const s = this.header.numRequiredSignatures;
    if (t >= this.header.numRequiredSignatures) {
      const h = t - s, d = this.accountKeys.length - s - this.header.numReadonlyUnsignedAccounts;
      return h < d;
    } else {
      const h = s - this.header.numReadonlySignedAccounts;
      return t < h;
    }
  }
  isProgramId(t) {
    return this.indexToProgramIds.has(t);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((t, s) => !this.isProgramId(s));
  }
  serialize() {
    const t = this.accountKeys.length;
    let s = [];
    encodeLength(s, t);
    const h = this.instructions.map((Y) => {
      const {
        accounts: ie,
        programIdIndex: ne
      } = Y, de = Array.from(bs58.decode(Y.data));
      let ce = [];
      encodeLength(ce, ie.length);
      let re = [];
      return encodeLength(re, de.length), {
        programIdIndex: ne,
        keyIndicesCount: buffer.Buffer.from(ce),
        keyIndices: ie,
        dataLength: buffer.Buffer.from(re),
        data: de
      };
    });
    let m = [];
    encodeLength(m, h.length);
    let d = buffer.Buffer.alloc(PACKET_DATA_SIZE);
    buffer.Buffer.from(m).copy(d);
    let v = m.length;
    h.forEach((Y) => {
      const ne = struct([u8("programIdIndex"), blob(Y.keyIndicesCount.length, "keyIndicesCount"), seq(u8("keyIndex"), Y.keyIndices.length, "keyIndices"), blob(Y.dataLength.length, "dataLength"), seq(u8("userdatum"), Y.data.length, "data")]).encode(Y, d, v);
      v += ne;
    }), d = d.slice(0, v);
    const _ = struct([blob(1, "numRequiredSignatures"), blob(1, "numReadonlySignedAccounts"), blob(1, "numReadonlyUnsignedAccounts"), blob(s.length, "keyCount"), seq(publicKey("key"), t, "keys"), publicKey("recentBlockhash")]), T = {
      numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: buffer.Buffer.from(s),
      keys: this.accountKeys.map((Y) => toBuffer(Y.toBytes())),
      recentBlockhash: bs58.decode(this.recentBlockhash)
    };
    let z = buffer.Buffer.alloc(2048);
    const J = _.encode(T, z);
    return d.copy(z, J), z.slice(0, J + d.length);
  }
  static from(t) {
    let s = [...t];
    const h = s.shift();
    if (h !== (h & VERSION_PREFIX_MASK))
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    const m = s.shift(), d = s.shift(), v = decodeLength(s);
    let _ = [];
    for (let ie = 0; ie < v; ie++) {
      const ne = s.slice(0, PUBLIC_KEY_LENGTH);
      s = s.slice(PUBLIC_KEY_LENGTH), _.push(new PublicKey(buffer.Buffer.from(ne)));
    }
    const T = s.slice(0, PUBLIC_KEY_LENGTH);
    s = s.slice(PUBLIC_KEY_LENGTH);
    const z = decodeLength(s);
    let J = [];
    for (let ie = 0; ie < z; ie++) {
      const ne = s.shift(), de = decodeLength(s), ce = s.slice(0, de);
      s = s.slice(de);
      const re = decodeLength(s), oe = s.slice(0, re), pe = bs58.encode(buffer.Buffer.from(oe));
      s = s.slice(re), J.push({
        programIdIndex: ne,
        accounts: ce,
        data: pe
      });
    }
    const Y = {
      header: {
        numRequiredSignatures: h,
        numReadonlySignedAccounts: m,
        numReadonlyUnsignedAccounts: d
      },
      recentBlockhash: bs58.encode(buffer.Buffer.from(T)),
      accountKeys: _,
      instructions: J
    };
    return new Message(Y);
  }
}
class MessageV0 {
  constructor(t) {
    this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = t.header, this.staticAccountKeys = t.staticAccountKeys, this.recentBlockhash = t.recentBlockhash, this.compiledInstructions = t.compiledInstructions, this.addressTableLookups = t.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let t = 0;
    for (const s of this.addressTableLookups)
      t += s.readonlyIndexes.length + s.writableIndexes.length;
    return t;
  }
  getAccountKeys(t) {
    let s;
    if (t && "accountKeysFromLookups" in t && t.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != t.accountKeysFromLookups.writable.length + t.accountKeysFromLookups.readonly.length)
        throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
      s = t.accountKeysFromLookups;
    } else if (t && "addressLookupTableAccounts" in t && t.addressLookupTableAccounts)
      s = this.resolveAddressTableLookups(t.addressLookupTableAccounts);
    else if (this.addressTableLookups.length > 0)
      throw new Error("Failed to get account keys because address table lookups were not resolved");
    return new MessageAccountKeys(this.staticAccountKeys, s);
  }
  isAccountSigner(t) {
    return t < this.header.numRequiredSignatures;
  }
  isAccountWritable(t) {
    const s = this.header.numRequiredSignatures, h = this.staticAccountKeys.length;
    if (t >= h) {
      const m = t - h, d = this.addressTableLookups.reduce((v, _) => v + _.writableIndexes.length, 0);
      return m < d;
    } else if (t >= this.header.numRequiredSignatures) {
      const m = t - s, v = h - s - this.header.numReadonlyUnsignedAccounts;
      return m < v;
    } else {
      const m = s - this.header.numReadonlySignedAccounts;
      return t < m;
    }
  }
  resolveAddressTableLookups(t) {
    const s = {
      writable: [],
      readonly: []
    };
    for (const h of this.addressTableLookups) {
      const m = t.find((d) => d.key.equals(h.accountKey));
      if (!m)
        throw new Error(`Failed to find address lookup table account for table key ${h.accountKey.toBase58()}`);
      for (const d of h.writableIndexes)
        if (d < m.state.addresses.length)
          s.writable.push(m.state.addresses[d]);
        else
          throw new Error(`Failed to find address for index ${d} in address lookup table ${h.accountKey.toBase58()}`);
      for (const d of h.readonlyIndexes)
        if (d < m.state.addresses.length)
          s.readonly.push(m.state.addresses[d]);
        else
          throw new Error(`Failed to find address for index ${d} in address lookup table ${h.accountKey.toBase58()}`);
    }
    return s;
  }
  static compile(t) {
    const s = CompiledKeys.compile(t.instructions, t.payerKey), h = new Array(), m = {
      writable: new Array(),
      readonly: new Array()
    }, d = t.addressLookupTableAccounts || [];
    for (const J of d) {
      const Y = s.extractTableLookup(J);
      if (Y !== void 0) {
        const [ie, {
          writable: ne,
          readonly: de
        }] = Y;
        h.push(ie), m.writable.push(...ne), m.readonly.push(...de);
      }
    }
    const [v, _] = s.getMessageComponents(), z = new MessageAccountKeys(_, m).compileInstructions(t.instructions);
    return new MessageV0({
      header: v,
      staticAccountKeys: _,
      recentBlockhash: t.recentBlockhash,
      compiledInstructions: z,
      addressTableLookups: h
    });
  }
  serialize() {
    const t = Array();
    encodeLength(t, this.staticAccountKeys.length);
    const s = this.serializeInstructions(), h = Array();
    encodeLength(h, this.compiledInstructions.length);
    const m = this.serializeAddressTableLookups(), d = Array();
    encodeLength(d, this.addressTableLookups.length);
    const v = struct([u8("prefix"), struct([u8("numRequiredSignatures"), u8("numReadonlySignedAccounts"), u8("numReadonlyUnsignedAccounts")], "header"), blob(t.length, "staticAccountKeysLength"), seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), blob(h.length, "instructionsLength"), blob(s.length, "serializedInstructions"), blob(d.length, "addressTableLookupsLength"), blob(m.length, "serializedAddressTableLookups")]), _ = new Uint8Array(PACKET_DATA_SIZE), T = 1 << 7, z = v.encode({
      prefix: T,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(t),
      staticAccountKeys: this.staticAccountKeys.map((J) => J.toBytes()),
      recentBlockhash: bs58.decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(h),
      serializedInstructions: s,
      addressTableLookupsLength: new Uint8Array(d),
      serializedAddressTableLookups: m
    }, _);
    return _.slice(0, z);
  }
  serializeInstructions() {
    let t = 0;
    const s = new Uint8Array(PACKET_DATA_SIZE);
    for (const h of this.compiledInstructions) {
      const m = Array();
      encodeLength(m, h.accountKeyIndexes.length);
      const d = Array();
      encodeLength(d, h.data.length);
      const v = struct([u8("programIdIndex"), blob(m.length, "encodedAccountKeyIndexesLength"), seq(u8(), h.accountKeyIndexes.length, "accountKeyIndexes"), blob(d.length, "encodedDataLength"), blob(h.data.length, "data")]);
      t += v.encode({
        programIdIndex: h.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(m),
        accountKeyIndexes: h.accountKeyIndexes,
        encodedDataLength: new Uint8Array(d),
        data: h.data
      }, s, t);
    }
    return s.slice(0, t);
  }
  serializeAddressTableLookups() {
    let t = 0;
    const s = new Uint8Array(PACKET_DATA_SIZE);
    for (const h of this.addressTableLookups) {
      const m = Array();
      encodeLength(m, h.writableIndexes.length);
      const d = Array();
      encodeLength(d, h.readonlyIndexes.length);
      const v = struct([publicKey("accountKey"), blob(m.length, "encodedWritableIndexesLength"), seq(u8(), h.writableIndexes.length, "writableIndexes"), blob(d.length, "encodedReadonlyIndexesLength"), seq(u8(), h.readonlyIndexes.length, "readonlyIndexes")]);
      t += v.encode({
        accountKey: h.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(m),
        writableIndexes: h.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(d),
        readonlyIndexes: h.readonlyIndexes
      }, s, t);
    }
    return s.slice(0, t);
  }
  static deserialize(t) {
    let s = [...t];
    const h = s.shift(), m = h & VERSION_PREFIX_MASK;
    assert(h !== m, "Expected versioned message but received legacy message");
    const d = m;
    assert(d === 0, `Expected versioned message with version 0 but found version ${d}`);
    const v = {
      numRequiredSignatures: s.shift(),
      numReadonlySignedAccounts: s.shift(),
      numReadonlyUnsignedAccounts: s.shift()
    }, _ = [], T = decodeLength(s);
    for (let de = 0; de < T; de++)
      _.push(new PublicKey(s.splice(0, PUBLIC_KEY_LENGTH)));
    const z = bs58.encode(s.splice(0, PUBLIC_KEY_LENGTH)), J = decodeLength(s), Y = [];
    for (let de = 0; de < J; de++) {
      const ce = s.shift(), re = decodeLength(s), oe = s.splice(0, re), pe = decodeLength(s), ae = new Uint8Array(s.splice(0, pe));
      Y.push({
        programIdIndex: ce,
        accountKeyIndexes: oe,
        data: ae
      });
    }
    const ie = decodeLength(s), ne = [];
    for (let de = 0; de < ie; de++) {
      const ce = new PublicKey(s.splice(0, PUBLIC_KEY_LENGTH)), re = decodeLength(s), oe = s.splice(0, re), pe = decodeLength(s), ae = s.splice(0, pe);
      ne.push({
        accountKey: ce,
        writableIndexes: oe,
        readonlyIndexes: ae
      });
    }
    return new MessageV0({
      header: v,
      staticAccountKeys: _,
      recentBlockhash: z,
      compiledInstructions: Y,
      addressTableLookups: ne
    });
  }
}
const VersionedMessage = {
  deserializeMessageVersion(l) {
    const t = l[0], s = t & VERSION_PREFIX_MASK;
    return s === t ? "legacy" : s;
  },
  deserialize: (l) => {
    const t = VersionedMessage.deserializeMessageVersion(l);
    if (t === "legacy")
      return Message.from(l);
    if (t === 0)
      return MessageV0.deserialize(l);
    throw new Error(`Transaction message version ${t} deserialization is not supported`);
  }
};
let TransactionStatus;
(function(l) {
  l[l.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED", l[l.PROCESSED = 1] = "PROCESSED", l[l.TIMED_OUT = 2] = "TIMED_OUT", l[l.NONCE_INVALID = 3] = "NONCE_INVALID";
})(TransactionStatus || (TransactionStatus = {}));
const DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
class TransactionInstruction {
  constructor(t) {
    this.keys = void 0, this.programId = void 0, this.data = buffer.Buffer.alloc(0), this.programId = t.programId, this.keys = t.keys, t.data && (this.data = t.data);
  }
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey: t,
        isSigner: s,
        isWritable: h
      }) => ({
        pubkey: t.toJSON(),
        isSigner: s,
        isWritable: h
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}
class Transaction {
  get signature() {
    return this.signatures.length > 0 ? this.signatures[0].signature : null;
  }
  constructor(t) {
    if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, !!t)
      if (t.feePayer && (this.feePayer = t.feePayer), t.signatures && (this.signatures = t.signatures), Object.prototype.hasOwnProperty.call(t, "nonceInfo")) {
        const {
          minContextSlot: s,
          nonceInfo: h
        } = t;
        this.minNonceContextSlot = s, this.nonceInfo = h;
      } else if (Object.prototype.hasOwnProperty.call(t, "lastValidBlockHeight")) {
        const {
          blockhash: s,
          lastValidBlockHeight: h
        } = t;
        this.recentBlockhash = s, this.lastValidBlockHeight = h;
      } else {
        const {
          recentBlockhash: s,
          nonceInfo: h
        } = t;
        h && (this.nonceInfo = h), this.recentBlockhash = s;
      }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((t) => t.toJSON()),
      signers: this.signatures.map(({
        publicKey: t
      }) => t.toJSON())
    };
  }
  add(...t) {
    if (t.length === 0)
      throw new Error("No instructions");
    return t.forEach((s) => {
      "instructions" in s ? this.instructions = this.instructions.concat(s.instructions) : "data" in s && "programId" in s && "keys" in s ? this.instructions.push(s) : this.instructions.push(new TransactionInstruction(s));
    }), this;
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
      return this._message;
    let t, s;
    if (this.nonceInfo ? (t = this.nonceInfo.nonce, this.instructions[0] != this.nonceInfo.nonceInstruction ? s = [this.nonceInfo.nonceInstruction, ...this.instructions] : s = this.instructions) : (t = this.recentBlockhash, s = this.instructions), !t)
      throw new Error("Transaction recentBlockhash required");
    s.length < 1 && console.warn("No instructions provided");
    let h;
    if (this.feePayer)
      h = this.feePayer;
    else if (this.signatures.length > 0 && this.signatures[0].publicKey)
      h = this.signatures[0].publicKey;
    else
      throw new Error("Transaction fee payer required");
    for (let ce = 0; ce < s.length; ce++)
      if (s[ce].programId === void 0)
        throw new Error(`Transaction instruction index ${ce} has undefined program id`);
    const m = [], d = [];
    s.forEach((ce) => {
      ce.keys.forEach((oe) => {
        d.push({
          ...oe
        });
      });
      const re = ce.programId.toString();
      m.includes(re) || m.push(re);
    }), m.forEach((ce) => {
      d.push({
        pubkey: new PublicKey(ce),
        isSigner: !1,
        isWritable: !1
      });
    });
    const v = [];
    d.forEach((ce) => {
      const re = ce.pubkey.toString(), oe = v.findIndex((pe) => pe.pubkey.toString() === re);
      oe > -1 ? (v[oe].isWritable = v[oe].isWritable || ce.isWritable, v[oe].isSigner = v[oe].isSigner || ce.isSigner) : v.push(ce);
    }), v.sort(function(ce, re) {
      return ce.isSigner !== re.isSigner ? ce.isSigner ? -1 : 1 : ce.isWritable !== re.isWritable ? ce.isWritable ? -1 : 1 : ce.pubkey.toBase58().localeCompare(re.pubkey.toBase58());
    });
    const _ = v.findIndex((ce) => ce.pubkey.equals(h));
    if (_ > -1) {
      const [ce] = v.splice(_, 1);
      ce.isSigner = !0, ce.isWritable = !0, v.unshift(ce);
    } else
      v.unshift({
        pubkey: h,
        isSigner: !0,
        isWritable: !0
      });
    for (const ce of this.signatures) {
      const re = v.findIndex((oe) => oe.pubkey.equals(ce.publicKey));
      if (re > -1)
        v[re].isSigner || (v[re].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
      else
        throw new Error(`unknown signer: ${ce.publicKey.toString()}`);
    }
    let T = 0, z = 0, J = 0;
    const Y = [], ie = [];
    v.forEach(({
      pubkey: ce,
      isSigner: re,
      isWritable: oe
    }) => {
      re ? (Y.push(ce.toString()), T += 1, oe || (z += 1)) : (ie.push(ce.toString()), oe || (J += 1));
    });
    const ne = Y.concat(ie), de = s.map((ce) => {
      const {
        data: re,
        programId: oe
      } = ce;
      return {
        programIdIndex: ne.indexOf(oe.toString()),
        accounts: ce.keys.map((pe) => ne.indexOf(pe.pubkey.toString())),
        data: bs58.encode(re)
      };
    });
    return de.forEach((ce) => {
      assert(ce.programIdIndex >= 0), ce.accounts.forEach((re) => assert(re >= 0));
    }), new Message({
      header: {
        numRequiredSignatures: T,
        numReadonlySignedAccounts: z,
        numReadonlyUnsignedAccounts: J
      },
      accountKeys: ne,
      recentBlockhash: t,
      instructions: de
    });
  }
  _compile() {
    const t = this.compileMessage(), s = t.accountKeys.slice(0, t.header.numRequiredSignatures);
    return this.signatures.length === s.length && this.signatures.every((m, d) => s[d].equals(m.publicKey)) || (this.signatures = s.map((h) => ({
      signature: null,
      publicKey: h
    }))), t;
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(t) {
    return (await t.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...t) {
    if (t.length === 0)
      throw new Error("No signers");
    const s = /* @__PURE__ */ new Set();
    this.signatures = t.filter((h) => {
      const m = h.toString();
      return s.has(m) ? !1 : (s.add(m), !0);
    }).map((h) => ({
      signature: null,
      publicKey: h
    }));
  }
  sign(...t) {
    if (t.length === 0)
      throw new Error("No signers");
    const s = /* @__PURE__ */ new Set(), h = [];
    for (const d of t) {
      const v = d.publicKey.toString();
      s.has(v) || (s.add(v), h.push(d));
    }
    this.signatures = h.map((d) => ({
      signature: null,
      publicKey: d.publicKey
    }));
    const m = this._compile();
    this._partialSign(m, ...h);
  }
  partialSign(...t) {
    if (t.length === 0)
      throw new Error("No signers");
    const s = /* @__PURE__ */ new Set(), h = [];
    for (const d of t) {
      const v = d.publicKey.toString();
      s.has(v) || (s.add(v), h.push(d));
    }
    const m = this._compile();
    this._partialSign(m, ...h);
  }
  _partialSign(t, ...s) {
    const h = t.serialize();
    s.forEach((m) => {
      const d = sign(h, m.secretKey);
      this._addSignature(m.publicKey, toBuffer(d));
    });
  }
  addSignature(t, s) {
    this._compile(), this._addSignature(t, s);
  }
  _addSignature(t, s) {
    assert(s.length === 64);
    const h = this.signatures.findIndex((m) => t.equals(m.publicKey));
    if (h < 0)
      throw new Error(`unknown signer: ${t.toString()}`);
    this.signatures[h].signature = buffer.Buffer.from(s);
  }
  verifySignatures(t) {
    return this._verifySignatures(this.serializeMessage(), t === void 0 ? !0 : t);
  }
  _verifySignatures(t, s) {
    for (const {
      signature: h,
      publicKey: m
    } of this.signatures)
      if (h === null) {
        if (s)
          return !1;
      } else if (!verify(h, t, m.toBytes()))
        return !1;
    return !0;
  }
  serialize(t) {
    const {
      requireAllSignatures: s,
      verifySignatures: h
    } = Object.assign({
      requireAllSignatures: !0,
      verifySignatures: !0
    }, t), m = this.serializeMessage();
    if (h && !this._verifySignatures(m, s))
      throw new Error("Signature verification failed");
    return this._serialize(m);
  }
  _serialize(t) {
    const {
      signatures: s
    } = this, h = [];
    encodeLength(h, s.length);
    const m = h.length + s.length * 64 + t.length, d = buffer.Buffer.alloc(m);
    return assert(s.length < 256), buffer.Buffer.from(h).copy(d, 0), s.forEach(({
      signature: v
    }, _) => {
      v !== null && (assert(v.length === 64, "signature has invalid length"), buffer.Buffer.from(v).copy(d, h.length + _ * 64));
    }), t.copy(d, h.length + s.length * 64), assert(d.length <= PACKET_DATA_SIZE, `Transaction too large: ${d.length} > ${PACKET_DATA_SIZE}`), d;
  }
  get keys() {
    return assert(this.instructions.length === 1), this.instructions[0].keys.map((t) => t.pubkey);
  }
  get programId() {
    return assert(this.instructions.length === 1), this.instructions[0].programId;
  }
  get data() {
    return assert(this.instructions.length === 1), this.instructions[0].data;
  }
  static from(t) {
    let s = [...t];
    const h = decodeLength(s);
    let m = [];
    for (let d = 0; d < h; d++) {
      const v = s.slice(0, SIGNATURE_LENGTH_IN_BYTES);
      s = s.slice(SIGNATURE_LENGTH_IN_BYTES), m.push(bs58.encode(buffer.Buffer.from(v)));
    }
    return Transaction.populate(Message.from(s), m);
  }
  static populate(t, s = []) {
    const h = new Transaction();
    return h.recentBlockhash = t.recentBlockhash, t.header.numRequiredSignatures > 0 && (h.feePayer = t.accountKeys[0]), s.forEach((m, d) => {
      const v = {
        signature: m == bs58.encode(DEFAULT_SIGNATURE) ? null : bs58.decode(m),
        publicKey: t.accountKeys[d]
      };
      h.signatures.push(v);
    }), t.instructions.forEach((m) => {
      const d = m.accounts.map((v) => {
        const _ = t.accountKeys[v];
        return {
          pubkey: _,
          isSigner: h.signatures.some((T) => T.publicKey.toString() === _.toString()) || t.isAccountSigner(v),
          isWritable: t.isAccountWritable(v)
        };
      });
      h.instructions.push(new TransactionInstruction({
        keys: d,
        programId: t.accountKeys[m.programIdIndex],
        data: bs58.decode(m.data)
      }));
    }), h._message = t, h._json = h.toJSON(), h;
  }
}
class TransactionMessage {
  constructor(t) {
    this.payerKey = void 0, this.instructions = void 0, this.recentBlockhash = void 0, this.payerKey = t.payerKey, this.instructions = t.instructions, this.recentBlockhash = t.recentBlockhash;
  }
  static decompile(t, s) {
    const {
      header: h,
      compiledInstructions: m,
      recentBlockhash: d
    } = t, {
      numRequiredSignatures: v,
      numReadonlySignedAccounts: _,
      numReadonlyUnsignedAccounts: T
    } = h, z = v - _;
    assert(z > 0, "Message header is invalid");
    const J = t.staticAccountKeys.length - v - T;
    assert(J >= 0, "Message header is invalid");
    const Y = t.getAccountKeys(s), ie = Y.get(0);
    if (ie === void 0)
      throw new Error("Failed to decompile message because no account keys were found");
    const ne = [];
    for (const de of m) {
      const ce = [];
      for (const oe of de.accountKeyIndexes) {
        const pe = Y.get(oe);
        if (pe === void 0)
          throw new Error(`Failed to find key for account key index ${oe}`);
        const ae = oe < v;
        let me;
        ae ? me = oe < z : oe < Y.staticAccountKeys.length ? me = oe - v < J : me = oe - Y.staticAccountKeys.length < Y.accountKeysFromLookups.writable.length, ce.push({
          pubkey: pe,
          isSigner: oe < h.numRequiredSignatures,
          isWritable: me
        });
      }
      const re = Y.get(de.programIdIndex);
      if (re === void 0)
        throw new Error(`Failed to find program id for program id index ${de.programIdIndex}`);
      ne.push(new TransactionInstruction({
        programId: re,
        data: toBuffer(de.data),
        keys: ce
      }));
    }
    return new TransactionMessage({
      payerKey: ie,
      instructions: ne,
      recentBlockhash: d
    });
  }
  compileToLegacyMessage() {
    return Message.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions
    });
  }
  compileToV0Message(t) {
    return MessageV0.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
      addressLookupTableAccounts: t
    });
  }
}
class VersionedTransaction {
  get version() {
    return this.message.version;
  }
  constructor(t, s) {
    if (this.signatures = void 0, this.message = void 0, s !== void 0)
      assert(s.length === t.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = s;
    else {
      const h = [];
      for (let m = 0; m < t.header.numRequiredSignatures; m++)
        h.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      this.signatures = h;
    }
    this.message = t;
  }
  serialize() {
    const t = this.message.serialize(), s = Array();
    encodeLength(s, this.signatures.length);
    const h = struct([blob(s.length, "encodedSignaturesLength"), seq(signature(), this.signatures.length, "signatures"), blob(t.length, "serializedMessage")]), m = new Uint8Array(2048), d = h.encode({
      encodedSignaturesLength: new Uint8Array(s),
      signatures: this.signatures,
      serializedMessage: t
    }, m);
    return m.slice(0, d);
  }
  static deserialize(t) {
    let s = [...t];
    const h = [], m = decodeLength(s);
    for (let v = 0; v < m; v++)
      h.push(new Uint8Array(s.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
    const d = VersionedMessage.deserialize(new Uint8Array(s));
    return new VersionedTransaction(d, h);
  }
  sign(t) {
    const s = this.message.serialize(), h = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const m of t) {
      const d = h.findIndex((v) => v.equals(m.publicKey));
      assert(d >= 0, `Cannot sign with non signer key ${m.publicKey.toBase58()}`), this.signatures[d] = sign(s, m.secretKey);
    }
  }
  addSignature(t, s) {
    assert(s.byteLength === 64, "Signature must be 64 bytes long");
    const m = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex((d) => d.equals(t));
    assert(m >= 0, `Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`), this.signatures[m] = s;
  }
}
const SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111"), SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111"), SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111"), SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111"), SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111"), SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111"), SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111"), SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111"), SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
async function sendAndConfirmTransaction(l, t, s, h) {
  const m = h && {
    skipPreflight: h.skipPreflight,
    preflightCommitment: h.preflightCommitment || h.commitment,
    maxRetries: h.maxRetries,
    minContextSlot: h.minContextSlot
  }, d = await l.sendTransaction(t, s, m);
  let v;
  if (t.recentBlockhash != null && t.lastValidBlockHeight != null)
    v = (await l.confirmTransaction({
      abortSignal: h == null ? void 0 : h.abortSignal,
      signature: d,
      blockhash: t.recentBlockhash,
      lastValidBlockHeight: t.lastValidBlockHeight
    }, h && h.commitment)).value;
  else if (t.minNonceContextSlot != null && t.nonceInfo != null) {
    const {
      nonceInstruction: _
    } = t.nonceInfo, T = _.keys[0].pubkey;
    v = (await l.confirmTransaction({
      abortSignal: h == null ? void 0 : h.abortSignal,
      minContextSlot: t.minNonceContextSlot,
      nonceAccountPubkey: T,
      nonceValue: t.nonceInfo.nonce,
      signature: d
    }, h && h.commitment)).value;
  } else
    (h == null ? void 0 : h.abortSignal) != null && console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."), v = (await l.confirmTransaction(d, h && h.commitment)).value;
  if (v.err)
    throw new Error(`Transaction ${d} failed (${JSON.stringify(v)})`);
  return d;
}
function sleep(l) {
  return new Promise((t) => setTimeout(t, l));
}
function encodeData(l, t) {
  const s = l.layout.span >= 0 ? l.layout.span : getAlloc(l, t), h = buffer.Buffer.alloc(s), m = Object.assign({
    instruction: l.index
  }, t);
  return l.layout.encode(m, h), h;
}
function decodeData$1(l, t) {
  let s;
  try {
    s = l.layout.decode(t);
  } catch (h) {
    throw new Error("invalid instruction; " + h);
  }
  if (s.instruction !== l.index)
    throw new Error(`invalid instruction; instruction index mismatch ${s.instruction} != ${l.index}`);
  return s;
}
const FeeCalculatorLayout = nu64("lamportsPerSignature"), NonceAccountLayout = struct([u32("version"), u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), struct([FeeCalculatorLayout], "feeCalculator")]), NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
class NonceAccount {
  constructor(t) {
    this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = t.authorizedPubkey, this.nonce = t.nonce, this.feeCalculator = t.feeCalculator;
  }
  static fromAccountData(t) {
    const s = NonceAccountLayout.decode(toBuffer(t), 0);
    return new NonceAccount({
      authorizedPubkey: new PublicKey(s.authorizedPubkey),
      nonce: new PublicKey(s.nonce).toString(),
      feeCalculator: s.feeCalculator
    });
  }
}
const encodeDecode = (l) => {
  const t = l.decode.bind(l), s = l.encode.bind(l);
  return {
    decode: t,
    encode: s
  };
}, bigInt = (l) => (t) => {
  const s = blob(l, t), {
    encode: h,
    decode: m
  } = encodeDecode(s), d = s;
  return d.decode = (v, _) => {
    const T = m(v, _);
    return toBigIntLE_1(buffer.Buffer.from(T));
  }, d.encode = (v, _, T) => {
    const z = toBufferLE_1(v, l);
    return h(z, _, T);
  }, d;
}, u64 = bigInt(8);
class SystemInstruction {
  constructor() {
  }
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const h = u32("instruction").decode(t.data);
    let m;
    for (const [d, v] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS))
      if (v.index == h) {
        m = d;
        break;
      }
    if (!m)
      throw new Error("Instruction type incorrect; not a SystemInstruction");
    return m;
  }
  static decodeCreateAccount(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const {
      lamports: s,
      space: h,
      programId: m
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      newAccountPubkey: t.keys[1].pubkey,
      lamports: s,
      space: h,
      programId: new PublicKey(m)
    };
  }
  static decodeTransfer(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const {
      lamports: s
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      toPubkey: t.keys[1].pubkey,
      lamports: s
    };
  }
  static decodeTransferWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const {
      lamports: s,
      seed: h,
      programId: m
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      basePubkey: t.keys[1].pubkey,
      toPubkey: t.keys[2].pubkey,
      lamports: s,
      seed: h,
      programId: new PublicKey(m)
    };
  }
  static decodeAllocate(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const {
      space: s
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, t.data);
    return {
      accountPubkey: t.keys[0].pubkey,
      space: s
    };
  }
  static decodeAllocateWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const {
      base: s,
      seed: h,
      space: m,
      programId: d
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, t.data);
    return {
      accountPubkey: t.keys[0].pubkey,
      basePubkey: new PublicKey(s),
      seed: h,
      space: m,
      programId: new PublicKey(d)
    };
  }
  static decodeAssign(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const {
      programId: s
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, t.data);
    return {
      accountPubkey: t.keys[0].pubkey,
      programId: new PublicKey(s)
    };
  }
  static decodeAssignWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const {
      base: s,
      seed: h,
      programId: m
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, t.data);
    return {
      accountPubkey: t.keys[0].pubkey,
      basePubkey: new PublicKey(s),
      seed: h,
      programId: new PublicKey(m)
    };
  }
  static decodeCreateWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const {
      base: s,
      seed: h,
      lamports: m,
      space: d,
      programId: v
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      newAccountPubkey: t.keys[1].pubkey,
      basePubkey: new PublicKey(s),
      seed: h,
      lamports: m,
      space: d,
      programId: new PublicKey(v)
    };
  }
  static decodeNonceInitialize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const {
      authorized: s
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, t.data);
    return {
      noncePubkey: t.keys[0].pubkey,
      authorizedPubkey: new PublicKey(s)
    };
  }
  static decodeNonceAdvance(t) {
    return this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3), decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, t.data), {
      noncePubkey: t.keys[0].pubkey,
      authorizedPubkey: t.keys[2].pubkey
    };
  }
  static decodeNonceWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
    const {
      lamports: s
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, t.data);
    return {
      noncePubkey: t.keys[0].pubkey,
      toPubkey: t.keys[1].pubkey,
      authorizedPubkey: t.keys[4].pubkey,
      lamports: s
    };
  }
  static decodeNonceAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const {
      authorized: s
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, t.data);
    return {
      noncePubkey: t.keys[0].pubkey,
      authorizedPubkey: t.keys[1].pubkey,
      newAuthorizedPubkey: new PublicKey(s)
    };
  }
  static checkProgramId(t) {
    if (!t.equals(SystemProgram.programId))
      throw new Error("invalid instruction; programId is not SystemProgram");
  }
  static checkKeyLength(t, s) {
    if (t.length < s)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${s}`);
  }
}
const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: struct([u32("instruction"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: struct([u32("instruction"), u64("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: struct([u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: struct([u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: struct([u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: struct([u32("instruction"), ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: struct([u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: struct([u32("instruction")])
  }
});
class SystemProgram {
  constructor() {
  }
  static createAccount(t) {
    const s = SYSTEM_INSTRUCTION_LAYOUTS.Create, h = encodeData(s, {
      lamports: t.lamports,
      space: t.space,
      programId: toBuffer(t.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: t.fromPubkey,
        isSigner: !0,
        isWritable: !0
      }, {
        pubkey: t.newAccountPubkey,
        isSigner: !0,
        isWritable: !0
      }],
      programId: this.programId,
      data: h
    });
  }
  static transfer(t) {
    let s, h;
    if ("basePubkey" in t) {
      const m = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      s = encodeData(m, {
        lamports: BigInt(t.lamports),
        seed: t.seed,
        programId: toBuffer(t.programId.toBuffer())
      }), h = [{
        pubkey: t.fromPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: t.basePubkey,
        isSigner: !0,
        isWritable: !1
      }, {
        pubkey: t.toPubkey,
        isSigner: !1,
        isWritable: !0
      }];
    } else {
      const m = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      s = encodeData(m, {
        lamports: BigInt(t.lamports)
      }), h = [{
        pubkey: t.fromPubkey,
        isSigner: !0,
        isWritable: !0
      }, {
        pubkey: t.toPubkey,
        isSigner: !1,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: h,
      programId: this.programId,
      data: s
    });
  }
  static assign(t) {
    let s, h;
    if ("basePubkey" in t) {
      const m = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      s = encodeData(m, {
        base: toBuffer(t.basePubkey.toBuffer()),
        seed: t.seed,
        programId: toBuffer(t.programId.toBuffer())
      }), h = [{
        pubkey: t.accountPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: t.basePubkey,
        isSigner: !0,
        isWritable: !1
      }];
    } else {
      const m = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      s = encodeData(m, {
        programId: toBuffer(t.programId.toBuffer())
      }), h = [{
        pubkey: t.accountPubkey,
        isSigner: !0,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: h,
      programId: this.programId,
      data: s
    });
  }
  static createAccountWithSeed(t) {
    const s = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, h = encodeData(s, {
      base: toBuffer(t.basePubkey.toBuffer()),
      seed: t.seed,
      lamports: t.lamports,
      space: t.space,
      programId: toBuffer(t.programId.toBuffer())
    });
    let m = [{
      pubkey: t.fromPubkey,
      isSigner: !0,
      isWritable: !0
    }, {
      pubkey: t.newAccountPubkey,
      isSigner: !1,
      isWritable: !0
    }];
    return t.basePubkey != t.fromPubkey && m.push({
      pubkey: t.basePubkey,
      isSigner: !0,
      isWritable: !1
    }), new TransactionInstruction({
      keys: m,
      programId: this.programId,
      data: h
    });
  }
  static createNonceAccount(t) {
    const s = new Transaction();
    "basePubkey" in t && "seed" in t ? s.add(SystemProgram.createAccountWithSeed({
      fromPubkey: t.fromPubkey,
      newAccountPubkey: t.noncePubkey,
      basePubkey: t.basePubkey,
      seed: t.seed,
      lamports: t.lamports,
      space: NONCE_ACCOUNT_LENGTH,
      programId: this.programId
    })) : s.add(SystemProgram.createAccount({
      fromPubkey: t.fromPubkey,
      newAccountPubkey: t.noncePubkey,
      lamports: t.lamports,
      space: NONCE_ACCOUNT_LENGTH,
      programId: this.programId
    }));
    const h = {
      noncePubkey: t.noncePubkey,
      authorizedPubkey: t.authorizedPubkey
    };
    return s.add(this.nonceInitialize(h)), s;
  }
  static nonceInitialize(t) {
    const s = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, h = encodeData(s, {
      authorized: toBuffer(t.authorizedPubkey.toBuffer())
    }), m = {
      keys: [{
        pubkey: t.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }],
      programId: this.programId,
      data: h
    };
    return new TransactionInstruction(m);
  }
  static nonceAdvance(t) {
    const s = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, h = encodeData(s), m = {
      keys: [{
        pubkey: t.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: t.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: h
    };
    return new TransactionInstruction(m);
  }
  static nonceWithdraw(t) {
    const s = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, h = encodeData(s, {
      lamports: t.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: t.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: t.toPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: t.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: h
    });
  }
  static nonceAuthorize(t) {
    const s = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, h = encodeData(s, {
      authorized: toBuffer(t.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: t.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: t.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: h
    });
  }
  static allocate(t) {
    let s, h;
    if ("basePubkey" in t) {
      const m = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      s = encodeData(m, {
        base: toBuffer(t.basePubkey.toBuffer()),
        seed: t.seed,
        space: t.space,
        programId: toBuffer(t.programId.toBuffer())
      }), h = [{
        pubkey: t.accountPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: t.basePubkey,
        isSigner: !0,
        isWritable: !1
      }];
    } else {
      const m = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      s = encodeData(m, {
        space: t.space
      }), h = [{
        pubkey: t.accountPubkey,
        isSigner: !0,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: h,
      programId: this.programId,
      data: s
    });
  }
}
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
const CHUNK_SIZE = PACKET_DATA_SIZE - 300;
class Loader {
  constructor() {
  }
  static getMinNumSignatures(t) {
    return 2 * (Math.ceil(t / Loader.chunkSize) + 1 + 1);
  }
  static async load(t, s, h, m, d) {
    {
      const Y = await t.getMinimumBalanceForRentExemption(d.length), ie = await t.getAccountInfo(h.publicKey, "confirmed");
      let ne = null;
      if (ie !== null) {
        if (ie.executable)
          return console.error("Program load failed, account is already executable"), !1;
        ie.data.length !== d.length && (ne = ne || new Transaction(), ne.add(SystemProgram.allocate({
          accountPubkey: h.publicKey,
          space: d.length
        }))), ie.owner.equals(m) || (ne = ne || new Transaction(), ne.add(SystemProgram.assign({
          accountPubkey: h.publicKey,
          programId: m
        }))), ie.lamports < Y && (ne = ne || new Transaction(), ne.add(SystemProgram.transfer({
          fromPubkey: s.publicKey,
          toPubkey: h.publicKey,
          lamports: Y - ie.lamports
        })));
      } else
        ne = new Transaction().add(SystemProgram.createAccount({
          fromPubkey: s.publicKey,
          newAccountPubkey: h.publicKey,
          lamports: Y > 0 ? Y : 1,
          space: d.length,
          programId: m
        }));
      ne !== null && await sendAndConfirmTransaction(t, ne, [s, h], {
        commitment: "confirmed"
      });
    }
    const v = struct([u32("instruction"), u32("offset"), u32("bytesLength"), u32("bytesLengthPadding"), seq(u8("byte"), offset(u32(), -8), "bytes")]), _ = Loader.chunkSize;
    let T = 0, z = d, J = [];
    for (; z.length > 0; ) {
      const Y = z.slice(0, _), ie = buffer.Buffer.alloc(_ + 16);
      v.encode({
        instruction: 0,
        offset: T,
        bytes: Y,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, ie);
      const ne = new Transaction().add({
        keys: [{
          pubkey: h.publicKey,
          isSigner: !0,
          isWritable: !0
        }],
        programId: m,
        data: ie
      });
      J.push(sendAndConfirmTransaction(t, ne, [s, h], {
        commitment: "confirmed"
      })), t._rpcEndpoint.includes("solana.com") && await sleep(1e3 / 4), T += _, z = z.slice(_);
    }
    await Promise.all(J);
    {
      const Y = struct([u32("instruction")]), ie = buffer.Buffer.alloc(Y.span);
      Y.encode({
        instruction: 1
      }, ie);
      const ne = new Transaction().add({
        keys: [{
          pubkey: h.publicKey,
          isSigner: !0,
          isWritable: !0
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: !1,
          isWritable: !1
        }],
        programId: m,
        data: ie
      });
      await sendAndConfirmTransaction(t, ne, [s, h], {
        commitment: "confirmed"
      });
    }
    return !0;
  }
}
Loader.chunkSize = CHUNK_SIZE;
const BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
class BpfLoader {
  static getMinNumSignatures(t) {
    return Loader.getMinNumSignatures(t);
  }
  static load(t, s, h, m, d) {
    return Loader.load(t, s, h, d, m);
  }
}
var objToString = Object.prototype.toString, objKeys = Object.keys || function(l) {
  var t = [];
  for (var s in l)
    t.push(s);
  return t;
};
function stringify(l, t) {
  var s, h, m, d, v, _, T;
  if (l === !0)
    return "true";
  if (l === !1)
    return "false";
  switch (typeof l) {
    case "object":
      if (l === null)
        return null;
      if (l.toJSON && typeof l.toJSON == "function")
        return stringify(l.toJSON(), t);
      if (T = objToString.call(l), T === "[object Array]") {
        for (m = "[", h = l.length - 1, s = 0; s < h; s++)
          m += stringify(l[s], !0) + ",";
        return h > -1 && (m += stringify(l[s], !0)), m + "]";
      } else if (T === "[object Object]") {
        for (d = objKeys(l).sort(), h = d.length, m = "", s = 0; s < h; )
          v = d[s], _ = stringify(l[v], !1), _ !== void 0 && (m && (m += ","), m += JSON.stringify(v) + ":" + _), s++;
        return "{" + m + "}";
      } else
        return JSON.stringify(l);
    case "function":
    case "undefined":
      return t ? null : void 0;
    case "string":
      return JSON.stringify(l);
    default:
      return isFinite(l) ? l : null;
  }
}
var fastStableStringify = function(l) {
  var t = stringify(l, !1);
  if (t !== void 0)
    return "" + t;
}, fastStableStringify$1 = fastStableStringify;
const MINIMUM_SLOT_PER_EPOCH = 32;
function trailingZeros(l) {
  let t = 0;
  for (; l > 1; )
    l /= 2, t++;
  return t;
}
function nextPowerOfTwo(l) {
  return l === 0 ? 1 : (l--, l |= l >> 1, l |= l >> 2, l |= l >> 4, l |= l >> 8, l |= l >> 16, l |= l >> 32, l + 1);
}
class EpochSchedule {
  constructor(t, s, h, m, d) {
    this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = t, this.leaderScheduleSlotOffset = s, this.warmup = h, this.firstNormalEpoch = m, this.firstNormalSlot = d;
  }
  getEpoch(t) {
    return this.getEpochAndSlotIndex(t)[0];
  }
  getEpochAndSlotIndex(t) {
    if (t < this.firstNormalSlot) {
      const s = trailingZeros(nextPowerOfTwo(t + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1, h = this.getSlotsInEpoch(s), m = t - (h - MINIMUM_SLOT_PER_EPOCH);
      return [s, m];
    } else {
      const s = t - this.firstNormalSlot, h = Math.floor(s / this.slotsPerEpoch), m = this.firstNormalEpoch + h, d = s % this.slotsPerEpoch;
      return [m, d];
    }
  }
  getFirstSlotInEpoch(t) {
    return t <= this.firstNormalEpoch ? (Math.pow(2, t) - 1) * MINIMUM_SLOT_PER_EPOCH : (t - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
  }
  getLastSlotInEpoch(t) {
    return this.getFirstSlotInEpoch(t) + this.getSlotsInEpoch(t) - 1;
  }
  getSlotsInEpoch(t) {
    return t < this.firstNormalEpoch ? Math.pow(2, t + trailingZeros(MINIMUM_SLOT_PER_EPOCH)) : this.slotsPerEpoch;
  }
}
class SendTransactionError extends Error {
  constructor(t, s) {
    super(t), this.logs = void 0, this.logs = s;
  }
}
const SolanaJSONRPCErrorCode = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
class SolanaJSONRPCError extends Error {
  constructor({
    code: t,
    message: s,
    data: h
  }, m) {
    super(m != null ? `${m}: ${s}` : s), this.code = void 0, this.data = void 0, this.code = t, this.data = h, this.name = "SolanaJSONRPCError";
  }
}
var fetchImpl = globalThis.fetch;
const NUM_TICKS_PER_SECOND = 160, DEFAULT_TICKS_PER_SLOT = 64, NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT, MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
function decodeData(l, t) {
  let s;
  try {
    s = l.layout.decode(t);
  } catch (h) {
    throw new Error("invalid instruction; " + h);
  }
  if (s.typeIndex !== l.index)
    throw new Error(`invalid account data; account type mismatch ${s.typeIndex} != ${l.index}`);
  return s;
}
const LOOKUP_TABLE_META_SIZE = 56;
class AddressLookupTableAccount {
  constructor(t) {
    this.key = void 0, this.state = void 0, this.key = t.key, this.state = t.state;
  }
  isActive() {
    const t = BigInt("0xffffffffffffffff");
    return this.state.deactivationSlot === t;
  }
  static deserialize(t) {
    const s = decodeData(LookupTableMetaLayout, t), h = t.length - LOOKUP_TABLE_META_SIZE;
    assert(h >= 0, "lookup table is invalid"), assert(h % 32 === 0, "lookup table is invalid");
    const m = h / 32, {
      addresses: d
    } = struct([seq(publicKey(), m, "addresses")]).decode(t.slice(LOOKUP_TABLE_META_SIZE));
    return {
      deactivationSlot: s.deactivationSlot,
      lastExtendedSlot: s.lastExtendedSlot,
      lastExtendedSlotStartIndex: s.lastExtendedStartIndex,
      authority: s.authority.length !== 0 ? new PublicKey(s.authority[0]) : void 0,
      addresses: d.map((v) => new PublicKey(v))
    };
  }
}
const LookupTableMetaLayout = {
  index: 1,
  layout: struct([
    u32("typeIndex"),
    u64("deactivationSlot"),
    nu64("lastExtendedSlot"),
    u8("lastExtendedStartIndex"),
    u8(),
    seq(publicKey(), offset(u8(), -1), "authority")
  ])
}, URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(l) {
  const t = l.match(URL_RE);
  if (t == null)
    throw TypeError(`Failed to validate endpoint URL \`${l}\``);
  const [
    s,
    h,
    m,
    d
  ] = t, v = l.startsWith("https:") ? "wss:" : "ws:", _ = m == null ? null : parseInt(m.slice(1), 10), T = _ == null ? "" : `:${_ + 1}`;
  return `${v}//${h}${T}${d}`;
}
var _process$env$npm_pack;
const PublicKeyFromString = coerce(instance(PublicKey), string(), (l) => new PublicKey(l)), RawAccountDataResult = tuple([string(), literal("base64")]), BufferFromRawAccountData = coerce(instance(buffer.Buffer), RawAccountDataResult, (l) => buffer.Buffer.from(l[0], "base64")), BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
function assertEndpointUrl(l) {
  if (/^https?:/.test(l) === !1)
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  return l;
}
function extractCommitmentFromConfig(l) {
  let t, s;
  if (typeof l == "string")
    t = l;
  else if (l) {
    const {
      commitment: h,
      ...m
    } = l;
    t = h, s = m;
  }
  return {
    commitment: t,
    config: s
  };
}
function createRpcResult(l) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result: l
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
const UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(l) {
  return coerce(createRpcResult(l), UnknownRpcResult, (t) => "error" in t ? t : {
    ...t,
    result: create(t.result, l)
  });
}
function jsonRpcResultAndContext(l) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value: l
  }));
}
function notificationResultAndContext(l) {
  return type({
    context: type({
      slot: number()
    }),
    value: l
  });
}
function versionedMessageFromResponse(l, t) {
  return l === 0 ? new MessageV0({
    header: t.header,
    staticAccountKeys: t.accountKeys.map((s) => new PublicKey(s)),
    recentBlockhash: t.recentBlockhash,
    compiledInstructions: t.instructions.map((s) => ({
      programIdIndex: s.programIdIndex,
      accountKeyIndexes: s.accounts,
      data: bs58.decode(s.data)
    })),
    addressTableLookups: t.addressTableLookups
  }) : new Message(t);
}
const GetInflationGovernorResult = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
}), GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
})))), GetInflationRateResult = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
}), GetEpochInfoResult = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
}), GetEpochScheduleResult = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
}), GetLeaderScheduleResult = record(string(), array(number())), TransactionErrorResult = nullable(union([type({}), string()])), SignatureStatusResult = type({
  err: TransactionErrorResult
}), SignatureReceivedResult = literal("receivedSignature"), VersionResult = type({
  "solana-core": string(),
  "feature-set": optional(number())
}), SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  })))
})), BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));
function createRpcClient(l, t, s, h, m, d) {
  const v = s || fetchImpl;
  let _;
  d != null && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
  let T;
  return h && (T = async (J, Y) => {
    const ie = await new Promise((ne, de) => {
      try {
        h(J, Y, (ce, re) => ne([ce, re]));
      } catch (ce) {
        de(ce);
      }
    });
    return await v(...ie);
  }), new browser(async (J, Y) => {
    const ie = {
      method: "POST",
      body: J,
      agent: _,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, t || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let ne = 5, de, ce = 500;
      for (; T ? de = await T(l, ie) : de = await v(l, ie), !(de.status !== 429 || m === !0 || (ne -= 1, ne === 0)); )
        console.log(`Server responded with ${de.status} ${de.statusText}.  Retrying after ${ce}ms delay...`), await sleep(ce), ce *= 2;
      const re = await de.text();
      de.ok ? Y(null, re) : Y(new Error(`${de.status} ${de.statusText}: ${re}`));
    } catch (ne) {
      ne instanceof Error && Y(ne);
    }
  }, {});
}
function createRpcRequest(l) {
  return (t, s) => new Promise((h, m) => {
    l.request(t, s, (d, v) => {
      if (d) {
        m(d);
        return;
      }
      h(v);
    });
  });
}
function createRpcBatchRequest(l) {
  return (t) => new Promise((s, h) => {
    t.length === 0 && s([]);
    const m = t.map((d) => l.request(d.methodName, d.args));
    l.request(m, (d, v) => {
      if (d) {
        h(d);
        return;
      }
      s(v);
    });
  });
}
const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult), GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult), GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult), GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult), GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult), SlotRpcResult = jsonRpcResult(number()), GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString)
})), TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
}), GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
}))), GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  })
}))), ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number()
}), GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedAccountDataResult,
    rentEpoch: number()
  })
}))), GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number(),
  address: PublicKeyFromString
}))), AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: BufferFromRawAccountData,
  rentEpoch: number()
}), KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
}), ParsedOrRawAccountData = coerce(union([instance(buffer.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (l) => Array.isArray(l) ? create(l, BufferFromRawAccountData) : l), ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: ParsedOrRawAccountData,
  rentEpoch: number()
}), KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
}), StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
}), GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
}))), GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
}))), AccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(AccountInfoResult)
}), ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
}), ProgramAccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
}), SlotInfoResult = type({
  parent: number(),
  slot: number(),
  root: number()
}), SlotNotificationResult = type({
  subscription: number(),
  result: SlotInfoResult
}), SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]), SlotUpdateNotificationResult = type({
  subscription: number(),
  result: SlotUpdateResult
}), SignatureNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
}), RootNotificationResult = type({
  subscription: number(),
  result: number()
}), ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
}), VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
}), GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
})), ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]), SignatureStatusResponse = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
}), GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse))), GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number()), AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
}), ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
}), AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
}), ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
}), ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
}), RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
}), InstructionResult = union([RawInstructionResult, ParsedInstructionResult]), UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]), ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (l) => "accounts" in l ? create(l, RawInstructionResult) : create(l, ParsedInstructionResult)), ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
}), TokenBalanceResult = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  uiTokenAmount: TokenAmountResult
}), LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
}), ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
}), ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
}), TransactionVersionStruct = union([literal(0), literal("legacy")]), RewardsResult = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
}), GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number())
}))), GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
}))), GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  meta: ConfirmedTransactionMetaResult,
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
}))), GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct)
}))), GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})), GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number()
})), PerfSampleResult = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
}), GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult)), GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
}))), RequestAirdropRpcResult = jsonRpcResult(string()), SendTransactionRpcResult = jsonRpcResult(string()), LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
}), LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number()
}), COMMON_HTTP_HEADERS = {
  "solana-client": `js/${(_process$env$npm_pack = "0.0.0-development") !== null && _process$env$npm_pack !== void 0 ? _process$env$npm_pack : "UNKNOWN"}`
};
class Connection {
  constructor(t, s) {
    this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionHashByClientSubscriptionId = {}, this._subscriptionStateChangeCallbacksByHash = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
    let h, m, d, v, _, T;
    s && typeof s == "string" ? this._commitment = s : s && (this._commitment = s.commitment, this._confirmTransactionInitialTimeout = s.confirmTransactionInitialTimeout, h = s.wsEndpoint, m = s.httpHeaders, d = s.fetch, v = s.fetchMiddleware, _ = s.disableRetryOnRateLimit, T = s.httpAgent), this._rpcEndpoint = assertEndpointUrl(t), this._rpcWsEndpoint = h || makeWebsocketUrl(t), this._rpcClient = createRpcClient(t, m, d, v, _, T), this._rpcRequest = createRpcRequest(this._rpcClient), this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient), this._rpcWebSocket = new Client_1(this._rpcWsEndpoint, {
      autoconnect: !1,
      max_reconnects: 1 / 0
    }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
  }
  get commitment() {
    return this._commitment;
  }
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  async getBalanceAndContext(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = this._buildArgs(
      [t.toBase58()],
      h,
      void 0,
      m
    ), v = await this._rpcRequest("getBalance", d), _ = create(v, jsonRpcResultAndContext(number()));
    if ("error" in _)
      throw new SolanaJSONRPCError(_.error, `failed to get balance for ${t.toBase58()}`);
    return _.result;
  }
  async getBalance(t, s) {
    return await this.getBalanceAndContext(t, s).then((h) => h.value).catch((h) => {
      throw new Error("failed to get balance of account " + t.toBase58() + ": " + h);
    });
  }
  async getBlockTime(t) {
    const s = await this._rpcRequest("getBlockTime", [t]), h = create(s, jsonRpcResult(nullable(number())));
    if ("error" in h)
      throw new SolanaJSONRPCError(h.error, `failed to get block time for slot ${t}`);
    return h.result;
  }
  async getMinimumLedgerSlot() {
    const t = await this._rpcRequest("minimumLedgerSlot", []), s = create(t, jsonRpcResult(number()));
    if ("error" in s)
      throw new SolanaJSONRPCError(s.error, "failed to get minimum ledger slot");
    return s.result;
  }
  async getFirstAvailableBlock() {
    const t = await this._rpcRequest("getFirstAvailableBlock", []), s = create(t, SlotRpcResult);
    if ("error" in s)
      throw new SolanaJSONRPCError(s.error, "failed to get first available block");
    return s.result;
  }
  async getSupply(t) {
    let s = {};
    typeof t == "string" ? s = {
      commitment: t
    } : t ? s = {
      ...t,
      commitment: t && t.commitment || this.commitment
    } : s = {
      commitment: this.commitment
    };
    const h = await this._rpcRequest("getSupply", [s]), m = create(h, GetSupplyRpcResult);
    if ("error" in m)
      throw new SolanaJSONRPCError(m.error, "failed to get supply");
    return m.result;
  }
  async getTokenSupply(t, s) {
    const h = this._buildArgs([t.toBase58()], s), m = await this._rpcRequest("getTokenSupply", h), d = create(m, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get token supply");
    return d.result;
  }
  async getTokenAccountBalance(t, s) {
    const h = this._buildArgs([t.toBase58()], s), m = await this._rpcRequest("getTokenAccountBalance", h), d = create(m, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get token account balance");
    return d.result;
  }
  async getTokenAccountsByOwner(t, s, h) {
    const {
      commitment: m,
      config: d
    } = extractCommitmentFromConfig(h);
    let v = [t.toBase58()];
    "mint" in s ? v.push({
      mint: s.mint.toBase58()
    }) : v.push({
      programId: s.programId.toBase58()
    });
    const _ = this._buildArgs(v, m, "base64", d), T = await this._rpcRequest("getTokenAccountsByOwner", _), z = create(T, GetTokenAccountsByOwner);
    if ("error" in z)
      throw new SolanaJSONRPCError(z.error, `failed to get token accounts owned by account ${t.toBase58()}`);
    return z.result;
  }
  async getParsedTokenAccountsByOwner(t, s, h) {
    let m = [t.toBase58()];
    "mint" in s ? m.push({
      mint: s.mint.toBase58()
    }) : m.push({
      programId: s.programId.toBase58()
    });
    const d = this._buildArgs(m, h, "jsonParsed"), v = await this._rpcRequest("getTokenAccountsByOwner", d), _ = create(v, GetParsedTokenAccountsByOwner);
    if ("error" in _)
      throw new SolanaJSONRPCError(_.error, `failed to get token accounts owned by account ${t.toBase58()}`);
    return _.result;
  }
  async getLargestAccounts(t) {
    const s = {
      ...t,
      commitment: t && t.commitment || this.commitment
    }, h = s.filter || s.commitment ? [s] : [], m = await this._rpcRequest("getLargestAccounts", h), d = create(m, GetLargestAccountsRpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get largest accounts");
    return d.result;
  }
  async getTokenLargestAccounts(t, s) {
    const h = this._buildArgs([t.toBase58()], s), m = await this._rpcRequest("getTokenLargestAccounts", h), d = create(m, GetTokenLargestAccountsResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get token largest accounts");
    return d.result;
  }
  async getAccountInfoAndContext(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = this._buildArgs([t.toBase58()], h, "base64", m), v = await this._rpcRequest("getAccountInfo", d), _ = create(v, jsonRpcResultAndContext(nullable(AccountInfoResult)));
    if ("error" in _)
      throw new SolanaJSONRPCError(_.error, `failed to get info about account ${t.toBase58()}`);
    return _.result;
  }
  async getParsedAccountInfo(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = this._buildArgs([t.toBase58()], h, "jsonParsed", m), v = await this._rpcRequest("getAccountInfo", d), _ = create(v, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
    if ("error" in _)
      throw new SolanaJSONRPCError(_.error, `failed to get info about account ${t.toBase58()}`);
    return _.result;
  }
  async getAccountInfo(t, s) {
    try {
      return (await this.getAccountInfoAndContext(t, s)).value;
    } catch (h) {
      throw new Error("failed to get info about account " + t.toBase58() + ": " + h);
    }
  }
  async getMultipleParsedAccounts(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = t.map((z) => z.toBase58()), v = this._buildArgs([d], h, "jsonParsed", m), _ = await this._rpcRequest("getMultipleAccounts", v), T = create(_, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
    if ("error" in T)
      throw new SolanaJSONRPCError(T.error, `failed to get info for accounts ${d}`);
    return T.result;
  }
  async getMultipleAccountsInfoAndContext(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = t.map((z) => z.toBase58()), v = this._buildArgs([d], h, "base64", m), _ = await this._rpcRequest("getMultipleAccounts", v), T = create(_, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
    if ("error" in T)
      throw new SolanaJSONRPCError(T.error, `failed to get info for accounts ${d}`);
    return T.result;
  }
  async getMultipleAccountsInfo(t, s) {
    return (await this.getMultipleAccountsInfoAndContext(t, s)).value;
  }
  async getStakeActivation(t, s, h) {
    const {
      commitment: m,
      config: d
    } = extractCommitmentFromConfig(s), v = this._buildArgs(
      [t.toBase58()],
      m,
      void 0,
      {
        ...d,
        epoch: h != null ? h : d == null ? void 0 : d.epoch
      }
    ), _ = await this._rpcRequest("getStakeActivation", v), T = create(_, jsonRpcResult(StakeActivationResult));
    if ("error" in T)
      throw new SolanaJSONRPCError(T.error, `failed to get Stake Activation ${t.toBase58()}`);
    return T.result;
  }
  async getProgramAccounts(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), {
      encoding: d,
      ...v
    } = m || {}, _ = this._buildArgs([t.toBase58()], h, d || "base64", v), T = await this._rpcRequest("getProgramAccounts", _), z = create(T, jsonRpcResult(array(KeyedAccountInfoResult)));
    if ("error" in z)
      throw new SolanaJSONRPCError(z.error, `failed to get accounts owned by program ${t.toBase58()}`);
    return z.result;
  }
  async getParsedProgramAccounts(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = this._buildArgs([t.toBase58()], h, "jsonParsed", m), v = await this._rpcRequest("getProgramAccounts", d), _ = create(v, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
    if ("error" in _)
      throw new SolanaJSONRPCError(_.error, `failed to get accounts owned by program ${t.toBase58()}`);
    return _.result;
  }
  async confirmTransaction(t, s) {
    let h;
    if (typeof t == "string")
      h = t;
    else {
      var m;
      const v = t;
      if ((m = v.abortSignal) !== null && m !== void 0 && m.aborted)
        return Promise.reject(v.abortSignal.reason);
      h = v.signature;
    }
    let d;
    try {
      d = bs58.decode(h);
    } catch {
      throw new Error("signature must be base58 encoded: " + h);
    }
    return assert(d.length === 64, "signature has invalid length"), typeof t == "string" ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
      commitment: s || this.commitment,
      signature: h
    }) : "lastValidBlockHeight" in t ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
      commitment: s || this.commitment,
      strategy: t
    }) : await this.confirmTransactionUsingDurableNonceStrategy({
      commitment: s || this.commitment,
      strategy: t
    });
  }
  getCancellationPromise(t) {
    return new Promise((s, h) => {
      t != null && (t.aborted ? h(t.reason) : t.addEventListener("abort", () => {
        h(t.reason);
      }));
    });
  }
  getTransactionConfirmationPromise({
    commitment: t,
    signature: s
  }) {
    let h, m, d = !1;
    const v = new Promise((T, z) => {
      try {
        h = this.onSignature(s, (Y, ie) => {
          h = void 0;
          const ne = {
            context: ie,
            value: Y
          };
          T({
            __type: TransactionStatus.PROCESSED,
            response: ne
          });
        }, t);
        const J = new Promise((Y) => {
          h == null ? Y() : m = this._onSubscriptionStateChange(h, (ie) => {
            ie === "subscribed" && Y();
          });
        });
        (async () => {
          if (await J, d)
            return;
          const Y = await this.getSignatureStatus(s);
          if (d || Y == null)
            return;
          const {
            context: ie,
            value: ne
          } = Y;
          if (ne != null)
            if (ne != null && ne.err)
              z(ne.err);
            else {
              switch (t) {
                case "confirmed":
                case "single":
                case "singleGossip": {
                  if (ne.confirmationStatus === "processed")
                    return;
                  break;
                }
                case "finalized":
                case "max":
                case "root": {
                  if (ne.confirmationStatus === "processed" || ne.confirmationStatus === "confirmed")
                    return;
                  break;
                }
                case "processed":
                case "recent":
              }
              d = !0, T({
                __type: TransactionStatus.PROCESSED,
                response: {
                  context: ie,
                  value: ne
                }
              });
            }
        })();
      } catch (J) {
        z(J);
      }
    });
    return {
      abortConfirmation: () => {
        m && (m(), m = void 0), h != null && (this.removeSignatureListener(h), h = void 0);
      },
      confirmationPromise: v
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment: t,
    strategy: {
      abortSignal: s,
      lastValidBlockHeight: h,
      signature: m
    }
  }) {
    let d = !1;
    const v = new Promise((Y) => {
      const ie = async () => {
        try {
          return await this.getBlockHeight(t);
        } catch {
          return -1;
        }
      };
      (async () => {
        let ne = await ie();
        if (!d) {
          for (; ne <= h; )
            if (await sleep(1e3), d || (ne = await ie(), d))
              return;
          Y({
            __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
          });
        }
      })();
    }), {
      abortConfirmation: _,
      confirmationPromise: T
    } = this.getTransactionConfirmationPromise({
      commitment: t,
      signature: m
    }), z = this.getCancellationPromise(s);
    let J;
    try {
      const Y = await Promise.race([z, T, v]);
      if (Y.__type === TransactionStatus.PROCESSED)
        J = Y.response;
      else
        throw new TransactionExpiredBlockheightExceededError(m);
    } finally {
      d = !0, _();
    }
    return J;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment: t,
    strategy: {
      abortSignal: s,
      minContextSlot: h,
      nonceAccountPubkey: m,
      nonceValue: d,
      signature: v
    }
  }) {
    let _ = !1;
    const T = new Promise((ce) => {
      let re = d, oe = null;
      const pe = async () => {
        try {
          const {
            context: ae,
            value: me
          } = await this.getNonceAndContext(m, {
            commitment: t,
            minContextSlot: h
          });
          return oe = ae.slot, me == null ? void 0 : me.nonce;
        } catch {
          return re;
        }
      };
      (async () => {
        if (re = await pe(), !_)
          for (; ; ) {
            if (d !== re) {
              ce({
                __type: TransactionStatus.NONCE_INVALID,
                slotInWhichNonceDidAdvance: oe
              });
              return;
            }
            if (await sleep(2e3), _ || (re = await pe(), _))
              return;
          }
      })();
    }), {
      abortConfirmation: z,
      confirmationPromise: J
    } = this.getTransactionConfirmationPromise({
      commitment: t,
      signature: v
    }), Y = this.getCancellationPromise(s);
    let ie;
    try {
      const ce = await Promise.race([Y, J, T]);
      if (ce.__type === TransactionStatus.PROCESSED)
        ie = ce.response;
      else {
        var ne;
        let re;
        for (; ; ) {
          var de;
          const oe = await this.getSignatureStatus(v);
          if (oe == null)
            break;
          if (oe.context.slot < ((de = ce.slotInWhichNonceDidAdvance) !== null && de !== void 0 ? de : h)) {
            await sleep(400);
            continue;
          }
          re = oe;
          break;
        }
        if ((ne = re) !== null && ne !== void 0 && ne.value) {
          const oe = t || "finalized", {
            confirmationStatus: pe
          } = re.value;
          switch (oe) {
            case "processed":
            case "recent":
              if (pe !== "processed" && pe !== "confirmed" && pe !== "finalized")
                throw new TransactionExpiredNonceInvalidError(v);
              break;
            case "confirmed":
            case "single":
            case "singleGossip":
              if (pe !== "confirmed" && pe !== "finalized")
                throw new TransactionExpiredNonceInvalidError(v);
              break;
            case "finalized":
            case "max":
            case "root":
              if (pe !== "finalized")
                throw new TransactionExpiredNonceInvalidError(v);
              break;
            default:
              ((ae) => {
              })(oe);
          }
          ie = {
            context: re.context,
            value: {
              err: re.value.err
            }
          };
        } else
          throw new TransactionExpiredNonceInvalidError(v);
      }
    } finally {
      _ = !0, z();
    }
    return ie;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment: t,
    signature: s
  }) {
    let h;
    const m = new Promise((T) => {
      let z = this._confirmTransactionInitialTimeout || 6e4;
      switch (t) {
        case "processed":
        case "recent":
        case "single":
        case "confirmed":
        case "singleGossip": {
          z = this._confirmTransactionInitialTimeout || 3e4;
          break;
        }
      }
      h = setTimeout(() => T({
        __type: TransactionStatus.TIMED_OUT,
        timeoutMs: z
      }), z);
    }), {
      abortConfirmation: d,
      confirmationPromise: v
    } = this.getTransactionConfirmationPromise({
      commitment: t,
      signature: s
    });
    let _;
    try {
      const T = await Promise.race([v, m]);
      if (T.__type === TransactionStatus.PROCESSED)
        _ = T.response;
      else
        throw new TransactionExpiredTimeoutError(s, T.timeoutMs / 1e3);
    } finally {
      clearTimeout(h), d();
    }
    return _;
  }
  async getClusterNodes() {
    const t = await this._rpcRequest("getClusterNodes", []), s = create(t, jsonRpcResult(array(ContactInfoResult)));
    if ("error" in s)
      throw new SolanaJSONRPCError(s.error, "failed to get cluster nodes");
    return s.result;
  }
  async getVoteAccounts(t) {
    const s = this._buildArgs([], t), h = await this._rpcRequest("getVoteAccounts", s), m = create(h, GetVoteAccounts);
    if ("error" in m)
      throw new SolanaJSONRPCError(m.error, "failed to get vote accounts");
    return m.result;
  }
  async getSlot(t) {
    const {
      commitment: s,
      config: h
    } = extractCommitmentFromConfig(t), m = this._buildArgs(
      [],
      s,
      void 0,
      h
    ), d = await this._rpcRequest("getSlot", m), v = create(d, jsonRpcResult(number()));
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get slot");
    return v.result;
  }
  async getSlotLeader(t) {
    const {
      commitment: s,
      config: h
    } = extractCommitmentFromConfig(t), m = this._buildArgs(
      [],
      s,
      void 0,
      h
    ), d = await this._rpcRequest("getSlotLeader", m), v = create(d, jsonRpcResult(string()));
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get slot leader");
    return v.result;
  }
  async getSlotLeaders(t, s) {
    const h = [t, s], m = await this._rpcRequest("getSlotLeaders", h), d = create(m, jsonRpcResult(array(PublicKeyFromString)));
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get slot leaders");
    return d.result;
  }
  async getSignatureStatus(t, s) {
    const {
      context: h,
      value: m
    } = await this.getSignatureStatuses([t], s);
    assert(m.length === 1);
    const d = m[0];
    return {
      context: h,
      value: d
    };
  }
  async getSignatureStatuses(t, s) {
    const h = [t];
    s && h.push(s);
    const m = await this._rpcRequest("getSignatureStatuses", h), d = create(m, GetSignatureStatusesRpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get signature status");
    return d.result;
  }
  async getTransactionCount(t) {
    const {
      commitment: s,
      config: h
    } = extractCommitmentFromConfig(t), m = this._buildArgs(
      [],
      s,
      void 0,
      h
    ), d = await this._rpcRequest("getTransactionCount", m), v = create(d, jsonRpcResult(number()));
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get transaction count");
    return v.result;
  }
  async getTotalSupply(t) {
    return (await this.getSupply({
      commitment: t,
      excludeNonCirculatingAccountsList: !0
    })).value.total;
  }
  async getInflationGovernor(t) {
    const s = this._buildArgs([], t), h = await this._rpcRequest("getInflationGovernor", s), m = create(h, GetInflationGovernorRpcResult);
    if ("error" in m)
      throw new SolanaJSONRPCError(m.error, "failed to get inflation");
    return m.result;
  }
  async getInflationReward(t, s, h) {
    const {
      commitment: m,
      config: d
    } = extractCommitmentFromConfig(h), v = this._buildArgs(
      [t.map((z) => z.toBase58())],
      m,
      void 0,
      {
        ...d,
        epoch: s != null ? s : d == null ? void 0 : d.epoch
      }
    ), _ = await this._rpcRequest("getInflationReward", v), T = create(_, GetInflationRewardResult);
    if ("error" in T)
      throw new SolanaJSONRPCError(T.error, "failed to get inflation reward");
    return T.result;
  }
  async getInflationRate() {
    const t = await this._rpcRequest("getInflationRate", []), s = create(t, GetInflationRateRpcResult);
    if ("error" in s)
      throw new SolanaJSONRPCError(s.error, "failed to get inflation rate");
    return s.result;
  }
  async getEpochInfo(t) {
    const {
      commitment: s,
      config: h
    } = extractCommitmentFromConfig(t), m = this._buildArgs(
      [],
      s,
      void 0,
      h
    ), d = await this._rpcRequest("getEpochInfo", m), v = create(d, GetEpochInfoRpcResult);
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get epoch info");
    return v.result;
  }
  async getEpochSchedule() {
    const t = await this._rpcRequest("getEpochSchedule", []), s = create(t, GetEpochScheduleRpcResult);
    if ("error" in s)
      throw new SolanaJSONRPCError(s.error, "failed to get epoch schedule");
    const h = s.result;
    return new EpochSchedule(h.slotsPerEpoch, h.leaderScheduleSlotOffset, h.warmup, h.firstNormalEpoch, h.firstNormalSlot);
  }
  async getLeaderSchedule() {
    const t = await this._rpcRequest("getLeaderSchedule", []), s = create(t, GetLeaderScheduleRpcResult);
    if ("error" in s)
      throw new SolanaJSONRPCError(s.error, "failed to get leader schedule");
    return s.result;
  }
  async getMinimumBalanceForRentExemption(t, s) {
    const h = this._buildArgs([t], s), m = await this._rpcRequest("getMinimumBalanceForRentExemption", h), d = create(m, GetMinimumBalanceForRentExemptionRpcResult);
    return "error" in d ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : d.result;
  }
  async getRecentBlockhashAndContext(t) {
    const s = this._buildArgs([], t), h = await this._rpcRequest("getRecentBlockhash", s), m = create(h, GetRecentBlockhashAndContextRpcResult);
    if ("error" in m)
      throw new SolanaJSONRPCError(m.error, "failed to get recent blockhash");
    return m.result;
  }
  async getRecentPerformanceSamples(t) {
    const s = await this._rpcRequest("getRecentPerformanceSamples", t ? [t] : []), h = create(s, GetRecentPerformanceSamplesRpcResult);
    if ("error" in h)
      throw new SolanaJSONRPCError(h.error, "failed to get recent performance samples");
    return h.result;
  }
  async getFeeCalculatorForBlockhash(t, s) {
    const h = this._buildArgs([t], s), m = await this._rpcRequest("getFeeCalculatorForBlockhash", h), d = create(m, GetFeeCalculatorRpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get fee calculator");
    const {
      context: v,
      value: _
    } = d.result;
    return {
      context: v,
      value: _ !== null ? _.feeCalculator : null
    };
  }
  async getFeeForMessage(t, s) {
    const h = toBuffer(t.serialize()).toString("base64"), m = this._buildArgs([h], s), d = await this._rpcRequest("getFeeForMessage", m), v = create(d, jsonRpcResultAndContext(nullable(number())));
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get fee for message");
    if (v.result === null)
      throw new Error("invalid blockhash");
    return v.result;
  }
  async getRecentBlockhash(t) {
    try {
      return (await this.getRecentBlockhashAndContext(t)).value;
    } catch (s) {
      throw new Error("failed to get recent blockhash: " + s);
    }
  }
  async getLatestBlockhash(t) {
    try {
      return (await this.getLatestBlockhashAndContext(t)).value;
    } catch (s) {
      throw new Error("failed to get recent blockhash: " + s);
    }
  }
  async getLatestBlockhashAndContext(t) {
    const {
      commitment: s,
      config: h
    } = extractCommitmentFromConfig(t), m = this._buildArgs(
      [],
      s,
      void 0,
      h
    ), d = await this._rpcRequest("getLatestBlockhash", m), v = create(d, GetLatestBlockhashRpcResult);
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get latest blockhash");
    return v.result;
  }
  async getVersion() {
    const t = await this._rpcRequest("getVersion", []), s = create(t, jsonRpcResult(VersionResult));
    if ("error" in s)
      throw new SolanaJSONRPCError(s.error, "failed to get version");
    return s.result;
  }
  async getGenesisHash() {
    const t = await this._rpcRequest("getGenesisHash", []), s = create(t, jsonRpcResult(string()));
    if ("error" in s)
      throw new SolanaJSONRPCError(s.error, "failed to get genesis hash");
    return s.result;
  }
  async getBlock(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = this._buildArgsAtLeastConfirmed(
      [t],
      h,
      void 0,
      m
    ), v = await this._rpcRequest("getBlock", d);
    try {
      switch (m == null ? void 0 : m.transactionDetails) {
        case "accounts": {
          const _ = create(v, GetAccountsModeBlockRpcResult);
          if ("error" in _)
            throw _.error;
          return _.result;
        }
        case "none": {
          const _ = create(v, GetNoneModeBlockRpcResult);
          if ("error" in _)
            throw _.error;
          return _.result;
        }
        default: {
          const _ = create(v, GetBlockRpcResult);
          if ("error" in _)
            throw _.error;
          const {
            result: T
          } = _;
          return T ? {
            ...T,
            transactions: T.transactions.map(({
              transaction: z,
              meta: J,
              version: Y
            }) => ({
              meta: J,
              transaction: {
                ...z,
                message: versionedMessageFromResponse(Y, z.message)
              },
              version: Y
            }))
          } : null;
        }
      }
    } catch (_) {
      throw new SolanaJSONRPCError(_, "failed to get confirmed block");
    }
  }
  async getParsedBlock(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = this._buildArgsAtLeastConfirmed([t], h, "jsonParsed", m), v = await this._rpcRequest("getBlock", d);
    try {
      switch (m == null ? void 0 : m.transactionDetails) {
        case "accounts": {
          const _ = create(v, GetParsedAccountsModeBlockRpcResult);
          if ("error" in _)
            throw _.error;
          return _.result;
        }
        case "none": {
          const _ = create(v, GetParsedNoneModeBlockRpcResult);
          if ("error" in _)
            throw _.error;
          return _.result;
        }
        default: {
          const _ = create(v, GetParsedBlockRpcResult);
          if ("error" in _)
            throw _.error;
          return _.result;
        }
      }
    } catch (_) {
      throw new SolanaJSONRPCError(_, "failed to get block");
    }
  }
  async getBlockHeight(t) {
    const {
      commitment: s,
      config: h
    } = extractCommitmentFromConfig(t), m = this._buildArgs(
      [],
      s,
      void 0,
      h
    ), d = await this._rpcRequest("getBlockHeight", m), v = create(d, jsonRpcResult(number()));
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get block height information");
    return v.result;
  }
  async getBlockProduction(t) {
    let s, h;
    if (typeof t == "string")
      h = t;
    else if (t) {
      const {
        commitment: _,
        ...T
      } = t;
      h = _, s = T;
    }
    const m = this._buildArgs([], h, "base64", s), d = await this._rpcRequest("getBlockProduction", m), v = create(d, BlockProductionResponseStruct);
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get block production information");
    return v.result;
  }
  async getTransaction(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = this._buildArgsAtLeastConfirmed(
      [t],
      h,
      void 0,
      m
    ), v = await this._rpcRequest("getTransaction", d), _ = create(v, GetTransactionRpcResult);
    if ("error" in _)
      throw new SolanaJSONRPCError(_.error, "failed to get transaction");
    const T = _.result;
    return T && {
      ...T,
      transaction: {
        ...T.transaction,
        message: versionedMessageFromResponse(T.version, T.transaction.message)
      }
    };
  }
  async getParsedTransaction(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = this._buildArgsAtLeastConfirmed([t], h, "jsonParsed", m), v = await this._rpcRequest("getTransaction", d), _ = create(v, GetParsedTransactionRpcResult);
    if ("error" in _)
      throw new SolanaJSONRPCError(_.error, "failed to get transaction");
    return _.result;
  }
  async getParsedTransactions(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = t.map((T) => ({
      methodName: "getTransaction",
      args: this._buildArgsAtLeastConfirmed([T], h, "jsonParsed", m)
    }));
    return (await this._rpcBatchRequest(d)).map((T) => {
      const z = create(T, GetParsedTransactionRpcResult);
      if ("error" in z)
        throw new SolanaJSONRPCError(z.error, "failed to get transactions");
      return z.result;
    });
  }
  async getTransactions(t, s) {
    const {
      commitment: h,
      config: m
    } = extractCommitmentFromConfig(s), d = t.map((T) => ({
      methodName: "getTransaction",
      args: this._buildArgsAtLeastConfirmed(
        [T],
        h,
        void 0,
        m
      )
    }));
    return (await this._rpcBatchRequest(d)).map((T) => {
      const z = create(T, GetTransactionRpcResult);
      if ("error" in z)
        throw new SolanaJSONRPCError(z.error, "failed to get transactions");
      const J = z.result;
      return J && {
        ...J,
        transaction: {
          ...J.transaction,
          message: versionedMessageFromResponse(J.version, J.transaction.message)
        }
      };
    });
  }
  async getConfirmedBlock(t, s) {
    const h = this._buildArgsAtLeastConfirmed([t], s), m = await this._rpcRequest("getConfirmedBlock", h), d = create(m, GetConfirmedBlockRpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get confirmed block");
    const v = d.result;
    if (!v)
      throw new Error("Confirmed block " + t + " not found");
    const _ = {
      ...v,
      transactions: v.transactions.map(({
        transaction: T,
        meta: z
      }) => {
        const J = new Message(T.message);
        return {
          meta: z,
          transaction: {
            ...T,
            message: J
          }
        };
      })
    };
    return {
      ..._,
      transactions: _.transactions.map(({
        transaction: T,
        meta: z
      }) => ({
        meta: z,
        transaction: Transaction.populate(T.message, T.signatures)
      }))
    };
  }
  async getBlocks(t, s, h) {
    const m = this._buildArgsAtLeastConfirmed(s !== void 0 ? [t, s] : [t], h), d = await this._rpcRequest("getBlocks", m), v = create(d, jsonRpcResult(array(number())));
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get blocks");
    return v.result;
  }
  async getBlockSignatures(t, s) {
    const h = this._buildArgsAtLeastConfirmed([t], s, void 0, {
      transactionDetails: "signatures",
      rewards: !1
    }), m = await this._rpcRequest("getBlock", h), d = create(m, GetBlockSignaturesRpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get block");
    const v = d.result;
    if (!v)
      throw new Error("Block " + t + " not found");
    return v;
  }
  async getConfirmedBlockSignatures(t, s) {
    const h = this._buildArgsAtLeastConfirmed([t], s, void 0, {
      transactionDetails: "signatures",
      rewards: !1
    }), m = await this._rpcRequest("getConfirmedBlock", h), d = create(m, GetBlockSignaturesRpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get confirmed block");
    const v = d.result;
    if (!v)
      throw new Error("Confirmed block " + t + " not found");
    return v;
  }
  async getConfirmedTransaction(t, s) {
    const h = this._buildArgsAtLeastConfirmed([t], s), m = await this._rpcRequest("getConfirmedTransaction", h), d = create(m, GetTransactionRpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get transaction");
    const v = d.result;
    if (!v)
      return v;
    const _ = new Message(v.transaction.message), T = v.transaction.signatures;
    return {
      ...v,
      transaction: Transaction.populate(_, T)
    };
  }
  async getParsedConfirmedTransaction(t, s) {
    const h = this._buildArgsAtLeastConfirmed([t], s, "jsonParsed"), m = await this._rpcRequest("getConfirmedTransaction", h), d = create(m, GetParsedTransactionRpcResult);
    if ("error" in d)
      throw new SolanaJSONRPCError(d.error, "failed to get confirmed transaction");
    return d.result;
  }
  async getParsedConfirmedTransactions(t, s) {
    const h = t.map((v) => ({
      methodName: "getConfirmedTransaction",
      args: this._buildArgsAtLeastConfirmed([v], s, "jsonParsed")
    }));
    return (await this._rpcBatchRequest(h)).map((v) => {
      const _ = create(v, GetParsedTransactionRpcResult);
      if ("error" in _)
        throw new SolanaJSONRPCError(_.error, "failed to get confirmed transactions");
      return _.result;
    });
  }
  async getConfirmedSignaturesForAddress(t, s, h) {
    let m = {}, d = await this.getFirstAvailableBlock();
    for (; !("until" in m) && (s--, !(s <= 0 || s < d)); )
      try {
        const T = await this.getConfirmedBlockSignatures(s, "finalized");
        T.signatures.length > 0 && (m.until = T.signatures[T.signatures.length - 1].toString());
      } catch (T) {
        if (T instanceof Error && T.message.includes("skipped"))
          continue;
        throw T;
      }
    let v = await this.getSlot("finalized");
    for (; !("before" in m) && (h++, !(h > v)); )
      try {
        const T = await this.getConfirmedBlockSignatures(h);
        T.signatures.length > 0 && (m.before = T.signatures[T.signatures.length - 1].toString());
      } catch (T) {
        if (T instanceof Error && T.message.includes("skipped"))
          continue;
        throw T;
      }
    return (await this.getConfirmedSignaturesForAddress2(t, m)).map((T) => T.signature);
  }
  async getConfirmedSignaturesForAddress2(t, s, h) {
    const m = this._buildArgsAtLeastConfirmed([t.toBase58()], h, void 0, s), d = await this._rpcRequest("getConfirmedSignaturesForAddress2", m), v = create(d, GetConfirmedSignaturesForAddress2RpcResult);
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get confirmed signatures for address");
    return v.result;
  }
  async getSignaturesForAddress(t, s, h) {
    const m = this._buildArgsAtLeastConfirmed([t.toBase58()], h, void 0, s), d = await this._rpcRequest("getSignaturesForAddress", m), v = create(d, GetSignaturesForAddressRpcResult);
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get signatures for address");
    return v.result;
  }
  async getAddressLookupTable(t, s) {
    const {
      context: h,
      value: m
    } = await this.getAccountInfoAndContext(t, s);
    let d = null;
    return m !== null && (d = new AddressLookupTableAccount({
      key: t,
      state: AddressLookupTableAccount.deserialize(m.data)
    })), {
      context: h,
      value: d
    };
  }
  async getNonceAndContext(t, s) {
    const {
      context: h,
      value: m
    } = await this.getAccountInfoAndContext(t, s);
    let d = null;
    return m !== null && (d = NonceAccount.fromAccountData(m.data)), {
      context: h,
      value: d
    };
  }
  async getNonce(t, s) {
    return await this.getNonceAndContext(t, s).then((h) => h.value).catch((h) => {
      throw new Error("failed to get nonce for account " + t.toBase58() + ": " + h);
    });
  }
  async requestAirdrop(t, s) {
    const h = await this._rpcRequest("requestAirdrop", [t.toBase58(), s]), m = create(h, RequestAirdropRpcResult);
    if ("error" in m)
      throw new SolanaJSONRPCError(m.error, `airdrop to ${t.toBase58()} failed`);
    return m.result;
  }
  async _blockhashWithExpiryBlockHeight(t) {
    if (!t) {
      for (; this._pollingBlockhash; )
        await sleep(100);
      const h = Date.now() - this._blockhashInfo.lastFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
      if (this._blockhashInfo.latestBlockhash !== null && !h)
        return this._blockhashInfo.latestBlockhash;
    }
    return await this._pollNewBlockhash();
  }
  async _pollNewBlockhash() {
    this._pollingBlockhash = !0;
    try {
      const t = Date.now(), s = this._blockhashInfo.latestBlockhash, h = s ? s.blockhash : null;
      for (let m = 0; m < 50; m++) {
        const d = await this.getLatestBlockhash("finalized");
        if (h !== d.blockhash)
          return this._blockhashInfo = {
            latestBlockhash: d,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          }, d;
        await sleep(MS_PER_SLOT / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - t}ms`);
    } finally {
      this._pollingBlockhash = !1;
    }
  }
  async getStakeMinimumDelegation(t) {
    const {
      commitment: s,
      config: h
    } = extractCommitmentFromConfig(t), m = this._buildArgs([], s, "base64", h), d = await this._rpcRequest("getStakeMinimumDelegation", m), v = create(d, jsonRpcResultAndContext(number()));
    if ("error" in v)
      throw new SolanaJSONRPCError(v.error, "failed to get stake minimum delegation");
    return v.result;
  }
  async simulateTransaction(t, s, h) {
    if ("message" in t) {
      const ce = t.serialize(), re = buffer.Buffer.from(ce).toString("base64");
      if (Array.isArray(s) || h !== void 0)
        throw new Error("Invalid arguments");
      const oe = s || {};
      oe.encoding = "base64", "commitment" in oe || (oe.commitment = this.commitment);
      const pe = [re, oe], ae = await this._rpcRequest("simulateTransaction", pe), me = create(ae, SimulatedTransactionResponseStruct);
      if ("error" in me)
        throw new Error("failed to simulate transaction: " + me.error.message);
      return me.result;
    }
    let m;
    if (t instanceof Transaction) {
      let de = t;
      m = new Transaction(), m.feePayer = de.feePayer, m.instructions = t.instructions, m.nonceInfo = de.nonceInfo, m.signatures = de.signatures;
    } else
      m = Transaction.populate(t), m._message = m._json = void 0;
    if (s !== void 0 && !Array.isArray(s))
      throw new Error("Invalid arguments");
    const d = s;
    if (m.nonceInfo && d)
      m.sign(...d);
    else {
      let de = this._disableBlockhashCaching;
      for (; ; ) {
        const ce = await this._blockhashWithExpiryBlockHeight(de);
        if (m.lastValidBlockHeight = ce.lastValidBlockHeight, m.recentBlockhash = ce.blockhash, !d)
          break;
        if (m.sign(...d), !m.signature)
          throw new Error("!signature");
        const re = m.signature.toString("base64");
        if (!this._blockhashInfo.simulatedSignatures.includes(re) && !this._blockhashInfo.transactionSignatures.includes(re)) {
          this._blockhashInfo.simulatedSignatures.push(re);
          break;
        } else
          de = !0;
      }
    }
    const v = m._compile(), _ = v.serialize(), z = m._serialize(_).toString("base64"), J = {
      encoding: "base64",
      commitment: this.commitment
    };
    if (h) {
      const de = (Array.isArray(h) ? h : v.nonProgramIds()).map((ce) => ce.toBase58());
      J.accounts = {
        encoding: "base64",
        addresses: de
      };
    }
    d && (J.sigVerify = !0);
    const Y = [z, J], ie = await this._rpcRequest("simulateTransaction", Y), ne = create(ie, SimulatedTransactionResponseStruct);
    if ("error" in ne) {
      let de;
      if ("data" in ne.error && (de = ne.error.data.logs, de && Array.isArray(de))) {
        const ce = `
    `, re = ce + de.join(ce);
        console.error(ne.error.message, re);
      }
      throw new SendTransactionError("failed to simulate transaction: " + ne.error.message, de);
    }
    return ne.result;
  }
  async sendTransaction(t, s, h) {
    if ("version" in t) {
      if (s && Array.isArray(s))
        throw new Error("Invalid arguments");
      const v = t.serialize();
      return await this.sendRawTransaction(v, h);
    }
    if (s === void 0 || !Array.isArray(s))
      throw new Error("Invalid arguments");
    const m = s;
    if (t.nonceInfo)
      t.sign(...m);
    else {
      let v = this._disableBlockhashCaching;
      for (; ; ) {
        const _ = await this._blockhashWithExpiryBlockHeight(v);
        if (t.lastValidBlockHeight = _.lastValidBlockHeight, t.recentBlockhash = _.blockhash, t.sign(...m), !t.signature)
          throw new Error("!signature");
        const T = t.signature.toString("base64");
        if (this._blockhashInfo.transactionSignatures.includes(T))
          v = !0;
        else {
          this._blockhashInfo.transactionSignatures.push(T);
          break;
        }
      }
    }
    const d = t.serialize();
    return await this.sendRawTransaction(d, h);
  }
  async sendRawTransaction(t, s) {
    const h = toBuffer(t).toString("base64");
    return await this.sendEncodedTransaction(h, s);
  }
  async sendEncodedTransaction(t, s) {
    const h = {
      encoding: "base64"
    }, m = s && s.skipPreflight, d = s && s.preflightCommitment || this.commitment;
    s && s.maxRetries != null && (h.maxRetries = s.maxRetries), s && s.minContextSlot != null && (h.minContextSlot = s.minContextSlot), m && (h.skipPreflight = m), d && (h.preflightCommitment = d);
    const v = [t, h], _ = await this._rpcRequest("sendTransaction", v), T = create(_, SendTransactionRpcResult);
    if ("error" in T) {
      let z;
      throw "data" in T.error && (z = T.error.data.logs), new SendTransactionError("failed to send transaction: " + T.error.message, z);
    }
    return T.result;
  }
  _wsOnOpen() {
    this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval(() => {
      this._rpcWebSocket.notify("ping").catch(() => {
      });
    }, 5e3), this._updateSubscriptions();
  }
  _wsOnError(t) {
    this._rpcWebSocketConnected = !1, console.error("ws error:", t.message);
  }
  _wsOnClose(t) {
    if (this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER, this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null), this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), t === 1e3) {
      this._updateSubscriptions();
      return;
    }
    this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach(([s, h]) => {
      this._setSubscription(s, {
        ...h,
        state: "pending"
      });
    });
  }
  _setSubscription(t, s) {
    var h;
    const m = (h = this._subscriptionsByHash[t]) === null || h === void 0 ? void 0 : h.state;
    if (this._subscriptionsByHash[t] = s, m !== s.state) {
      const d = this._subscriptionStateChangeCallbacksByHash[t];
      d && d.forEach((v) => {
        try {
          v(s.state);
        } catch {
        }
      });
    }
  }
  _onSubscriptionStateChange(t, s) {
    var h;
    const m = this._subscriptionHashByClientSubscriptionId[t];
    if (m == null)
      return () => {
      };
    const d = (h = this._subscriptionStateChangeCallbacksByHash)[m] || (h[m] = /* @__PURE__ */ new Set());
    return d.add(s), () => {
      d.delete(s), d.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[m];
    };
  }
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1, this._rpcWebSocketIdleTimeout = setTimeout(() => {
        this._rpcWebSocketIdleTimeout = null;
        try {
          this._rpcWebSocket.close();
        } catch (h) {
          h instanceof Error && console.log(`Error when closing socket connection: ${h.message}`);
        }
      }, 500));
      return;
    }
    if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketConnected = !0), !this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();
      return;
    }
    const t = this._rpcWebSocketGeneration, s = () => t === this._rpcWebSocketGeneration;
    await Promise.all(
      Object.keys(this._subscriptionsByHash).map(async (h) => {
        const m = this._subscriptionsByHash[h];
        if (m !== void 0)
          switch (m.state) {
            case "pending":
            case "unsubscribed":
              if (m.callbacks.size === 0) {
                delete this._subscriptionsByHash[h], m.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[m.serverSubscriptionId], await this._updateSubscriptions();
                return;
              }
              await (async () => {
                const {
                  args: d,
                  method: v
                } = m;
                try {
                  this._setSubscription(h, {
                    ...m,
                    state: "subscribing"
                  });
                  const _ = await this._rpcWebSocket.call(v, d);
                  this._setSubscription(h, {
                    ...m,
                    serverSubscriptionId: _,
                    state: "subscribed"
                  }), this._subscriptionCallbacksByServerSubscriptionId[_] = m.callbacks, await this._updateSubscriptions();
                } catch (_) {
                  if (_ instanceof Error && console.error(`${v} error for argument`, d, _.message), !s())
                    return;
                  this._setSubscription(h, {
                    ...m,
                    state: "pending"
                  }), await this._updateSubscriptions();
                }
              })();
              break;
            case "subscribed":
              m.callbacks.size === 0 && await (async () => {
                const {
                  serverSubscriptionId: d,
                  unsubscribeMethod: v
                } = m;
                if (this._subscriptionsAutoDisposedByRpc.has(d))
                  this._subscriptionsAutoDisposedByRpc.delete(d);
                else {
                  this._setSubscription(h, {
                    ...m,
                    state: "unsubscribing"
                  }), this._setSubscription(h, {
                    ...m,
                    state: "unsubscribing"
                  });
                  try {
                    await this._rpcWebSocket.call(v, [d]);
                  } catch (_) {
                    if (_ instanceof Error && console.error(`${v} error:`, _.message), !s())
                      return;
                    this._setSubscription(h, {
                      ...m,
                      state: "subscribed"
                    }), await this._updateSubscriptions();
                    return;
                  }
                }
                this._setSubscription(h, {
                  ...m,
                  state: "unsubscribed"
                }), await this._updateSubscriptions();
              })();
              break;
          }
      })
    );
  }
  _handleServerNotification(t, s) {
    const h = this._subscriptionCallbacksByServerSubscriptionId[t];
    h !== void 0 && h.forEach((m) => {
      try {
        m(
          ...s
        );
      } catch (d) {
        console.error(d);
      }
    });
  }
  _wsOnAccountNotification(t) {
    const {
      result: s,
      subscription: h
    } = create(t, AccountNotificationResult);
    this._handleServerNotification(h, [s.value, s.context]);
  }
  _makeSubscription(t, s) {
    const h = this._nextClientSubscriptionId++, m = fastStableStringify$1([t.method, s]), d = this._subscriptionsByHash[m];
    return d === void 0 ? this._subscriptionsByHash[m] = {
      ...t,
      args: s,
      callbacks: /* @__PURE__ */ new Set([t.callback]),
      state: "pending"
    } : d.callbacks.add(t.callback), this._subscriptionHashByClientSubscriptionId[h] = m, this._subscriptionDisposeFunctionsByClientSubscriptionId[h] = async () => {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[h], delete this._subscriptionHashByClientSubscriptionId[h];
      const v = this._subscriptionsByHash[m];
      assert(v !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${h}`), v.callbacks.delete(t.callback), await this._updateSubscriptions();
    }, this._updateSubscriptions(), h;
  }
  onAccountChange(t, s, h) {
    const m = this._buildArgs(
      [t.toBase58()],
      h || this._commitment || "finalized",
      "base64"
    );
    return this._makeSubscription({
      callback: s,
      method: "accountSubscribe",
      unsubscribeMethod: "accountUnsubscribe"
    }, m);
  }
  async removeAccountChangeListener(t) {
    await this._unsubscribeClientSubscription(t, "account change");
  }
  _wsOnProgramAccountNotification(t) {
    const {
      result: s,
      subscription: h
    } = create(t, ProgramAccountNotificationResult);
    this._handleServerNotification(h, [{
      accountId: s.value.pubkey,
      accountInfo: s.value.account
    }, s.context]);
  }
  onProgramAccountChange(t, s, h, m) {
    const d = this._buildArgs(
      [t.toBase58()],
      h || this._commitment || "finalized",
      "base64",
      m ? {
        filters: m
      } : void 0
    );
    return this._makeSubscription({
      callback: s,
      method: "programSubscribe",
      unsubscribeMethod: "programUnsubscribe"
    }, d);
  }
  async removeProgramAccountChangeListener(t) {
    await this._unsubscribeClientSubscription(t, "program account change");
  }
  onLogs(t, s, h) {
    const m = this._buildArgs(
      [typeof t == "object" ? {
        mentions: [t.toString()]
      } : t],
      h || this._commitment || "finalized"
    );
    return this._makeSubscription({
      callback: s,
      method: "logsSubscribe",
      unsubscribeMethod: "logsUnsubscribe"
    }, m);
  }
  async removeOnLogsListener(t) {
    await this._unsubscribeClientSubscription(t, "logs");
  }
  _wsOnLogsNotification(t) {
    const {
      result: s,
      subscription: h
    } = create(t, LogsNotificationResult);
    this._handleServerNotification(h, [s.value, s.context]);
  }
  _wsOnSlotNotification(t) {
    const {
      result: s,
      subscription: h
    } = create(t, SlotNotificationResult);
    this._handleServerNotification(h, [s]);
  }
  onSlotChange(t) {
    return this._makeSubscription(
      {
        callback: t,
        method: "slotSubscribe",
        unsubscribeMethod: "slotUnsubscribe"
      },
      []
    );
  }
  async removeSlotChangeListener(t) {
    await this._unsubscribeClientSubscription(t, "slot change");
  }
  _wsOnSlotUpdatesNotification(t) {
    const {
      result: s,
      subscription: h
    } = create(t, SlotUpdateNotificationResult);
    this._handleServerNotification(h, [s]);
  }
  onSlotUpdate(t) {
    return this._makeSubscription(
      {
        callback: t,
        method: "slotsUpdatesSubscribe",
        unsubscribeMethod: "slotsUpdatesUnsubscribe"
      },
      []
    );
  }
  async removeSlotUpdateListener(t) {
    await this._unsubscribeClientSubscription(t, "slot update");
  }
  async _unsubscribeClientSubscription(t, s) {
    const h = this._subscriptionDisposeFunctionsByClientSubscriptionId[t];
    h ? await h() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${t}\` for '${s}' events could not be found.`);
  }
  _buildArgs(t, s, h, m) {
    const d = s || this._commitment;
    if (d || h || m) {
      let v = {};
      h && (v.encoding = h), d && (v.commitment = d), m && (v = Object.assign(v, m)), t.push(v);
    }
    return t;
  }
  _buildArgsAtLeastConfirmed(t, s, h, m) {
    const d = s || this._commitment;
    if (d && !["confirmed", "finalized"].includes(d))
      throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
    return this._buildArgs(t, s, h, m);
  }
  _wsOnSignatureNotification(t) {
    const {
      result: s,
      subscription: h
    } = create(t, SignatureNotificationResult);
    s.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add(h), this._handleServerNotification(h, s.value === "receivedSignature" ? [{
      type: "received"
    }, s.context] : [{
      type: "status",
      result: s.value
    }, s.context]);
  }
  onSignature(t, s, h) {
    const m = this._buildArgs(
      [t],
      h || this._commitment || "finalized"
    ), d = this._makeSubscription({
      callback: (v, _) => {
        if (v.type === "status") {
          s(v.result, _);
          try {
            this.removeSignatureListener(d);
          } catch {
          }
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, m);
    return d;
  }
  onSignatureWithOptions(t, s, h) {
    const {
      commitment: m,
      ...d
    } = {
      ...h,
      commitment: h && h.commitment || this._commitment || "finalized"
    }, v = this._buildArgs(
      [t],
      m,
      void 0,
      d
    ), _ = this._makeSubscription({
      callback: (T, z) => {
        s(T, z);
        try {
          this.removeSignatureListener(_);
        } catch {
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, v);
    return _;
  }
  async removeSignatureListener(t) {
    await this._unsubscribeClientSubscription(t, "signature result");
  }
  _wsOnRootNotification(t) {
    const {
      result: s,
      subscription: h
    } = create(t, RootNotificationResult);
    this._handleServerNotification(h, [s]);
  }
  onRootChange(t) {
    return this._makeSubscription(
      {
        callback: t,
        method: "rootSubscribe",
        unsubscribeMethod: "rootUnsubscribe"
      },
      []
    );
  }
  async removeRootChangeListener(t) {
    await this._unsubscribeClientSubscription(t, "root change");
  }
}
class Keypair {
  constructor(t) {
    this._keypair = void 0, this._keypair = t != null ? t : generateKeypair();
  }
  static generate() {
    return new Keypair(generateKeypair());
  }
  static fromSecretKey(t, s) {
    if (t.byteLength !== 64)
      throw new Error("bad secret key size");
    const h = t.slice(32, 64);
    if (!s || !s.skipValidation) {
      const m = t.slice(0, 32), d = getPublicKey(m);
      for (let v = 0; v < 32; v++)
        if (h[v] !== d[v])
          throw new Error("provided secretKey is invalid");
    }
    return new Keypair({
      publicKey: h,
      secretKey: t
    });
  }
  static fromSeed(t) {
    const s = getPublicKey(t), h = new Uint8Array(64);
    return h.set(t), h.set(s, 32), new Keypair({
      publicKey: s,
      secretKey: h
    });
  }
  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: struct([u32("instruction"), u64("recentSlot"), u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: struct([u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: struct([u32("instruction"), u64(), seq(publicKey(), offset(u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: struct([u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: struct([u32("instruction")])
  }
});
class AddressLookupTableInstruction {
  constructor() {
  }
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const h = u32("instruction").decode(t.data);
    let m;
    for (const [d, v] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS))
      if (v.index == h) {
        m = d;
        break;
      }
    if (!m)
      throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
    return m;
  }
  static decodeCreateLookupTable(t) {
    this.checkProgramId(t.programId), this.checkKeysLength(t.keys, 4);
    const {
      recentSlot: s
    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, t.data);
    return {
      authority: t.keys[1].pubkey,
      payer: t.keys[2].pubkey,
      recentSlot: Number(s)
    };
  }
  static decodeExtendLookupTable(t) {
    if (this.checkProgramId(t.programId), t.keys.length < 2)
      throw new Error(`invalid instruction; found ${t.keys.length} keys, expected at least 2`);
    const {
      addresses: s
    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, t.data);
    return {
      lookupTable: t.keys[0].pubkey,
      authority: t.keys[1].pubkey,
      payer: t.keys.length > 2 ? t.keys[2].pubkey : void 0,
      addresses: s.map((h) => new PublicKey(h))
    };
  }
  static decodeCloseLookupTable(t) {
    return this.checkProgramId(t.programId), this.checkKeysLength(t.keys, 3), {
      lookupTable: t.keys[0].pubkey,
      authority: t.keys[1].pubkey,
      recipient: t.keys[2].pubkey
    };
  }
  static decodeFreezeLookupTable(t) {
    return this.checkProgramId(t.programId), this.checkKeysLength(t.keys, 2), {
      lookupTable: t.keys[0].pubkey,
      authority: t.keys[1].pubkey
    };
  }
  static decodeDeactivateLookupTable(t) {
    return this.checkProgramId(t.programId), this.checkKeysLength(t.keys, 2), {
      lookupTable: t.keys[0].pubkey,
      authority: t.keys[1].pubkey
    };
  }
  static checkProgramId(t) {
    if (!t.equals(AddressLookupTableProgram.programId))
      throw new Error("invalid instruction; programId is not AddressLookupTable Program");
  }
  static checkKeysLength(t, s) {
    if (t.length < s)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${s}`);
  }
}
class AddressLookupTableProgram {
  constructor() {
  }
  static createLookupTable(t) {
    const [s, h] = PublicKey.findProgramAddressSync([t.authority.toBuffer(), toBufferLE_1(BigInt(t.recentSlot), 8)], this.programId), m = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, d = encodeData(m, {
      recentSlot: BigInt(t.recentSlot),
      bumpSeed: h
    }), v = [{
      pubkey: s,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: t.authority,
      isSigner: !0,
      isWritable: !1
    }, {
      pubkey: t.payer,
      isSigner: !0,
      isWritable: !0
    }, {
      pubkey: SystemProgram.programId,
      isSigner: !1,
      isWritable: !1
    }];
    return [new TransactionInstruction({
      programId: this.programId,
      keys: v,
      data: d
    }), s];
  }
  static freezeLookupTable(t) {
    const s = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable, h = encodeData(s), m = [{
      pubkey: t.lookupTable,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: t.authority,
      isSigner: !0,
      isWritable: !1
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: m,
      data: h
    });
  }
  static extendLookupTable(t) {
    const s = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, h = encodeData(s, {
      addresses: t.addresses.map((d) => d.toBytes())
    }), m = [{
      pubkey: t.lookupTable,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: t.authority,
      isSigner: !0,
      isWritable: !1
    }];
    return t.payer && m.push({
      pubkey: t.payer,
      isSigner: !0,
      isWritable: !0
    }, {
      pubkey: SystemProgram.programId,
      isSigner: !1,
      isWritable: !1
    }), new TransactionInstruction({
      programId: this.programId,
      keys: m,
      data: h
    });
  }
  static deactivateLookupTable(t) {
    const s = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable, h = encodeData(s), m = [{
      pubkey: t.lookupTable,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: t.authority,
      isSigner: !0,
      isWritable: !1
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: m,
      data: h
    });
  }
  static closeLookupTable(t) {
    const s = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable, h = encodeData(s), m = [{
      pubkey: t.lookupTable,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: t.authority,
      isSigner: !0,
      isWritable: !1
    }, {
      pubkey: t.recipient,
      isSigner: !1,
      isWritable: !0
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: m,
      data: h
    });
  }
}
AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
class ComputeBudgetInstruction {
  constructor() {
  }
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const h = u8("instruction").decode(t.data);
    let m;
    for (const [d, v] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS))
      if (v.index == h) {
        m = d;
        break;
      }
    if (!m)
      throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
    return m;
  }
  static decodeRequestUnits(t) {
    this.checkProgramId(t.programId);
    const {
      units: s,
      additionalFee: h
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, t.data);
    return {
      units: s,
      additionalFee: h
    };
  }
  static decodeRequestHeapFrame(t) {
    this.checkProgramId(t.programId);
    const {
      bytes: s
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, t.data);
    return {
      bytes: s
    };
  }
  static decodeSetComputeUnitLimit(t) {
    this.checkProgramId(t.programId);
    const {
      units: s
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, t.data);
    return {
      units: s
    };
  }
  static decodeSetComputeUnitPrice(t) {
    this.checkProgramId(t.programId);
    const {
      microLamports: s
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, t.data);
    return {
      microLamports: s
    };
  }
  static checkProgramId(t) {
    if (!t.equals(ComputeBudgetProgram.programId))
      throw new Error("invalid instruction; programId is not ComputeBudgetProgram");
  }
}
const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: struct([u8("instruction"), u32("units"), u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: struct([u8("instruction"), u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: struct([u8("instruction"), u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: struct([u8("instruction"), u64("microLamports")])
  }
});
class ComputeBudgetProgram {
  constructor() {
  }
  static requestUnits(t) {
    const s = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, h = encodeData(s, t);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: h
    });
  }
  static requestHeapFrame(t) {
    const s = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, h = encodeData(s, t);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: h
    });
  }
  static setComputeUnitLimit(t) {
    const s = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, h = encodeData(s, t);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: h
    });
  }
  static setComputeUnitPrice(t) {
    const s = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, h = encodeData(s, {
      microLamports: BigInt(t.microLamports)
    });
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: h
    });
  }
}
ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
const PRIVATE_KEY_BYTES$1 = 64, PUBLIC_KEY_BYTES$1 = 32, SIGNATURE_BYTES = 64, ED25519_INSTRUCTION_LAYOUT = struct([u8("numSignatures"), u8("padding"), u16("signatureOffset"), u16("signatureInstructionIndex"), u16("publicKeyOffset"), u16("publicKeyInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u16("messageInstructionIndex")]);
class Ed25519Program {
  constructor() {
  }
  static createInstructionWithPublicKey(t) {
    const {
      publicKey: s,
      message: h,
      signature: m,
      instructionIndex: d
    } = t;
    assert(s.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${s.length} bytes`), assert(m.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${m.length} bytes`);
    const v = ED25519_INSTRUCTION_LAYOUT.span, _ = v + s.length, T = _ + m.length, z = 1, J = buffer.Buffer.alloc(T + h.length), Y = d == null ? 65535 : d;
    return ED25519_INSTRUCTION_LAYOUT.encode({
      numSignatures: z,
      padding: 0,
      signatureOffset: _,
      signatureInstructionIndex: Y,
      publicKeyOffset: v,
      publicKeyInstructionIndex: Y,
      messageDataOffset: T,
      messageDataSize: h.length,
      messageInstructionIndex: Y
    }, J), J.fill(s, v), J.fill(m, _), J.fill(h, T), new TransactionInstruction({
      keys: [],
      programId: Ed25519Program.programId,
      data: J
    });
  }
  static createInstructionWithPrivateKey(t) {
    const {
      privateKey: s,
      message: h,
      instructionIndex: m
    } = t;
    assert(s.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${s.length} bytes`);
    try {
      const d = Keypair.fromSecretKey(s), v = d.publicKey.toBytes(), _ = sign(h, d.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: v,
        message: h,
        signature: _,
        instructionIndex: m
      });
    } catch (d) {
      throw new Error(`Error creating instruction; ${d}`);
    }
  }
}
Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
utils$1.hmacSha256Sync = (l, ...t) => {
  const s = hmac.create(sha256, l);
  return t.forEach((h) => s.update(h)), s.digest();
};
const ecdsaSign = (l, t) => signSync(l, t, {
  der: !1,
  recovered: !0
});
utils$1.isValidPrivateKey;
const publicKeyCreate = getPublicKey$1, PRIVATE_KEY_BYTES = 32, ETHEREUM_ADDRESS_BYTES = 20, PUBLIC_KEY_BYTES = 64, SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11, SECP256K1_INSTRUCTION_LAYOUT = struct([u8("numSignatures"), u16("signatureOffset"), u8("signatureInstructionIndex"), u16("ethAddressOffset"), u8("ethAddressInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u8("messageInstructionIndex"), blob(20, "ethAddress"), blob(64, "signature"), u8("recoveryId")]);
class Secp256k1Program {
  constructor() {
  }
  static publicKeyToEthAddress(t) {
    assert(t.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${t.length} bytes`);
    try {
      return buffer.Buffer.from(keccak_256(toBuffer(t))).slice(-ETHEREUM_ADDRESS_BYTES);
    } catch (s) {
      throw new Error(`Error constructing Ethereum address: ${s}`);
    }
  }
  static createInstructionWithPublicKey(t) {
    const {
      publicKey: s,
      message: h,
      signature: m,
      recoveryId: d,
      instructionIndex: v
    } = t;
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program.publicKeyToEthAddress(s),
      message: h,
      signature: m,
      recoveryId: d,
      instructionIndex: v
    });
  }
  static createInstructionWithEthAddress(t) {
    const {
      ethAddress: s,
      message: h,
      signature: m,
      recoveryId: d,
      instructionIndex: v = 0
    } = t;
    let _;
    typeof s == "string" ? s.startsWith("0x") ? _ = buffer.Buffer.from(s.substr(2), "hex") : _ = buffer.Buffer.from(s, "hex") : _ = s, assert(_.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${_.length} bytes`);
    const T = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE, z = T, J = T + _.length, Y = J + m.length + 1, ie = 1, ne = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + h.length);
    return SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures: ie,
      signatureOffset: J,
      signatureInstructionIndex: v,
      ethAddressOffset: z,
      ethAddressInstructionIndex: v,
      messageDataOffset: Y,
      messageDataSize: h.length,
      messageInstructionIndex: v,
      signature: toBuffer(m),
      ethAddress: toBuffer(_),
      recoveryId: d
    }, ne), ne.fill(toBuffer(h), SECP256K1_INSTRUCTION_LAYOUT.span), new TransactionInstruction({
      keys: [],
      programId: Secp256k1Program.programId,
      data: ne
    });
  }
  static createInstructionWithPrivateKey(t) {
    const {
      privateKey: s,
      message: h,
      instructionIndex: m
    } = t;
    assert(s.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${s.length} bytes`);
    try {
      const d = toBuffer(s), v = publicKeyCreate(
        d,
        !1
      ).slice(1), _ = buffer.Buffer.from(keccak_256(toBuffer(h))), [T, z] = ecdsaSign(_, d);
      return this.createInstructionWithPublicKey({
        publicKey: v,
        message: h,
        signature: T,
        recoveryId: z,
        instructionIndex: m
      });
    } catch (d) {
      throw new Error(`Error creating instruction; ${d}`);
    }
  }
}
Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
const STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
class Authorized {
  constructor(t, s) {
    this.staker = void 0, this.withdrawer = void 0, this.staker = t, this.withdrawer = s;
  }
}
class Lockup {
  constructor(t, s, h) {
    this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = t, this.epoch = s, this.custodian = h;
  }
}
Lockup.default = new Lockup(0, 0, PublicKey.default);
class StakeInstruction {
  constructor() {
  }
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const h = u32("instruction").decode(t.data);
    let m;
    for (const [d, v] of Object.entries(STAKE_INSTRUCTION_LAYOUTS))
      if (v.index == h) {
        m = d;
        break;
      }
    if (!m)
      throw new Error("Instruction type incorrect; not a StakeInstruction");
    return m;
  }
  static decodeInitialize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const {
      authorized: s,
      lockup: h
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, t.data);
    return {
      stakePubkey: t.keys[0].pubkey,
      authorized: new Authorized(new PublicKey(s.staker), new PublicKey(s.withdrawer)),
      lockup: new Lockup(h.unixTimestamp, h.epoch, new PublicKey(h.custodian))
    };
  }
  static decodeDelegate(t) {
    return this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 6), decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, t.data), {
      stakePubkey: t.keys[0].pubkey,
      votePubkey: t.keys[1].pubkey,
      authorizedPubkey: t.keys[5].pubkey
    };
  }
  static decodeAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const {
      newAuthorized: s,
      stakeAuthorizationType: h
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, t.data), m = {
      stakePubkey: t.keys[0].pubkey,
      authorizedPubkey: t.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(s),
      stakeAuthorizationType: {
        index: h
      }
    };
    return t.keys.length > 3 && (m.custodianPubkey = t.keys[3].pubkey), m;
  }
  static decodeAuthorizeWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const {
      newAuthorized: s,
      stakeAuthorizationType: h,
      authoritySeed: m,
      authorityOwner: d
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, t.data), v = {
      stakePubkey: t.keys[0].pubkey,
      authorityBase: t.keys[1].pubkey,
      authoritySeed: m,
      authorityOwner: new PublicKey(d),
      newAuthorizedPubkey: new PublicKey(s),
      stakeAuthorizationType: {
        index: h
      }
    };
    return t.keys.length > 3 && (v.custodianPubkey = t.keys[3].pubkey), v;
  }
  static decodeSplit(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const {
      lamports: s
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, t.data);
    return {
      stakePubkey: t.keys[0].pubkey,
      splitStakePubkey: t.keys[1].pubkey,
      authorizedPubkey: t.keys[2].pubkey,
      lamports: s
    };
  }
  static decodeMerge(t) {
    return this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3), decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, t.data), {
      stakePubkey: t.keys[0].pubkey,
      sourceStakePubKey: t.keys[1].pubkey,
      authorizedPubkey: t.keys[4].pubkey
    };
  }
  static decodeWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
    const {
      lamports: s
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, t.data), h = {
      stakePubkey: t.keys[0].pubkey,
      toPubkey: t.keys[1].pubkey,
      authorizedPubkey: t.keys[4].pubkey,
      lamports: s
    };
    return t.keys.length > 5 && (h.custodianPubkey = t.keys[5].pubkey), h;
  }
  static decodeDeactivate(t) {
    return this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3), decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, t.data), {
      stakePubkey: t.keys[0].pubkey,
      authorizedPubkey: t.keys[2].pubkey
    };
  }
  static checkProgramId(t) {
    if (!t.equals(StakeProgram.programId))
      throw new Error("invalid instruction; programId is not StakeProgram");
  }
  static checkKeyLength(t, s) {
    if (t.length < s)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${s}`);
  }
}
const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: struct([u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: struct([u32("instruction")])
  },
  Split: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: struct([u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: struct([u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
}), StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
class StakeProgram {
  constructor() {
  }
  static initialize(t) {
    const {
      stakePubkey: s,
      authorized: h,
      lockup: m
    } = t, d = m || Lockup.default, v = STAKE_INSTRUCTION_LAYOUTS.Initialize, _ = encodeData(v, {
      authorized: {
        staker: toBuffer(h.staker.toBuffer()),
        withdrawer: toBuffer(h.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: d.unixTimestamp,
        epoch: d.epoch,
        custodian: toBuffer(d.custodian.toBuffer())
      }
    }), T = {
      keys: [{
        pubkey: s,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }],
      programId: this.programId,
      data: _
    };
    return new TransactionInstruction(T);
  }
  static createAccountWithSeed(t) {
    const s = new Transaction();
    s.add(SystemProgram.createAccountWithSeed({
      fromPubkey: t.fromPubkey,
      newAccountPubkey: t.stakePubkey,
      basePubkey: t.basePubkey,
      seed: t.seed,
      lamports: t.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey: h,
      authorized: m,
      lockup: d
    } = t;
    return s.add(this.initialize({
      stakePubkey: h,
      authorized: m,
      lockup: d
    }));
  }
  static createAccount(t) {
    const s = new Transaction();
    s.add(SystemProgram.createAccount({
      fromPubkey: t.fromPubkey,
      newAccountPubkey: t.stakePubkey,
      lamports: t.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey: h,
      authorized: m,
      lockup: d
    } = t;
    return s.add(this.initialize({
      stakePubkey: h,
      authorized: m,
      lockup: d
    }));
  }
  static delegate(t) {
    const {
      stakePubkey: s,
      authorizedPubkey: h,
      votePubkey: m
    } = t, d = STAKE_INSTRUCTION_LAYOUTS.Delegate, v = encodeData(d);
    return new Transaction().add({
      keys: [{
        pubkey: s,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: m,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: h,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: v
    });
  }
  static authorize(t) {
    const {
      stakePubkey: s,
      authorizedPubkey: h,
      newAuthorizedPubkey: m,
      stakeAuthorizationType: d,
      custodianPubkey: v
    } = t, _ = STAKE_INSTRUCTION_LAYOUTS.Authorize, T = encodeData(_, {
      newAuthorized: toBuffer(m.toBuffer()),
      stakeAuthorizationType: d.index
    }), z = [{
      pubkey: s,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: h,
      isSigner: !0,
      isWritable: !1
    }];
    return v && z.push({
      pubkey: v,
      isSigner: !1,
      isWritable: !1
    }), new Transaction().add({
      keys: z,
      programId: this.programId,
      data: T
    });
  }
  static authorizeWithSeed(t) {
    const {
      stakePubkey: s,
      authorityBase: h,
      authoritySeed: m,
      authorityOwner: d,
      newAuthorizedPubkey: v,
      stakeAuthorizationType: _,
      custodianPubkey: T
    } = t, z = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, J = encodeData(z, {
      newAuthorized: toBuffer(v.toBuffer()),
      stakeAuthorizationType: _.index,
      authoritySeed: m,
      authorityOwner: toBuffer(d.toBuffer())
    }), Y = [{
      pubkey: s,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: h,
      isSigner: !0,
      isWritable: !1
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: !1,
      isWritable: !1
    }];
    return T && Y.push({
      pubkey: T,
      isSigner: !1,
      isWritable: !1
    }), new Transaction().add({
      keys: Y,
      programId: this.programId,
      data: J
    });
  }
  static splitInstruction(t) {
    const {
      stakePubkey: s,
      authorizedPubkey: h,
      splitStakePubkey: m,
      lamports: d
    } = t, v = STAKE_INSTRUCTION_LAYOUTS.Split, _ = encodeData(v, {
      lamports: d
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: s,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: m,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: h,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: _
    });
  }
  static split(t) {
    const s = new Transaction();
    return s.add(SystemProgram.createAccount({
      fromPubkey: t.authorizedPubkey,
      newAccountPubkey: t.splitStakePubkey,
      lamports: 0,
      space: this.space,
      programId: this.programId
    })), s.add(this.splitInstruction(t));
  }
  static splitWithSeed(t) {
    const {
      stakePubkey: s,
      authorizedPubkey: h,
      splitStakePubkey: m,
      basePubkey: d,
      seed: v,
      lamports: _
    } = t, T = new Transaction();
    return T.add(SystemProgram.allocate({
      accountPubkey: m,
      basePubkey: d,
      seed: v,
      space: this.space,
      programId: this.programId
    })), T.add(this.splitInstruction({
      stakePubkey: s,
      authorizedPubkey: h,
      splitStakePubkey: m,
      lamports: _
    }));
  }
  static merge(t) {
    const {
      stakePubkey: s,
      sourceStakePubKey: h,
      authorizedPubkey: m
    } = t, d = STAKE_INSTRUCTION_LAYOUTS.Merge, v = encodeData(d);
    return new Transaction().add({
      keys: [{
        pubkey: s,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: h,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: m,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: v
    });
  }
  static withdraw(t) {
    const {
      stakePubkey: s,
      authorizedPubkey: h,
      toPubkey: m,
      lamports: d,
      custodianPubkey: v
    } = t, _ = STAKE_INSTRUCTION_LAYOUTS.Withdraw, T = encodeData(_, {
      lamports: d
    }), z = [{
      pubkey: s,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: m,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: !1,
      isWritable: !1
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: !1,
      isWritable: !1
    }, {
      pubkey: h,
      isSigner: !0,
      isWritable: !1
    }];
    return v && z.push({
      pubkey: v,
      isSigner: !1,
      isWritable: !1
    }), new Transaction().add({
      keys: z,
      programId: this.programId,
      data: T
    });
  }
  static deactivate(t) {
    const {
      stakePubkey: s,
      authorizedPubkey: h
    } = t, m = STAKE_INSTRUCTION_LAYOUTS.Deactivate, d = encodeData(m);
    return new Transaction().add({
      keys: [{
        pubkey: s,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: h,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: d
    });
  }
}
StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
StakeProgram.space = 200;
class VoteInit {
  constructor(t, s, h, m) {
    this.nodePubkey = void 0, this.authorizedVoter = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.nodePubkey = t, this.authorizedVoter = s, this.authorizedWithdrawer = h, this.commission = m;
  }
}
class VoteInstruction {
  constructor() {
  }
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const h = u32("instruction").decode(t.data);
    let m;
    for (const [d, v] of Object.entries(VOTE_INSTRUCTION_LAYOUTS))
      if (v.index == h) {
        m = d;
        break;
      }
    if (!m)
      throw new Error("Instruction type incorrect; not a VoteInstruction");
    return m;
  }
  static decodeInitializeAccount(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 4);
    const {
      voteInit: s
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, t.data);
    return {
      votePubkey: t.keys[0].pubkey,
      nodePubkey: t.keys[3].pubkey,
      voteInit: new VoteInit(new PublicKey(s.nodePubkey), new PublicKey(s.authorizedVoter), new PublicKey(s.authorizedWithdrawer), s.commission)
    };
  }
  static decodeAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const {
      newAuthorized: s,
      voteAuthorizationType: h
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, t.data);
    return {
      votePubkey: t.keys[0].pubkey,
      authorizedPubkey: t.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(s),
      voteAuthorizationType: {
        index: h
      }
    };
  }
  static decodeAuthorizeWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: s,
        currentAuthorityDerivedKeySeed: h,
        newAuthorized: m,
        voteAuthorizationType: d
      }
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, t.data);
    return {
      currentAuthorityDerivedKeyBasePubkey: t.keys[2].pubkey,
      currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(s),
      currentAuthorityDerivedKeySeed: h,
      newAuthorizedPubkey: new PublicKey(m),
      voteAuthorizationType: {
        index: d
      },
      votePubkey: t.keys[0].pubkey
    };
  }
  static decodeWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const {
      lamports: s
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, t.data);
    return {
      votePubkey: t.keys[0].pubkey,
      authorizedWithdrawerPubkey: t.keys[2].pubkey,
      lamports: s,
      toPubkey: t.keys[1].pubkey
    };
  }
  static checkProgramId(t) {
    if (!t.equals(VoteProgram.programId))
      throw new Error("invalid instruction; programId is not VoteProgram");
  }
  static checkKeyLength(t, s) {
    if (t.length < s)
      throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${s}`);
  }
}
const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: struct([u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
}), VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
class VoteProgram {
  constructor() {
  }
  static initializeAccount(t) {
    const {
      votePubkey: s,
      nodePubkey: h,
      voteInit: m
    } = t, d = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, v = encodeData(d, {
      voteInit: {
        nodePubkey: toBuffer(m.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer(m.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer(m.authorizedWithdrawer.toBuffer()),
        commission: m.commission
      }
    }), _ = {
      keys: [{
        pubkey: s,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: h,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: v
    };
    return new TransactionInstruction(_);
  }
  static createAccount(t) {
    const s = new Transaction();
    return s.add(SystemProgram.createAccount({
      fromPubkey: t.fromPubkey,
      newAccountPubkey: t.votePubkey,
      lamports: t.lamports,
      space: this.space,
      programId: this.programId
    })), s.add(this.initializeAccount({
      votePubkey: t.votePubkey,
      nodePubkey: t.voteInit.nodePubkey,
      voteInit: t.voteInit
    }));
  }
  static authorize(t) {
    const {
      votePubkey: s,
      authorizedPubkey: h,
      newAuthorizedPubkey: m,
      voteAuthorizationType: d
    } = t, v = VOTE_INSTRUCTION_LAYOUTS.Authorize, _ = encodeData(v, {
      newAuthorized: toBuffer(m.toBuffer()),
      voteAuthorizationType: d.index
    }), T = [{
      pubkey: s,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: !1,
      isWritable: !1
    }, {
      pubkey: h,
      isSigner: !0,
      isWritable: !1
    }];
    return new Transaction().add({
      keys: T,
      programId: this.programId,
      data: _
    });
  }
  static authorizeWithSeed(t) {
    const {
      currentAuthorityDerivedKeyBasePubkey: s,
      currentAuthorityDerivedKeyOwnerPubkey: h,
      currentAuthorityDerivedKeySeed: m,
      newAuthorizedPubkey: d,
      voteAuthorizationType: v,
      votePubkey: _
    } = t, T = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, z = encodeData(T, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(h.toBuffer()),
        currentAuthorityDerivedKeySeed: m,
        newAuthorized: toBuffer(d.toBuffer()),
        voteAuthorizationType: v.index
      }
    }), J = [{
      pubkey: _,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: !1,
      isWritable: !1
    }, {
      pubkey: s,
      isSigner: !0,
      isWritable: !1
    }];
    return new Transaction().add({
      keys: J,
      programId: this.programId,
      data: z
    });
  }
  static withdraw(t) {
    const {
      votePubkey: s,
      authorizedWithdrawerPubkey: h,
      lamports: m,
      toPubkey: d
    } = t, v = VOTE_INSTRUCTION_LAYOUTS.Withdraw, _ = encodeData(v, {
      lamports: m
    }), T = [{
      pubkey: s,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: d,
      isSigner: !1,
      isWritable: !0
    }, {
      pubkey: h,
      isSigner: !0,
      isWritable: !1
    }];
    return new Transaction().add({
      keys: T,
      programId: this.programId,
      data: _
    });
  }
  static safeWithdraw(t, s, h) {
    if (t.lamports > s - h)
      throw new Error("Withdraw will leave vote account with insuffcient funds.");
    return VoteProgram.withdraw(t);
  }
}
VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
VoteProgram.space = 3731;
const VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111"), InfoString = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  keybaseUsername: optional(string())
});
class ValidatorInfo {
  constructor(t, s) {
    this.key = void 0, this.info = void 0, this.key = t, this.info = s;
  }
  static fromConfigData(t) {
    let s = [...t];
    if (decodeLength(s) !== 2)
      return null;
    const m = [];
    for (let d = 0; d < 2; d++) {
      const v = new PublicKey(s.slice(0, PUBLIC_KEY_LENGTH));
      s = s.slice(PUBLIC_KEY_LENGTH);
      const _ = s.slice(0, 1)[0] === 1;
      s = s.slice(1), m.push({
        publicKey: v,
        isSigner: _
      });
    }
    if (m[0].publicKey.equals(VALIDATOR_INFO_KEY) && m[1].isSigner) {
      const d = rustString().decode(buffer.Buffer.from(s)), v = JSON.parse(d);
      return assert$1(v, InfoString), new ValidatorInfo(m[1].publicKey, v);
    }
    return null;
  }
}
const VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111"), VoteAccountLayout = struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  u8("commission"),
  nu64(),
  seq(struct([nu64("slot"), u32("confirmationCount")]), offset(u32(), -8), "votes"),
  u8("rootSlotValid"),
  nu64("rootSlot"),
  nu64(),
  seq(struct([nu64("epoch"), publicKey("authorizedVoter")]), offset(u32(), -8), "authorizedVoters"),
  struct([seq(struct([publicKey("authorizedPubkey"), nu64("epochOfLastAuthorizedSwitch"), nu64("targetEpoch")]), 32, "buf"), nu64("idx"), u8("isEmpty")], "priorVoters"),
  nu64(),
  seq(struct([nu64("epoch"), nu64("credits"), nu64("prevCredits")]), offset(u32(), -8), "epochCredits"),
  struct([nu64("slot"), nu64("timestamp")], "lastTimestamp")
]);
class VoteAccount {
  constructor(t) {
    this.nodePubkey = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.rootSlot = void 0, this.votes = void 0, this.authorizedVoters = void 0, this.priorVoters = void 0, this.epochCredits = void 0, this.lastTimestamp = void 0, this.nodePubkey = t.nodePubkey, this.authorizedWithdrawer = t.authorizedWithdrawer, this.commission = t.commission, this.rootSlot = t.rootSlot, this.votes = t.votes, this.authorizedVoters = t.authorizedVoters, this.priorVoters = t.priorVoters, this.epochCredits = t.epochCredits, this.lastTimestamp = t.lastTimestamp;
  }
  static fromAccountData(t) {
    const h = VoteAccountLayout.decode(toBuffer(t), 4);
    let m = h.rootSlot;
    return h.rootSlotValid || (m = null), new VoteAccount({
      nodePubkey: new PublicKey(h.nodePubkey),
      authorizedWithdrawer: new PublicKey(h.authorizedWithdrawer),
      commission: h.commission,
      votes: h.votes,
      rootSlot: m,
      authorizedVoters: h.authorizedVoters.map(parseAuthorizedVoter),
      priorVoters: getPriorVoters(h.priorVoters),
      epochCredits: h.epochCredits,
      lastTimestamp: h.lastTimestamp
    });
  }
}
function parseAuthorizedVoter({
  authorizedVoter: l,
  epoch: t
}) {
  return {
    epoch: t,
    authorizedVoter: new PublicKey(l)
  };
}
function parsePriorVoters({
  authorizedPubkey: l,
  epochOfLastAuthorizedSwitch: t,
  targetEpoch: s
}) {
  return {
    authorizedPubkey: new PublicKey(l),
    epochOfLastAuthorizedSwitch: t,
    targetEpoch: s
  };
}
function getPriorVoters({
  buf: l,
  idx: t,
  isEmpty: s
}) {
  return s ? [] : [...l.slice(t + 1).map(parsePriorVoters), ...l.slice(0, t).map(parsePriorVoters)];
}
const endpoint = {
  http: {
    devnet: "http://api.devnet.solana.com",
    testnet: "http://api.testnet.solana.com",
    "mainnet-beta": "http://api.mainnet-beta.solana.com/"
  },
  https: {
    devnet: "https://api.devnet.solana.com",
    testnet: "https://api.testnet.solana.com",
    "mainnet-beta": "https://api.mainnet-beta.solana.com/"
  }
};
function clusterApiUrl(l, t) {
  const s = t === !1 ? "http" : "https";
  if (!l)
    return endpoint[s].devnet;
  const h = endpoint[s][l];
  if (!h)
    throw new Error(`Unknown ${s} cluster: ${l}`);
  return h;
}
async function sendAndConfirmRawTransaction(l, t, s, h) {
  let m, d;
  s && Object.prototype.hasOwnProperty.call(s, "lastValidBlockHeight") || s && Object.prototype.hasOwnProperty.call(s, "nonceValue") ? (m = s, d = h) : d = s;
  const v = d && {
    skipPreflight: d.skipPreflight,
    preflightCommitment: d.preflightCommitment || d.commitment,
    minContextSlot: d.minContextSlot
  }, _ = await l.sendRawTransaction(t, v), T = d && d.commitment, J = (await (m ? l.confirmTransaction(m, T) : l.confirmTransaction(_, T))).value;
  if (J.err)
    throw new Error(`Raw transaction ${_} failed (${JSON.stringify(J)})`);
  return _;
}
const LAMPORTS_PER_SOL = 1e9;
var index_browser_esm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Account,
  AddressLookupTableAccount,
  AddressLookupTableInstruction,
  AddressLookupTableProgram,
  Authorized,
  BLOCKHASH_CACHE_TIMEOUT_MS,
  BPF_LOADER_DEPRECATED_PROGRAM_ID,
  BPF_LOADER_PROGRAM_ID,
  BpfLoader,
  COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,
  ComputeBudgetInstruction,
  ComputeBudgetProgram,
  Connection,
  Ed25519Program,
  Enum,
  EpochSchedule,
  FeeCalculatorLayout,
  Keypair,
  LAMPORTS_PER_SOL,
  LOOKUP_TABLE_INSTRUCTION_LAYOUTS,
  Loader,
  Lockup,
  MAX_SEED_LENGTH,
  Message,
  MessageAccountKeys,
  MessageV0,
  NONCE_ACCOUNT_LENGTH,
  NonceAccount,
  PACKET_DATA_SIZE,
  PUBLIC_KEY_LENGTH,
  PublicKey,
  SIGNATURE_LENGTH_IN_BYTES,
  SOLANA_SCHEMA,
  STAKE_CONFIG_ID,
  STAKE_INSTRUCTION_LAYOUTS,
  SYSTEM_INSTRUCTION_LAYOUTS,
  SYSVAR_CLOCK_PUBKEY,
  SYSVAR_EPOCH_SCHEDULE_PUBKEY,
  SYSVAR_INSTRUCTIONS_PUBKEY,
  SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
  SYSVAR_RENT_PUBKEY,
  SYSVAR_REWARDS_PUBKEY,
  SYSVAR_SLOT_HASHES_PUBKEY,
  SYSVAR_SLOT_HISTORY_PUBKEY,
  SYSVAR_STAKE_HISTORY_PUBKEY,
  Secp256k1Program,
  SendTransactionError,
  SolanaJSONRPCError,
  SolanaJSONRPCErrorCode,
  StakeAuthorizationLayout,
  StakeInstruction,
  StakeProgram,
  Struct,
  SystemInstruction,
  SystemProgram,
  Transaction,
  TransactionExpiredBlockheightExceededError,
  TransactionExpiredNonceInvalidError,
  TransactionExpiredTimeoutError,
  TransactionInstruction,
  TransactionMessage,
  get TransactionStatus() {
    return TransactionStatus;
  },
  VALIDATOR_INFO_KEY,
  VERSION_PREFIX_MASK,
  VOTE_PROGRAM_ID,
  ValidatorInfo,
  VersionedMessage,
  VersionedTransaction,
  VoteAccount,
  VoteAuthorizationLayout,
  VoteInit,
  VoteInstruction,
  VoteProgram,
  clusterApiUrl,
  sendAndConfirmRawTransaction,
  sendAndConfirmTransaction
}), require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(index_browser_esm), utils = {}, require$$0 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$c), require$$1 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$g), require$$2 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$e), require$$3 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$9), require$$4 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$k), require$$5 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$d), require$$6 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$7), require$$7 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$5), require$$8 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$i), require$$9 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$l), require$$10 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$8), require$$11 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$2), require$$12 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$6), require$$13 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$j), require$$14 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$h), require$$15 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$b), require$$16 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$f), require$$17 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$a), require$$18 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$1), require$$19 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$4), require$$20 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$3);
(function(l) {
  var t = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(X, fe, k, p) {
    p === void 0 && (p = k), Object.defineProperty(X, p, { enumerable: !0, get: function() {
      return fe[k];
    } });
  } : function(X, fe, k, p) {
    p === void 0 && (p = k), X[p] = fe[k];
  }), s = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(X, fe) {
    Object.defineProperty(X, "default", { enumerable: !0, value: fe });
  } : function(X, fe) {
    X.default = fe;
  }), h = commonjsGlobal && commonjsGlobal.__importStar || function(X) {
    if (X && X.__esModule)
      return X;
    var fe = {};
    if (X != null)
      for (var k in X)
        k !== "default" && Object.prototype.hasOwnProperty.call(X, k) && t(fe, X, k);
    return s(fe, X), fe;
  };
  Object.defineProperty(l, "__esModule", { value: !0 }), l.formatBytes32String = l.Utf8ErrorFuncs = l.toUtf8String = l.toUtf8CodePoints = l.toUtf8Bytes = l._toEscapedUtf8String = l.nameprep = l.hexDataSlice = l.hexDataLength = l.hexZeroPad = l.hexValue = l.hexStripZeros = l.hexConcat = l.isHexString = l.hexlify = l.base64 = l.base58 = l.TransactionDescription = l.LogDescription = l.Interface = l.SigningKey = l.HDNode = l.defaultPath = l.isBytesLike = l.isBytes = l.zeroPad = l.stripZeros = l.concat = l.arrayify = l.shallowCopy = l.resolveProperties = l.getStatic = l.defineReadOnly = l.deepCopy = l.checkProperties = l.poll = l.fetchJson = l._fetchData = l.RLP = l.Logger = l.checkResultErrors = l.FormatTypes = l.ParamType = l.FunctionFragment = l.EventFragment = l.ErrorFragment = l.ConstructorFragment = l.Fragment = l.defaultAbiCoder = l.AbiCoder = void 0, l.Indexed = l.Utf8ErrorReason = l.UnicodeNormalizationForm = l.SupportedAlgorithm = l.mnemonicToSeed = l.isValidMnemonic = l.entropyToMnemonic = l.mnemonicToEntropy = l.getAccountPath = l.verifyTypedData = l.verifyMessage = l.recoverPublicKey = l.computePublicKey = l.recoverAddress = l.computeAddress = l.getJsonWalletAddress = l.TransactionTypes = l.serializeTransaction = l.parseTransaction = l.accessListify = l.joinSignature = l.splitSignature = l.soliditySha256 = l.solidityKeccak256 = l.solidityPack = l.shuffled = l.randomBytes = l.sha512 = l.sha256 = l.ripemd160 = l.keccak256 = l.computeHmac = l.commify = l.parseUnits = l.formatUnits = l.parseEther = l.formatEther = l.isAddress = l.getCreate2Address = l.getContractAddress = l.getIcapAddress = l.getAddress = l._TypedDataEncoder = l.id = l.isValidName = l.namehash = l.hashMessage = l.dnsEncode = l.parseBytes32String = void 0;
  var m = require$$0;
  Object.defineProperty(l, "AbiCoder", { enumerable: !0, get: function() {
    return m.AbiCoder;
  } }), Object.defineProperty(l, "checkResultErrors", { enumerable: !0, get: function() {
    return m.checkResultErrors;
  } }), Object.defineProperty(l, "ConstructorFragment", { enumerable: !0, get: function() {
    return m.ConstructorFragment;
  } }), Object.defineProperty(l, "defaultAbiCoder", { enumerable: !0, get: function() {
    return m.defaultAbiCoder;
  } }), Object.defineProperty(l, "ErrorFragment", { enumerable: !0, get: function() {
    return m.ErrorFragment;
  } }), Object.defineProperty(l, "EventFragment", { enumerable: !0, get: function() {
    return m.EventFragment;
  } }), Object.defineProperty(l, "FormatTypes", { enumerable: !0, get: function() {
    return m.FormatTypes;
  } }), Object.defineProperty(l, "Fragment", { enumerable: !0, get: function() {
    return m.Fragment;
  } }), Object.defineProperty(l, "FunctionFragment", { enumerable: !0, get: function() {
    return m.FunctionFragment;
  } }), Object.defineProperty(l, "Indexed", { enumerable: !0, get: function() {
    return m.Indexed;
  } }), Object.defineProperty(l, "Interface", { enumerable: !0, get: function() {
    return m.Interface;
  } }), Object.defineProperty(l, "LogDescription", { enumerable: !0, get: function() {
    return m.LogDescription;
  } }), Object.defineProperty(l, "ParamType", { enumerable: !0, get: function() {
    return m.ParamType;
  } }), Object.defineProperty(l, "TransactionDescription", { enumerable: !0, get: function() {
    return m.TransactionDescription;
  } });
  var d = require$$1;
  Object.defineProperty(l, "getAddress", { enumerable: !0, get: function() {
    return d.getAddress;
  } }), Object.defineProperty(l, "getCreate2Address", { enumerable: !0, get: function() {
    return d.getCreate2Address;
  } }), Object.defineProperty(l, "getContractAddress", { enumerable: !0, get: function() {
    return d.getContractAddress;
  } }), Object.defineProperty(l, "getIcapAddress", { enumerable: !0, get: function() {
    return d.getIcapAddress;
  } }), Object.defineProperty(l, "isAddress", { enumerable: !0, get: function() {
    return d.isAddress;
  } });
  var v = h(require$$2);
  l.base64 = v;
  var _ = require$$3;
  Object.defineProperty(l, "base58", { enumerable: !0, get: function() {
    return _.Base58;
  } });
  var T = require$$4;
  Object.defineProperty(l, "arrayify", { enumerable: !0, get: function() {
    return T.arrayify;
  } }), Object.defineProperty(l, "concat", { enumerable: !0, get: function() {
    return T.concat;
  } }), Object.defineProperty(l, "hexConcat", { enumerable: !0, get: function() {
    return T.hexConcat;
  } }), Object.defineProperty(l, "hexDataSlice", { enumerable: !0, get: function() {
    return T.hexDataSlice;
  } }), Object.defineProperty(l, "hexDataLength", { enumerable: !0, get: function() {
    return T.hexDataLength;
  } }), Object.defineProperty(l, "hexlify", { enumerable: !0, get: function() {
    return T.hexlify;
  } }), Object.defineProperty(l, "hexStripZeros", { enumerable: !0, get: function() {
    return T.hexStripZeros;
  } }), Object.defineProperty(l, "hexValue", { enumerable: !0, get: function() {
    return T.hexValue;
  } }), Object.defineProperty(l, "hexZeroPad", { enumerable: !0, get: function() {
    return T.hexZeroPad;
  } }), Object.defineProperty(l, "isBytes", { enumerable: !0, get: function() {
    return T.isBytes;
  } }), Object.defineProperty(l, "isBytesLike", { enumerable: !0, get: function() {
    return T.isBytesLike;
  } }), Object.defineProperty(l, "isHexString", { enumerable: !0, get: function() {
    return T.isHexString;
  } }), Object.defineProperty(l, "joinSignature", { enumerable: !0, get: function() {
    return T.joinSignature;
  } }), Object.defineProperty(l, "zeroPad", { enumerable: !0, get: function() {
    return T.zeroPad;
  } }), Object.defineProperty(l, "splitSignature", { enumerable: !0, get: function() {
    return T.splitSignature;
  } }), Object.defineProperty(l, "stripZeros", { enumerable: !0, get: function() {
    return T.stripZeros;
  } });
  var z = require$$5;
  Object.defineProperty(l, "_TypedDataEncoder", { enumerable: !0, get: function() {
    return z._TypedDataEncoder;
  } }), Object.defineProperty(l, "dnsEncode", { enumerable: !0, get: function() {
    return z.dnsEncode;
  } }), Object.defineProperty(l, "hashMessage", { enumerable: !0, get: function() {
    return z.hashMessage;
  } }), Object.defineProperty(l, "id", { enumerable: !0, get: function() {
    return z.id;
  } }), Object.defineProperty(l, "isValidName", { enumerable: !0, get: function() {
    return z.isValidName;
  } }), Object.defineProperty(l, "namehash", { enumerable: !0, get: function() {
    return z.namehash;
  } });
  var J = require$$6;
  Object.defineProperty(l, "defaultPath", { enumerable: !0, get: function() {
    return J.defaultPath;
  } }), Object.defineProperty(l, "entropyToMnemonic", { enumerable: !0, get: function() {
    return J.entropyToMnemonic;
  } }), Object.defineProperty(l, "getAccountPath", { enumerable: !0, get: function() {
    return J.getAccountPath;
  } }), Object.defineProperty(l, "HDNode", { enumerable: !0, get: function() {
    return J.HDNode;
  } }), Object.defineProperty(l, "isValidMnemonic", { enumerable: !0, get: function() {
    return J.isValidMnemonic;
  } }), Object.defineProperty(l, "mnemonicToEntropy", { enumerable: !0, get: function() {
    return J.mnemonicToEntropy;
  } }), Object.defineProperty(l, "mnemonicToSeed", { enumerable: !0, get: function() {
    return J.mnemonicToSeed;
  } });
  var Y = require$$7;
  Object.defineProperty(l, "getJsonWalletAddress", { enumerable: !0, get: function() {
    return Y.getJsonWalletAddress;
  } });
  var ie = require$$8;
  Object.defineProperty(l, "keccak256", { enumerable: !0, get: function() {
    return ie.keccak256;
  } });
  var ne = require$$9;
  Object.defineProperty(l, "Logger", { enumerable: !0, get: function() {
    return ne.Logger;
  } });
  var de = require$$10;
  Object.defineProperty(l, "computeHmac", { enumerable: !0, get: function() {
    return de.computeHmac;
  } }), Object.defineProperty(l, "ripemd160", { enumerable: !0, get: function() {
    return de.ripemd160;
  } }), Object.defineProperty(l, "sha256", { enumerable: !0, get: function() {
    return de.sha256;
  } }), Object.defineProperty(l, "sha512", { enumerable: !0, get: function() {
    return de.sha512;
  } });
  var ce = require$$11;
  Object.defineProperty(l, "solidityKeccak256", { enumerable: !0, get: function() {
    return ce.keccak256;
  } }), Object.defineProperty(l, "solidityPack", { enumerable: !0, get: function() {
    return ce.pack;
  } }), Object.defineProperty(l, "soliditySha256", { enumerable: !0, get: function() {
    return ce.sha256;
  } });
  var re = require$$12;
  Object.defineProperty(l, "randomBytes", { enumerable: !0, get: function() {
    return re.randomBytes;
  } }), Object.defineProperty(l, "shuffled", { enumerable: !0, get: function() {
    return re.shuffled;
  } });
  var oe = require$$13;
  Object.defineProperty(l, "checkProperties", { enumerable: !0, get: function() {
    return oe.checkProperties;
  } }), Object.defineProperty(l, "deepCopy", { enumerable: !0, get: function() {
    return oe.deepCopy;
  } }), Object.defineProperty(l, "defineReadOnly", { enumerable: !0, get: function() {
    return oe.defineReadOnly;
  } }), Object.defineProperty(l, "getStatic", { enumerable: !0, get: function() {
    return oe.getStatic;
  } }), Object.defineProperty(l, "resolveProperties", { enumerable: !0, get: function() {
    return oe.resolveProperties;
  } }), Object.defineProperty(l, "shallowCopy", { enumerable: !0, get: function() {
    return oe.shallowCopy;
  } });
  var pe = h(require$$14);
  l.RLP = pe;
  var ae = require$$15;
  Object.defineProperty(l, "computePublicKey", { enumerable: !0, get: function() {
    return ae.computePublicKey;
  } }), Object.defineProperty(l, "recoverPublicKey", { enumerable: !0, get: function() {
    return ae.recoverPublicKey;
  } }), Object.defineProperty(l, "SigningKey", { enumerable: !0, get: function() {
    return ae.SigningKey;
  } });
  var me = require$$16;
  Object.defineProperty(l, "formatBytes32String", { enumerable: !0, get: function() {
    return me.formatBytes32String;
  } }), Object.defineProperty(l, "nameprep", { enumerable: !0, get: function() {
    return me.nameprep;
  } }), Object.defineProperty(l, "parseBytes32String", { enumerable: !0, get: function() {
    return me.parseBytes32String;
  } }), Object.defineProperty(l, "_toEscapedUtf8String", { enumerable: !0, get: function() {
    return me._toEscapedUtf8String;
  } }), Object.defineProperty(l, "toUtf8Bytes", { enumerable: !0, get: function() {
    return me.toUtf8Bytes;
  } }), Object.defineProperty(l, "toUtf8CodePoints", { enumerable: !0, get: function() {
    return me.toUtf8CodePoints;
  } }), Object.defineProperty(l, "toUtf8String", { enumerable: !0, get: function() {
    return me.toUtf8String;
  } }), Object.defineProperty(l, "Utf8ErrorFuncs", { enumerable: !0, get: function() {
    return me.Utf8ErrorFuncs;
  } });
  var ge = require$$17;
  Object.defineProperty(l, "accessListify", { enumerable: !0, get: function() {
    return ge.accessListify;
  } }), Object.defineProperty(l, "computeAddress", { enumerable: !0, get: function() {
    return ge.computeAddress;
  } }), Object.defineProperty(l, "parseTransaction", { enumerable: !0, get: function() {
    return ge.parse;
  } }), Object.defineProperty(l, "recoverAddress", { enumerable: !0, get: function() {
    return ge.recoverAddress;
  } }), Object.defineProperty(l, "serializeTransaction", { enumerable: !0, get: function() {
    return ge.serialize;
  } }), Object.defineProperty(l, "TransactionTypes", { enumerable: !0, get: function() {
    return ge.TransactionTypes;
  } });
  var we = require$$18;
  Object.defineProperty(l, "commify", { enumerable: !0, get: function() {
    return we.commify;
  } }), Object.defineProperty(l, "formatEther", { enumerable: !0, get: function() {
    return we.formatEther;
  } }), Object.defineProperty(l, "parseEther", { enumerable: !0, get: function() {
    return we.parseEther;
  } }), Object.defineProperty(l, "formatUnits", { enumerable: !0, get: function() {
    return we.formatUnits;
  } }), Object.defineProperty(l, "parseUnits", { enumerable: !0, get: function() {
    return we.parseUnits;
  } });
  var Ee = require$$19;
  Object.defineProperty(l, "verifyMessage", { enumerable: !0, get: function() {
    return Ee.verifyMessage;
  } }), Object.defineProperty(l, "verifyTypedData", { enumerable: !0, get: function() {
    return Ee.verifyTypedData;
  } });
  var Te = require$$20;
  Object.defineProperty(l, "_fetchData", { enumerable: !0, get: function() {
    return Te._fetchData;
  } }), Object.defineProperty(l, "fetchJson", { enumerable: !0, get: function() {
    return Te.fetchJson;
  } }), Object.defineProperty(l, "poll", { enumerable: !0, get: function() {
    return Te.poll;
  } });
  var Ke = require$$10;
  Object.defineProperty(l, "SupportedAlgorithm", { enumerable: !0, get: function() {
    return Ke.SupportedAlgorithm;
  } });
  var Se = require$$16;
  Object.defineProperty(l, "UnicodeNormalizationForm", { enumerable: !0, get: function() {
    return Se.UnicodeNormalizationForm;
  } }), Object.defineProperty(l, "Utf8ErrorReason", { enumerable: !0, get: function() {
    return Se.Utf8ErrorReason;
  } });
})(utils);
Object.defineProperty(SolanaProvider$1, "__esModule", { value: !0 });
SolanaProvider$1.SolanaProvider = void 0;
const face_types_1$2 = dist, web3_js_1 = require$$1$1, utils_1 = utils;
class SolanaProvider {
  constructor(t) {
    this.internal = t;
  }
  async getPublicKeys() {
    return (await this.internal.getAddresses(face_types_1$2.Blockchain.SOLANA)).map((s) => new web3_js_1.PublicKey(utils_1.base58.decode(s)));
  }
  async signAndSendTransaction(t) {
    const s = {
      serializedHex: t.serialize({
        requireAllSignatures: !1,
        verifySignatures: !1
      }).toString("hex")
    };
    return await this.internal.sendRpc({
      method: "solana_sendTransaction",
      params: [s]
    });
  }
}
SolanaProvider$1.SolanaProvider = SolanaProvider;
Object.defineProperty(Solana$1, "__esModule", { value: !0 });
Solana$1.Solana = void 0;
const SolanaProvider_1 = SolanaProvider$1;
class Solana {
  constructor(t) {
    this.internal = t;
  }
  getProvider() {
    return new SolanaProvider_1.SolanaProvider(this.internal);
  }
}
Solana$1.Solana = Solana;
var internal = {}, iframe = {};
Object.defineProperty(iframe, "__esModule", { value: !0 });
iframe.Iframe = void 0;
const face_types_1$1 = dist, overlayStyles = {
  display: "none",
  position: "fixed",
  top: "0",
  right: "0",
  width: "100%",
  height: "100%",
  borderRadius: "0",
  border: "none",
  zIndex: "2147483647"
};
function applyOverlayStyles(l) {
  for (const [t, s] of Object.entries(overlayStyles))
    l.style[t] = s;
}
class Ready {
  constructor() {
    this._isCompleted = !1, this._eventListeners = Array(), this.complete = () => {
      this._isCompleted = !0, this._eventListeners.forEach((t) => t());
    }, this.add = (t) => {
      this._eventListeners.push(t);
    }, this.isCompleted = () => this._isCompleted;
  }
}
class Iframe {
  constructor(t, s, h, m) {
    this._ready = new Ready(), this.requestIndex = 0, this.activeElement = null, this._blockchain = s, this._env = h;
    const d = Math.random().toString();
    if (this.randomPrefix = d.substring(d.length - 6), document.getElementById("face-iframe"))
      throw new Error("Face is already initialized, Face can be initialized once.");
    window.addEventListener("message", async (v) => {
      v.origin === m && await this.processMessage(v.data);
    }), this._iframe = new Promise((v) => {
      const _ = () => {
        if (!document.getElementById("face-iframe")) {
          const T = document.createElement("iframe");
          T.id = "face-iframe", T.title = "Secure Modal", T.src = new URL(`${m}?api_key=${t}&blockchain=${s}&env=${h}`).href, T.allow = "clipboard-read; clipboard-write", applyOverlayStyles(T), document.body.appendChild(T), v(T);
        }
      };
      ["loaded", "interactive", "complete"].includes(document.readyState) ? _() : window.addEventListener("load", _, !1);
    });
  }
  async sendChildMessage(t) {
    var s, h;
    await this.ready(), this.requestIndex += 1;
    const m = `${this.randomPrefix}-${this.requestIndex}`;
    return t.id = m, t.from = face_types_1$1.JsonRpcSource.FACE_SDK, (h = (s = await this._iframe) === null || s === void 0 ? void 0 : s.contentWindow) === null || h === void 0 || h.postMessage(t, "*"), m;
  }
  waitForResponse(t) {
    return new Promise((s, h) => {
      const m = (d) => {
        const v = d.data;
        t && v.id !== t || (window.removeEventListener("message", m), v.error && h(v.error), s(v.result));
      };
      window.addEventListener("message", m);
    });
  }
  async processMessage(t) {
    switch (t.method) {
      case face_types_1$1.JsonRpcMethod.face_ready:
        this._ready.complete();
        break;
      case face_types_1$1.JsonRpcMethod.face_openIframe:
        await this.showOverlay();
        break;
      case face_types_1$1.JsonRpcMethod.face_closeIframe:
        await this.hideOverlay();
        break;
    }
  }
  async ready() {
    return new Promise(async (t) => {
      if (this._ready.isCompleted()) {
        t();
        return;
      }
      this._ready.add(() => {
        t();
      });
    });
  }
  async showOverlay() {
    await this.ready();
    const t = await this._iframe;
    t.style.display = "block", this.activeElement = document.activeElement, t.focus();
  }
  async hideOverlay() {
    var t;
    await this.ready();
    const s = await this._iframe;
    s.style.display = "none", !((t = this.activeElement) === null || t === void 0) && t.focus && this.activeElement.focus(), this.activeElement = null;
  }
  setBlockchain(t) {
    this._blockchain = t;
  }
}
iframe.Iframe = Iframe;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal)
    return internal;
  hasRequiredInternal = 1, Object.defineProperty(internal, "__esModule", { value: !0 }), internal.Internal = void 0;
  const l = dist, t = require$$1$3, s = requireFace(), h = iframe, m = t.BigNumber.from(1e5).toHexString();
  class d {
    constructor({ apiKey: _, network: T, env: z, iframeUrl: J, face: Y }) {
      const ie = this.getBlockchainFromNetwork(T), ne = z != null ? z : this.getDefaultEnv(T);
      this.iframe = new h.Iframe(_, ie, ne, this.getIframeUrl(ne, J)), this.face = Y;
    }
    async getAddresses(_) {
      const T = await this.iframe.sendChildMessage({
        method: l.JsonRpcMethod.face_accounts,
        params: [_]
      }), z = await this.iframe.waitForResponse(T);
      return z || Promise.reject(new Error("get address failed"));
    }
    async estimateGas(_) {
      return await Promise.all(_.params.map(async (T) => {
        if (T.from)
          if (T.data) {
            const z = [
              "function transfer(address to, uint256 value) public returns (bool success)"
            ], { name: J, args: Y } = await this.decodeData(T.data, z).catch(() => ({}));
            if ((Y == null ? void 0 : Y.to) && (Y == null ? void 0 : Y.value)) {
              const ie = await this.getBalance(T.from, T.to), ne = { to: Y.to, value: Y.value };
              ie.sub(ne.value).lt(0) && (ne.value = "0x0"), T.data = await this.encodeData(z, J, [ne.to, ne.value]);
            }
          } else
            (await this.getBalance(T.from)).sub(T.value).lt(0) && (T.value = "0x0");
      })), await this.sendRpc(_).catch(() => m);
    }
    async getBalance(_, T) {
      if (T) {
        const z = await this.encodeData(["function balanceOf(address owner) view returns (uint256)"], "balanceOf", [_]), J = await this.sendRpc({
          method: l.JsonRpcMethod.eth_call,
          params: [
            {
              to: T,
              data: z
            },
            "latest"
          ]
        });
        return t.BigNumber.from(J);
      }
      return t.BigNumber.from(await this.sendRpc({
        method: l.JsonRpcMethod.eth_getBalance,
        params: [_, "latest"]
      }));
    }
    async ownerOf(_, T) {
      const z = await this.encodeData(["function ownerOf(uint256 tokenId) view returns (address)"], "ownerOf", [T]);
      return ("0x" + (await this.sendRpc({
        method: l.JsonRpcMethod.eth_call,
        params: [
          {
            to: _,
            data: z
          },
          "latest"
        ]
      })).substring(26)).toLowerCase();
    }
    async logout() {
      const _ = await this.iframe.sendChildMessage({
        method: l.JsonRpcMethod.face_logOut
      });
      await this.iframe.waitForResponse(_);
    }
    async getCurrentUser() {
      const _ = await this.iframe.sendChildMessage({
        method: l.JsonRpcMethod.face_currentUser
      });
      return await this.iframe.waitForResponse(_);
    }
    async isLoggedIn() {
      await this.iframe.sendChildMessage({
        method: l.JsonRpcMethod.face_loggedIn
      });
      const _ = await this.iframe.waitForResponse();
      return _ || !1;
    }
    async ready() {
      return this.iframe.ready();
    }
    async loginWithCredential() {
      const _ = await this.iframe.sendChildMessage({
        method: l.JsonRpcMethod.face_logInSignUp
      });
      return await this.iframe.waitForResponse(_);
    }
    async directSocialLogin(_) {
      const T = await this.iframe.sendChildMessage({
        method: l.JsonRpcMethod.face_directSocialLogin,
        params: [_]
      });
      return await this.iframe.waitForResponse(T);
    }
    async loginWithIdToken(_) {
      const T = await this.iframe.sendChildMessage({
        method: l.JsonRpcMethod.face_loginWithIdToken,
        params: [_]
      });
      return await this.iframe.waitForResponse(T);
    }
    async openWalletConnect(_, T) {
      await this.iframe.sendChildMessage({
        method: l.JsonRpcMethod.face_openWalletConnect,
        params: [_, T]
      });
    }
    async openHome() {
      await this.iframe.sendChildMessage({
        method: l.JsonRpcMethod.face_openHome
      });
    }
    async sendRpc(_) {
      const T = await this.iframe.sendChildMessage(_);
      return await this.iframe.waitForResponse(T);
    }
    getBlockchainFromNetwork(_) {
      switch (_) {
        case s.Network.ETHEREUM:
        case s.Network.GOERLI:
          return l.Blockchain.ETHEREUM;
        case s.Network.POLYGON:
        case s.Network.MUMBAI:
          return l.Blockchain.POLYGON;
        case s.Network.BNB_SMART_CHAIN:
        case s.Network.BNB_SMART_CHAIN_TESTNET:
          return l.Blockchain.BNB_SMART_CHAIN;
        case s.Network.KLAYTN:
        case s.Network.BAOBAB:
          return l.Blockchain.KLAYTN;
        case s.Network.SOLANA:
        case s.Network.SOLANA_DEVNET:
          return l.Blockchain.SOLANA;
        case s.Network.BORA:
        case s.Network.BORA_TESTNET:
          return l.Blockchain.BORA;
        case s.Network.NEAR:
        case s.Network.NEAR_TESTNET:
          return l.Blockchain.NEAR;
        default:
          return l.Blockchain.ETHEREUM;
      }
    }
    getIframeUrl(_, T) {
      if (T != null)
        return T;
      switch (_) {
        case l.Env.Local:
          return "http://localhost:3333";
        case l.Env.Dev:
          return "https://app.dev.facewallet.xyz";
        case l.Env.StageTest:
          return "https://app.stage-test.facewallet.xyz";
        case l.Env.ProdTest:
          return "https://app.test.facewallet.xyz";
        case l.Env.StageMainnet:
          return "https://app.stage.facewallet.xyz";
        case l.Env.ProdMainnet:
          return "https://app.facewallet.xyz";
        default:
          return "https://app.facewallet.xyz";
      }
    }
    getDefaultEnv(_) {
      return _ && (_ === s.Network.GOERLI || _ === s.Network.MUMBAI || _ === s.Network.BAOBAB || _ === s.Network.BNB_SMART_CHAIN_TESTNET || _ === s.Network.BORA_TESTNET || _ === s.Network.SOLANA_DEVNET || _ === s.Network.NEAR_TESTNET) ? l.Env.ProdTest : l.Env.ProdMainnet;
    }
    async decodeData(_, T) {
      const z = new t.ethers.utils.Interface(T), { name: J, args: Y } = z.parseTransaction({ data: _ });
      return { name: J, args: Y };
    }
    async encodeData(_, T, z) {
      return new t.ethers.utils.Interface(_).encodeFunctionData(T, z);
    }
    async switchNetwork(_) {
      const T = this.getBlockchainFromNetwork(_), z = {
        method: l.JsonRpcMethod.face_switchNetwork,
        params: [{ blockchain: T }]
      }, J = await this.sendRpc(z);
      return this.face.setNetwork(_), this.iframe.setBlockchain(T), J;
    }
  }
  return internal.Internal = d, internal;
}
var provider = {};
Object.defineProperty(provider, "__esModule", { value: !0 });
provider.Provider = void 0;
const face_types_1 = dist;
class ProviderTemplate {
  constructor() {
    this.sendAsync = (t, s) => {
    };
  }
}
class Provider extends ProviderTemplate {
  constructor(t) {
    super(), this.internal = t;
  }
  async request(t) {
    if (Array.isArray(t))
      return Promise.all(t.map((s) => this.internal.sendRpc(s)));
    switch (t.method) {
      case face_types_1.JsonRpcMethod.wallet_switchEthereumChain:
        const s = face_types_1.NetworkChainIdMap[t.params[0].chainId];
        return this.internal.switchNetwork(s);
      case face_types_1.JsonRpcMethod.eth_estimateGas:
        return this.internal.estimateGas(t);
      case "personal_listAccounts":
      case "eth_accounts":
        return this.internal.getAddresses();
      default:
        return this.internal.sendRpc(t);
    }
  }
}
provider.Provider = Provider;
var wallet = {};
Object.defineProperty(wallet, "__esModule", { value: !0 });
wallet.Wallet = void 0;
class Wallet {
  constructor(t) {
    this.internal = t;
  }
  close() {
    this.internal.iframe.hideOverlay();
  }
  async home() {
    return this.internal.openHome();
  }
}
wallet.Wallet = Wallet;
var walletConnect = {};
Object.defineProperty(walletConnect, "__esModule", { value: !0 });
walletConnect.WalletConnect = void 0;
class WalletConnect {
  constructor(t) {
    this.internal = t;
  }
  async connectOpensea(t) {
    await this.connect("OpenSea", t ? "https://opensea.io/collection/" + t : "https://opensea.io");
  }
  async connect(t, s) {
    await this.internal.openWalletConnect(t, s);
  }
}
walletConnect.WalletConnect = WalletConnect;
var hasRequiredFace;
function requireFace() {
  return hasRequiredFace || (hasRequiredFace = 1, function(l) {
    var t = commonjsGlobal && commonjsGlobal.__rest || function(Y, ie) {
      var ne = {};
      for (var de in Y)
        Object.prototype.hasOwnProperty.call(Y, de) && ie.indexOf(de) < 0 && (ne[de] = Y[de]);
      if (Y != null && typeof Object.getOwnPropertySymbols == "function")
        for (var ce = 0, de = Object.getOwnPropertySymbols(Y); ce < de.length; ce++)
          ie.indexOf(de[ce]) < 0 && Object.prototype.propertyIsEnumerable.call(Y, de[ce]) && (ne[de[ce]] = Y[de[ce]]);
      return ne;
    };
    Object.defineProperty(l, "__esModule", { value: !0 }), l.Face = l.Network = void 0;
    const s = dist;
    Object.defineProperty(l, "Network", { enumerable: !0, get: function() {
      return s.Network;
    } });
    const h = auth, m = Near$1, d = Solana$1, v = requireInternal(), _ = provider, T = wallet, z = walletConnect;
    class J {
      constructor(ie) {
        var { apiKey: ne, network: de } = ie, ce = t(ie, ["apiKey", "network"]);
        if (this.getAddresses = async (re) => await this.internal.getAddresses(re), this.setNetwork = (re) => {
          this.network = re;
        }, this.getNetwork = () => this.network, this.getChainId = async () => Number(await this.internal.sendRpc({ method: "eth_chainId", params: [] })), de = de || s.Network.ETHEREUM, !(0, s.isSupportedNetwork)(de))
          throw (0, s.unsupportedChainError)();
        this.network = de, this.internal = new v.Internal({
          apiKey: ne,
          network: de,
          env: ce.env,
          iframeUrl: ce.iframeUrl,
          face: this
        }), this.auth = new h.Auth(this.internal), this.wc = new z.WalletConnect(this.internal), this.solana = new d.Solana(this.internal), this.near = new m.Near(this.internal), this.wallet = new T.Wallet(this.internal);
      }
      async ready() {
        return this.internal.ready();
      }
      getEthLikeProvider() {
        return new _.Provider(this.internal);
      }
      async switchNetwork(ie) {
        return this.internal.switchNetwork(ie);
      }
    }
    l.Face = J;
  }(face)), face;
}
(function(l) {
  var t = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(h, m, d, v) {
    v === void 0 && (v = d);
    var _ = Object.getOwnPropertyDescriptor(m, d);
    (!_ || ("get" in _ ? !m.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return m[d];
    } }), Object.defineProperty(h, v, _);
  } : function(h, m, d, v) {
    v === void 0 && (v = d), h[v] = m[d];
  }), s = commonjsGlobal && commonjsGlobal.__exportStar || function(h, m) {
    for (var d in h)
      d !== "default" && !Object.prototype.hasOwnProperty.call(m, d) && t(m, h, d);
  };
  Object.defineProperty(l, "__esModule", { value: !0 }), s(requireFace(), l);
})(dist$1);
const btn = "_btn_1ij5m_5", active$1 = "_active_1ij5m_19", can_not_switch = "_can_not_switch_1ij5m_36", styles$3 = {
  btn,
  active: active$1,
  can_not_switch
}, ChainButton = ({
  chain: l,
  loading: t,
  disabled: s,
  isActive: h,
  canSwitchChain: m,
  onClick: d
}) => {
  const {
    name: v,
    chainId: _
  } = l;
  let T = h ? styles$3.active : styles$3.btn;
  const z = m && !h;
  let J;
  return z ? J = () => d() : (T = `${T} ${styles$3.can_not_switch}`, J = () => {
  }), /* @__PURE__ */ jsx(Button, {
    block: !0,
    className: T,
    disabled: t || s,
    icon: getChainIconOld(_, 23, 23),
    onClick: J,
    children: v
  });
}, ChainButtonWithLogic = ({
  chain: l,
  loading: t,
  connectedChainId: s,
  expectedChainId: h,
  canSwitchChain: m,
  onClick: d
}) => {
  const {
    chainId: v
  } = l, _ = v === s;
  let T;
  return !_ && h && (T = v !== h), /* @__PURE__ */ jsx(ChainButton, {
    onClick: d,
    loading: t,
    disabled: T,
    isActive: _,
    canSwitchChain: m,
    chain: l
  });
}, button = "_button_1evvb_5", wallet_name = "_wallet_name_1evvb_18", acc = "_acc_1evvb_27", cnn = "_cnn_1evvb_37", active = "_active_1evvb_47", disabled = "_disabled_1evvb_55", loading = "_loading_1evvb_58", spinner$1 = "_spinner_1evvb_66", styles$2 = {
  button,
  wallet_name,
  acc,
  cnn,
  active,
  disabled,
  loading,
  spinner: spinner$1
}, spinner = /* @__PURE__ */ jsx(Spin, {
  className: styles$2.spinner,
  indicator: /* @__PURE__ */ jsx(LoadingOutlined$1, {
    style: {
      fontSize: 24
    },
    spin: !0
  })
}), ConnectButton = ({
  account: l,
  onClick: t,
  walletIcon: s,
  walletName: h,
  labelText: m,
  loading: d,
  disabled: v
}) => {
  let _, T = styles$2.button;
  l ? (_ = /* @__PURE__ */ jsx("span", {
    className: styles$2.acc,
    children: toMasskedAddress(l)
  }), T = `${T} ${styles$2.active}`) : d ? (_ = spinner, T = `${T} ${styles$2.loading}`) : v ? (_ = /* @__PURE__ */ jsx("span", {
    className: styles$2.cnn,
    children: m
  }), T = `${T} ${styles$2.disabled}`) : _ = /* @__PURE__ */ jsx("span", {
    className: styles$2.cnn,
    children: m
  });
  let z = t;
  return (l || d || v) && (z = void 0), /* @__PURE__ */ jsxs("div", {
    onClick: z,
    className: T,
    children: [s, /* @__PURE__ */ jsx("span", {
      className: styles$2.wallet_name,
      children: h
    }), _]
  });
}, Svg$1 = () => /* @__PURE__ */ jsxs("svg", {
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: [/* @__PURE__ */ jsx("path", {
    d: "M29.5057 2.09412L17.7998 10.7882L19.9645 5.65882L29.5057 2.09412Z",
    fill: "#E2761B",
    stroke: "#E2761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M2.48242 2.09412L14.0942 10.8706L12.0354 5.65882L2.48242 2.09412Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M25.2944 22.2471L22.1768 27.0235L28.8473 28.8588L30.765 22.353L25.2944 22.2471Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M1.24707 22.353L3.15295 28.8588L9.82354 27.0235L6.70589 22.2471L1.24707 22.353Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M9.44671 14.1764L7.58789 16.9882L14.2114 17.2823L13.9761 10.1647L9.44671 14.1764Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M22.541 14.1765L17.9527 10.0823L17.7998 17.2823L24.4116 16.9882L22.541 14.1765Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M9.82324 27.0236L13.7997 25.0824L10.3644 22.4L9.82324 27.0236Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M18.1885 25.0824L22.1767 27.0236L21.6238 22.4L18.1885 25.0824Z",
    fill: "#E4761B",
    stroke: "#E4761B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M22.1767 27.0236L18.1885 25.0824L18.5061 27.6824L18.4708 28.7765L22.1767 27.0236Z",
    fill: "#D7C1B3",
    stroke: "#D7C1B3",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M9.82422 27.0236L13.5301 28.7765L13.5066 27.6824L13.8007 25.0824L9.82422 27.0236Z",
    fill: "#D7C1B3",
    stroke: "#D7C1B3",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M13.5882 20.6824L10.2705 19.7059L12.6117 18.6353L13.5882 20.6824Z",
    fill: "#233447",
    stroke: "#233447",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M18.4004 20.6824L19.3769 18.6353L21.7298 19.7059L18.4004 20.6824Z",
    fill: "#233447",
    stroke: "#233447",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M9.8237 27.0235L10.3884 22.2471L6.70605 22.353L9.8237 27.0235Z",
    fill: "#CD6116",
    stroke: "#CD6116",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M21.6123 22.2471L22.177 27.0235L25.2947 22.353L21.6123 22.2471Z",
    fill: "#CD6116",
    stroke: "#CD6116",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M24.4116 16.9882L17.7998 17.2823L18.4116 20.6823L19.388 18.6353L21.741 19.7059L24.4116 16.9882Z",
    fill: "#CD6116",
    stroke: "#CD6116",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M10.2702 19.7059L12.6232 18.6353L13.5879 20.6823L14.2114 17.2823L7.58789 16.9882L10.2702 19.7059Z",
    fill: "#CD6116",
    stroke: "#CD6116",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M7.58887 16.9883L10.3653 22.4L10.2712 19.7059L7.58887 16.9883Z",
    fill: "#E4751F",
    stroke: "#E4751F",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M21.7417 19.7059L21.624 22.4L24.4123 16.9883L21.7417 19.7059Z",
    fill: "#E4751F",
    stroke: "#E4751F",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M14.2124 17.2824L13.5889 20.6824L14.3653 24.6942L14.5418 19.4118L14.2124 17.2824Z",
    fill: "#E4751F",
    stroke: "#E4751F",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M17.801 17.2824L17.4834 19.4001L17.6246 24.6942L18.4128 20.6824L17.801 17.2824Z",
    fill: "#E4751F",
    stroke: "#E4751F",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M18.4123 20.6823L17.624 24.6941L18.1887 25.0823L21.624 22.4L21.7417 19.7059L18.4123 20.6823Z",
    fill: "#F6851B",
    stroke: "#F6851B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M10.2705 19.7059L10.3646 22.4L13.7999 25.0823L14.3646 24.6941L13.5882 20.6823L10.2705 19.7059Z",
    fill: "#F6851B",
    stroke: "#F6851B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M18.4703 28.7765L18.5056 27.6824L18.2115 27.4236H13.7762L13.5056 27.6824L13.5291 28.7765L9.82324 27.0236L11.1174 28.0824L13.7409 29.9059H18.2468L20.8821 28.0824L22.1762 27.0236L18.4703 28.7765Z",
    fill: "#C0AD9E",
    stroke: "#C0AD9E",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M18.1882 25.0823L17.6235 24.6941H14.3647L13.8 25.0823L13.5059 27.6823L13.7764 27.4235H18.2117L18.5059 27.6823L18.1882 25.0823Z",
    fill: "#161616",
    stroke: "#161616",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M30.0002 11.3529L31.0002 6.55294L29.5061 2.09412L18.1885 10.4941L22.5414 14.1765L28.6944 15.9765L30.0591 14.3882L29.4708 13.9647L30.412 13.1059L29.6826 12.5412L30.6238 11.8235L30.0002 11.3529Z",
    fill: "#763D16",
    stroke: "#763D16",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M1 6.55294L2 11.3529L1.36471 11.8235L2.30588 12.5412L1.58824 13.1059L2.52941 13.9647L1.94118 14.3882L3.29412 15.9765L9.44706 14.1765L13.8 10.4941L2.48235 2.09412L1 6.55294Z",
    fill: "#763D16",
    stroke: "#763D16",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M28.6946 15.9765L22.5417 14.1765L24.4123 16.9882L21.624 22.4L25.2946 22.3529H30.7652L28.6946 15.9765Z",
    fill: "#F6851B",
    stroke: "#F6851B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M9.44707 14.1765L3.29413 15.9765L1.24707 22.3529H6.70589L10.3647 22.4L7.58825 16.9882L9.44707 14.1765Z",
    fill: "#F6851B",
    stroke: "#F6851B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ jsx("path", {
    d: "M17.7999 17.2823L18.1881 10.4941L19.9763 5.65881H12.0352L13.7999 10.4941L14.2116 17.2823L14.3528 19.4235L14.3646 24.6941H17.6234L17.6469 19.4235L17.7999 17.2823Z",
    fill: "#F6851B",
    stroke: "#F6851B",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })]
}), MetamaskIcon = /* @__PURE__ */ jsx(Icon, {
  component: Svg$1
}), Svg = () => /* @__PURE__ */ jsx("svg", {
  width: "42",
  height: "32",
  viewBox: "0 0 30 20",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: /* @__PURE__ */ jsx("path", {
    d: "M6.14162 4.39898C11.034 -0.391048 18.9661 -0.391048 23.8584 4.39898L24.4472 4.97546C24.6918 5.21496 24.6918 5.60327 24.4472 5.84277L22.433 7.81482C22.3107 7.93457 22.1124 7.93457 21.9901 7.81482L21.1799 7.02151C17.7668 3.67986 12.2332 3.67986 8.82018 7.02151L7.95246 7.87108C7.83015 7.99083 7.63184 7.99083 7.50953 7.87108L5.49536 5.89903C5.25074 5.65953 5.25074 5.27122 5.49536 5.03172L6.14162 4.39898ZM28.0239 8.47738L29.8165 10.2325C30.0612 10.472 30.0612 10.8603 29.8165 11.0998L21.7335 19.0139C21.4889 19.2534 21.0923 19.2534 20.8476 19.0139C20.8476 19.0139 20.8476 19.0139 20.8476 19.0139L15.1108 13.3971C15.0496 13.3372 14.9505 13.3372 14.8893 13.3971C14.8893 13.3971 14.8893 13.3971 14.8893 13.3971L9.15259 19.0139C8.90797 19.2534 8.51137 19.2534 8.26675 19.0139C8.26674 19.0139 8.26674 19.0139 8.26674 19.0139L0.183463 11.0997C-0.0611544 10.8602 -0.0611544 10.4719 0.183463 10.2324L1.97609 8.47728C2.22071 8.23778 2.61731 8.23778 2.86193 8.47728L8.59887 14.0942C8.66002 14.1541 8.75918 14.1541 8.82033 14.0942C8.82033 14.0942 8.82033 14.0942 8.82033 14.0942L14.557 8.47728C14.8016 8.23777 15.1982 8.23776 15.4428 8.47726C15.4428 8.47726 15.4428 8.47726 15.4428 8.47727L21.1798 14.0942C21.2409 14.1541 21.3401 14.1541 21.4012 14.0942L27.1381 8.47738C27.3827 8.23788 27.7793 8.23788 28.0239 8.47738Z",
    fill: "#3B99FC"
  })
}), WalletConnectIcon = /* @__PURE__ */ jsx(Icon, {
  component: Svg
}), chain_name = "_chain_name_8kdgo_1", styles$1 = {
  chain_name
}, bold = "_bold_5fnjw_5", styles = {
  bold
}, Bold = ({
  className: l,
  children: t
}) => {
  const s = l ? `${l} ${styles.bold}` : styles.bold;
  return /* @__PURE__ */ jsx("span", {
    className: s,
    children: t
  });
}, ChainName = ({
  children: l
}) => /* @__PURE__ */ jsx(Bold, {
  className: styles$1.chain_name,
  children: l
}), Alert = ({
  account: l,
  chain: t,
  supportedChains: s,
  expectedChainId: h
}) => l ? h ? /* @__PURE__ */ jsxs(Fragment$1, {
  children: ["You connected to ", /* @__PURE__ */ jsxs(ChainName, {
    children: [t.name, "."]
  }), /* @__PURE__ */ jsxs("div", {
    children: ["Please connect to ", /* @__PURE__ */ jsx(ChainName, {
      children: getChainName(h)
    }), " network."]
  })]
}) : s.some((m) => m.name === t.name) ? /* @__PURE__ */ jsxs(Fragment$1, {
  children: ["You are currently using ", /* @__PURE__ */ jsx(Bold, {
    children: "Oort Digital"
  }), " on the ", /* @__PURE__ */ jsx(ChainName, {
    children: t.name
  }), " network"]
}) : /* @__PURE__ */ jsxs(Fragment$1, {
  children: ["You connected to ", /* @__PURE__ */ jsxs(ChainName, {
    children: [t.name, "."]
  }), /* @__PURE__ */ jsxs("div", {
    children: ["Please connect to the appropriate network. ", /* @__PURE__ */ jsx(ChainName, {
      children: s.map((m) => m.name).join(", ")
    })]
  })]
}) : null, style = {
  height: "32px",
  width: "32px"
}, FaceWalletIcon = /* @__PURE__ */ jsx("img", {
  style,
  src: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCACQAJADAREAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD+ZGv+28/zgCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP3d/4Iw/8ABG3Uv+CkmveJvif8U/EWu+Af2Yvhrrtv4c1vU/DcUEfi74k+MzZ22qXPgnwhqGoWl7pei2ui6Xe6ZqPi3xHd2WpT2UWr6Lpek6Vc3Wq3Wq+Hv4A+m99NjC/Riy/K+FeE8ty/iHxU4owFTMsDhcznUlk3DGSKvUwlLPc5w2GrUMXjquOxdDFYbJ8so18LCvPB47F4vF0qOEpYTMv1Tw38OZ8Z1a+Ox1arhMkwVVUas6KSxGNxPLGpLDYec4yp040qcoTxFaUZuKqUoU6cpVJTpf2PeGv+CFn/AASn8L6PbaPbfsh+ENWS3Hz6j4l8W/EvxFrF1IVVXmudR1XxpcTkvsDeTD5NrGxYwW8W9gf8Us0+n39LnNcbVxtXxlznBuq9MNleT8L5bgqMbtxhSw2EyOnTSje3PPnrSSXtKk7Jn9F0fC3gOhTjTXD2Hqcv262IxtapJ23lOeJb1tsrRT2SN/8A4cm/8Erv+jMfhl/4MPHH/wA1led/xPT9LX/o93FP/hNkP/znNv8AiGfAn/RN4L/wPFf/ADQH/Dk3/gld/wBGY/DL/wAGHjj/AOayj/ien6Wv/R7uKf8AwmyH/wCc4f8AEM+BP+ibwX/geK/+aA/4cm/8Erv+jMfhl/4MPHH/AM1lH/E9P0tf+j3cU/8AhNkP/wA5w/4hnwJ/0TeC/wDA8V/80B/w5N/4JXf9GY/DL/wYeOP/AJrKP+J6fpa/9Hu4p/8ACbIf/nOH/EM+BP8Aom8F/wCB4r/5oD/hyb/wSu/6Mx+GX/gw8cf/ADWUf8T0/S1/6PdxT/4TZD/85w/4hnwJ/wBE3gv/AAPFf/NAf8OTf+CV3/RmPwy/8GHjj/5rKP8Aien6Wv8A0e7in/wmyH/5zh/xDPgT/om8F/4Hiv8A5oKt7/wRC/4JU39rPZz/ALGnw7jiuEMcj2Wu/ETTbpVJBzBfad4ztb22fjiW2uIpAMgOASDtQ+nf9LjD1qdan428SSnTlzRjXy/hrFUW/wDp5h8TkdWhVj/dq05x620RMvDHgOcXF8OYNJqz5auMhL5ShiYyi/NNM/mS/wCCzf8AwQJ8Nfsl/DXXf2r/ANj/AFHxNqfwf8M3VrJ8VfhD4nvm8Q618ONI1K9jsLbxh4N8STBNX1/wZZXt1YWOu6Prw1XxL4ejnPiOXxBrGhDVR4a/1N+hF+0OzTxh4oy/wh8Z8NlWF40zWlWjwlxllWHWW4HibGYWhLEVclzvLIOWDy7PK9CliMRl+Ny/6pleZSp/2ZDLsFmH1T+1PxPxI8J6OQYKrn/Ds688uoSi8fl9eftquDpzkoRxGGrO1SthoylCNWnV9pXop+2dapS9p7H+Vyv9aj8ICgAoAKACgAoAKACgD/Tl/wCCCnhzRvDv/BKD9k7+x7GKzbXdH+IniPV5E3NJf6zqnxb8eG7vriRyzPK0cNvbR5O2G1tra2jCxQoo/wCV/wDaEZnjsy+l74v/AF2vOusBjeGsswcZWUcPgcJwdw/7GhTiklGClOpVl1nWq1asm5zk3/bfhTRp0eAcg9nFR9rTxlao1vOpPMMXzSb6uyUV2jFJaJH7A1/GB+iBQAUAFABQAUAFABQB5L8fPCWj+PfgX8Z/A/iK1hvtB8Y/Cn4h+F9as7mLzoLnS9e8Javpd/BLFuTzEktrqRWUOhOfldDhh9h4eZxjeHuPuB8+y2tUw+YZLxfw3muBr0p8lSli8vznB4vD1ITtLllGrSi0+WSXWLWj8/NsPTxWV5lha0VKliMBjKFSMldShVw9SE01pdOMn1Xqj/Hzr/s/P88AoAKACgAoAKACgAoA/wBQD/ghf/yih/Y4/wCxL8Z/+rZ+IFf8qH0+f+UvPGv/ALHmR/8ArH8On9weFv8AyQXDn/YNif8A1YYs/Wav4/PvwoAKACgAoAKACgAoA4z4j/8AJPPHn/YmeKP/AEx31e5wz/yUnD3/AGPMp/8AU/DnNjf9zxf/AGDV/wD01M/xzK/7Uz/OkKACgAoAKACgAoAKAP8AUA/4IX/8oof2OP8AsS/Gf/q2fiBX/Kh9Pn/lLzxr/wCx5kf/AKx/Dp/cHhb/AMkFw5/2DYn/ANWGLP1mr+Pz78KAP5hPiF/wcU6B+yz+3X+0r+y7+1L8IdSvfhZ8OPiRceHfAXxP+E0aXXi3SNKj0jTbqO18a+C/EOq2dn4jinurx518QeHtb0e7sbIJAPDGuzOLpP8AVXhv9mtmPiz4A+F/iv4T8ZYahxZxNwxSzLiHhXjCUqWT4zFyxmKpSq5HnmXYOtXyydOlRjTeXZlgMbRxFfmqPNcBCPsZfiGM8YaWRcU51kee5fOWBweNdHCY7AJSxFOmqcJKOJw1apGNZOUm/bUatOUY2XsKr94/V74Uf8Fd/wDgmj8ZtMttS8JftnfAzSTcohGmfEvxfa/B/XY5WQM1s+i/FVfB2oyTRnKN9mt54XZSYJZo9rt/IfF/0NfpRcE4qrhc48EOPsZ7KTTxXC+S1eNMBKCk0qscdwi86w0aclaS9rUpzimlUhCV4r73AeIPBWZQjPD8SZXT5l8GNxEcuqp9vZY/6tNtf3U0+ja1Oq8e/wDBUf8A4Jy/DXTZNV8Uftt/s0vDH96z8K/Frwj8QddxsLhl8NeANS8TeIXRlB2OmlsjthEZnIU+Tw99E/6THFGKjhMp8CvFGM5bV834PznhzAX5lFp5pxFhcqy2Mk370ZYtSiveklFNm+L454OwUPaV+JslaX2aGYYfF1dr/wAHCTr1rdnyWey1Pw6/ao/4OfPhDaeI9A+Gn7D/AMO9V+Kmta74o0HRLv4t/E3S9U8I+B7GwvtdtLK6l8LeCJfsnjbxJfXmnyTLZT+JI/BUOk3c1rdT6Vr0cU+mt/efhJ+yq4yrZZmHFHjxxJhOEsDl+VZhjqPB3C2LwmcZ9XxGHy+tXowzbPoe2yLLMPQxMYOvTyuWezxlGFWlTxmXynTxS/MM+8b8vjWpYLhjBzx9SrXpUpZhjYVMPhYwlVjGToYV8uKrTlBvldZYZU5OMnTqpOB/VxX+RJ+9BQBxnxH/AOSeePP+xM8Uf+mO+r3OGf8AkpOHv+x5lP8A6n4c5sb/ALni/wDsGr/+mpn+OZX/AGpn+dIUAFABQAUAFABQAUAf6gH/AAQv/wCUUP7HH/Yl+M//AFbPxAr/AJUPp8/8peeNf/Y8yP8A9Y/h0/uDwt/5ILhz/sGxP/qwxZ+s1fx+ffhQB/AL/wAHNn7Ffiv4UftbWv7YGiaPNcfCj9pLTPDul69rVrG7Wnh34xeCvDVr4cvNC1EJvisf+Eo8G+HtG8SaLNI0R1m/tPGPlwmTSLmab/oi/ZZeOWUcX+DtXwYx2NhT4v8ADHFZlisvwNWUVWzLgvPM0q5nQx+GbtOv/ZOd5ljssx0IqawOHrZJzTUcbSpw/k3xt4ar4DiCPEVKm3gM5hRhVqRXu0cxw1GNGVKdtI+3w1GlWpt29pOOJsr05N/zJ1/qafiQUAfrv/wRJ/Ys8Sftk/t6fCSH+yJrj4U/A7xN4e+NHxg1mS3eXSrbRfBuqJrXhrwpdvmOOS6+IPinS7Dw1HZLPHdnRZPEOr2ySx6JcqP42+nX445Z4J/R84xn9dp0+LuPcqzLgfgvAxqqGLq47O8JLA5pm9GPvSjS4cynF4jNJV3TlRWOjluCquEsfSZ+heGXDVbiPivL17NvAZXXo5lmNRq9ONLDVFVo0JbJyxdeEKCjdS9m61RXVKR/p31/ysn9uhQBxnxH/wCSeePP+xM8Uf8Apjvq9zhn/kpOHv8AseZT/wCp+HObG/7ni/8AsGr/APpqZ/jmV/2pn+dIUAFABQAUAFABQAUAf6gH/BC//lFD+xx/2JfjP/1bPxAr/lQ+nz/yl541/wDY8yP/ANY/h0/uDwt/5ILhz/sGxP8A6sMWfrNX8fn34UAeVfG34I/Cv9oz4X+Lvgz8avBej+P/AIb+ONNbTPEPhrWoWe3uI1kSe0vbO5heK80vWNLvIoNR0bWtMuLTVdH1O2ttQ067tru3imT67gTjvi3wz4ryfjfgbPMbw7xPkOJWKy3NMDNRqU5OMqdahXpTU6GLwWLoTqYbHYHFU62ExuFq1cNiaNWjUnB8GZ5ZgM5wOIy3MsNTxeCxUOStRqq6aveMoyVpU6lOSU6dWDjUpzjGcJRkkz+O/wDaf/4NSfiDB4j1XWf2Pf2hvB2q+E7u4nutO8CfHyDW/D/iDQbdpVMelxePPBOg+J9O8UskZk8m8vPCHhJlCxW9x9ocyX7f7SeFX7XThyplmEwPjR4b53g84o06dLE5/wCHtTA5lluYVFFqWLnw/nuYZVicpTko89ChnOcJtzqUvZx5cOv52zzwGxarVKnDub4aph5Nyhhc2VWjWpK+lNYrDUq8K9le0pYfD9FK+szzP4H/APBqT+07rfiKwl/aH/aE+C/w+8GLLbzahB8K18YfEnxpcW6sr3NhDD4j8MfD7w5pVxMmYIdT/tXX4bWVjcNpd9HEIJ/quPP2unhXgMtxEPDfw4444jztwqQw1Ti15LwxkdOo040sRUqZZmvEeZ4unCVqk8L9Ty+daK9msXh5TdSnxZX4DZ3VrQecZvluEw105rAfWMbiWusEq1DCUYN7KftKqi9eSVrP+vv9jP8AYi/Z6/YN+EVp8Hf2evCH9haO80epeKfE+qzR6p43+IHiJYBBJ4j8a+IPIt31PUGTdHZ2dtb2Oh6LbO1joOk6XYYtq/xl8bvHbxH+kFxlW418R85/tDGqnLC5TlWDhLCZDw7lrqOpHLMjy72lWOFwylaVatVqYjH46qliMwxmLxH70/oXhvhjKOFcvjl2UYf2VNtTr16jVTFYutazrYmtaLnO2kYxUKVKL5aVOEdD62r8dPoAoA4z4j/8k88ef9iZ4o/9Md9XucM/8lJw9/2PMp/9T8Oc2N/3PF/9g1f/ANNTP8cyv+1M/wA6QoAKACgAoAKACgAoA/04/wDggl4l0XxJ/wAEn/2Tzo99DdvoWkfEbw1rEMciNPputaT8XvHq3VjeRKzNbzNBLa38EcoR5tOvrG8VfJuomb/lg/aE5Xjss+l74v8A13DzoxzDGcM5pgpyjJU8VgcZwbw86WIoTaSqQVSFbD1JQvGGJoV6DfPSml/bfhTWp1uAcg9nJS9lTxtGok1eFSnmOL5oyXR2cZpPVwlGW0kfsHX8Xn6IFABQAUAFABQAUAFAHkvx88XaF8P/AIF/Gfx34nvodN8N+DPhT8Q/FWv6hcyLFBZaPoHhLV9V1K6lkf5USGztZpGJ/u9CeK+w8PMmx/EXH3BGQZVQniszzvi7hvKcvw1KLnUr43Mc4weEwtKEVrKVStWhFJdzz82xFLCZXmWKryUKOGwGMr1Zt2UadLD1Kk5N9lGLZ/j51/2fn+eAUAFABQAUAFABQAUAfu3/AMEY/wDgsnqn/BNrXfE3ww+KHhzW/iB+zH8StetfEWt6Z4dngbxd8NvGItbXSrzxv4QsNQubTS9bt9Z0iy07T/FXhu7vNMmv00fRNS0vV7O50y703X/4A+m79CfCfSdwGV8VcKZngOHfFThfL6uW4DF5lTqLJ+J8l9tVxdHIs6xGHpVsXgamCxlfE4nKM0o0MVDDyxuOwuLwdaliqOJy/wDVPDfxGqcGVa2Bx1Gri8kxtWNarCi19YwWJ5Y05YrDwm4wqqpTjCFejKUHNU6U6dSMoShV/sd8Lf8ABdb/AIJTeK9Fsdat/wBrrwpoovLeOaTSvFPhD4l+HNa0+ZgRNZX2n6n4LhYXFrKrwyS2kl3YTFBPY3t3Zy29zN/ipm30Avpc5RjsRgang3m+O9hUlCOLynOuFsywOJgn7lfD4jC55NezqwcZxhWjRxEE/Z16FGtCpSh/RdDxS4DxFKNVcQ4elzJN06+HxtGrB9YyhPDLWLum4uUHvGUotSfQ/wDD7P8A4JXf9Hm/DL/wXeOP/mTrzf8AiRb6Wv8A0ZHin/wpyD/58G3/ABEzgT/opMD/AOA4n/5QH/D7P/gld/0eb8Mv/Bd44/8AmTo/4kW+lr/0ZHin/wAKcg/+fAf8RM4E/wCikwP/AIDif/lAf8Ps/wDgld/0eb8Mv/Bd44/+ZOj/AIkW+lr/ANGR4p/8Kcg/+fAf8RM4E/6KTA/+A4n/AOUB/wAPs/8Agld/0eb8Mv8AwXeOP/mTo/4kW+lr/wBGR4p/8Kcg/wDnwH/ETOBP+ikwP/gOJ/8AlAf8Ps/+CV3/AEeb8Mv/AAXeOP8A5k6P+JFvpa/9GR4p/wDCnIP/AJ8B/wARM4E/6KTA/wDgOJ/+UB/w+z/4JXf9Hm/DL/wXeOP/AJk6P+JFvpa/9GR4p/8ACnIP/nwH/ETOBP8AopMD/wCA4n/5QVr3/gt9/wAEqbC0ub2f9sv4eSQ2kMlxKlloPxF1K7aOJS7Lbafp3gu6v7yYgER21nbT3EzYSKJ3IU60PoH/AEuMRWpUKfglxJGdacacJV8w4awtFSm0k6uIxOeUcPQgm/eq1qtOnBXlOcYpsmXidwHCMpPiTBtRTbUaWMnKy/lhDDSnJ9oxi2+iZ/M5/wAFmP8Agvz4Z/ar+Gmsfsq/scWvibTvhN4r8iL4sfF3xHY3PhvWvH2jQulyPA3hHw5My6po3hK9nSF/E2q68llrGvxwnQYtG07RTf3Gv/6kfQk/Z4Zp4R8UYLxb8a62VYnjDKPaT4Q4NyyvSzTA8PY2cZUnn2cZnBPCY3OKFOU45VhMvdfBZdKf9oSxuJx31enl34p4keLFDPsFUyHhyNeGX4iyx+YVoyo1MXTTUvquHov36eHk0nXqVeWpVS9kqcKfO6v8qVf63n4OFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAP/Z"
}), stopedLoading = {
  inProcess: !1,
  cnnName: ConnectorNames.Undefined
}, useConnectModalCommon = ({
  props: l,
  isMobile: t,
  btnGutter: s,
  styles: h
}) => {
  const {
    onCancel: m,
    onClose: d,
    afterConnect: v,
    afterChainSwitch: _,
    web3: T,
    expectedChainId: z
  } = l, [J, Y] = useState(stopedLoading), ie = (B) => Y({
    inProcess: !0,
    cnnName: B
  }), ne = () => Y(stopedLoading), de = /* @__PURE__ */ jsxs(Fragment$1, {
    children: ["By connecting, I accept Oort Digital\u2019s ", /* @__PURE__ */ jsx("a", {
      href: "https://oort.digital/terms",
      children: "Terms of Service"
    }), " and acknowledge"]
  }), ce = /* @__PURE__ */ jsxs(Fragment$1, {
    children: ["that you have read and understand the ", /* @__PURE__ */ jsx("a", {
      href: "https://oort.digital/terms#disclaimer",
      children: "Oort Digital protocol disclaimer"
    })]
  }), {
    supportedChains: re,
    chain: oe,
    switchChain: pe,
    canSwitchChain: ae,
    connect: me,
    account: ge,
    connectorName: we,
    supportedConnectors: Ee
  } = T, Te = () => {
    d && d(), m && m();
  }, Ke = async (B, L) => {
    ie(L);
    try {
      await me(B, L) && (m && m(), v && v());
    } finally {
      ne();
    }
  }, Se = async (B) => {
    ie(we);
    try {
      await pe(B) && (m && m(), _ && _());
    } finally {
      ne();
    }
  }, X = (B) => {
    const {
      chainId: L
    } = B;
    return /* @__PURE__ */ jsx(Col, {
      flex: t ? 24 : 3,
      children: /* @__PURE__ */ jsx(ChainButtonWithLogic, {
        onClick: () => Se(L),
        loading: J.inProcess,
        expectedChainId: z,
        connectedChainId: oe.chainId,
        canSwitchChain: ae,
        chain: B
      })
    }, L);
  }, fe = (B, L, C, G) => {
    if (ge && C === we)
      return /* @__PURE__ */ jsx(ConnectButton, {
        disabled: J.inProcess,
        walletName: L,
        walletIcon: G,
        account: ge
      });
    const R = Ee[C];
    return R.isInstalled ? /* @__PURE__ */ jsx(ConnectButton, {
      loading: C === J.cnnName,
      disabled: J.inProcess,
      walletName: L,
      onClick: () => Ke(B, C),
      walletIcon: G,
      labelText: "Connect"
    }) : /* @__PURE__ */ jsx(ConnectButton, {
      walletName: L,
      disabled: J.inProcess,
      onClick: () => window.open(R.installUrl, "_blank").focus(),
      walletIcon: G,
      labelText: "Install"
    });
  }, k = t ? void 0 : "space-between", p = t ? 24 : 12, x = z || re[0].chainId, S = /* @__PURE__ */ jsxs(Fragment$1, {
    children: [!isChainEmpty(oe) && /* @__PURE__ */ jsxs(Fragment$1, {
      children: [/* @__PURE__ */ jsx("div", {
        className: h.description,
        children: /* @__PURE__ */ jsx(Alert, {
          account: ge,
          chain: oe,
          supportedChains: re,
          expectedChainId: z
        })
      }), /* @__PURE__ */ jsx(Row, {
        gutter: s,
        className: h.chain_buttons,
        justify: k,
        children: re.map((B) => X(B))
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: h.description,
      children: [/* @__PURE__ */ jsx(Bold, {
        children: "Connect your Wallet"
      }), " and jump into the world of NFT's"]
    }), /* @__PURE__ */ jsxs(Row, {
      gutter: s,
      justify: k,
      children: [/* @__PURE__ */ jsx(Col, {
        span: p,
        children: fe(x, "Metamask", ConnectorNames.Injected, MetamaskIcon)
      }), /* @__PURE__ */ jsx(Col, {
        span: p,
        children: fe(x, "FaceWallet", ConnectorNames.FaceWallet, FaceWalletIcon)
      }), /* @__PURE__ */ jsx(Col, {
        span: p,
        children: fe(x, "WalletConnect", ConnectorNames.WalletConnect, WalletConnectIcon)
      })]
    })]
  });
  return {
    footer1: de,
    footer2: ce,
    content: S,
    onCancel: Te,
    loading: J.inProcess
  };
};
export {
  useConnectModalCommon as u
};
//# sourceMappingURL=useConnectModalCommon.28978413.mjs.map
