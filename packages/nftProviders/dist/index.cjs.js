"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var h=require("moralis");function k(r){return r&&typeof r=="object"&&"default"in r?r:{default:r}}var o=k(h),d=(r=>(r.ERC721="ERC721",r.ERC1155="ERC1155",r))(d||{}),c=(r=>(r.Opensea="opensea",r.OpenseaV2="openseaV2",r.Moralis="moralis",r.MoralisOpensea="MoralisOpensea",r))(c||{});function g(r){if(r)return{name:r.name,description:r.description,image:r.image}}function N({symbol:r,amount:t,name:a,token_address:e,token_id:s,contract_type:n}){return{name:a,tokenAddress:e,tokenId:s,contractType:n,amount:t?parseInt(t):0,symbol:r}}class m{constructor(t,a,e,s="info"){this.providerKind=c.Moralis,this._startPromise=o.default.start({apiKey:e.apiKey,formatEvmAddress:"checksum",formatEvmChainId:"decimal",logLevel:s}),this.chainId=a,this._logger=t}async featchNftOwner(t){var a;await this._startPromise;const{address:e,tokenId:s}=t,n=await o.default.EvmApi.nft.getNFTTokenIdOwners({chain:this.chainId,address:e,tokenId:s});if(!((a=n.result)!=null&&a.length))return{asset:void 0};const i=n.result.sort((l,p)=>{const f=l.result.blockNumber,u=p.result.blockNumber;return f<u?-1:f>u?1:0})[0].toJSON();return{asset:{address:i.tokenAddress,tokenId:i.tokenId.toString(),ownerAddress:i.ownerOf}}}async featchNft(t){await this._startPromise;const{address:a,tokenId:e}=t,s=(await o.default.EvmApi.nft.getNFTMetadata({chain:this.chainId,address:a,tokenId:e})).raw,n=N(s);return this.mapNft(n,s.normalized_metadata)}async featchNftImageSrc(t){return await this._startPromise,(await this.featchNft(t)).image}async featchAccountNfts(t){await this._startPromise;const a=await o.default.EvmApi.nft.getWalletNFTs({chain:this.chainId,address:t.ownerAddress,tokenAddresses:t.tokenAddresses,limit:t.limit}),{pagination:e,result:s}=a,n=s.map(i=>this.mapNft(i.toJSON(),g(i.metadata)));return{page:e.page,pageSize:e.pageSize,total:e.total,data:n,cursor:e.cursor}}ParseImage(t,a,e){if(e.image!==void 0)return e.image;this._logger.trace(`No image. TokenAddress: ${t} TokenId: ${a} Metadata: ${e}`)}ParseNftName(t,a,e){if(e.name!==void 0)return e.name;this._logger.trace(`No nftName. TokenAddress: ${t} TokenId: ${a} Metadata: ${e}`)}ParseDescription(t,a,e){if(e.description!==void 0)return e.description;this._logger.trace(`No description. TokenAddress: ${t} TokenId: ${a} Metadata: ${e}`)}static ParseContractType(t,a,e){if(e==="ERC721")return d.ERC721;if(e==="ERC1155")return d.ERC1155;throw new Error(`Unknow contarct type: ${e}. TokenAddress: ${t} TokenId: ${a}`)}mapNft(t,a){const e=t.tokenId.toString(),s={projectName:t.name,amount:t.amount||0,contractType:m.ParseContractType(t.tokenAddress,e,t.contractType),tokenAddress:t.tokenAddress,tokenId:e,symbol:t.symbol||"",rawData:t,image:void 0,imageProvider:c.Moralis,nftName:void 0,description:void 0};return a&&(s.image=this.ParseImage(t.tokenAddress,e,a),s.nftName=this.ParseNftName(t.tokenAddress,e,a),s.description=this.ParseDescription(t.tokenAddress,e,a)),s}}exports.MoralisNftProvider=m,exports.NftType=d,exports.ProviderKind=c;
//# sourceMappingURL=index.cjs.js.map
