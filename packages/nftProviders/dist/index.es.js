import i from"moralis";var d=(s=>(s.ERC721="ERC721",s.ERC1155="ERC1155",s))(d||{}),c=(s=>(s.Opensea="opensea",s.OpenseaV2="openseaV2",s.Moralis="moralis",s.MoralisOpensea="MoralisOpensea",s))(c||{});function k(s){if(s)return{name:s.name,description:s.description,image:s.image}}function u({symbol:s,amount:t,name:a,token_address:e,token_id:r,contract_type:n}){return{name:a,tokenAddress:e,tokenId:r,contractType:n,amount:t?parseInt(t):0,symbol:s}}class m{constructor(t,a,e,r="info"){this.providerKind=c.Moralis,this._startPromise=i.start({apiKey:e.apiKey,formatEvmAddress:"checksum",formatEvmChainId:"decimal",logLevel:r}),this.chainId=a,this._logger=t}async featchNftOwner(t){var a;await this._startPromise;const{address:e,tokenId:r}=t,n=await i.EvmApi.nft.getNFTTokenIdOwners({chain:this.chainId,address:e,tokenId:r});if(!((a=n.result)!=null&&a.length))return{asset:void 0};const o=n.result.sort((h,l)=>{const p=h.result.blockNumber,f=l.result.blockNumber;return p<f?-1:p>f?1:0})[0].toJSON();return{asset:{address:o.tokenAddress,tokenId:o.tokenId.toString(),ownerAddress:o.ownerOf}}}async featchNft(t){await this._startPromise;const{address:a,tokenId:e}=t,r=(await i.EvmApi.nft.getNFTMetadata({chain:this.chainId,address:a,tokenId:e})).raw,n=u(r);return this.mapNft(n,r.normalized_metadata)}async featchNftImageSrc(t){return await this._startPromise,(await this.featchNft(t)).image}async featchAccountNfts(t){await this._startPromise;const a=await i.EvmApi.nft.getWalletNFTs({chain:this.chainId,address:t.ownerAddress,tokenAddresses:t.tokenAddresses,limit:t.limit}),{pagination:e,result:r}=a,n=r.map(o=>this.mapNft(o.toJSON(),k(o.metadata)));return{page:e.page,pageSize:e.pageSize,total:e.total,data:n,cursor:e.cursor}}ParseImage(t,a,e){if(e.image!==void 0)return e.image;this._logger.trace(`No image. TokenAddress: ${t} TokenId: ${a} Metadata: ${e}`)}ParseNftName(t,a,e){if(e.name!==void 0)return e.name;this._logger.trace(`No nftName. TokenAddress: ${t} TokenId: ${a} Metadata: ${e}`)}ParseDescription(t,a,e){if(e.description!==void 0)return e.description;this._logger.trace(`No description. TokenAddress: ${t} TokenId: ${a} Metadata: ${e}`)}static ParseContractType(t,a,e){if(e==="ERC721")return d.ERC721;if(e==="ERC1155")return d.ERC1155;throw new Error(`Unknow contarct type: ${e}. TokenAddress: ${t} TokenId: ${a}`)}mapNft(t,a){const e=t.tokenId.toString(),r={projectName:t.name,amount:t.amount||0,contractType:m.ParseContractType(t.tokenAddress,e,t.contractType),tokenAddress:t.tokenAddress,tokenId:e,symbol:t.symbol||"",rawData:t,image:void 0,imageProvider:c.Moralis,nftName:void 0,description:void 0};return a&&(r.image=this.ParseImage(t.tokenAddress,e,a),r.nftName=this.ParseNftName(t.tokenAddress,e,a),r.description=this.ParseDescription(t.tokenAddress,e,a)),r}}export{m as MoralisNftProvider,d as NftType,c as ProviderKind};
//# sourceMappingURL=index.es.js.map
