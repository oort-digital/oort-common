{"version":3,"file":"index.cjs.js","sources":["../src/baseConnector.ts","../src/connectorProvider.ts","../src/connectorNames.ts","../src/injectedConnector.ts","../src/walletConnectConnector.ts","../src/faceWalletConnector.ts"],"sourcesContent":["import { providers, Signer } from \"ethers\";\r\nimport { ILogger } from \"@oort/logger\";\r\nimport { ConnectorNames } from \"./connectorNames\";\r\n\r\ntype AccountChangedHandlerType = (accounts: Array<string>) => void\r\ntype ChainChangedHandlerType = (chainId: string) => void\r\ntype DisconnectHandlerType = (error: any) => void\r\n\r\nexport interface IChainInfo {\r\n    name: string\r\n    chainId: number\r\n    rpcUrl: string\r\n    blockExplorer?: string\r\n    nativeCurrency?: {\r\n        name: string\r\n        symbol: string\r\n        decimals: number\r\n    }\r\n}\r\nexport interface IChainMap {\r\n    [chainId: number]: IChainInfo\r\n  }\r\n\r\nexport abstract class BaseConnector {\r\n    name: ConnectorNames;\r\n\r\n    protected readonly _chains: IChainMap = {}\r\n\r\n    private _externalAccountChangedHandlers: AccountChangedHandlerType[] = []\r\n    private accountsChangedHandler?: AccountChangedHandlerType\r\n\r\n    private _externalChainChangedHandlers: ChainChangedHandlerType[] = []\r\n    private chainChangedHandler?: ChainChangedHandlerType\r\n\r\n    private _externalDisconnectHandlers: DisconnectHandlerType[] = []\r\n    protected disconnectHandler?: DisconnectHandlerType\r\n\r\n    protected readonly logger: ILogger\r\n\r\n    private readonly _checkConnectionDelayMs : number = 500;\r\n    private _timerId?: NodeJS.Timeout;\r\n    \r\n    private async CheckConnection(): Promise<void> {\r\n        if(!await this.isConnected)\r\n        {\r\n            if(this._timerId) {\r\n                clearInterval(this._timerId)\r\n                this.logger.debug(`${this.name}Connector. CheckConnection stopped`)\r\n            }\r\n\r\n            this._externalDisconnectHandlers.forEach(h => h(undefined));\r\n            this._externalDisconnectHandlers = [];\r\n        }\r\n    }\r\n\r\n    constructor(logger: ILogger, name: ConnectorNames, chains: IChainInfo[]) {\r\n        this.name = name\r\n        this.logger = logger\r\n        chains.forEach(x => this._chains[x.chainId] = x)\r\n    }\r\n\r\n    protected initListeners(web3Provider: any) {\r\n        this.logger.debug('initListeners')\r\n        const that = this\r\n        this.accountsChangedHandler = (accounts: Array<string>) => {\r\n            this.logger.debug(`${this.name}.accountsChangedHandler`)\r\n            that._externalAccountChangedHandlers.forEach(h => h(accounts));\r\n        }\r\n\r\n        this.chainChangedHandler = (chainId: string) => {\r\n            this.logger.debug(`${this.name}.chainChangedHandler`)\r\n            that._externalChainChangedHandlers.forEach(h => h(chainId));\r\n        }\r\n\r\n        this.disconnectHandler = (error: any) => {\r\n            this.logger.debug(`${this.name}.disconnectHandler ${JSON.stringify(error)}`)\r\n            that._externalDisconnectHandlers.forEach(h => h(error));\r\n        }\r\n\r\n        web3Provider.on('accountsChanged', this.accountsChangedHandler);\r\n        web3Provider.on('chainChanged', this.chainChangedHandler);\r\n        // use custom connection check by timer. See onDisconnect\r\n        // web3Provider.on(\"disconnect\", this.disconnectHandler);\r\n    }\r\n\r\n    protected removeListeners_(rawProvider: any) {\r\n        rawProvider.removeListener('accountsChanged', this.accountsChangedHandler);\r\n        rawProvider.removeListener('chainChanged', this.chainChangedHandler);\r\n        // this.rawProvider.removeListener(\"disconnect\", this.disconnectHandler);\r\n        this._externalAccountChangedHandlers = []\r\n        this._externalChainChangedHandlers = []\r\n        this._externalDisconnectHandlers = []\r\n    }\r\n\r\n    protected abstract getRawProvider(): Promise<any>;\r\n   \r\n    onAccountsChanged(handler: AccountChangedHandlerType) {\r\n        this._externalAccountChangedHandlers.push(handler)\r\n    }\r\n\r\n    onChainChanged(handler: ChainChangedHandlerType): void {\r\n        this._externalChainChangedHandlers.push(handler)\r\n    }\r\n\r\n    onDisconnect(handler: (error: any) => void): void {\r\n\r\n        if(!this._timerId) {\r\n            const self = this;\r\n            this._timerId = setInterval(() => self.CheckConnection(), this._checkConnectionDelayMs)\r\n        }\r\n        \r\n        this._externalDisconnectHandlers.push(handler);\r\n    }\r\n\r\n    abstract get isConnected(): Promise<boolean>\r\n\r\n\r\n    async getSigner(): Promise<Signer> {\r\n        const provider = new providers.Web3Provider(await this.getRawProvider())\r\n        return provider.getSigner()\r\n    }\r\n}","import { ILogger } from \"@oort/logger\";\r\nimport { ConnectorNames } from \"./connectorNames\";\r\nimport { IConnector } from \"./iConnector\";\r\n\r\nconst lsKey = 'cur_connector';\r\n\r\ninterface ICurConnector {\r\n    chainId: number\r\n    name: ConnectorNames\r\n}\r\n\r\nconst getCurConnectorName = () : ICurConnector | undefined => {\r\n    const jsonStr = localStorage.getItem(lsKey);\r\n    return jsonStr ? JSON.parse(jsonStr) : undefined;\r\n}\r\n\r\nconst setCurConnectorName = (curConnector: ICurConnector) => localStorage.setItem(lsKey, JSON.stringify(curConnector));\r\nconst removeCurConnectorName = () => localStorage.removeItem(lsKey);\r\n\r\n\r\nexport class ConnectorProvider\r\n{\r\n    private readonly _logger: ILogger\r\n    public readonly connectorsByName: { [name: string]: IConnector } = {}\r\n    private _curConnector: IConnector | undefined\r\n    public readonly WaitInitialisationAsync : Promise<void>\r\n\r\n    private async InitAsync(connectors: IConnector[], curConnectorData: ICurConnector | undefined): Promise<void> {\r\n        let curConnector: IConnector | undefined = undefined\r\n        for(let i = 0; i < connectors.length; i++) {\r\n            const c = connectors[i]\r\n            this.connectorsByName[c.name] = c\r\n            if(c.name === curConnectorData?.name) {\r\n                if(await c.isConnected) {\r\n                    curConnector = c\r\n                }\r\n            }\r\n        }\r\n\r\n        if(curConnector) {\r\n            if(await curConnector.connect(curConnectorData!.chainId)) {\r\n                this._curConnector = curConnector\r\n                this._logger.debug(`Current connector is ${this._curConnector.name}`)\r\n            }\r\n        }\r\n    }\r\n\r\n    constructor(logger: ILogger, connectors: IConnector[]) {\r\n        this._logger = logger\r\n        this.WaitInitialisationAsync = this.InitAsync(connectors, getCurConnectorName());\r\n    }\r\n\r\n    public get CurConnector(): IConnector | undefined {\r\n        return this._curConnector;\r\n    }\r\n\r\n    async connect(chainId: number, connectorName: ConnectorNames): Promise<void> {\r\n        await this.WaitInitialisationAsync\r\n        const curConnector = this.connectorsByName[connectorName]\r\n        if(await curConnector.connect(chainId)) {\r\n            setCurConnectorName({ chainId, name: connectorName})\r\n            this._curConnector = curConnector\r\n        }\r\n    }\r\n\r\n    async disconnect(): Promise<void> {\r\n        await this._curConnector?.disconnect()\r\n        removeCurConnectorName()\r\n        this._curConnector = undefined\r\n    }\r\n}","export enum ConnectorNames {\r\n    Undefined = '',\r\n    Injected = 'Injected',\r\n    WalletConnect = 'WalletConnect',\r\n    FaceWallet = 'FaceWallet'\r\n}","import { ILogger } from \"@oort/logger\";\r\nimport { BaseConnector, IChainInfo } from \"./baseConnector\";\r\nimport { ConnectorNames } from \"./connectorNames\";\r\nimport { IConnector } from \"./iConnector\";\r\n\r\ndeclare global {\r\n    interface Window {\r\n        ethereum: any;\r\n    }\r\n}\r\n\r\nconst ErrorCodes = {\r\n  // User rejected the request (close metamask window or press reject button)\r\n  UserReject: 4001,\r\n\r\n  // This error code indicates that the chain has not been added to MetaMask.\r\n  UnknownChain: 4902\r\n}\r\n\r\nexport class InjectedConnector extends BaseConnector implements IConnector\r\n{\r\n  get canSwitchChain() { return !!window.ethereum.isMetaMask }\r\n\r\n  disconnect(): Promise<void> {\r\n    super.removeListeners_(window.ethereum)\r\n    return Promise.resolve()\r\n  }\r\n\r\n  async connect(chainId: number): Promise<boolean> {\r\n    if(this._ethRequestAccounts) {\r\n      this.logger.debug('InjectedConnector.enable already called')\r\n      return await this._ethRequestAccounts\r\n    }\r\n\r\n    this.logger.debug('InjectedConnector.enable')\r\n    this._ethRequestAccounts = this.prvEnable()\r\n    const result = await this._ethRequestAccounts\r\n    this._ethRequestAccounts = undefined\r\n\r\n    const signer = await this.getSigner()\r\n    const curChainId = await signer.getChainId()\r\n\r\n    if(curChainId !== chainId) {\r\n      await this.switchChain(chainId)\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async switchChain(chainId: number): Promise<boolean> {\r\n    const chainIdHex = `0x${chainId.toString(16)}`\r\n    try {\r\n        if(!this._chains[chainId]) {\r\n            throw new Error(`Chain ${chainId} not supported`)\r\n        }\r\n        await window.ethereum.request({\r\n          method: 'wallet_switchEthereumChain',\r\n          params: [{ chainId: chainIdHex }],\r\n        });\r\n    } catch (switchError: any) {\r\n      // This error code indicates that the chain has not been added to MetaMask.\r\n      if (switchError.code === ErrorCodes.UnknownChain) {\r\n        return await this.addEthereumChain(chainId, chainIdHex)\r\n      }\r\n      else if (switchError.code === ErrorCodes.UserReject) {\r\n        return false;\r\n      }\r\n      // handle other \"switch\" errors\r\n      throw switchError\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  get isConnected(): Promise<boolean> {\r\n    return this.isConnectedAsync()\r\n  }\r\n\r\n  get isInstalled(): boolean {\r\n    return !!window.ethereum\r\n  }\r\n\r\n  get installUrl(): string {\r\n    return 'https://metamask.io/download'\r\n  }\r\n\r\n  constructor(logger: ILogger, chains: IChainInfo[]) {\r\n      super(logger, ConnectorNames.Injected, chains);\r\n      if(this.isInstalled) {\r\n        this.initListeners(window.ethereum)\r\n      }\r\n  }\r\n\r\n  private addEthereumChain = async (chainId: number, chainIdHex: string): Promise<boolean> => {\r\n    try {\r\n      const chain = this._chains[chainId]\r\n      const blockExplorerUrls = chain.blockExplorer ? [chain.blockExplorer] : undefined\r\n      await window.ethereum.request({\r\n        method: 'wallet_addEthereumChain',\r\n        params: [{\r\n          chainId: chainIdHex,\r\n          chainName: chain.name,\r\n          rpcUrls: [chain.rpcUrl],\r\n          nativeCurrency: chain.nativeCurrency,\r\n          blockExplorerUrls\r\n        }]\r\n      });\r\n    } catch (addError: any) {\r\n      if (addError.code === ErrorCodes.UserReject) {\r\n        // User rejected the request (close metamask window or press reject button)\r\n        return false;\r\n      }\r\n\r\n      throw addError\r\n    }\r\n    \r\n    return true\r\n  }\r\n\r\n  protected getRawProvider(): Promise<any> {\r\n    return Promise.resolve(window.ethereum)\r\n  }\r\n\r\n  private _ethRequestAccounts: Promise<boolean> | undefined = undefined\r\n\r\n  private async prvEnable(): Promise<boolean> {\r\n    try {\r\n      await window.ethereum.request({ method: 'eth_requestAccounts' })\r\n    }\r\n    catch(error: any) {\r\n      if (error.code === ErrorCodes.UserReject) {\r\n        // EIP-1193 userRejectedRequest error\r\n        this.logger.warn('Please connect to MetaMask.');\r\n      } else {\r\n        this.logger.error(error);\r\n      }\r\n      return false\r\n    }\r\n    return true\r\n  }\r\n\r\n  private async isConnectedAsync(): Promise<boolean> {\r\n    const response: string[] = await window.ethereum.request({ method: 'eth_accounts' })\r\n    return response.length > 0\r\n  }\r\n}","import WalletConnectProvider from \"@walletconnect/web3-provider\";\r\nimport { IRPCMap } from \"@walletconnect/types\";\r\nimport { ILogger } from \"@oort/logger\";\r\nimport { BaseConnector, IChainInfo } from \"./baseConnector\";\r\nimport { ConnectorNames } from \"./connectorNames\";\r\nimport { IConnector } from \"./iConnector\";\r\n\r\nexport interface IWalletConnectOptions {\r\n    modalZIndex?: number //actual for v2\r\n    projectId: string //actual for v2\r\n    logger: ILogger\r\n    chains: IChainInfo[]\r\n}\r\n\r\nexport class WalletConnectConnector extends BaseConnector implements IConnector {\r\n\r\n    private _walletConnect: WalletConnectProvider\r\n    private readonly _rpc: IRPCMap\r\n\r\n    constructor({ logger, chains }: IWalletConnectOptions) {\r\n        super(logger, ConnectorNames.WalletConnect, chains)\r\n        this._rpc = {}\r\n        chains.forEach(x => this._rpc[x.chainId] = x.rpcUrl)\r\n        this._walletConnect = new WalletConnectProvider({ rpc: this._rpc })\r\n        this.initListeners(this._walletConnect)\r\n    }\r\n\r\n    async disconnect(): Promise<void> {\r\n        super.removeListeners_(this._walletConnect)\r\n        await this._walletConnect.disconnect()\r\n    }\r\n    \r\n    get canSwitchChain() { return false }\r\n\r\n    // @ts-ignore\r\n    switchChain(chainId: number): Promise<boolean> {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    protected getRawProvider(): Promise<any> {\r\n        return Promise.resolve(this._walletConnect)\r\n      }\r\n\r\n    get isConnected(): Promise<boolean> {\r\n        const lsItem = localStorage.getItem('walletconnect');\r\n        const result = (!!lsItem) && this._walletConnect.isWalletConnect\r\n        return Promise.resolve(result)\r\n        //return this._walletConnect.connected\r\n    }\r\n\r\n    get isInstalled(): boolean {\r\n        return true\r\n    }\r\n\r\n    get installUrl(): string {\r\n        return ''\r\n    }\r\n\r\n    async connect(_chainId: number/* this parameter is used for V2 */): Promise<boolean> {\r\n        try {\r\n            await this._walletConnect.enable();\r\n        }\r\n        catch(error)\r\n        {\r\n            this._walletConnect = new WalletConnectProvider({ rpc: this._rpc });\r\n            return false\r\n        }\r\n        return true\r\n    }\r\n}","import { ILogger } from \"@oort/logger\";\r\nimport { Face, Network } from \"@haechi-labs/face-sdk\";\r\nimport { BaseConnector, IChainInfo } from \"./baseConnector\";\r\nimport { IConnector } from \"./iConnector\";\r\nimport { ConnectorNames } from \"./connectorNames\";\r\n\r\nconst getNetworkById = (id: number): Network => {\r\n    if(id === 1) { return Network.ETHEREUM }\r\n    if(id === 80001) { return Network.MUMBAI }\r\n    if(id === 5) { return Network.GOERLI }\r\n    throw new Error(`Unknow chain id: ${id}`)\r\n}\r\n\r\nexport interface IFaceWalletOptions {\r\n    logger: ILogger\r\n    chains: IChainInfo[]\r\n    testnetApiKey: string | null\r\n    mainnetApiKey: string | null\r\n}\r\n\r\nexport class FaceWalletConnector extends BaseConnector implements IConnector {\r\n\r\n    async disconnect(): Promise<void> {\r\n        await this.face.auth.logout()\r\n    }\r\n    \r\n    get canSwitchChain() { return true }\r\n\r\n    // @ts-ignore\r\n    async switchChain(chainId: number): Promise<boolean> {\r\n        const network = getNetworkById(chainId)\r\n        await this.face.switchNetwork(network)\r\n        return true\r\n    }\r\n\r\n    get isConnected(): Promise<boolean> {\r\n        if(!this._face) {\r\n            return Promise.resolve(false)\r\n        }\r\n        return this._face.auth.isLoggedIn()\r\n    }\r\n\r\n    get isInstalled(): boolean {\r\n        return true\r\n    }\r\n\r\n    get installUrl(): string {\r\n        return ''\r\n    }\r\n\r\n    async connect(chainId: number): Promise<boolean> {\r\n        \r\n        if(!this._face) {\r\n            const network = getNetworkById(chainId)\r\n            this._face = new Face({\r\n                network: network, \r\n                apiKey: this.resolveApiKey(network)\r\n            })\r\n        }\r\n\r\n        if(await this.face.auth.isLoggedIn()) {\r\n            return true\r\n        }\r\n\r\n        /*const response = */await this.face.auth.login()\r\n\r\n        return true\r\n    }\r\n\r\n    constructor({ logger, chains, testnetApiKey, mainnetApiKey }: IFaceWalletOptions) {\r\n        super(logger, ConnectorNames.FaceWallet, chains)\r\n\r\n        if(!testnetApiKey && !mainnetApiKey) {\r\n            throw new Error(`Set value for testnetApiKey or mainnetApiKey or both`)\r\n        }\r\n\r\n        this._mainnetApiKey = mainnetApiKey\r\n        this._testnetApiKey = testnetApiKey\r\n\r\n        /*\r\n        don't create new Face in constructor, it catch error\r\n        no time to research it =)\r\n        this._face = new Face({\r\n            network: Network.MUMBAI, \r\n            apiKey: resolveApiKey(Network.MUMBAI)\r\n        })\r\n        */\r\n    }\r\n\r\n    protected getRawProvider(): Promise<any> {\r\n        return Promise.resolve(this.face.getEthLikeProvider())\r\n    }\r\n\r\n    /*\r\n    According to https://docs.facewallet.xyz/docs/initialize\r\n    Face objects cannot be duplicated. For an object that was created,\r\n    we recommend you manage and use it as a global variable or global state.\r\n    */\r\n    private _face: Face | undefined\r\n\r\n    private get face(): Face {\r\n\r\n        if(!this._face) {\r\n            throw new Error('Provider not connected. Call FaceWalletConnector.connect first')\r\n        }\r\n    \r\n        return this._face\r\n    }\r\n\r\n    private _testnetApiKey: string | null\r\n    private _mainnetApiKey: string | null\r\n\r\n    private resolveApiKey = (network: Network) => {\r\n        switch (network) {\r\n          case Network.ETHEREUM:\r\n          case Network.POLYGON:\r\n          case Network.BNB_SMART_CHAIN:\r\n          case Network.KLAYTN:\r\n          case Network.BORA:\r\n            {\r\n                if(!this._mainnetApiKey) {\r\n                    throw new Error('No API key for mainnet')\r\n                }\r\n                return this._mainnetApiKey\r\n            }\r\n          case Network.GOERLI:\r\n          case Network.MUMBAI:\r\n          case Network.BNB_SMART_CHAIN_TESTNET:\r\n          case Network.BAOBAB:\r\n          case Network.BORA_TESTNET:\r\n            {\r\n                if(!this._testnetApiKey) {\r\n                    throw new Error('No API key for testnet')\r\n                }\r\n                return this._testnetApiKey\r\n            }\r\n          default:\r\n            throw new Error(\"unsupported network error\");\r\n        }\r\n    }\r\n\r\n\r\n}"],"names":["BaseConnector","logger","name","chains","x","h","web3Provider","that","accounts","chainId","error","rawProvider","handler","self","providers","lsKey","getCurConnectorName","jsonStr","setCurConnectorName","curConnector","removeCurConnectorName","ConnectorProvider","connectors","curConnectorData","i","c","connectorName","_a","ConnectorNames","ErrorCodes","InjectedConnector","chainIdHex","chain","blockExplorerUrls","addError","result","switchError","WalletConnectConnector","WalletConnectProvider","_chainId","getNetworkById","id","Network","FaceWalletConnector","testnetApiKey","mainnetApiKey","network","Face"],"mappings":"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"}