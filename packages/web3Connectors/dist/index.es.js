import{providers as l}from"ethers";import o from"@walletconnect/web3-provider";const c="cur_connector",d=()=>localStorage.getItem(c)||void 0,u=s=>localStorage.setItem(c,s),C=()=>localStorage.removeItem(c);class g{constructor(e,t){this.connectorsByName={},this._logger=e,this.WaitInitialisationAsync=this.InitAsync(t,d())}async InitAsync(e,t){let r;for(let n=0;n<e.length;n++){const i=e[n];this.connectorsByName[i.name]=i,i.name===t&&await i.isConnected&&(r=i)}r&&await r.enable()&&(this._curConnector=r,this._logger.debug(`Current connector is ${this._curConnector.name}`))}get CurConnector(){return this._curConnector}async EnableAsync(e){await this.WaitInitialisationAsync;const t=this.connectorsByName[e];await t.enable()&&(u(e),this._curConnector=t)}async disconnect(){var e;await((e=this._curConnector)==null?void 0:e.disconnect()),C(),this._curConnector=void 0}}class h{constructor(e,t,r){this._chains={},this._externalAccountChangedHandlers=[],this._externalChainChangedHandlers=[],this._externalDisconnectHandlers=[],this._checkConnectionDelayMs=500,this.name=t,this.logger=e,r.forEach(n=>this._chains[n.chainId]=n)}async CheckConnection(){await this.isConnected||(this._timerId&&(clearInterval(this._timerId),this.logger.debug(`${this.name}Connector. CheckConnection stopped`)),this._externalDisconnectHandlers.forEach(e=>e(void 0)),this._externalDisconnectHandlers=[])}initListeners(e){this.logger.debug("initListeners");const t=this;this.accountsChangedHandler=r=>{this.logger.debug(`${this.name}.accountsChangedHandler`),t._externalAccountChangedHandlers.forEach(n=>n(r))},this.chainChangedHandler=r=>{this.logger.debug(`${this.name}.chainChangedHandler`),t._externalChainChangedHandlers.forEach(n=>n(r))},this.disconnectHandler=r=>{this.logger.debug(`${this.name}.disconnectHandler ${JSON.stringify(r)}`),t._externalDisconnectHandlers.forEach(n=>n(r))},e.on("accountsChanged",this.accountsChangedHandler),e.on("chainChanged",this.chainChangedHandler)}removeListeners(){this.rawProvider.removeListener("accountsChanged",this.accountsChangedHandler),this.rawProvider.removeListener("chainChanged",this.chainChangedHandler),this._externalAccountChangedHandlers=[],this._externalChainChangedHandlers=[],this._externalDisconnectHandlers=[]}onAccountsChanged(e){this._externalAccountChangedHandlers.push(e)}onChainChanged(e){this._externalChainChangedHandlers.push(e)}onDisconnect(e){if(!this._timerId){const t=this;this._timerId=setInterval(()=>t.CheckConnection(),this._checkConnectionDelayMs)}this._externalDisconnectHandlers.push(e)}get signer(){return new l.Web3Provider(this.rawProvider).getSigner()}disconnect(){return this.removeListeners(),Promise.resolve()}}var a=(s=>(s.Undefined="",s.Injected="Injected",s.WalletConnect="WalletConnect",s))(a||{});class w extends h{constructor(e,t){super(e,a.Injected,t),this._ethRequestAccounts=void 0,this.isInstalled&&this.initListeners(window.ethereum)}get canSwitchChain(){return!!window.ethereum.isMetaMask}async switchChain(e){const t=`0x${e.toString(16)}`;try{if(!this._chains[e])throw new Error(`Chain ${e} not supported`);await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:t}]})}catch(r){if(r.code===4902)try{const n=this._chains[e];await window.ethereum.request({method:"wallet_addEthereumChain",params:[{chainId:t,chainName:n.name,rpcUrls:[n.rpcUrl],nativeCurrency:n.nativeCurrency,blockExplorerUrls:[n.blockExplorer]}]})}catch(n){throw n}}}async prvEnable(){try{await this.rawProvider.request({method:"eth_requestAccounts"})}catch(e){return e.code===4001?this.logger.warn("Please connect to MetaMask."):this.logger.error(e),!1}return!0}async enable(){if(this._ethRequestAccounts)return this.logger.debug("InjectedConnector.enable already called"),await this._ethRequestAccounts;this.logger.debug("InjectedConnector.enable"),this._ethRequestAccounts=this.prvEnable();const e=await this._ethRequestAccounts;return this._ethRequestAccounts=void 0,e}async isConnectedAsync(){return(await window.ethereum.request({method:"eth_accounts"})).length>0}get isConnected(){return this.isConnectedAsync()}get isInstalled(){return!!window.ethereum}get installUrl(){return"https://metamask.io/download"}get rawProvider(){return window.ethereum}}class _ extends h{constructor(e,t){super(e,a.WalletConnect,t),this._rpc={},t.forEach(r=>this._rpc[r.chainId]=r.rpcUrl),this._walletConnect=new o({rpc:this._rpc}),this.initListeners(this._walletConnect)}async disconnect(){await super.disconnect(),await this._walletConnect.disconnect()}get canSwitchChain(){return!1}switchChain(e){throw new Error("Method not implemented.")}get rawProvider(){return this._walletConnect}get isConnected(){const e=!!localStorage.getItem("walletconnect")&&this._walletConnect.isWalletConnect;return Promise.resolve(e)}get isInstalled(){return!0}get installUrl(){return""}async enable(){try{return await this._walletConnect.enable()}catch(e){return this._walletConnect=new o({rpc:this._rpc}),Promise.reject(e)}}}export{a as ConnectorNames,g as ConnectorProvider,w as InjectedConnector,_ as WalletConnectConnector};
//# sourceMappingURL=index.es.js.map
