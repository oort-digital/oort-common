import{providers as w}from"ethers";import d from"@walletconnect/web3-provider";import{Network as a,Face as C}from"@haechi-labs/face-sdk";class o{constructor(e,t,n){this._chains={},this._externalAccountChangedHandlers=[],this._externalChainChangedHandlers=[],this._externalDisconnectHandlers=[],this._checkConnectionDelayMs=500,this.name=t,this.logger=e,n.forEach(s=>this._chains[s.chainId]=s)}async CheckConnection(){await this.isConnected||(this._timerId&&(clearInterval(this._timerId),this.logger.debug(`${this.name}Connector. CheckConnection stopped`)),this._externalDisconnectHandlers.forEach(e=>e(void 0)),this._externalDisconnectHandlers=[])}initListeners(e){this.logger.debug("initListeners");const t=this;this.accountsChangedHandler=n=>{this.logger.debug(`${this.name}.accountsChangedHandler`),t._externalAccountChangedHandlers.forEach(s=>s(n))},this.chainChangedHandler=n=>{this.logger.debug(`${this.name}.chainChangedHandler`),t._externalChainChangedHandlers.forEach(s=>s(n))},this.disconnectHandler=n=>{this.logger.debug(`${this.name}.disconnectHandler ${JSON.stringify(n)}`),t._externalDisconnectHandlers.forEach(s=>s(n))},e.on("accountsChanged",this.accountsChangedHandler),e.on("chainChanged",this.chainChangedHandler)}removeListeners_(e){e.removeListener("accountsChanged",this.accountsChangedHandler),e.removeListener("chainChanged",this.chainChangedHandler),this._externalAccountChangedHandlers=[],this._externalChainChangedHandlers=[],this._externalDisconnectHandlers=[]}onAccountsChanged(e){this._externalAccountChangedHandlers.push(e)}onChainChanged(e){this._externalChainChangedHandlers.push(e)}onDisconnect(e){if(!this._timerId){const t=this;this._timerId=setInterval(()=>t.CheckConnection(),this._checkConnectionDelayMs)}this._externalDisconnectHandlers.push(e)}async getSigner(){return new w.Web3Provider(await this.getRawProvider()).getSigner()}}const l="cur_connector",_=()=>{const r=localStorage.getItem(l);return r?JSON.parse(r):void 0},m=r=>localStorage.setItem(l,JSON.stringify(r)),p=()=>localStorage.removeItem(l);class y{constructor(e,t){this.connectorsByName={},this._logger=e,this.WaitInitialisationAsync=this.InitAsync(t,_())}async InitAsync(e,t){let n;for(let s=0;s<e.length;s++){const i=e[s];this.connectorsByName[i.name]=i,i.name===t?.name&&await i.isConnected&&(n=i)}n&&await n.connect(t.chainId)&&(this._curConnector=n,this._logger.debug(`Current connector is ${this._curConnector.name}`))}get CurConnector(){return this._curConnector}async connect(e,t){await this.WaitInitialisationAsync;const n=this.connectorsByName[t];await n.connect(e)&&(m({chainId:e,name:t}),this._curConnector=n)}async disconnect(){var e;await((e=this._curConnector)==null?void 0:e.disconnect()),p(),this._curConnector=void 0}}var c=(r=>(r.Undefined="",r.Injected="Injected",r.WalletConnect="WalletConnect",r.FaceWallet="FaceWallet",r))(c||{});const h={UserReject:4001,UnknownChain:4902};class f extends o{constructor(e,t){super(e,c.Injected,t),this.addEthereumChain=async(n,s)=>{try{const i=this._chains[n],g=i.blockExplorer?[i.blockExplorer]:void 0;await window.ethereum.request({method:"wallet_addEthereumChain",params:[{chainId:s,chainName:i.name,rpcUrls:[i.rpcUrl],nativeCurrency:i.nativeCurrency,blockExplorerUrls:g}]})}catch(i){if(i.code===h.UserReject)return!1;throw i}return!0},this._ethRequestAccounts=void 0,this.isInstalled&&this.initListeners(window.ethereum)}get canSwitchChain(){return!!window.ethereum.isMetaMask}disconnect(){return super.removeListeners_(window.ethereum),Promise.resolve()}async connect(e){if(this._ethRequestAccounts)return this.logger.debug("InjectedConnector.enable already called"),await this._ethRequestAccounts;this.logger.debug("InjectedConnector.enable"),this._ethRequestAccounts=this.prvEnable();const t=await this._ethRequestAccounts;return this._ethRequestAccounts=void 0,await(await this.getSigner()).getChainId()!==e&&await this.switchChain(e),t}async switchChain(e){const t=`0x${e.toString(16)}`;try{if(!this._chains[e])throw new Error(`Chain ${e} not supported`);await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:t}]})}catch(n){if(n.code===h.UnknownChain)return await this.addEthereumChain(e,t);if(n.code===h.UserReject)return!1;throw n}return!0}get isConnected(){return this.isConnectedAsync()}get isInstalled(){return!!window.ethereum}get installUrl(){return"https://metamask.io/download"}getRawProvider(){return Promise.resolve(window.ethereum)}async prvEnable(){try{await window.ethereum.request({method:"eth_requestAccounts"})}catch(e){return e.code===h.UserReject?this.logger.warn("Please connect to MetaMask."):this.logger.error(e),!1}return!0}async isConnectedAsync(){return(await window.ethereum.request({method:"eth_accounts"})).length>0}}class A extends o{constructor({logger:e,chains:t}){super(e,c.WalletConnect,t),this._rpc={},t.forEach(n=>this._rpc[n.chainId]=n.rpcUrl),this._walletConnect=new d({rpc:this._rpc}),this.initListeners(this._walletConnect)}async disconnect(){super.removeListeners_(this._walletConnect),await this._walletConnect.disconnect()}get canSwitchChain(){return!1}switchChain(e){throw new Error("Method not implemented.")}getRawProvider(){return Promise.resolve(this._walletConnect)}get isConnected(){const e=!!localStorage.getItem("walletconnect")&&this._walletConnect.isWalletConnect;return Promise.resolve(e)}get isInstalled(){return!0}get installUrl(){return""}async connect(e){try{await this._walletConnect.enable()}catch{return this._walletConnect=new d({rpc:this._rpc}),!1}return!0}}const u=r=>{if(r===1)return a.ETHEREUM;if(r===80001)return a.MUMBAI;if(r===5)return a.GOERLI;throw new Error(`Unknow chain id: ${r}`)};class I extends o{constructor({logger:e,chains:t,testnetApiKey:n,mainnetApiKey:s}){if(super(e,c.FaceWallet,t),this.resolveApiKey=i=>{switch(i){case a.ETHEREUM:case a.POLYGON:case a.BNB_SMART_CHAIN:case a.KLAYTN:case a.BORA:{if(!this._mainnetApiKey)throw new Error("No API key for mainnet");return this._mainnetApiKey}case a.GOERLI:case a.MUMBAI:case a.BNB_SMART_CHAIN_TESTNET:case a.BAOBAB:case a.BORA_TESTNET:{if(!this._testnetApiKey)throw new Error("No API key for testnet");return this._testnetApiKey}default:throw new Error("unsupported network error")}},!n&&!s)throw new Error("Set value for testnetApiKey or mainnetApiKey or both");this._mainnetApiKey=s,this._testnetApiKey=n}async disconnect(){await this.face.auth.logout()}get canSwitchChain(){return!0}async switchChain(e){const t=u(e);return await this.face.switchNetwork(t),!0}get isConnected(){return this._face?this._face.auth.isLoggedIn():Promise.resolve(!1)}get isInstalled(){return!0}get installUrl(){return""}async connect(e){if(!this._face){const t=u(e);this._face=new C({network:t,apiKey:this.resolveApiKey(t)})}return await this.face.auth.isLoggedIn()||await this.face.auth.login(),!0}getRawProvider(){return Promise.resolve(this.face.getEthLikeProvider())}get face(){if(!this._face)throw new Error("Provider not connected. Call FaceWalletConnector.connect first");return this._face}}export{o as BaseConnector,c as ConnectorNames,y as ConnectorProvider,I as FaceWalletConnector,f as InjectedConnector,A as WalletConnectConnector};
//# sourceMappingURL=index.es.js.map
