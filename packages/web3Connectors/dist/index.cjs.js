"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var l=require("ethers"),d=require("@walletconnect/web3-provider");function u(s){return s&&typeof s=="object"&&"default"in s?s:{default:s}}var o=u(d);const i="cur_connector",C=()=>localStorage.getItem(i)||void 0,g=s=>localStorage.setItem(i,s),w=()=>localStorage.removeItem(i);class _{constructor(e,t){this.connectorsByName={},this._logger=e,this.WaitInitialisationAsync=this.InitAsync(t,C())}async InitAsync(e,t){let r;for(let n=0;n<e.length;n++){const a=e[n];this.connectorsByName[a.name]=a,a.name===t&&await a.isConnected&&(r=a)}r&&await r.enable()&&(this._curConnector=r,this._logger.debug(`Current connector is ${this._curConnector.name}`))}get CurConnector(){return this._curConnector}async EnableAsync(e){await this.WaitInitialisationAsync;const t=this.connectorsByName[e];await t.enable()&&(g(e),this._curConnector=t)}async disconnect(){var e;await((e=this._curConnector)==null?void 0:e.disconnect()),w(),this._curConnector=void 0}}class h{constructor(e,t,r){this._chains={},this._externalAccountChangedHandlers=[],this._externalChainChangedHandlers=[],this._externalDisconnectHandlers=[],this._checkConnectionDelayMs=500,this.name=t,this.logger=e,r.forEach(n=>this._chains[n.chainId]=n)}async CheckConnection(){await this.isConnected||(this._timerId&&(clearInterval(this._timerId),this.logger.debug(`${this.name}Connector. CheckConnection stopped`)),this._externalDisconnectHandlers.forEach(e=>e(void 0)),this._externalDisconnectHandlers=[])}initListeners(e){this.logger.debug("initListeners");const t=this;this.accountsChangedHandler=r=>{this.logger.debug(`${this.name}.accountsChangedHandler`),t._externalAccountChangedHandlers.forEach(n=>n(r))},this.chainChangedHandler=r=>{this.logger.debug(`${this.name}.chainChangedHandler`),t._externalChainChangedHandlers.forEach(n=>n(r))},this.disconnectHandler=r=>{this.logger.debug(`${this.name}.disconnectHandler ${JSON.stringify(r)}`),t._externalDisconnectHandlers.forEach(n=>n(r))},e.on("accountsChanged",this.accountsChangedHandler),e.on("chainChanged",this.chainChangedHandler)}removeListeners(){this.rawProvider.removeListener("accountsChanged",this.accountsChangedHandler),this.rawProvider.removeListener("chainChanged",this.chainChangedHandler),this._externalAccountChangedHandlers=[],this._externalChainChangedHandlers=[],this._externalDisconnectHandlers=[]}onAccountsChanged(e){this._externalAccountChangedHandlers.push(e)}onChainChanged(e){this._externalChainChangedHandlers.push(e)}onDisconnect(e){if(!this._timerId){const t=this;this._timerId=setInterval(()=>t.CheckConnection(),this._checkConnectionDelayMs)}this._externalDisconnectHandlers.push(e)}get signer(){return new l.providers.Web3Provider(this.rawProvider).getSigner()}disconnect(){return this.removeListeners(),Promise.resolve()}}var c=(s=>(s.Undefined="",s.Injected="Injected",s.WalletConnect="WalletConnect",s))(c||{});class m extends h{constructor(e,t){super(e,c.Injected,t),this._ethRequestAccounts=void 0,this.isInstalled&&this.initListeners(window.ethereum)}get canSwitchChain(){return!!window.ethereum.isMetaMask}async switchChain(e){const t=`0x${e.toString(16)}`;try{if(!this._chains[e])throw new Error(`Chain ${e} not supported`);await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:t}]})}catch(r){if(r.code===4902)try{const n=this._chains[e];await window.ethereum.request({method:"wallet_addEthereumChain",params:[{chainId:t,chainName:n.name,rpcUrls:[n.rpcUrl],nativeCurrency:n.nativeCurrency,blockExplorerUrls:[n.blockExplorer]}]})}catch(n){throw n}}}async prvEnable(){try{await this.rawProvider.request({method:"eth_requestAccounts"})}catch(e){return e.code===4001?this.logger.warn("Please connect to MetaMask."):this.logger.error(e),!1}return!0}async enable(){if(this._ethRequestAccounts)return this.logger.debug("InjectedConnector.enable already called"),await this._ethRequestAccounts;this.logger.debug("InjectedConnector.enable"),this._ethRequestAccounts=this.prvEnable();const e=await this._ethRequestAccounts;return this._ethRequestAccounts=void 0,e}async isConnectedAsync(){return(await window.ethereum.request({method:"eth_accounts"})).length>0}get isConnected(){return this.isConnectedAsync()}get isInstalled(){return!!window.ethereum}get installUrl(){return"https://metamask.io/download"}get rawProvider(){return window.ethereum}}class v extends h{constructor(e,t){super(e,c.WalletConnect,t),this._rpc={},t.forEach(r=>this._rpc[r.chainId]=r.rpcUrl),this._walletConnect=new o.default({rpc:this._rpc}),this.initListeners(this._walletConnect)}async disconnect(){await super.disconnect(),await this._walletConnect.disconnect()}get canSwitchChain(){return!1}switchChain(e){throw new Error("Method not implemented.")}get rawProvider(){return this._walletConnect}get isConnected(){const e=!!localStorage.getItem("walletconnect")&&this._walletConnect.isWalletConnect;return Promise.resolve(e)}get isInstalled(){return!0}get installUrl(){return""}async enable(){try{return await this._walletConnect.enable()}catch(e){return this._walletConnect=new o.default({rpc:this._rpc}),Promise.reject(e)}}}exports.ConnectorNames=c,exports.ConnectorProvider=_,exports.InjectedConnector=m,exports.WalletConnectConnector=v;
//# sourceMappingURL=index.cjs.js.map
